using System;
using System.Linq;
using System.Text;
using System.IO;
using wmxCLRLibrary.basicBuffer;
using System.Diagnostics;
using System.Collections.Generic;
using System.Windows.Forms;

namespace SG2000X
{
    public class CSq_Grd
    {
        private readonly int TIMEOUT = 30000;
        /// <summary>
        /// 버퍼 모션에서 트리거 사용 시 트리거 시간
        /// </summary>
        private readonly double BF_TIME = 0.075;

        public bool m_bHD { get; set; }

        public int Step { get { return m_iStep; } }
        private int m_iStep = 0;
        private int m_iPreStep = 0;

        public ESeq iSeq;
        public ESeq SEQ = ESeq.Idle;

        //201003 pjh :
        public eErr eWater;
        //
        
        //ksg
        private bool m_bReqStop = false;
        
        //20200423 lks (메뉴얼 동작시 정지 플래그)
        private bool m_bManualStop = false;

        //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
        public bool m_bManual18PMeasure = false; //매뉴얼 동작시 18 Point 측정인지 아닌지 여부
        //

        //211028 syc : Qorvo Probe Up Time Check
        Stopwatch sStopwatch = new Stopwatch();
        public static bool m_bPrbUptimeChk = false; // 중복해서 들어가는 구문에서 한번만 로그 찍기위한 변수
        //

        // 2020.10.13 SungTae : Dresser 5-Point Counting
        public int m_iDrsMeaCnt = 0;
        public double m_dOldMeaValue = 0.0D;
        public double m_dMaxMeaValue = 0.0D;        // 2020.10.26 SungTae : Add
        public double m_dMinMeaValue = 0.0D;        // 2020.10.26 SungTae : Add

        /// <summary>
        /// //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
        /// 프로브값 비교용 임시 변수
        /// </summary>
        private double dtmp = 0.0;

        private CTim m_Timout_485 = new CTim(); //  2023.03.15 Max

        #region 그라인딩, 드레싱, 테이블 그라인딩 공용 변수
        public int GStep { get { return m_iGStep; } }
        private int m_iGStep = 0;
        private int m_iGPreStep = 0;
        private tTempData m_tGrT = new tTempData();
        /// <summary>
        /// 그라인딩 12-스텝 총 카운트
        /// </summary>
        public int[] m_aGrd = new int[GV.StepMaxCnt];
        /// <summary>
        /// 그라인딩 3-스텝 총 카운트
        /// </summary>
        public int[] m_aGrd_3 = new int[GV.StepMaxCnt_3];       // 2020.09.21 SungTae : 
        /// <summary>
        /// 드레싱 및 그라인딩 시작 위치
        /// </summary>
        private double m_dStartZ = 0.0;
        /// <summary>
        /// 그라인딩 스텝 종료 후 마지막 Z축 위치
        /// </summary>
        public double m_dLastPosZ = 0.0;
        /// <summary>
        /// 그라인딩 시 스텝 번호 0 = rought1, 1 = rought2, 2 = rought3, 3 = fine
        /// </summary>
        public int m_iIndex = 0;
        /// <summary>
        /// 자재 그라인딩 중 측정값(한 포인트)
        /// </summary>
        public double m_dInspGrd;
        //20190421 ghk_휠 리그라인딩 옵셋
        /// <summary>
        /// 그라인딩 전 자재 높이
        /// </summary>
        public double m_dStartHeight;
        /// <summary>
        /// 그라인딩 스텝 모드에 따른 Step Count
        /// </summary>
        public int m_iStepMaxCnt = 0;       // 2020.09.08 SungTae : 추가
        #endregion

        #region 좌우 방향에 따른 변수
        /// <summary>
        /// 현재 클래스의 좌우 방향
        /// </summary>
        private EWay m_eWy;

        /// <summary>
        /// 0 : Left, 1 : Right
        /// </summary>
        private int m_iWy = 0;
        /// <summary>
        /// 현재 파트의 번호
        /// </summary>
        private int m_iPart = 0;
        /// <summary>
        /// 현재 파트의 버퍼 모션 채널 번호(파트번호와 동일)
        /// </summary>
        private uint m_nCh = 0;
        /// <summary>
        /// 현재 좌우 방향에서 X축 인덱스
        /// </summary>
        private int m_iX;
        /// <summary>
        /// 현재 좌우 방향에서 Y축 인덱스
        /// </summary>
        private int m_iY;
        /// <summary>
        /// 현재 좌우 방향에서 Z축 인덱스
        /// </summary>
        private int m_iZ;
        /// <summary>
        /// 현재 좌우 방향에서 Spindle 인덱스
        /// </summary>
        private int m_iSp;
        #endregion

        #region 하위 동작 공용 변수
        /// <summary>
        /// 임시 Input 변수 1
        /// </summary>
        private eX m_eIn1;
        /// <summary>
        /// 임시 Input 변수 1
        /// </summary>
        private eX m_eIn2;
        /// <summary>
        /// 임시 Output 변수 1
        /// </summary>
        private eY m_eOt1;
        /// <summary>
        /// 임시 Output 변수 1
        /// </summary>
        private eY m_eOt2;
        /// <summary>
        /// 휠 측정 시 측정 반복 횟수
        /// </summary>
        private int m_iWhlCnt = 0;
        /// <summary>
        /// 휠 측정 시 측정 값 저장 변수
        /// </summary>
        private double[] m_aTip = new double[3];

        //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
        /// <summary>
        /// 휠 측정 시 Z축 위치, 시퀀스 내 사용 변수 0:좌 1:우
        /// </summary>
        public static double[] m_aWheelTipZPos = new double[3];
        //

        /// <summary>
        /// Last 자재 그라인딩 후 Table Clean 하기 위한 변수
        /// </summary>
        public bool LastTbClean = false; //200121 ksg :
        #endregion

        /// <summary>
        /// 사이클 함수 자체의 타임아웃 타이머
        /// </summary>
        private CTim m_mGTimeout  = new CTim();
        private CTim m_mTimeout  = new CTim();
        private CTim m_mSpl      = new CTim();
        private CTim m_mSpl_Chk  = new CTim(); // 2023.03.15 Max - Spindle Stop Check
        private CTim m_Delay     = new CTim();
        private CTim m_PbDelay   = new CTim();
        private CTim m_SaveDelay = new CTim();
        private CTim m_ActualDelay = new CTim();    // 2021.05.23 SungTae : [추가] 설정한 Delay 체크하여 추가한 SVID(Actual Parameter(Spindle & Grd Y-Axis Speed)) Update

        /// <summary>
        /// 프로브 다운 타이머
        /// </summary>
        private CTim m_tmPrb = new CTim();
        /// <summary>
        /// DI check 시 타이머
        /// </summary>
        private CTim m_tmChkDI = new CTim();

        /// <summary>
        /// 드레싱 및 그라인딩 현재 카운트
        /// </summary>
        public int m_iCnt = 0;
        /// <summary>
        /// 리그라인딩 현재 카운트
        /// </summary>
        public int m_iReCnt = 0;
        /// <summary>
        /// 스핀들 RPM
        /// </summary>
        private int m_iRpm = 0;
        /// <summary>
        /// Fine Grinding 검사 유무 확인
        /// </summary>
        public bool m_bFineCheck = false;
        /// <summary>
        /// 프로브 테스트 찍는 위치
        /// false = base, true = center
        /// </summary>
        public bool m_bProbeTestDir = false;
        /// <summary>
        /// 프로브 테스트 카운트
        /// </summary>
        public int m_iProbeTestCnt = 0;
        /// <summary>
        /// 프로브 X축 타켓 위치
        /// </summary>
        private double m_dPosX = 0.0;
        /// <summary>
        /// 테이블 타켓 위치
        /// </summary>
        private double m_dPosY = 0.0;
        /// <summary>
        /// Z축 CycleDep, Z축 타켓 위치로 사용
        /// </summary>
        private double m_dPosZ = 0.0;

        /// Z축 Probe measure 수행시 이동할 안전위치
        /// </summary>
        private double m_dPosSafetyZ = 0.0;

        /// <summary>
        /// Z축 현재 값 
        /// </summary>
        private double m_dCurZ = 0.0;
        /// <summary>
        /// 테이블 속도
        /// </summary>
        private double m_dVelY = 0.0;

        /// <summary>
        /// Z축 CycleDep
        /// </summary>
        private double m_dCylZ = 0.0;

        /// <summary>
        /// 자재 측정시 iCol에 대한 테이블 높이 차이 값(테이블 센터 기준으로 설정)
        /// </summary>
        private double m_InspOffset = 0.0;
        /// <summary>
        /// 자재 측정 위치 이동 후 Zero세팅(테이블기준)
        /// </summary>
        private double m_InspZeroOffset = 0.0;
        /// <summary>
        /// Top 모드 사용 안할때 유저 입력값과 측정 값중 가장 높은 값과의 차이 저장
        /// </summary>
        private double m_dStripOffset = 0.0;
        /// Rought 그라인딩 시 TotalDepth
        /// </summary>
        private double m_dRoughtTotal = 0.0;
        private bool m_bRoughtLast = false;

        //201023 JSKim : Over Grinding Correction - Grinding Count Correction 기능
        /// <summary>
        /// 측정 후 파악되는 오버 그라인딩 값
        /// </summary>
        private double m_dRoughOver = 0.0;
        //

        /// <summary>
        /// 자재 측정 높이 Before 메뉴얼 사용
        /// </summary>
        public double[,] m_aInspBf;
        /// <summary>
        /// 자재 측정 높이 After 메뉴얼 사용
        /// </summary>
        public double[,] m_aInspAf;
        // 2020.09.14 JSKim St
        /// <summary>
        /// 자재 측정 높이 Before 메뉴얼 사용(PCB + Mold 측정높이)
        /// </summary>
        public double[,] m_aInspTotalBf;
        /// <summary>
        /// 자재 측정 높이 After 메뉴얼 사용(PCB + Mold 측정높이)
        /// </summary>
        public double[,] m_aInspTotalAf;
        // 2020.09.14 JSKim Ed
        /// <summary>
        /// 왼쪽 그라인딩 전 자재 측정 높이 에러
        /// </summary>
        public bool m_bMeaErrBf_L;
        /// <summary>
        /// 왼쪽 그라인딩 후 자재 측정 높이 에러
        /// </summary>
        public bool m_bMeaErrAf_L;
        /// <summary>
        /// 오른쪽 그라인딩 전 자재 측정 높이 에러
        /// </summary>
        public bool m_bMeaErrBf_R;
        /// <summary>
        /// 오른쪽 그라인딩 후 자재 측정 높이 에러
        /// </summary>
        public bool m_bMeaErrAf_R;
        /// <summary>
        /// 그라인딩 전 각 포인트 자재 측정 에러
        /// </summary>
        public bool[,] m_abMeaBfErr;
        /// <summary>
        /// 그라인딩 후 각 포인트 자재 측정 에러
        /// </summary>
        public bool[,] m_abMeaAfErr;

        // 2022.08.05 SungTae Start : [추가] (ASE-KR 개발건)
        // User가 설정한 Final Target Thickness와 자재 측정 높이 비교 시 같지 않을 경우 ALARM 발생용
        /// <summary>
        /// 왼쪽 그라인딩 후 Final Target Thickness와 자재 측정 높이 비교 시 에러
        /// </summary>
        public bool m_bMeaErr_FinalTarget_L;
        /// <summary>
        /// 오른쪽 그라인딩 후 Final Target Thickness와 자재 측정 높이 비교 시 에러
        /// </summary>
        public bool m_bMeaErr_FinalTarget_R;
        // 2022.08.05 SungTae End

        /// <summary>
        /// 자재 왼쪽 오른쪽 구분전 데이터 임시 저장
        /// </summary>
        public double[,] m_aInspTemp;
        // 2020.09.14 JSKim St
        /// <summary>
        /// 자재 왼쪽 오른쪽 구분전 Total Thickness 데이터 임시 저장
        /// </summary>
        public double[,] m_aInspTotalTemp;
        // 2020.09.14 JSKim Ed
        /// <summary>
        /// 자재 왼쪽 오른쪽 구분전 데이터 임시 저장
        /// </summary>
        public double[,] m_aInspShift; //190528 ksg :

        /// <summary>
        /// 자재 측정시 사용할 현재 iRow 값
        /// </summary>
        private int m_iRow = 0;
        /// <summary>
        /// 자재 측정시 사용할 현재 iCol 값
        /// </summary>
        private int m_iCol = 0;
        /// <summary>
        /// 측정 시 현재 유닛 인덱스
        /// </summary>
        private int m_iUnit = 0; // 200316 mjy : 추가
        /// <summary>
        /// Probe와 실 자재 값 틀린거 보정치 
        /// </summary>
        private double m_PbOfset = 0; //190312 ksg :
        /// <summary>
        /// 각 Step 마다 10um 띄우는 변수
        /// </summary>
        private double m_ZPosUpOffset = 0; //190419 ksg :
        /// <summary>
        /// 각 Step 마다 10um 띄우는 변수
        /// </summary>
        public bool m_CntTimeFlag = false; //190423 ksg :
        /// <summary>
        /// 각 Step 마다 10um 띄우는 변수
        /// </summary>
        private double m_ReGrdDep = 0.0; //190711 ksg : ReGrinding 조건

        /// <summary>
        /// 리그라인딩에서 Cycle Depth로 나눈 나머지를 리그라인딩 하는 플래그, 리그라인딩 판정 두께보다 크면
        /// </summary>
        private bool m_bRemainder = false; // 2022.09.26 lhs

        /// <summary>
        /// 리그라인딩에서 Cycle Depth로 나눈 나머지
        /// </summary>
        private double m_dRemainder = 0.0; // 2022.09.26 lhs

        /// <summary>
        /// Target 계산 오류 시 Error 띄우는 알람 Flag
        /// </summary>
        private bool m_WrongCalFlag = false; //190813 ksg :

        // 2021.07.30 SungTae : [추가] ASE-KR VOC로 Grinding이 완료된 자재가 재투입 시 Over Grinding 되는 Issue 관련 조건 추가
        /// <summary>
        /// [ASE-KR 전용] PCB Thickness 계산 오류 시 Error 띄우는 알람 Flag
        /// </summary>
        private bool m_WrongPCBThicknessFlag = false;

        // 2021.09.23 SungTae : [추가] Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 추가 (ASE-KR VOC)
        /// <summary>
        /// Before/After Measure 시 Table Base 측정 횟수 Count
        /// </summary>
        private int m_iTblMeasCnt = 0;

        //20190910 ghk_grd_drs_error
        /// <summary>
        /// 드레싱 or 그라인딩 중 드레셔 측정, 휠 측정, 자재 측정 중 에러 발생시 확인 용
        /// </summary>
        private bool m_bSubErr = false;

        private tLog m_LogVal = new tLog(); //190218 ksg :
        private string m_siX = "";
        private string m_siY = "";
        private string m_siZ = "";

        //20190618 ghk_dfserver
        private string m_sRowData = "";
        //

        //20190704 ghk_meawhl
        private short m_iAddr;
        private short m_iBit;

        private double dTemp;
        private int nSpindle_Degree;     // Spindle 각도 함수
        private int nSpindle_Degree_Temp;// Spindle 각도 함수

        //200811 myk : Probe Calibration Check
        public string sProbe = "";
        public bool bCalCheck = false;
        public int m_nCalCheckCount;

        public double[] Old_Encoder_Val    = new double[CMot.It.AxL+10];
        public double[] Curr_Encoder_Value = new double[CMot.It.AxL+10];
        public double[] Old_Probe_Val      = new double[2];
		
        public bool   m_NeedDrs      = false;

        // 2020-11-15, jhLee : Skyworks VOC, Table clean 주기를 지정하여 동작한다.
        /// <summary>
        /// 그라인딩 가동된 제품 카운트, 지정된 수량을 넘어서면 Table Clean을 수행한다.
        /// </summary>
        public int m_iProcessCnt = 0;


        //syc : Probe contact table
        private double m_dProVal = 0.0;
        private int  m_iPbTb_Dly = 1500;

        /// <summary>
        /// 버퍼 동작 상태값 클래스
        /// </summary>
        BufferStatus m_mBfStat = new BufferStatus();

        //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
        private int m_iOnpX = (int)EAx.OnLoaderPicker_X;
        private int m_iOfpX = (int)EAx.OffLoaderPicker_X;

        /// <summary>
        /// Picker 자재 Vacuum 체크 상태
        /// 0=정상,
        /// 1=On-Picker 자재 Vacuum Error,
        /// 2=Off-Picker 자재 Vacuum Error
        /// </summary>
        private int m_iPickerVacErr = 0;

        /// <summary>
        /// Grinding, Dressing에서 프로브 사용 시점에 대한 플래그
        /// </summary>
        private bool m_bUsePrbFlag = false;
        /// <summary>
        /// 측정 시 잘못 측정 햇을때 반복횟수
        /// </summary>
        private int m_iWrongCnt = 0;
        /// <summary>
        /// 프로브 업 체크 반복 횟수
        /// </summary>
        private int m_iPrbUpCnt = 0;
        /// <summary>
        /// 그라인딩 시 오버그라인딩 방지를 위한 시작 위치 상승 옵셋 200923 jym
        /// </summary>
        private double m_dGrdUpOffset = 0;


        //-------- 2020.11.27 lhs Start
        // [TM8] Table Measure 8 Point
        /// <summary>
        /// 테이블 측정포인트 인덱스
        /// </summary>
        public int m_nPtIdx = 0;
        /// <summary>
        /// 테이블 반복측정 인덱스
        /// </summary>
        public int m_nReptIdx = 0;
        /// <summary>
        /// 테이블 상단 측정했는지 여부 (측정포인트가 있는 Col별)
        /// </summary>
        public bool  m_bTopMode = false;
        /// <summary>
        /// 테이블 상단 측정했는지 여부 (측정포인트가 있는 Col별)
        /// </summary>
        public bool[] m_bMeased_Top = new bool[CTm8.m_nMaxPt];
        /// <summary>
        /// 테이블 중앙상단 테이블 높이 측정값(X=0, Y=Insp)
        /// </summary>
        public double m_dTableH_CT = 0.0;
        /// <summary>
        /// 테이블 상단 테이블 높이 측정값 (측정포인트가 있는 Col별로 보정을 하기 위한 변수)
        /// </summary>
        public double[] m_dTableH_Top = new double[CTm8.m_nMaxPt];
        //-------- 2020.11.27 lhs End

        //201203 jhc : 드레싱 후 N번째 그라인딩 시 휠 소모량 보정 기능
        private bool m_TotalWheelLossLimitOver = false; //누적 Wheel Loss 제한량 초과 여부 (Z축 과도 DOWN 제한 필요)
        //

        //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
        private CTim m_TableVacLowDelay = new CTim(); //201231
        private bool m_bStateTableVacuumLow = false; //201231
        private bool m_bErrTableVacuumLow = false;
        private bool m_bErrSpindleCurrentLow = false;
        private bool m_bErrSpindleCurrentHigh = false;
        //..

        // 2021.08.01 lhs Start : TopMold, BtmMold의 Avg, Max 계산을 위한 저장용
        private List<double> m_listTopMoldTh;
        private List<double> m_listBtmMoldTh;
        // 2021.08.01 lhs End 

        // 2021-05-25, jhLee, Multi-LOT, 가공중인 Strip과 LOT의 데이터 처리용 레퍼런스 변수, On-Picker에서 지정해준다.
        public TPart m_myPart;              // 가공중인 Strip 정보
        public TLotInfo m_myLotInfo;        // 가공중인 LOT 정보

        //210823 pjh : Auto run 확인 변수
        public bool bAuto = false;
        //
        //211006 pjh : Error 발생 확인 변수
        public bool m_bProbeAbnormalCheck = false;
        //
        private int itenpointAutocalCount = 0; // 211223 syc : 10point auto cal 반복 카운트 확인
        private string sAutocal = ""; // 211223 syc : 10point auto cal 카운트별 명령어 저장

        // 2021-06-09,  jhLee, Multi-LOT
       // SPC 기록시 사용되는 데이터를 위해 LotInfo 주소를 대입해준다.
        private void SetMyLotInfo()
        {
            // Multi-LOT을 사용할 때만 유효
            if (CData.IsMultiLOT())
            {
                // 현재 Strip Data에 지정된 Lot Name으로 LOT Information pointer를 조회한다.
                if (!CData.LotMgr.GetLotInfoName(CData.Parts[m_iPart].sLotName, ref m_myLotInfo))
                {
                    // Lot Info 할당에 실패할 경우 기존에 사용하고 있는 대표 LotInfo를 사용한다.
                    m_myLotInfo = CData.LotInfo;
                }
            }
            else
            {
                m_myLotInfo = CData.LotInfo;
            }
        }



        /// <summary>
        /// Table 상단에서 On/Off Picker 자재 Vacuum 불량할 경우 Table 위로 자재 낙하 가능성 있으므로 체크함
        /// → 자재 낙하 상태에서 Table 이동 시 자재 파손 위험 있음
        /// → Picker 자재를 Table에 Place하는 타이밍에서는 체크하지 않도록 함
        /// </summary>
        /// <param name="eWy">EWay.L : L-Table 상단 Picker 자재 Vacuum 체크, EWay.R : L-Table 상단 Picker 자재 Vacuum 체크</param>
        /// <returns>0: 정상, 1: On-Picker 자재 Vacuum Error, 2: Off-Picker 자재 Vacuum Error</returns>
        private int Chk_PickerStripVacOk(EWay eWy)
        {
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////
            //On-Picker  (0) ---> (+) --->
            //        (dOnpXL1)     L-Table      (dOnpXL2)                 (dOnpXR1)      R-Table      (dOnpXR2)
            //----------------------▤▤▤▤-----------------------------------------------▤▤▤▤--------------------- 
            //        (dOfpXL2)     L-Table      (dOfpXL1)                 (dOfpXR2)      R-Table      (dOfpXR1)
            //Off-Picker  <--- (+) --- (0)

            double dOnpXL1 = CData.SPos.dONP_X_PlaceL - 250; //OnPicker (L-Table Pick/Place - 250 mm) 보다 오른쪽
            double dOnpXL2 = CData.SPos.dONP_X_PlaceL + 250; //OnPicker (L-Table Pick/Place + 250 mm) 보다 왼쪽
            double dOnpXR1 = CData.SPos.dONP_X_PlaceR - 250; //OnPicker (R-Table Pick/Place - 250 mm) 보다 오른쪽
            double dOnpXR2 = CData.SPos.dONP_X_PlaceR + 250; //OnPicker (R-Table Pick/Place + 250 mm) 보다 왼쪽
            double dOfpXL1 = CData.SPos.dOFP_X_PickL  - 250; //OffPicker (L-Table Pick/Place - 250 mm) 보다 왼쪽
            double dOfpXL2 = CData.SPos.dOFP_X_PickL  + 250; //OffPicker (L-Table Pick/Place + 250 mm) 보다 오른쪽
            double dOfpXR1 = CData.SPos.dOFP_X_PickR  - 250; //OffPicker (R-Table Pick/Place - 250 mm) 보다 왼쪽
            double dOfpXR2 = CData.SPos.dOFP_X_PickR  + 250; //OffPicker (R-Table Pick/Place + 250 mm) 보다 오른쪽
            double dOnpXPos = CMot.It.Get_FP(m_iOnpX);
            double dOfpXPos = CMot.It.Get_FP(m_iOfpX);

            if(eWy == EWay.L)
            {   ///////////////////////////////////////////
                // L-Table 위에서 Picker 자재 Vacuum 검사 //

                //On-Picker
                if (CData.Parts[(int)EPart.ONP].bExistStrip &&        //On-Picker Strip 있음
                    !CIO.It.Get_X(eX.ONP_Vacuum) &&                   //On-Picker Vacuum 불량
                    ((dOnpXL1 <= dOnpXPos) && (dOnpXPos <= dOnpXL2))) //자재 낙하 시 위험 위치
                { return 1; }

                //Off-Picker
                if (CData.Parts[(int)EPart.OFP].bExistStrip &&        //Off-Picker Strip 있음
                    !CIO.It.Get_X(eX.OFFP_Vacuum) &&                  //Off-Picker Vacuum 불량
                    ((dOfpXL1 <= dOfpXPos) && (dOfpXPos <= dOfpXL2))) //자재 낙하 시 위험 위치
                { return 2; }
            }
            else if(eWy == EWay.R)
            {   ///////////////////////////////////////////
                // R-Table 위에서 Picker 자재 Vacuum 검사 //

                //On-Picker
                if (CData.Parts[(int)EPart.ONP].bExistStrip &&        //On-Picker Strip 있음
                    !CIO.It.Get_X(eX.ONP_Vacuum) &&                   //On-Picker Vacuum 불량
                    ((dOnpXR1 <= dOnpXPos) && (dOnpXPos <= dOnpXR2))) //자재 낙하 시 위험 위치
                { return 1; }

                //Off-Picker
                if (CData.Parts[(int)EPart.OFP].bExistStrip &&        //Off-Picker Strip 있음
                    !CIO.It.Get_X(eX.OFFP_Vacuum) &&                  //Off-Picker Vacuum 불량
                    ((dOfpXR1 <= dOfpXPos) && (dOfpXPos <= dOfpXR2))) //자재 낙하 시 위험 위치
                { return 2; }
            }

            return 0;
        }
        ///////////////////////////////////////////////////////////////////////////////////////

        public CSq_Grd(EWay eWy)
        {
            m_SaveDelay.Set_Delay(50); //191018 ksg :

            m_eWy = eWy;
            m_iWy = (int)m_eWy;

            if (eWy == EWay.L)
            {
                m_iX   = (int)EAx.LeftGrindZone_X;
                m_iY   = (int)EAx.LeftGrindZone_Y;
                m_iZ   = (int)EAx.LeftGrindZone_Z;
                m_iSp  = (int)EAx.LeftSpindle;
                m_siX  = EAx.LeftGrindZone_X.ToString();
                m_siY  = EAx.LeftGrindZone_Y.ToString();
                m_siZ  = EAx.LeftGrindZone_Z.ToString();
                
                m_iAddr = 10;
                m_iBit = 7;
                m_iPart = (int)EPart.GRDL;
            }
            else
            {
                m_iX   = (int)EAx.RightGrindZone_X;
                m_iY   = (int)EAx.RightGrindZone_Y;
                m_iZ   = (int)EAx.RightGrindZone_Z;
                m_iSp  = (int)EAx.RightSpindle;
                m_siX  = EAx.RightGrindZone_X.ToString();
                m_siY  = EAx.RightGrindZone_Y.ToString();
                m_siZ  = EAx.RightGrindZone_Z.ToString();

                /*
                if (CDataOption.SplType == eSpindleType.Rs232)
                {
                    if (CDataOption.CurEqu == eEquType.Nomal)
                    {
                        m_iAddr = 85;
                        m_iBit = 7;
                    }
                    else
                    {
                        m_iAddr = 89;
                        m_iBit = 7;
                    }
                }
                else
                {
                    if (CDataOption.CurEqu == eEquType.Nomal)
                    {
                        m_iAddr = 97;
                        m_iBit = 7;
                    }
                    else
                    {
                        m_iAddr = 101;
                        m_iBit = 7;
                    }
                }
                */
                // 2023.03.15 Max
                if (CDataOption.CurEqu == eEquType.Nomal)
                {
                    m_iAddr = 97;
                    m_iBit = 7;
                }
                else
                {
                    m_iAddr = 101;
                    m_iBit = 7;
                }

                m_iPart = (int)EPart.GRDR;
            }

            m_nCh = (uint)m_iPart;
        }

        private void _SetLog(string sMsg, bool bData = false)
        {
            StackTrace mTrace = new StackTrace();
            StackFrame mFrame = mTrace.GetFrame(1);

            string sMth = mFrame.GetMethod().Name.PadRight(20);

            //200824 jhc : 
            string sStat = CSQ_Main.It.m_iStat.ToString();
            if (CSQ_Main.It.m_iStat == EStatus.Error)
            {
                sStat = string.Format("{0}[{1}]", sStat, (CData.iErrNo + 1).ToString("000"));
            }
            sStat.PadRight(20);

            string sLog = string.Format("{0}\t[{1}()]\tGSt : {2}\tSt : {3}\t{4}",sStat, sMth, m_iGStep.ToString("00"), m_iStep.ToString("00"), sMsg);
            CLog.Save_Log((m_eWy == EWay.L) ? eLog.GRL : eLog.GRR, eLog.None, sLog);
            if (bData)
            { CLog.Save_Log((m_eWy == EWay.L) ? eLog.GRL_DATA : eLog.GRR_DATA, eLog.None, sLog); }
        }

        private void _SetLog(string sMsg, double dPos, bool bData = false)
        {
            StackTrace mTrace = new StackTrace();
            StackFrame mFrame = mTrace.GetFrame(1);

            string sMth = mFrame.GetMethod().Name.PadRight(20);

            //200824 jhc : 
            string sStat = CSQ_Main.It.m_iStat.ToString();
            if (CSQ_Main.It.m_iStat == EStatus.Error)
            {
                sStat = string.Format("{0}[{1}]", sStat, (CData.iErrNo + 1).ToString("000"));
            }
            sStat.PadRight(20);

            sMsg = string.Format("{0}  Pos : {1}mm", sMsg, dPos);

            string sLog = string.Format("{0}\t[{1}()]\tGSt : {2}\tSt : {3}\t{4}",sStat, sMth, m_iGStep.ToString("00"), m_iStep.ToString("00"), sMsg);
            CLog.Save_Log((m_eWy == EWay.L) ? eLog.GRL : eLog.GRR, eLog.None, sLog);
            if (bData)
            { CLog.Save_Log((m_eWy == EWay.L) ? eLog.GRL_DATA : eLog.GRR_DATA, eLog.None, sLog); }
        }

        /// <summary>
        /// Initial Cycle
        /// </summary>
        public void Init_Cyl()
        {
            m_iPreStep  = 0;
            m_iStep     = 10;
            m_iGPreStep = 0;
            m_iGStep    = 10;

            // 2020.09.08 SungTae : 3 Step 기능 추가
            if (CDataOption.StepCnt == (int)EStepCnt.DEFAULT_STEP)  { m_iStepMaxCnt = GV.StepMaxCnt;    }
            else                                                    { m_iStepMaxCnt = GV.StepMaxCnt_3;  }
        }

		//20200504 lks
        public void ToStopManual()
        {
            if (!m_bManualStop && CSQ_Main.It.m_iStat == EStatus.Manual)
            {
                m_bManualStop = true;
            }
        }

        public bool ToStop()
        {
            m_bReqStop = true;
            
            if(m_iGStep > 14) 
            { return false;}
            else              
            { 
                //if(m_iGStep == 0 && m_iStep != 0) return false;
                if(m_iGStep == 0)
                {
                    if(m_eWy == EWay.L)
                    {
                        if(CData.Parts[(int)EPart.GRDL].iStat == ESeq.GRL_Grinding || CData.Parts[(int)EPart.GRDL].iStat == ESeq.GRL_Dressing)
                        {
                            m_iStep = 0;
                        }
                    }
                    else
                    {
                        if(CData.Parts[(int)EPart.GRDR].iStat == ESeq.GRR_Grinding || CData.Parts[(int)EPart.GRDR].iStat == ESeq.GRR_Dressing)
                        {
                            m_iStep = 0;
                        }
                    }
                }

                // 201008 jym : 스탑 시 프로브 업
                Func_PrbUp();

                m_iGStep = 0; 
                return true;                 
            }  
        }

        public bool ToReady()
        {
            m_bReqStop = false;
            SEQ        = ESeq.Idle;
            if (CData.Opt.bLotTblClean)
            {
                if (m_eWy == EWay.L)
                { CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_Table_Clean; }
                else
                { CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_Table_Clean; }
            }
            return true;
        }

        public bool Stop()
        {
            m_iGStep = 0;
            m_iStep = 0;

            // 201008 jym : 스탑 시 프로브 업
            Func_PrbUp();

            return true;
        }
        
        
        public void Encoder_Log_Save()
        {
            // if (CSQ_Main.It.m_iStat == EStatus.Auto_Running || CSQ_Main.It.m_iStat == EStatus.Manual)
            if ((CSQ_Main.It.m_iStat != EStatus.Manual))
            {
                m_SaveDelay.Set_Delay(1000); return;
            }
            else if (!m_SaveDelay.Chk_Delay())
            { return; }
            else {
                if (CSQ_Main.It.m_iStat != EStatus.Auto_Running)
                {
                    SaveLog_Encode(0, 0);
                }
                else SaveLog_Encode(m_iGStep, m_iStep);
            }
        }
        #region AutoRun
        public bool AutoRun()
        {
            iSeq = CData.Parts[m_iPart].iStat;

            // 2020.10.22 JSKim St
            bool bPumpLRunResult = false;
            bool bPumpRRunResult = false;
            // 2020.10.22 JSKim Ed

            if (SEQ == ESeq.Idle)
            {
                if (m_bReqStop) return false;
                if (CSQ_Main.It.m_iStat == EStatus.Stop)
                { return false; }

                // 2020.10.22 JSKim St
                if (CData.CurCompany == ECompany.JCET && CData.Opt.bDualPumpUse == true)
                {
                    bPumpLRunResult = CIO.It.Get_X(eX.PUMPL_Run) == false || CIO.It.Get_X(eX.ADD_PUMPL_Run) == false;
                    bPumpRRunResult = CIO.It.Get_X(eX.PUMPR_Run) == false || CIO.It.Get_X(eX.ADD_PUMPR_Run) == false;
                }
                else
                {
                    bPumpLRunResult = CIO.It.Get_X(eX.PUMPL_Run) == false;
                    bPumpRRunResult = CIO.It.Get_X(eX.PUMPR_Run) == false;
                }
                // 2020.10.22 JSKim Ed

                // 2020.10.22 JSKim St
                //if (!CIO.It.Get_X(eX.PUMPL_Run))
                if (bPumpLRunResult)
                // 2020.10.22 JSKim Ed
                { CIO.It.Set_Y(eY.PUMPL_Run, true); }

                // 2020.10.22 JSKim St
                //if (!CIO.It.Get_X(eX.PUMPR_Run))
                if (bPumpRRunResult)
                // 2020.10.22 JSKim Ed
                { CIO.It.Set_Y(eY.PUMPR_Run, true); }

                bool bWait       = false;
                bool bDressing   = false;
                bool bGrinding   = false;
                bool bWaterKnife = false;
                //20190703 ghk_automeasure
                bool bMeaStrip   = false;
                bool bAfMeaStrip = false;
                //
                //20190819 ghk_tableclean
                bool bTbClean = false;

                if (m_eWy == EWay.L)
                {
                    if(CData.Opt.aTblSkip[m_iWy])
                    {
                        CData.Parts[m_iPart].iStat = ESeq.GRL_WorkEnd;
                        return true;
                    }

                    if(iSeq == ESeq.GRL_WorkEnd)
                    {
                        if (LastTbClean)
                        {
                            //200401 jym : Lot End 시 드레싱 추가
                            if (CData.Opt.bLotDrs)
                            {
                                m_iGStep = 10;
                                m_iGPreStep = 0;
                                m_iStep = 10;
                                m_iPreStep = 0;
                                SEQ = ESeq.GRL_Dressing;
                                _SetLog(">>>>> Dressing start.");
                            }
                            else
                            {
                                LastTbClean = false;

                                m_iStep = 10;
                                m_iPreStep = 0;
                                SEQ = ESeq.GRL_Table_Clean;
                                _SetLog(">>>>> Table cleaning start.");
                            }

                            return false;
                        }
                        else
                        { 
                            return true;
                        }
                    }

                    if (iSeq == ESeq.GRL_Wait || iSeq == ESeq.Idle)
                    { bWait = true; }

                    if ((CData.Dev.aData[m_iWy].dDrsPrid != 0) && (CData.Whls[m_iWy].iGdc >= CData.Dev.aData[m_iWy].dDrsPrid))
                    { CData.DrData[m_iWy].bDrs = true; }


                    if ((CData.DrData[m_iWy].bDrs && (iSeq == ESeq.GRL_Ready || iSeq == ESeq.GRL_Wait) && (CData.Parts[(int)EPart.ONP].iStat != ESeq.ONP_PickTbL)))
                    {
                        bDressing           = true;
                        //CData.AutoWheelMeaL = true; //190929 ksg :
                        if(m_NeedDrs) m_NeedDrs = false; //200310 ksg : Spindle 부하
                    }
                    //200310 ksg : SPindle 부하
                    if ((m_NeedDrs && (iSeq == ESeq.GRL_Ready || iSeq == ESeq.GRL_Wait) && (CData.Parts[(int)EPart.ONP].iStat != ESeq.ONP_PickTbL)))
                    {
                        m_NeedDrs = false;
                        bDressing = true ;
                    }

                    // 2021-05-25, jhLee, Multi-LOT, Strip 정보가 갱신되었음을 표시 되었으면 현재 투입된 Strip에 해당되는 LOT 정보를 가져온다.
                    //  if ((iSeq == ESeq.GRL_Grinding) && CData.Parts[m_iPart].bIsUpdate)
                    if ( CData.Parts[m_iPart].bIsUpdate)
                    {
                        CData.Parts[m_iPart].bIsUpdate = false;                               // 갱신 Flag를 사용하였다.

                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        //// Multi-LOT을 사용할 때만 유효
                        //if (CDataOption.UseMultiLOT && CData.Opt.bMultiLOTUse)
                        //{
                        //    // 현재 Strip Data에 지정된 Lot Name으로 LOT Information pointer를 조회한다.
                        //    if (!CData.LotMgr.GetLotInfoName(CData.Parts[m_iPart].sLotName, ref m_myLotInfo))
                        //    {
                        //        // Lot Info 할당에 실패할 경우 기존에 사용하고 있는 대표 LotInfo를 사용한다.
                        //        m_myLotInfo = CData.LotInfo;
                        //    }
                        //}
                        //else
                        //    m_myLotInfo = CData.LotInfo;

                    }


                    if (iSeq == ESeq.GRL_Grinding && !bDressing)
                    {
                        //210901 syc : 2004U
                        if (CDataOption.Use2004U)
                        {
                            if (!CIO.It.Get_X(eX.GRDL_Unit_Vacuum_4U) || !CIO.It.Get_X(eX.GRDL_Carrier_Vacuum_4U))
                            {
                                CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_Ready;
                                //CErr.Show(eErr.LEFT_GRIND_VACUUM_ERROR);
                                m_iStep = 0;
                                return true;
                            }
                        }
                        //
                        else
                        {
                            if (!CIO.It.Get_X(eX.GRDL_TbVaccum))
                            {
                                CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_Ready;
                                //CErr.Show(eErr.LEFT_GRIND_VACUUM_ERROR);
                                m_iStep = 0;
                                return true;
                            }
                        }
                        
                        if (CData.Opt.bDryAuto)
                        {
                            //20190703 ghk_automeasure
                            if(CData.Opt.bDryAutoMeaStripSkip)
                            {
                                CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_WaitPick;
                                return false;
                            }
                            else
                            {
                                bMeaStrip = true;
                            }
                            //
                        }
                        else
                        {
                            bGrinding = true;
                        }
                    }

                    if (iSeq == ESeq.GRL_WaterKnife)
                    { bWaterKnife = true; }

                    if(iSeq == ESeq.GRL_Ready && CData.Parts[(int)EPart.ONP].iStat == ESeq.ONP_WorkEnd)
                    {
                        CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_WorkEnd;
                        _SetLog(">>>>> Work End.");

                        return false; //200228 ksg :
                    }

                    if(iSeq == ESeq.GRL_WorkEnd)
                    {
                        return true;
                    }

                    //20190703 ghk_automeasure
                    if (iSeq == ESeq.GRL_AfterMeaStrip)
                    { bAfMeaStrip = true; }
                    //

                    //20190819 ghk_tableclean
                    if (iSeq == ESeq.GRL_Table_Clean)
                    { bTbClean = true; }
                    //

                    if (bWait)
                    {
                        m_iStep    = 10;
                        m_iPreStep = 0 ;
                        SEQ = ESeq.GRL_Wait;
                        _SetLog(">>>>> Wait start.");
                    }

                    if (bDressing)
                    {
                        m_iGStep = 10;
                        m_iGPreStep = 0;
                        m_iStep = 10;
                        m_iPreStep = 0;
                        SEQ = ESeq.GRL_Dressing;
                        _SetLog(">>>>> Dressing start.", true);
                    }

                    if (bGrinding)
                    {
                        m_iGStep = 10;
                        m_iGPreStep = 0;
                        m_iStep = 10;
                        m_iPreStep = 0;
                        SEQ = ESeq.GRL_Grinding;
                        _SetLog(">>>>> Grinding start.", true);
                    }

                    if (bWaterKnife)
                    {
                        m_iStep = 10;
                        m_iPreStep = 0;
                        SEQ = ESeq.GRL_WaterKnife;
                        _SetLog(">>>>> Water knife start.");
                    }

                    //if(iSeq == ESeq.GRL_WorkEnd)  // 2021.11.18 lhs : 위에 같은 구문이 있어 삭제
                    //{
                    //    return true;
                    //}

                    //20190703 ghk_automeasure
                    if (bMeaStrip)
                    {
                        m_iStep = 10;
                        m_iPreStep = 0;
                        SEQ = ESeq.GRL_Strip_Measure;
                        _SetLog(">>>>> Measure strip start.", true);
                    }

                    if(bAfMeaStrip)
                    {
                        m_iStep = 10;
                        m_iPreStep = 0;
                        SEQ = ESeq.GRL_AfterMeaStrip;
                        _SetLog(">>>>> After measure strip start.", true);
                    }

                    if (bTbClean)
                    {
                        m_iStep    = 10;
                        m_iPreStep = 0 ;
                        SEQ = ESeq.GRL_Table_Clean;
                        _SetLog(">>>>> Table cleaning start.");
                    }
                } 
                else  // Right
                {
                    if(CData.Opt.aTblSkip[(int)EWay.R])
                    {
                        CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_WorkEnd;
                        return true;
                    }
                    if (iSeq == ESeq.GRR_Wait || iSeq == ESeq.Idle)
                    { bWait = true; }
                    
                    //20191206 ghk_drsperiod
                    if ((CData.Dev.aData[m_iWy].dDrsPrid != 0) && (CData.Whls[m_iWy].iGdc >= CData.Dev.aData[m_iWy].dDrsPrid))
                    { CData.DrData[m_iWy].bDrs = true; }
                    //

                    if (CData.DrData[m_iWy].bDrs && (iSeq == ESeq.GRR_Ready || iSeq == ESeq.GRR_Wait))
                    {
                        bDressing = true;
                        if(m_NeedDrs) m_NeedDrs = false; //200310 ksg : Spindle 부하
                    }

                    //200310 ksg : 스핀들 부하
                    if (m_NeedDrs && (iSeq == ESeq.GRR_Ready || iSeq == ESeq.GRR_Wait))
                    {
                        m_NeedDrs = false;
                        bDressing = true;
                    }
                    if (iSeq == ESeq.GRR_Grinding && !bDressing)
                    {
                        if(m_bReqStop) return false;
                        if (!CIO.It.Get_X(eX.GRDR_TbVaccum))
                        {
                            CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_Ready;
                            //CErr.Show(eErr.RIGHT_GRIND_VACUUM_ERROR);
                            m_iStep = 0;
                            return true;
                        }
                        
                        if (CData.Opt.bDryAuto)
                        {
                            //20190703 ghk_automeasure
                            if(CData.Opt.bDryAutoMeaStripSkip)
                            {
                                CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_WaitPick;
                                return false;
                            }
                            else
                            {
                                bMeaStrip = true;
                            }
                            //
                        }
                        else
                        { bGrinding = true; }
                    }

                    if (iSeq == ESeq.GRR_WaterKnife)
                    { bWaterKnife = true; }

#if true //20200416 jhc : R-Table WORK_END 조건 추가
                    if ((CDataOption.PickerImprove == ePickerTimeImprove.Use) && (CData.Dev.bDual == eDual.Dual)) //20200610 jhc : Auto_Running 상태가 아닐 수도 있음
                    //if ((CDataOption.PickerImprove == ePickerTimeImprove.Use) && (CSQ_Main.It.m_iStat == EStatus.Auto_Running) && (CData.Dev.bDual == eDual.Dual))
                    {//Picker Idle Time 개선 옵션 && Auto-Running && 스텝 모드
                        if ((iSeq == ESeq.GRR_Ready) &&                                //R-Table READY
                            (CData.Parts[(int)EPart.ONP].iStat == ESeq.ONP_WorkEnd) && //On-Picker WORK_END
                            (CData.Parts[(int)EPart.GRDL].bExistStrip == false) &&     //L-Table 자재 없음
                            (CData.Parts[(int)EPart.OFP].bExistStrip == false))        //Off-Picker 자재 없음
                        {
                            CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_WorkEnd;
                            _SetLog(">>>>> Work End.");

                            return false; //200228 ksg :
                        }
                    }
                    else
                    {
                        if (iSeq == ESeq.GRR_Ready && CData.Parts[(int)EPart.ONP].iStat == ESeq.ONP_WorkEnd)
                        {
                            CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_WorkEnd;
                            _SetLog(">>>>> Work End.");
                            
                            return false; //200228 ksg :
                        }
                    }
#else
                    if(iSeq == ESeq.GRR_Ready && CData.Parts[(int)EPart.ONP].iStat == ESeq.ONP_WorkEnd)
                    {
                        CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_WorkEnd; 
                        return false; //200228 ksg :
                    }
#endif

                    if(iSeq == ESeq.GRR_WorkEnd)
                    {
                        if (LastTbClean)
                        {
                            //200401 jym : Lot End 시 드레싱 추가
                            if (CData.Opt.bLotDrs)
                            {
                                m_iGStep = 10;
                                m_iGPreStep = 0;
                                m_iStep = 10;
                                m_iPreStep = 0;
                                SEQ = ESeq.GRR_Dressing;
                                _SetLog(">>>>> Dressing start.", true);
                            }
                            else
                            {
                                LastTbClean = false;
                                m_iStep = 10;
                                m_iPreStep = 0;
                                SEQ = ESeq.GRR_Table_Clean;
                                _SetLog(">>>>> Table cleaning start.");
                            }

                            return false;
                        }
                        else
                        {
                            return true;
                        }
                    }

                    //20190703 ghk_automeasure
                    if (iSeq == ESeq.GRR_AfterMeaStrip)
                    { bAfMeaStrip = true; }
                    //

                    //20190819 ghk_tableclean
                    if (iSeq == ESeq.GRR_Table_Clean)
                    { bTbClean = true; }
                    //

                    if (bWait)
                    {
                        m_iStep = 10;
                        m_iPreStep = 0;
                        SEQ = ESeq.GRR_Wait;
                        _SetLog(">>>>> Wait start.");
                    }

                    if (bDressing)
                    {
                        m_iGStep = 10;
                        m_iGPreStep = 0;
                        m_iStep = 10;
                        m_iPreStep = 0;
                        SEQ = ESeq.GRR_Dressing;
                        _SetLog(">>>>> Dressing start.", true);
                    }

                    if (bGrinding)
                    {
                        m_iGStep = 10;
                        m_iGPreStep = 0;
                        m_iStep = 10;
                        m_iPreStep = 0;
                        SEQ = ESeq.GRR_Grinding;
                        _SetLog(">>>>> Grinding start.", true);
                    }

                    if (bWaterKnife)
                    {
                        m_iStep = 10;
                        m_iPreStep = 0;
                        SEQ = ESeq.GRR_WaterKnife;
                        _SetLog(">>>>> Water knife start.");
                    }

                    if (iSeq == ESeq.GRR_WorkEnd)
                    {
                        return true;
                    }

                    if (bMeaStrip)
                    {
                        m_iStep = 10;
                        m_iPreStep = 0;
                        SEQ = ESeq.GRR_Strip_Measure;
                        _SetLog(">>>>> Measure strip start.", true);
                    }

                    if (bAfMeaStrip)
                    {
                        m_iStep = 10;
                        m_iPreStep = 0;
                        SEQ = ESeq.GRR_AfterMeaStrip;
                        _SetLog(">>>>> After measure strip start.", true);
                    }

                    if (bTbClean)
                    {
                        m_iStep = 10;
                        m_iPreStep = 0;
                        SEQ = ESeq.GRR_Table_Clean;
                        _SetLog(">>>>> Table cleaning start.");
                    }
                }
            }

            switch (SEQ)
            {
                default:
                    return false;
                //Left
                case ESeq.GRL_Wait:
                    if (Cyl_Wait())
                    {
                        SEQ = ESeq.Idle;
                        _SetLog("<<<<< Wait end.");
                    }
                    return false;

                case ESeq.GRL_Dressing:
                    if (((CDataOption.IsBfSeq == true) ? Cyl_DrsML() : Cyl_Drs()) == true)
                    {
                        //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
                        ResetAdvancedGrindCondition(1, false); //Condition 검사 플래그 리셋
                        //..

                        SEQ = ESeq.Idle;
                        _SetLog("<<<<< Dressing end.", true);
                    }
                    return false;

                case ESeq.GRL_Grinding:
                    if (((CDataOption.IsBfSeq == true) ? Cyl_GrdML() : Cyl_Grd()) == true)
                    {
                        //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
                        ResetAdvancedGrindCondition(0, false); //Condition 검사 플래그 리셋
                        //..

                        SEQ = ESeq.Idle;
                        _SetLog("<<<<< Grinding end.", true);
                    }
                    return false;

                case ESeq.GRL_WaterKnife:
                    if (Cyl_WKnife())
                    {
                        SEQ = ESeq.Idle;
                        _SetLog("<<<<< Water knife end.");
                    }
                    return false;
                //Right
                case ESeq.GRR_Wait:
                    if (Cyl_Wait())
                    {
                        SEQ = ESeq.Idle;
                        _SetLog("<<<<< Wait end.");
                    }
                    return false;

                case ESeq.GRR_Dressing:
                    if (((CDataOption.IsBfSeq == true) ? Cyl_DrsML() : Cyl_Drs()) == true)
                    {
                        //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
                        ResetAdvancedGrindCondition(1, false); //Condition 검사 플래그 리셋
                        //..

                        SEQ = ESeq.Idle;
                        _SetLog("<<<<< Dressing end.", true);
                    }
                    return false;

                case ESeq.GRR_Grinding:
                    if (((CDataOption.IsBfSeq == true) ? Cyl_GrdML() : Cyl_Grd()) == true)
                    {
                        //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
                        ResetAdvancedGrindCondition(0, false); //Condition 검사 플래그 리셋
                        //..

                        SEQ = ESeq.Idle;
                        _SetLog("<<<<< Grinding end.", true);
                    }
                    return false;

                case ESeq.GRR_WaterKnife:
                    if (Cyl_WKnife())
                    {
                        SEQ = ESeq.Idle;
                        _SetLog("<<<<< Water knife end.");
                    }
                    return false;

                //20190703 ghk_automeasure
                case ESeq.GRL_Strip_Measure:
                    if (CDataOption.Package == ePkg.Strip)
                    {
                        if (Cyl_MeaStrip((int)EMeaStep.Before))   // Before
                        {
                            SEQ = ESeq.Idle;
                            _SetLog("<<<<< Measure strip end.", true);
                        }
                    }
                    else
                    {
                        // 2020-10-27, jhLee : Motorizing probe measure
                        //d if (Cyl_MeaUnit(0))
                        if ((CData.Opt.bPbType) ? Cyl_MeaUnit_ZMotor(0) : Cyl_MeaUnit(0))
                        {
                            SEQ = ESeq.Idle;
                            _SetLog("<<<<< Measure strip end.", true);
                        }
                    }
                    return false;

                case ESeq.GRL_AfterMeaStrip:
                    if(Cyl_AfterMeaStrip())
                    {
                        SEQ = ESeq.Idle;
                        _SetLog("<<<<< After measure strip end.", true);
                    }
                    return false;

                case ESeq.GRR_Strip_Measure:
                    // 2020-12-14, jhLee, Motorize 적용
                    if (CDataOption.Package == ePkg.Strip)
                    {
                        if (Cyl_MeaStrip((int)EMeaStep.Before))    // Before
                        {
                            SEQ = ESeq.Idle;
                            _SetLog("<<<<< Measure strip end.", true);
                        }
                    }
                    else
                    {
                        // 2020-10-27, jhLee : Motorizing probe measure
                        //d if (Cyl_MeaUnit(0))
                        if ((CData.Opt.bPbType) ? Cyl_MeaUnit_ZMotor(0) : Cyl_MeaUnit(0))
                        {
                            SEQ = ESeq.Idle;
                            _SetLog("<<<<< Measure strip end.", true);
                        }
                    }

                    // old
                    //if (CData.Opt.bPbType)
                    //{
                    //    if (Cyl_MeaStripZAxis(0))
                    //    {
                    //        SEQ = ESeq.Idle;
                    //        _SetLog("<<<<< Measure strip end.", true);
                    //    }
                    //}
                    //else
                    //{
                    //    if (CDataOption.Package == ePkg.Strip)
                    //    {
                    //        if (Cyl_MeaStrip(0))
                    //        {
                    //            SEQ = ESeq.Idle;
                    //            _SetLog("<<<<< Measure strip end.", true);
                    //        }
                    //    }
                    //    else
                    //    {
                    //        if (Cyl_MeaUnit(0))
                    //        {
                    //            SEQ = ESeq.Idle;
                    //            _SetLog("<<<<< Measure strip end.", true);
                    //        }
                    //    }
                    //}
                    return false;

                case ESeq.GRR_AfterMeaStrip:
                    if (Cyl_AfterMeaStrip())
                    {
                        SEQ = ESeq.Idle;
                        _SetLog("<<<<< After measure strip end.", true);
                    }
                    return false;

                case ESeq.GRL_Table_Clean:
                    if (Cyl_TblClean())
                    {
                        SEQ = ESeq.Idle;
                        _SetLog("<<<<< Table cleaning end.");
                    }
                    return false;

                case ESeq.GRR_Table_Clean:
                    if (Cyl_TblClean())
                    {
                        SEQ = ESeq.Idle;
                        _SetLog("<<<<< Table cleaning end.");
                    }
                    return false;
            }
        }
        #endregion

        /// <summary>
        /// All Servo On/Off 용도
        /// </summary>
        /// <param name="bVal"></param>
        /// <returns></returns>
        public bool Cyl_Servo(bool bVal)
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_ALL_SERVO_ON_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_ALL_SERVO_ON_TIMEOUT); }
                    _SetLog("Error : Timeout.");

                    m_iStep = 0;
                    return true;
                }
            }

            m_iPreStep = m_iStep;

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10: // 1. 모든 축 서보 온
                    {
                        CMot.It.Set_SOn(m_iX, bVal);
                        CMot.It.Set_SOn(m_iY, bVal);
                        CMot.It.Set_SOn(m_iZ, bVal);
                        if(CDataOption.SplType == eSpindleType.EtherCat)
                        { CMot.It.Set_SOn(m_iSp, bVal); }
                        _SetLog("All servo-on : " + bVal);

                        m_iStep++;
                        return false;
                    }

                case 11: // 2. 서보 온 상태 체크
                    {
                        if ((CMot.It.Chk_Srv(m_iX) == bVal) &&
                            (CMot.It.Chk_Srv(m_iY) == bVal) &&
                            (CMot.It.Chk_Srv(m_iZ) == bVal))
                        {
                            /*
                            if ((CDataOption.SplType == eSpindleType.EtherCat) && (CMot.It.Chk_Srv(m_iSp) == bVal))
                            {
                                _SetLog("Check all servo-on.");
                                m_iStep++;
                            }
                            else if (CDataOption.SplType == eSpindleType.Rs232)
                            {
                                _SetLog("Check all servo-on.");
                                m_iStep++;
                            }
                            */
                            // 2023.03.15 Max
                            _SetLog("Check all servo-on.");
                            m_iStep++;
                        }

                        return false;
                    }

                case 12:
                    {
                        _SetLog("Finish.");

                        m_iStep = 0;
                        return true;
                    }
            }
        }

        /// <summary>
        /// Grind Part Homing
        /// 그라인드 파트 홈 시퀀스
        /// </summary>
        /// <returns></returns>
        public bool Cyl_Home()
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT * 3); }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_HOMING_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_HOMING_TIMEOUT); }
                    _SetLog("Error : Timeout.");

                    m_iStep = 0;
                    return true;
                }
            }

            m_iPreStep = m_iStep;

            if (SafePrb() != 0)
            {// 프로브 축 안전상태 체크
                if (m_eWy == EWay.L)
                { CErr.Show(eErr.LEFT_GRIND_PROBE_SAFTY_ERROR); }
                else
                { CErr.Show(eErr.RIGHT_GRIND_PROBE_SAFTY_ERROR); }
                _SetLog("Error : Probe not safty.");

                m_iStep = 0;
                return true;
            }

            if (SafeTbl(true, true, false) != 0)
            {// 테이블 축 안전상태 체크
                if (m_eWy == EWay.L)
                { CErr.Show(eErr.LEFT_GRIND_TABLE_SAFTY_ERROR); }
                else
                { CErr.Show(eErr.RIGHT_GRIND_TABLE_SAFTY_ERROR); }
                _SetLog("Error : Table not safty.");

                m_iStep = 0;
                return true;
            }

            if (SafeZ(false) != 0)
            {// Z축 안전상태 체크
                if (m_eWy == EWay.L)
                { CErr.Show(eErr.LEFT_GRIND_ZAXIS_SAFTY_ERROR); }
                else
                { CErr.Show(eErr.RIGHT_GRIND_ZAXIS_SAFTY_ERROR); }
                _SetLog("Error : Z axis not safty.");

                m_iStep = 0;
                return true;
            }

            switch (m_iStep)
            {
                default:
                    {
                        m_bHD = false;
                        m_iStep = 0;
                        return true;
                    }

                case 10: // 1. 축 상태 체크 (홈돈 제외)
                    {
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes(false))
                        {
                            m_iStep = 0;
                            return true;
                        }
                        _SetLog("Check axes.");

                        m_iStep++;
                        return false;
                    }

                case 11: // Z축 홈 시작
                    {
                        CMot.It.Mv_H(m_iZ);
                        _SetLog("Z axis homing.");

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {// Z축 홈 완료 확인
                        if (!CMot.It.Get_HD(m_iZ))
                        { return false; }
                        _SetLog("Check Z axis home");

                        m_iStep++;
                        return false;
                    }

                case 13:
                    {// 프로브, 테이블 홈 시작
                        CMot.It.Mv_H(m_iX);
                        CMot.It.Mv_H(m_iY);
                        _SetLog("X, Y axis homing.");

                        m_iStep++;
                        return false;
                    }

                case 14:
                    {// 프로브, 테이블 홈 완료 확인
                        if (!CMot.It.Get_HD(m_iX))
                        { return false; }

                        if (!CMot.It.Get_HD(m_iY))
                        { return false; }
                        _SetLog("Check X, Y axis home");

                        m_iStep++;
                        return false;
                    }

                case 15: //Wait 동작
                    {
                        m_dPosY = CData.SPos.dGRD_Y_Wait[m_iWy];
                       CMot.It.Mv_N(m_iY, m_dPosY); //191203 ksg :
                        _SetLog("Y axis move wait.", m_dPosY);

                       m_iStep++;
                       return false;                      
                    }

                case 16:
                    {// 전체 홈 완료
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }//191203 ksg :
                        m_bHD = true;
                        _SetLog("Finish.");
                        
                        m_iStep = 0;
                        return true;
                    }
            }
        }

        /// <summary>
        /// 대기 위치 이동
        /// </summary>
        /// <returns></returns>
        public bool Cyl_Wait()
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            {
                m_mTimeout.Set_Delay(TIMEOUT);
            }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_WAIT_POSITION_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_WAIT_POSITION_TIMEOUT); }
                    _SetLog("Error : Timeout.");

                    m_iStep = 0;
                    return true;
                }
            }

            m_iPreStep = m_iStep;

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if ((CData.CurCompany == ECompany.ASE_KR) &&
                (m_iStep == 20 || m_iStep == 21))
            {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                if (0 != m_iPickerVacErr)
                {
                    CMot.It.EStop(m_iY); //Table Y축 즉시 Stop

                    if (m_iPickerVacErr == 1)
                    { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                    else
                    { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                    m_iPickerVacErr = 0; //Picker Vac Error Flag 초기화
                    _SetLog("Error : Picker Vacuum : " + m_siY + " STOP : " + CMot.It.Get_FP(m_iY).ToString());

                    m_iStep = 0;
                    return true;
                }
            }
            ///////////////////////////////////////////////////////////////////////////////////////

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10: // 축 상태 체크
                    {
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max 
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }
                        _SetLog("Check axes.");
                        
                        m_iStep++;
                        return false;
                    }

                case 11: // IO 초기화
                    {
                        _InitCycle();
                        _SetLog("Init cycle."); 
                                                    
                        m_iStep++;
                        return false;
                    }

                case 12: // Z축 대기 위치 이동
                    {
                        if(CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        { m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy]; }
                        else
                        { m_dPosZ = CData.SPos.dGRD_Z_Wait[m_iWy]; }
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move position.", m_dPosZ);
                        
                        m_iStep++;
                        return false;
                    }

                case 13: // Z축 대기 위치 이동 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }
                        _SetLog("Check Z axis move.");

                        m_iStep++;
                        return false;
                    }

                case 14:
                    {// 9. 프로브 업
                        if (m_eWy == EWay.L)
                        {
                            m_eIn1 = eX.GRDL_ProbeAMP;
                            m_eOt1 = eY.GRDL_ProbeDn;
                        }
                        else
                        {
                            m_eIn1 = eX.GRDR_ProbeAMP;
                            m_eOt1 = eY.GRDR_ProbeDn;
                        }

                        //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(true);
                        }
                        Func_PrbDown(false);
                        _SetLog("Probe up.");

                        m_iStep++;

                        return false;
                    }

                case 15:
                    {// 10. 프로브 업 체크
                        //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                        dtmp = CPrb.It.Read_Val(m_eWy);
                        if (!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight))
                        { return false; }

                        //211227 pjh : Ejector Off
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(false);
                        }
                        //

                        _SetLog("Check probe up.");

                        m_iStep++;
                        return false;
                    }

                case 16:
                    {// 탑클리너 업
                        if (m_eWy == EWay.L)
                        {
                            m_eIn1 = eX.GRDL_TopClnDn; //syc : new cleaner 삭제 예정 확인 할것
                            m_eOt1 = eY.GRDL_TopClnDn;
                        }
                        else
                        {
                            m_eIn1 = eX.GRDR_TopClnDn;
                            m_eOt1 = eY.GRDR_TopClnDn;
                        }

                        Func_TcDown(false);
                        _SetLog("Top cleaner up.");

                        m_iStep++;
                        return false;
                    }

                case 17:
                    {//탑클리너 업 체크
                         //syc : new cleaner
                        //if (CIO.It.Get_X(m_eIn1))
                        if(Chk_CleanerDn(false))
                        { return false; }
                        _SetLog("Check top cleaner up.");

                        m_iStep++;
                        return false;
                    }

                case 18:
                    {// 프로브 축 표지션 0으로 위치 이동
                        m_dPosX = CData.SPos.dGRD_X_Zero[m_iWy];
                        CMot.It.Mv_N(m_iX, m_dPosX);
                        _SetLog("X axis move zero.", m_dPosX);

                        m_iStep++;
                        return false;
                    }

                case 19:
                    {// 프로브 축 포지션 0으로 이동 확인
                        if (!CMot.It.Get_Mv(m_iX, m_dPosX))
                        { return false; }
                        _SetLog("Check X axis move.");

                        m_iStep++;
                        return false;
                    }

                case 20:
                    {// 테이블 축 대기 위치 이동
                        m_dPosY = CData.SPos.dGRD_Y_Wait[m_iWy];
                        CMot.It.Mv_N(m_iY, m_dPosY);

                        _SetLog("Y axis move wait.", m_dPosY);

                        // 2020.11.24 JSKim St
                        if (CData.CurCompany == ECompany.JCET && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            if (m_eWy == EWay.L)    {   CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_Ready;    }
                            else                    {   CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_Ready;    }
                            _SetLog("Finish.  Status : " + CData.Parts[m_iPart].iStat);

                            m_iStep = 0;
                            return true;
                        }
                        // 2020.11.24 JSKim Ed

                        m_iStep++;
                        return false;
                    }

                case 21:
                    {// 테이블 축 대기 위치 이동 확인
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }
                        _SetLog("Check Y axis move.");

                        m_iStep++;
                        return false;
                    }

                case 22:
                    {// 종료
                        if (m_eWy == EWay.L)    { CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_Ready; }
                        else                    { CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_Ready; }
                        _SetLog("Finish.  Status : " + CData.Parts[m_iPart].iStat);

                        m_iStep = 0;
                        return true;
                    }
            }
        }
        /// <summary>
        /// Unit Mold 의 경우 측정 위치에 Unit 감지 되어 Vaccum 센서 감지 확인
        /// </summary>
        /// <param name="iIdx"></param>
        /// <returns></returns>
        public bool bChuck_Table_Unit_Exist(int nNext_Row_Cnt)
        {
            bool bret_val = false;
            bret_val = true;
            int nUnit_Cnt = CData.Dev.iRow;// * CData.Dev.iWinCnt;// Table 1 Mold 에 Y_axis Probe Row count
            if (m_eWy == EWay.L)
            {
                if (nNext_Row_Cnt < (nUnit_Cnt * 1))
                {
                    if (CIO.It.Get_X(eX.GRDL_Unit_4_Vacuum)) bret_val = true;                
                    Console.WriteLine("Unit 1, Vaccum 4 , Row Count " + nNext_Row_Cnt);
                }
                else if (nNext_Row_Cnt < (nUnit_Cnt * 2))
                {
                    if (CIO.It.Get_X(eX.GRDL_Unit_3_Vacuum)) bret_val = true;                    
                    Console.WriteLine("Unit 2, Vaccum 3 , Row Count " + nNext_Row_Cnt);
                }
                else if (nNext_Row_Cnt < (nUnit_Cnt * 3))
                {
                    if (CIO.It.Get_X(eX.GRDL_Unit_2_Vacuum)) bret_val = true;                    
                    Console.WriteLine("Unit 3, Vaccum 2 , Row Count " + nNext_Row_Cnt);
                }
                else if (nNext_Row_Cnt < (nUnit_Cnt * 4))
                {
                    if (CIO.It.Get_X(eX.GRDL_Unit_1_Vacuum)) bret_val = true;                    
                    Console.WriteLine("Unit 4, Vaccum 1 , Row Count " + nNext_Row_Cnt);
                }
            }else
            {
                if (nNext_Row_Cnt < (nUnit_Cnt * 1))
                {
                    if (CIO.It.Get_X(eX.GRDR_Unit_4_Vacuum)) bret_val = true;
                    Console.WriteLine("Unit 1, Vaccum 4 , Row Count " + nNext_Row_Cnt);
                }
                else if (nNext_Row_Cnt < (nUnit_Cnt * 2))
                {
                    if (CIO.It.Get_X(eX.GRDR_Unit_3_Vacuum)) bret_val = true;
                    Console.WriteLine("Unit 2, Vaccum 3 , Row Count " + nNext_Row_Cnt);
                }
                else if (nNext_Row_Cnt < (nUnit_Cnt * 3))
                {
                    if (CIO.It.Get_X(eX.GRDR_Unit_2_Vacuum)) bret_val = true;
                    Console.WriteLine("Unit 3, Vaccum 2 , Row Count " + nNext_Row_Cnt);
                }
                else if (nNext_Row_Cnt < (nUnit_Cnt * 4))
                {
                    if (CIO.It.Get_X(eX.GRDR_Unit_1_Vacuum)) bret_val = true;
                    Console.WriteLine("Unit 4, Vaccum 1 , Row Count " + nNext_Row_Cnt);
                }
            }
            //bret_val = true;
            return bret_val;
        }


        //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
        /// <summary>
        /// 현재 확인 대상 스트립의 18 Point 측정 여부 확인
        /// 
        /// Lot Open 상태에서 Before Measure 시작 시 본 function call 
        /// *** Step Mode, R-Table에서 Before Measure 시작시는 Leading Strip 투입 카운트 증가시키지 않음
        ///     (-> Step 모드에서는 L-Table에서 18포인트 측정 시 R-Table에서도 18 포인트 측정해야 함)
        /// 
        /// 매뉴얼 Grinding/Strip Measure 버튼 눌렀을 떄 팝업 창에서 사용자 선택 값    
        /// 
        /// </summary>
        /// <param name="b18PStrip">현재 확인 대상 스트립의 Leading Strip 여부 설정 값</param>
        /// <param name="bCountUp">true=현재 확인 대상 스트립이 Leading Stip인 경우 Leading Strip 측정 카운트를 1 증가시킴, false=Leading Strip 측정 카운트를 증가시키지 않음</param>
        /// <returns></returns>
        private int _checkIf18PStrip(ref bool b18PStrip, bool bCountUp)
        {
            /////////////////////////////////////////////////////////
            // => 18 Point 측정 사용 옵션 아니면 비적용
            // => Lot Open 후 첫 n장 설정 값이 0인 경우 비적용
            if ((!CDataOption.Use18PointMeasure) || (CData.Dev.i18PStripCount <= 0))
            {
                b18PStrip = false;
                return (-1);
            }

            /////////////////////////////////////////////////////////
            // Manual Grinding 또는 Manual Strip Measure의 경우
            //   => 버튼 눌렀을 때 팝업 창에서 사용자 선택으로 결정됨
            if (CSQ_Main.It.m_iStat == EStatus.Manual)
            {
                b18PStrip = m_bManual18PMeasure; //매뉴얼 Grinding/Strip Measure 버튼 눌렀을 떄 팝업 창에서 사용자 선택 값
                return (0);
            }

#if true
            /////////////////////////////////
            // Step Mode에서 R-Table인 경우 
            //   => 현재 설정 상태 변경하지 않음 (즉, Step 모드에서는 L-Table에서 18포인트 측정 시 R-Table에서도 18 포인트 측정해야 함)
            if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
            { return (0); }

            /////////////////////////////////
            // Step Mode L-Table, 
            // Normal Mode L-Table, 
            // Normal Mode R-Table 인 경우
            //   => 18 Point 기 측정회수 체크하여 현 시점 18 Point 측정 여부 판단

            // 2021-05-25, jhLee, Muti-Lot 사용시 해당 Lot의 정보를 이용하도록 한다.
            if (CData.IsMultiLOT())
            {
                SetMyLotInfo();     // 내부 사용 LotInfo  대입

                // 비정상 값 초기화
                if (m_myLotInfo.i18PMeasuredCount < 0) { m_myLotInfo.i18PMeasuredCount = 0; }

                // 18 Point 기 측정회수 체크하여 현 시점 18 Point 측정 여부 판단
                if (m_myLotInfo.i18PMeasuredCount < CData.Dev.i18PStripCount)
                {
                    ///////////////////////////////////////////////////////////////////
                    b18PStrip = true;
                    if (bCountUp ) // 항상 Lot Open 상태 && Count Up Flag True
                    {
                        m_myLotInfo.i18PMeasuredCount++; //18 Point 측정 회수 1 증가
                    }
                    ///////////////////////////////////////////////////////////////////
                }
                else
                {
                    b18PStrip = false;
                }
            }
            else
            {
                // 비정상 값 초기화
                if (CData.LotInfo.i18PMeasuredCount < 0) { CData.LotInfo.i18PMeasuredCount = 0; }

                // 18 Point 기 측정회수 체크하여 현 시점 18 Point 측정 여부 판단
                if (CData.LotInfo.i18PMeasuredCount < CData.Dev.i18PStripCount)
                {
                    ///////////////////////////////////////////////////////////////////
                    b18PStrip = true;
                    if (bCountUp && CData.LotInfo.bLotOpen) //Lot Open 상태 && Count Up Flag True
                    {
                        CData.LotInfo.i18PMeasuredCount++; //18 Point 측정 회수 1 증가
                    }
                    ///////////////////////////////////////////////////////////////////
                }
                else
                {
                    b18PStrip = false;
                }
            }

            return (0);
#else
            /////////////////////////////////////////////////////////
            // Auto-Running의 경우
            //   => Lot Open 상태 아니면 비적용
            //   => Run 중이 아니면 비적용
            if (CSQ_Main.It.m_bRun /*&& CData.LotInfo.bLotOpen*/)
            {
                /////////////////////////////////
                // Step Mode에서 R-Table인 경우 
                //   => 현재 설정 상태 변경하지 않음 (즉, Step 모드에서는 L-Table에서 18포인트 측정 시 R-Table에서도 18 포인트 측정해야 함)
                if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                { return (0); }

                /////////////////////////////////
                // Step Mode L-Table, 
                // Normal Mode L-Table, 
                // Normal Mode R-Table 인 경우
                //   => 18 Point 기 측정회수 체크하여 현 시점 18 Point 측정 여부 판단

                // 비정상 값 초기화
                if (CData.LotInfo.i18PMeasuredCount < 0) { CData.LotInfo.i18PMeasuredCount = 0; }

                // 18 Point 기 측정회수 체크하여 현 시점 18 Point 측정 여부 판단
                if (CData.LotInfo.i18PMeasuredCount < CData.Dev.i18PStripCount)
                {
                    ///////////////////////////////////////////////////////////////////
                    b18PStrip = true;
                    if (bCountUp && CData.LotInfo.bLotOpen) //Lot Open 상태 && Count Up Flag True
                    {
                        CData.LotInfo.i18PMeasuredCount++; //18 Point 측정 회수 1 증가
                    }
                    ///////////////////////////////////////////////////////////////////
                }
                else
                {
                    b18PStrip = false;
                }
                return (0);
            }
            else
            {
                b18PStrip = false;
                return (-1);
            }
#endif
        }
        //


        /// <returns></returns>
        /// <summary>
        /// 스트립 측정 포인트 수 체크
        /// 체크 후 측정포인트 수가 SECS/GEM 데이터용 배열 사이즈 초과시 Error 팝업 발생시킬 목적으로 호출함
        /// => 측정 전, Device Save 전 체크 필요함
        /// => 신규 Recipe가 아닌 기존 Recipe(Device)는 Save 동작 하지 않았을 수 있으므로, Measure 전 확인 필요
        /// </summary>
        /// <param name="bManualMode">true=매뉴얼(Grinding/StripMeasure) 버튼 또는 TenKey 눌렀을 때 체크용, false=Auto-Run 시작 시 체크용</param>
        /// <returns>측정 포인트 수가 SECS/GEM용 배열 사이즈 범위 초과시 표시할 에러 메시지, ""=측정 포인트 수가 SECS/GEM용 배열 사이즈 범위 이내(안전), !""=측정 포인트 수가 SECS/GEM용 배열 사이즈 범위 초과(위험)</returns>
        public string CheckMeasurePointCount(bool bManualMode)
        {
            int iRow = CData.Dev.iRow * CData.Dev.iWinCnt;
            int iCol = CData.Dev.iCol;
            int [] iCnt = { 0, 0 }; //idx 0=Before, 1=After
            bool b18PMeasure = false;

            if (CDataOption.Package == ePkg.Strip)
            {
                /////////////////////////////////////////////////////////
                // Manual Grinding 또는 Manual Strip Measure의 경우
                //   => 버튼 눌렀을 때 팝업 창에서 사용자 선택으로 결정됨
                if (bManualMode)
                {
                    b18PMeasure = m_bManual18PMeasure; //매뉴얼 Grinding/Strip Measure 버튼 눌렀을 떄 팝업 창에서 사용자 선택 값
                }
                else
                {
                    this._checkIf18PStrip(ref b18PMeasure, false);
                }

                if (b18PMeasure)
                { //18 Point 측정 스트립인 경우
                    for (int k=0; k<iCol; k++)
                    {
                        for (int j=0; j <iRow; j++)
                        {
                            if (CData.Dev.aData[m_iWy].aPosBf[j,k].bUse18P) { iCnt[0]++; }
                            if (CData.Dev.aData[m_iWy].aPosAf[j,k].bUse18P) { iCnt[1]++; }
                        }
                    }

                    if (GV.STRIP_MEASURE_POINT_MAX < iCnt[0])
                    {
                        if (m_eWy == EWay.L)
                        { return ("Test Strip Measure Point Count Over - Left, Before (" + iCnt[0] + ") > " + GV.STRIP_MEASURE_POINT_MAX); }
                        else
                        { return ("Test Strip Measure Point Count Over - Right, Before (" + iCnt[0] + ") > " + GV.STRIP_MEASURE_POINT_MAX); }
                    }
                    if (GV.STRIP_MEASURE_POINT_MAX < iCnt[1])
                    {
                        if (m_eWy == EWay.L)
                        { return ("Test Strip Measure Point Count Over - Left, After (" + iCnt[1] + ") > " + GV.STRIP_MEASURE_POINT_MAX); }
                        else
                        { return ("Test Strip Measure Point Count Over - Right, After (" + iCnt[1] + ") > " + GV.STRIP_MEASURE_POINT_MAX); }
                    }
                }
                else
                { //일반 스트립인 경우
                    for (int k=0; k<iCol; k++)
                    {
                        for (int j=0; j <iRow; j++)
                        {
                            if (CData.Dev.aData[m_iWy].aPosBf[j,k].bUse) { iCnt[0]++; }
                            if (CData.Dev.aData[m_iWy].aPosAf[j,k].bUse) { iCnt[1]++; }
                        }
                    }

                    if (GV.STRIP_MEASURE_POINT_MAX < iCnt[0])
                    {
                        if (m_eWy == EWay.L)
                        { return ("Main Strip Measure Point Count Over - Left, Before (" + iCnt[0] + ") > " + GV.STRIP_MEASURE_POINT_MAX); }
                        else
                        { return ("Main Strip Measure Point Count Over - Right, Before (" + iCnt[0] + ") > " + GV.STRIP_MEASURE_POINT_MAX); }
                    }
                    if (GV.STRIP_MEASURE_POINT_MAX < iCnt[1])
                    {
                        if (m_eWy == EWay.L)
                        { return ("Main Strip Measure Point Count Over - Left, After (" + iCnt[1] + ") > " + GV.STRIP_MEASURE_POINT_MAX); }
                        else
                        { return ("Main Strip Measure Point Count Over - Right, After (" + iCnt[1] + ") > " + GV.STRIP_MEASURE_POINT_MAX); }
                    }
                }
            }
            else
            {
                return (""); //2000U는 아직 18 Point 측정 기능 미지원
            }

            return (""); //스트립 측정 포인트 수 허용 범위 내 (OK)
        }
        //


        //200625 jhc : ASE-KR은 스트립 측정 시 테이블 한 번만 측정
        /// <summary>
        /// Cyl_MeaStrip_Probe() = Cyl_MeaStrip_T1() + Cyl_MeaStrip_T2() 하나로 통합한 함수 (T1과 동일한 동작으로 측정)
        /// Cyl_MeaStrip_T1() = 기존 Cyl_MeaStrip_() 함수 : ASE-KOREA (스트립 측정 시 테이블 한 번만 측정)
        /// Cyl_MeaStrip_T2() = 기존 Cyl_MeaStrip() 함수  : ASE-KOREA 이 외 사이트
        /// </summary>
        /// <param name="iBfAf"></param>
        /// <returns></returns>
        public bool Cyl_MeaStrip(int iBfAf)  // Before/After
        {
            // 2021.07.29 lhs Start : 측정함수 별도로 만들기
            if (CDataOption.UseNewSckGrindProc)
            {
                return Cyl_MeaStrip_NewSck(iBfAf); // before / After

            }
            else
            // 2021.07.29 lhs End
            {
                if (CData.Opt.bPbType)        // Z 축 모터를 이용한 측정 방식이라면
                {
                    return Cyl_MeaStrip_ZMotor(iBfAf);   // Z축 Up/Down 방식 사용
                }
                else
                {
                    // 2020-12-14, jhLee, 기존 T1, T2를 합친 하나의 함수를 사용 할 것인가 ?
                    if (CData.Opt.bMeasureFunctionType)
                    {
                        return Cyl_MeaStrip_Probe(iBfAf);    // 기존의 Probe Up/Down 방식을 이용한다.
                    }
                    else
                    {
                        // OLD, T1과 T2로 나뉜 함수
                        if (CData.CurCompany == ECompany.ASE_KR)
                        { return Cyl_MeaStrip_T1(iBfAf); }
                        else
                        { return Cyl_MeaStrip_T2(iBfAf); }
                    }
                }
            }

        }
        //


        /// <summary>
        /// Strip Thickness Measure
        /// 스트립 두께 측정 함수 0:Before, 1:After 
        /// 초기 Table 1번만 측정하게 수정 (200427 jym)
        /// </summary>
        /// <param name="iIdx"></param>
        /// <returns></returns>
        public bool Cyl_MeaStrip_T1(int iIdx) //200625 jhc : ASE-KR은 스트립 측정 시 테이블 한 번만 측정 <- Cyl_MeaStrip_()
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            {
                m_mTimeout.Set_Delay(TIMEOUT);
            }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (iIdx == (int)EMeaStep.Before/*0*/)     // 2021.09.17 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                    {
                        CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_STRIP_INSPECTION_BEFORE_TIMEOUT :
                                                           eErr.RIGHT_GRIND_STRIP_INSPECTION_BEFORE_TIMEOUT);
                        
                        _SetLog("Error : Before timeout.");
                        // 201009 jym : Before 측정 시에만 적용
                        m_bSubErr = true;
                    }
                    else
                    {
                        CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_STRIP_INSPECTION_AFTER_TIMEOUT :
                                                           eErr.RIGHT_GRIND_STRIP_INSPECTION_AFTER_TIMEOUT);
                        
                        _SetLog("Error : After timeout.");
                    }

                    m_iStep = 0;
                    return true;
                }
            }

            if (!Chk_Strip())
            {
                CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_VACUUM_ERROR :
                                                   eErr.RIGHT_GRIND_VACUUM_ERROR);
                _SetLog("Error : Vacuum fail.");

                // 201009 jym : Before 측정 시에만 적용
                if (iIdx == (int)EMeaStep.Before/*0*/)     // 2021.09.17 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                {
                    m_bSubErr = true;
                }

                m_iStep = 0;
                return true;
            }

            m_iPreStep = m_iStep;

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if ((CData.CurCompany == ECompany.ASE_KR) &&
                (m_iStep == 14 || m_iStep == 15 || m_iStep == 28 || m_iStep == 29 || m_iStep == 33 || m_iStep == 34))
            {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                if (0 != m_iPickerVacErr)
                {
                    CMot.It.EStop(m_iY); //Table Y축 즉시 Stop
                    _SetLog("Error : Picker vacuum fail.", CMot.It.Get_FP(m_iY));

                    m_iStep = 100; //정리 스텝으로
                    return false;
                }
            }
            ///////////////////////////////////////////////////////////////////////////////////////

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10:
                    {// 축 상태 체크
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }

                        m_bMeaErrBf_L = false;
                        m_bMeaErrAf_L = false;
                        m_bMeaErrBf_R = false;
                        m_bMeaErrAf_R = false;

                        // 2022.08.05 SungTae Start : [추가] (ASE-KR 개발건)
                        m_bMeaErr_FinalTarget_L = false;
                        m_bMeaErr_FinalTarget_R = false;
                        // 2022.08.05 SungTae End

                        // jhLee, Multi-LOT의 경우에도 SPC 기록
                        // ASE-KR의 경우 OFF-LINE과 ON-LINE(LOCAL) 상태에서 연속 LOT 처리되어야 해서 SECS/GEM Flag 확인 조건 추가함.
                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        //190319 ksg :
                        ProbeClearVal(iIdx);

                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if(CData.CurCompany == ECompany.Qorvo || (CData.CurCompany == ECompany.Qorvo_DZ) || CData.CurCompany == ECompany.SST) && iIdx == 0)
                        if((CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ ||
                            CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC ||
                            CData.CurCompany == ECompany.SST) && iIdx == (int)EMeaStep.Before/*0*/)     // 2021.09.17 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                        {
                            ProbeClearVal(iIdx + 1);
                        }

                        //191120 ksg :
                        InitPbValue(m_iWy, iIdx);

                        // 200920 jym : 프로브 업 체크 카운트 초기화
                        m_iPrbUpCnt = 0;

                        m_bSubErr = false;

                        _SetLog("Check axes.");

                        m_iStep++;
                        return false;
                    }

                case 11:
                    {// IO 초기화
                        _InitCycle();
                        _SetLog("Init cycle.");

                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            if (!CData.dfInfo.bBusy)
                            {
                                if (m_eWy == EWay.L)
                                {
                                    if (iIdx == (int)EMeaStep.Before/*0*/)     // 2021.09.17 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                                    {
                                        CData.GRLDfData.sBcr = CData.Parts[(int)EPart.GRDL].sBcr;
                                        CDf.It.SendBfStart("LGD");
                                    }
                                    else
                                    {
                                        if (CData.Dev.bDual == eDual.Normal)
                                        {
                                            CData.GRLDfData.sBcr = CData.Parts[(int)EPart.GRDL].sBcr;
                                            CDf.It.SendAfStart("LGD");
                                        }
                                    }
                                }
                                else
                                {
                                    // 2021.09.17 SungTae Start : [수정] 코드 확인이 용이하도록 변경
                                    // 0 -> (int)EMeaStep.Before
                                    // 1 -> (int)EMeaStep.After
                                    if (iIdx == (int)EMeaStep.Before/*0*/ && CData.Dev.bDual == eDual.Normal)
                                    {
                                        CData.GRRDfData.sBcr = CData.Parts[(int)EPart.GRDR].sBcr;
                                        CDf.It.SendBfStart("RGD");
                                    }
                                    else if (iIdx == (int)EMeaStep.After/*1*/)
                                    {
                                        CData.GRRDfData.sBcr = CData.Parts[(int)EPart.GRDR].sBcr;
                                        CDf.It.SendAfStart("RGD");
                                    }
                                    // 2021.09.17 SungTae End
                                }
                            }
                            else
                            {
                                return false;
                            }
                        }

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {// 데이터 저장 변수 초기화                       
                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            if (m_eWy == EWay.L)
                            {
                                if (iIdx == (int)EMeaStep.Before/*0*/)     // 2021.09.17 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                                {
                                    if (!CDf.It.ReciveAckGRL((int)ECMD.scBfStartL))
                                    {
                                        return false;
                                    }
                                }
                                else
                                {
                                    if (CData.Dev.bDual == eDual.Normal)
                                    {
                                        if (!CDf.It.ReciveAckGRL((int)ECMD.scAfStartL))
                                        {
                                            return false;
                                        }
                                    }
                                }

                                // 2021.09.17 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                                if (CData.dfInfo.sGl == "GL1" && iIdx == (int)EMeaStep.Before/*0*/ && CDataOption.MeasureDf == eDfServerType.MeasureDf)
                                {//GL1이고, Before측정이고, DF서버 사용시 DF 측정 할때
                                    if (!CData.dfInfo.bBusy)
                                    {
                                        CData.GRLDfData.dPcb1 = CData.Parts[(int)EPart.GRDL].dPcb[0];
                                        CData.GRLDfData.dPcb2 = CData.Parts[(int)EPart.GRDL].dPcb[1];
                                        CData.GRLDfData.dPcb3 = CData.Parts[(int)EPart.GRDL].dPcb[2];

                                        if      (CData.Dynamic.iHeightType == 0)    { CData.GRLDfData.sPcbUse = "Max"; }
                                        else if (CData.Dynamic.iHeightType == 1)    { CData.GRLDfData.sPcbUse = "Avg"; }

                                        CDf.It.SendPcbData("LGD");
                                    }
                                    else
                                    {
                                        return false;
                                    }
                                }
                            }
                            else
                            {
                                // 2021.09.17 SungTae Start : [수정] 코드 확인이 용이하도록 변경
                                // 0 -> (int)EMeaStep.Before
                                // 1 -> (int)EMeaStep.After
                                if (iIdx == (int)EMeaStep.Before/*0*/ && CData.Dev.bDual == eDual.Normal)
                                {
                                    if (!CDf.It.ReciveAckGRR((int)ECMD.scBfStartR)) { return false; }
                                }
                                else if (iIdx == (int)EMeaStep.After/*1*/)
                                {
                                    if (!CDf.It.ReciveAckGRR((int)ECMD.scAfStartR)) { return false; }
                                }

                                //GL1이고, Before측정이고, Step모드 아니고, DF서버 사용시 DF 측정 할때
                                if (CData.dfInfo.sGl == "GL1" && iIdx == (int)EMeaStep.Before/*0*/ && CData.Dev.bDual == eDual.Normal && CDataOption.MeasureDf == eDfServerType.MeasureDf)
                                {
                                    if (!CData.dfInfo.bBusy)
                                    {
                                        CData.GRRDfData.dPcb1 = CData.Parts[(int)EPart.GRDR].dPcb[0];
                                        CData.GRRDfData.dPcb2 = CData.Parts[(int)EPart.GRDR].dPcb[1];
                                        CData.GRRDfData.dPcb3 = CData.Parts[(int)EPart.GRDR].dPcb[2];

                                        if      (CData.Dynamic.iHeightType == 0)    { CData.GRRDfData.sPcbUse = "Max"; }
                                        else if (CData.Dynamic.iHeightType == 1)    { CData.GRRDfData.sPcbUse = "Avg"; }

                                        CDf.It.SendPcbData("RGD");
                                    }
                                    else
                                    {
                                        return false;
                                    }
                                }
                            }
                        }
                        //

                        m_iRow = 0;
                        m_iCol = 0;
                        m_dPosX = CData.SPos.dGRD_X_Zero[m_iWy];
                        m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS;
                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];

                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_ProbeDn;
                            m_eOt2 = eY.GRDL_ProbeAir;
                            m_eIn1 = eX.GRDL_ProbeAMP;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_ProbeDn;
                            m_eOt2 = eY.GRDR_ProbeAir;
                            m_eIn1 = eX.GRDR_ProbeAMP;
                        }

                        // 2021.09.17 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            m_aInspBf    = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            m_abMeaBfErr = new bool[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            
                            CData.GrData[m_iWy].aMeaBf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            
                            if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ ||
                                CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC ||
                                CData.CurCompany == ECompany.SST)
                            {
                                m_aInspAf    = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                                m_abMeaAfErr = new bool[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];

                                CData.GrData[m_iWy].aMeaAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            }

                        }
                        else
                        {
                            m_aInspAf    = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            m_abMeaAfErr = new bool[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            
                            CData.GrData[m_iWy].aMeaAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            
                            if (m_eWy == EWay.L)
                            {
                                m_aInspShift = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            }
                        }

                        m_aInspTemp = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];

                        _SetLog("Init data.");

                        //2021.08.06 syc : Up상태일때 Probe 값 정상 범위 인지 확인
                        //- Qorvo 프로브 앰프값 자동으로 바뀌는 이슈에 대한 방지책
                        //- Probe 값이 18.9xxx ~ 19.0xxx 범위 이탈시 알람
                        if (Chk_ProbeUpVal())
                        {
                            m_iStep = 0;
                            return true;
                        }

                        m_iStep++;
                        return false;
                    }

                case 13:
                    {// Z축 측정 위치 이동
                        // 2021.09.17 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl == "GL1" &&
                            iIdx == (int)EMeaStep.Before/*0*/ && CSQ_Main.It.m_iStat == EStatus.Auto_Running && CDataOption.MeasureDf == eDfServerType.MeasureDf)
                        {
                            if (m_eWy == EWay.L)
                            {
                                if (!CDf.It.ReciveAckGRL((int)ECMD.scPcbL))
                                {
                                    return false;
                                }
                            }
                            else
                            {
                                if (CData.Dev.bDual == eDual.Normal)
                                {
                                    if (!CDf.It.ReciveAckGRR((int)ECMD.scPcbR))
                                    {
                                        return false;
                                    }
                                }
                            }
                        }

                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move position.", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 14:
                    {// Z축 테이블 측정 위치 이동 확인, Y축 Table 상단 측정 위치 이동
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ)) { return false; }

                        // 2021.09.24 SungTae Start : [수정] Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가 (ASE-KR VOC)
                        //CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]);
                        //_SetLog("Y axis move measure table base(TOP).", CData.SPos.dGRD_Y_TblInsp[m_iWy]);

                        string sTblBase = (m_iTblMeasCnt == 0) ? "TOP" : "BTM";
                        double dPosY = 0.0;

                        if (m_iTblMeasCnt == 0)
                        {
                            // Table Y-Axis Top Position
                            dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                        }

                        else
                        {
                            // Table Y-Axis Btm Position
                            dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy] + Math.Abs((CData.SPos.dGRD_Y_TblInsp[m_iWy] - CData.MPos[m_iWy].dY_PRB_TBL_CENTER)) * 2;
                        }

                        CMot.It.Mv_N(m_iY, dPosY);

                        _SetLog("[" + sTblBase + "] Y axis move measure table base.", dPosY);
                        // 2021.09.24 SungTae End

                        m_iStep++;
                        return false;
                    }

                case 15:
                    {// Y축 Table 상단 측정 위치 이동 확인, X축 0으로 이동
                        // 2021.09.24 SungTae Start : [수정] Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가 (ASE-KR VOC)
                        //if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]))
                        //{
                        //    return false;
                        //}

                        double dPosY = 0.0;

                        if (m_iTblMeasCnt == 0) { dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy]; }
                        else                    { dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy] + Math.Abs((CData.SPos.dGRD_Y_TblInsp[m_iWy] - CData.MPos[m_iWy].dY_PRB_TBL_CENTER)) * 2; }

                        if (!CMot.It.Get_Mv(m_iY, dPosY))
                        {
                            return false;
                        }
                        // 2021.09.24 SungTae End

                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                        _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 16:
                    {// X축 0으로 이동 확인, 프로브 에어 온
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        {
                            return false;
                        }

                        Func_PrbAir(true);
                        _SetLog("Porbe air on.");

                        m_iStep++;
                        return false;
                    }

                case 17:
                    {//프로브 에어 온 확인, 프로브 다운
                        if (!Func_PrbAir(true))
                        {
                            return false;
                        }

                        Func_PrbDown(true);
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 18:
                    {//프로브 다운 확인, 프로브 에어 오프
                        if (!CIO.It.Get_X(m_eIn1))
                        {
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            Func_PrbAir(false);
                            _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }

                        return false;
                    }

                case 19:
                    {//프로브 에어 오프 확인, 프로브 값 획득 후 테이블 높이 계산
                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            m_InspZeroOffset = CPrb.It.Read_Val(m_eWy);

                            // 2021.09.24 SungTae Start : [수정] Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가 (ASE-KR VOC)
                            //CData.Tbl_Af[m_iWy, 0] = m_InspZeroOffset + GV.EQP_TABLE_MIN_THICKNESS;
                            //_SetLog("Table Base Thickness : " + CData.Tbl_Af[m_iWy, 0] + "mm", true);

                            string sWay = (m_iWy == (int)EWay.L) ? "LEFT" : "RIGHT";

                            if (m_iTblMeasCnt == 0)     // Top Base
                            {
                                CData.Tbl_Af[m_iWy, 0] = m_InspZeroOffset + GV.EQP_TABLE_MIN_THICKNESS;

                                _SetLog("[" + sWay + "] Table Top Base Thickness : " + CData.Tbl_Af[m_iWy, 0] + "mm.  PCB Value : " + m_InspZeroOffset + "mm", true);
                            }
                            else                        // Bottom Base
                            {
                                CData.Tbl_Af[m_iWy, 1] = m_InspZeroOffset + GV.EQP_TABLE_MIN_THICKNESS;

                                _SetLog("[" + sWay + "] Table Bottom Base Thickness : " + CData.Tbl_Af[m_iWy, 1] + "mm.  PCB Value: " + m_InspZeroOffset + "mm", true);
                            }

                            //if (CData.Tbl_Af[m_iWy, 0] > (GV.EQP_TABLE_MIN_THICKNESS + 4))
                            if (CData.Tbl_Af[m_iWy, 0] > (GV.EQP_TABLE_MIN_THICKNESS + 4) || CData.Tbl_Af[m_iWy, 1] > (GV.EQP_TABLE_MIN_THICKNESS + 4))
                            {
                                CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_MANUALZIG_ON_THE_TABLE :
                                                                   eErr.RIGHT_GRIND_MANUALZIG_ON_THE_TABLE);

                                _SetLog("Error : Manual Zig on the table.");

                                m_bSubErr = true;

                                m_iStep = 0;
                                m_iGStep = 0;
                                return true;
                            }
                            // 2021.09.24 SungTae End

                            m_InspZeroOffset = 0; //20200506 jym : DEBUG
                            m_iStep++;
                        }

                        return false;
                    }

                case 20:
                    {//프로브 업
                        Func_PrbDown(false);

                        m_Delay.Set_Delay(GV.PRB_DELAY);//191002 ksg :
                        _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 21:
                    {//프로브 업 확인, Z축 자재 측정 위치로 이동

                        bool bReadProbeVal = false; //201020 jhc : 단위 Case 문 내에서 프로브 1번만 읽기 위함 (불필요 delay 방지)

                        if (CData.CurCompany != ECompany.Qorvo    && CData.CurCompany != ECompany.Qorvo_DZ &&
                            CData.CurCompany != ECompany.Qorvo_RT && CData.CurCompany != ECompany.Qorvo_NC &&
                            CData.CurCompany != ECompany.SST)
                        {
                            //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                            dtmp = CPrb.It.Read_Val(m_eWy);

                            bReadProbeVal = true; //201020 jhc : 단위 Case 문 내에서 프로브 1번만 읽기 위함 (불필요 delay 방지)

                            if ((!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)) && m_Delay.Chk_Delay())
                            {
                                m_iPrbUpCnt++;

                                if (m_iPrbUpCnt == 3)
                                {
                                    CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET :
                                                                       eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                                    //_SetLog("Error : Probe up not complete.");
                                    //210907 pjh : Probe Up Log 추가
                                    _SetLog("Error : Probe up not complete. Probe Height: " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                                    //

                                    // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                                    if (iIdx == (int)EMeaStep.Before/*0*/)
                                    {
                                        m_bSubErr = true;
                                    }

                                    m_iStep = 0;
                                    return true;
                                }
                                else
                                {
                                    Func_PrbDown(false);
                                    m_Delay.Set_Delay(GV.PRB_DELAY);//191002 ksg :
                                    //_SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");
                                    //210907 pjh : Probe Up Log 추가
                                    _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms" + " Probe Height : " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                                    //
                                    _SetLog("Probe up cycle retry.  Count : " + m_iPrbUpCnt);

                                    return false;
                                }
                            }

                            // 200920 jym : 프로브 업 체크 카운트 초기화
                            m_iPrbUpCnt = 0;
                        }

                        // 2021.09.17 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                        //200325 ksg : Data Shift Probe Skip
                        if (CData.Dev.bDShiftPSkip && m_eWy == EWay.R && iIdx == (int)EMeaStep.Before/*0*/ && CSQ_Main.It.m_bRun && CData.Dev.bDual == eDual.Dual) //200428 ksg : Data Shift Probe Skip 조건 추가
                        {
#if true //201020 jhc : Data Shift전 Probe Up 후 Delay 필요
                            if (!bReadProbeVal)     //bReadProbeVal : 단위 Case 문 내에서 프로브 1번만 읽기 위함 (불필요 delay 방지)
                            {
                                dtmp = CPrb.It.Read_Val(m_eWy);
                            }

                            if ((!m_Delay.Chk_Delay()) && (!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)))
                            {
                                return false; //Data Shift 인 경우 프로브 업 대기
                            }
#endif
                            //200513 myk : Dats Shift 시 One Point 강제 셋팅
                            CData.GrData[(int)EWay.R].aOldOnPont[0] = CData.Parts[(int)EPart.GRDR].dShiftT;
                            //_SetLog("Data shift.");
                            _SetLog("Data shift -> OldOnePoint = " + CData.GrData[(int)EWay.R].aOldOnPont[0].ToString());  // 2021.12.07 lhs 로그수정

                            //210907 pjh : Probe Up Log 추가
                            _SetLog("Probe Height: " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                            //

                            m_iStep = 0;
                            return true;
                        }

                        //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                        dtmp = CPrb.It.Read_Val(m_eWy);

                        if (CIO.It.Get_X(m_eIn1) && (dtmp >= GV.dProbeUpHeight))
                        {
                            _SetLog("Check probe up.");
                            //210907 pjh : Probe Up Log 추가
                            _SetLog("Probe Height: " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                            //

                            m_iStep = 27;
                        }

                        return false;
                    }
                case 27:
                    {//프로브 업 확인, Z축 자재 측정 위치로 이동
                        if (CData.CurCompany != ECompany.Qorvo    && CData.CurCompany != ECompany.Qorvo_DZ &&
                            CData.CurCompany != ECompany.Qorvo_RT && CData.CurCompany != ECompany.Qorvo_NC &&
                            CData.CurCompany != ECompany.SST)
                        {
                            //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                            dtmp = CPrb.It.Read_Val(m_eWy);

                            if ((!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)) && m_Delay.Chk_Delay())
                            {
                                m_iPrbUpCnt++;
                                if (m_iPrbUpCnt == 3)
                                {
                                    CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET :
                                                                       eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                                    //_SetLog("Error : Probe up not complete.");
                                    //210907 pjh : Probe Up Log 추가
                                    _SetLog("Error : Probe up not complete. Probe Height: " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                                    //

                                    // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                                    if (iIdx == (int)EMeaStep.Before/*0*/)
                                    {
                                        m_bSubErr = true;
                                    }

                                    m_iStep = 0;
                                    return true;
                                }
                                else
                                {
                                    Func_PrbDown(false);
                                    m_Delay.Set_Delay(GV.PRB_DELAY);//191002 ksg :

                                    _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");
                                    _SetLog("Probe up cycle retry.  Count : " + m_iPrbUpCnt);

                                    return false;
                                }
                            }

                            // 200920 jym : 프로브 업 체크 카운트 초기화
                            m_iPrbUpCnt = 0;
                        }

                        //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                        dtmp = CPrb.It.Read_Val(m_eWy);

                        if (CIO.It.Get_X(m_eIn1) && (dtmp >= GV.dProbeUpHeight))
                        {
                            //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                            //여기에서 스트립 측정 포인트 18 포인트(Leading Strip)인지? 일반(Main Strip)인지? 결정
                            if (CDataOption.Use18PointMeasure)
                            {
                                // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                                if (iIdx == (int)EMeaStep.Before/*0*/) //200713 jhc : Before인 경우에만 18 포인트 스트립 여부 검사
                                {
                                    this._checkIf18PStrip(ref CData.Parts[m_iPart].b18PMeasure, true);
                                }
                                else
                                {//After인 경우에는 현재 설정된 18 포인트 스트립 여부값을 참조
                                    //Nothing to do
                                }

                                _SetLog("18 point measure : " + CData.Parts[m_iPart].b18PMeasure);
                            }
                            else
                            {
                                CData.Parts[m_iPart].b18PMeasure = false;
                            }

                            _SetLog("Check probe up.");
                            //210907 pjh : Probe Up Log 추가
                            _SetLog("Probe Height: " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                            //


                            // 2021.09.24 SungTae Start : [수정] Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가 (ASE-KR VOC)
                            //m_iStep++;

                            if (m_iTblMeasCnt == 0)
                            {
                                m_iTblMeasCnt++;
                                m_iStep = 13;
                            }
                            else
                            {
                                m_iTblMeasCnt = 0;
                                m_iStep++;
                            }
                            // 2021.09.24 SungTae End
                        }
                        return false;
                    }

                //1. m_iCol < CData.Dev.iCol 인지 확인
                //2. [m_iRow, m_iCol].bUse = true 인지 확인 for(int i = 0; i < CData.Dev.iRow)
                //3. [m_iRow, m_iCol].dX = Probe X축 Zero 위치와 같은지 확인
                //4. X축 [m_iRow, m_iCol].dX 위치로 이동
                //5. 테이블 상단 측정 후 프로브 X축 Zero일때 테이블 위치와 차이값 계산(m_InspOffset)
                //6. m_iRow < CData.Dev.iRow일때 m_iRow++ 하면서 bUse = true 일경우 프로브값 - m_InspOffset = 해당 위치 자재 높이
                //7. m_iCol++ 후 1번부터 반복
                //case 23:
                case 28:
                    {//== 반복 시작 지점 == 테이블 Y축 자재 측정 위치 이동 확인, m_iCol < CData.Dev.iCol 인지 확인, m_iCol열에서 사용자 설정 위치 있는지 확인, 있을 경우 프로브 X축 테이블 측정 위치와 같은지 확인, 같지 않을 경우 프로브 X축 해당 열위치로 이동                       
                        bool bTemp = false;

                        //Before 자재 측정
                        if (iIdx == (int)EMeaStep.Before/*0*/)     // 2021.09.17 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                        {//Before 자재 측정
                            if (m_iCol < CData.Dev.iCol)
                            {//측정 열이 사용자가 설정한 열보다 작은지 확인
                                for (int i = 0; i < CData.Dev.iRow * CData.Dev.iWinCnt; i++)
                                {//해당 열의 모든행에 사용자가 설정한 측정 포인트가 있는지 검사

                                    //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                                    if (CData.Parts[m_iPart].b18PMeasure)   { bTemp = CData.Dev.aData[m_iWy].aPosBf[i, m_iCol].bUse18P; }
                                    else                                    { bTemp = CData.Dev.aData[m_iWy].aPosBf[i, m_iCol].bUse; }

                                    if (bTemp) { break; }
                                }

                                if (bTemp)
                                {//해당 열 사용자 설정 측정 위치 있을 경우 해당 열이 센터와 같은지 확인 후 다를 경우 프로브 X축 해당 열 측정 위치로 이동
                                    if (m_dPosX == CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX)
                                    {
                                        /* m_iRow 자재 측정 위치로 이동 */
                                    }
                                    else
                                    {//프로브 X축 [m_iCol] 열 테이블 측정 위치로 이동
                                        // 2021.08.02 SungTae Start : [추가] Measure(Before/After/One-point) 시 측정 위치에 대한 Offset 설정 추가(ASE-KR VOC)
                                        //m_dPosX = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX;
                                        if (m_iWy == (int)EWay.L)
                                            m_dPosX = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX + CData.Dev.dMeasOffsetX;
                                        else
                                            m_dPosX = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX - CData.Dev.dMeasOffsetX;

                                        _SetLog("X axis position : " + CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX + "mm  Offset X : " + CData.Dev.dMeasOffsetX + "mm");
                                        // 2021.08.02 SungTae End

                                        CMot.It.Mv_N(m_iX, m_dPosX);
                                        _SetLog("X axis move position.", m_dPosX);

                                        CMot.It.Mv_N(m_iY, m_dPosY);
                                        _SetLog("Y axis move position.", m_dPosY);
                                    }

                                    _SetLog(string.Format("Use point(before).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                    m_iStep++;
                                }
                                else
                                {//해당 열에 사용자설정 측정 위치 없을 경우 m_iCol++ 후 반복
                                    m_iCol++;
                                    return false;
                                }
                            }
                            else
                            {
                                _SetLog(string.Format("Column end(before).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                m_iStep = 38;
                            }
                        }
                        else
                        {//After 자재 측정
                            if (m_iCol < CData.Dev.iCol)
                            {//측정 열이 사용자가 설정한 열보다 작은지 확인
                                for (int i = 0; i < CData.Dev.iRow * CData.Dev.iWinCnt; i++)
                                {//해당 열의 모든행에 사용자가 설정한 측정 포인트가 있는지 검사

                                    //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                                    if (CData.Parts[m_iPart].b18PMeasure)   { bTemp = CData.Dev.aData[m_iWy].aPosAf[i, m_iCol].bUse18P; }
                                    else                                    { bTemp = CData.Dev.aData[m_iWy].aPosAf[i, m_iCol].bUse; }

                                    if (bTemp) { break; }
                                }

                                if (bTemp)
                                {//해당 열 사용자 설정 측정 위치 있을 경우 해당 열이 센터와 같은지 확인 후 다를 경우 프로브 X축 해당 열 측정 위치로 이동
                                    if (m_dPosX == CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX)
                                    {
                                        /* m_iRow 자재 측정 위치로 이동 */
                                    }
                                    else
                                    {//프로브 X축 [m_iCol] 열 테이블 측정 위치로 이동
                                        // 2021.08.02 SungTae Start : [추가] Measure(Before/After/One-point) 시 측정 위치에 대한 Offset 설정 추가(ASE-KR VOC)
                                        //m_dPosX = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX;
                                        if (m_iWy == (int)EWay.L)
                                            m_dPosX = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX + CData.Dev.dMeasOffsetX;
                                        else
                                            m_dPosX = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX - CData.Dev.dMeasOffsetX;

                                        _SetLog("X axis position : " + CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX + "mm  Offset X : " + CData.Dev.dMeasOffsetX + "mm");
                                        // 2021.08.02 SungTae End

                                        //CMot.It.Mv_MN(m_iY, m_dPosY,m_iX, m_dPosX);
                                        CMot.It.Mv_N(m_iX, m_dPosX);
                                        _SetLog("X axis move position.", m_dPosX);

                                        CMot.It.Mv_N(m_iY, m_dPosY);
                                        _SetLog("Y axis move position.", m_dPosY);
                                    }

                                    _SetLog(string.Format("Use point(after).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                    m_iStep++;
                                }
                                else
                                {//해당 열에 사용자설정 측정 위치 없을 경우 m_iCol++ 후 반복
                                    m_iCol++;
                                    return false;
                                }
                            }
                            else
                            {
                                _SetLog(string.Format("Column end(after).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                m_iStep = 38;
                            }
                        }
                        return false;
                    }

                case 29:
                    {// X축 해당열 테이블 측정 위치로 이동 확인, 프로브 에어 온
                        if (!CMot.It.Get_Mv(m_iX, m_dPosX))
                        {
                            CMot.It.Mv_N(m_iX, m_dPosX);
                            return false;
                        }

                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        {
                            CMot.It.Mv_N(m_iY, m_dPosY);
                            return false;
                        }

                        Func_PrbAir(true);
                        _SetLog("Probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 30:
                    {// 프로브 에어 온 확인, 프로브 다운
                        if (!Func_PrbAir(true)) { return false; }

                        Func_PrbDown(true);
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 31:
                    {// 프로브 다운 확인 및 딜레이 설정, 프로브 에어 오프
                        if (!CIO.It.Get_X(m_eIn1))
                        {
                            Func_PrbAir(false);
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }
                        return false;
                    }

                case 32:
                    {// 프로브 에어 오프 확인, 테이블 높이 측정, 테이블 센터와의 옵셋 값 계산, 프로브 업
                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            m_InspOffset = CPrb.It.Read_Val(m_eWy);
                            _SetLog("Probe value : " + m_InspOffset + "mm", true);
                            Func_PrbDown(false);
                            m_Delay.Set_Delay(GV.PRB_DELAY);
                            _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }
                        return false;
                    }

                case 33:
                    {// == 자재 행(m_iRow) 측정 반복 시점 == 프로브 업 확인, 테이블 Y축 자재 측정 위치로 이동

                        bool bMeasure = false; //200712 jhc : 18 포인트 측정 (ASE-KR VOC)

                        if (CData.CurCompany != ECompany.Qorvo && CData.CurCompany != ECompany.Qorvo_DZ &&
                            CData.CurCompany != ECompany.Qorvo_RT && CData.CurCompany != ECompany.Qorvo_NC &&
                            CData.CurCompany != ECompany.SST)
                        {
                            //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                            dtmp = CPrb.It.Read_Val(m_eWy);

                            if ((!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)) && m_Delay.Chk_Delay())
                            {
                                m_iPrbUpCnt++;

                                if (m_iPrbUpCnt == 3)
                                {
                                    CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET :
                                                                       eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                                    
                                    _SetLog("Error : Probe up not complete.");

                                    // 201009 jym : Before 측정 시에만 적용
                                    if (iIdx == (int)EMeaStep.Before/*0*/)     // 2021.09.17 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                                    {
                                        m_bSubErr = true;
                                    }

                                    m_iStep = 0;
                                    return true;
                                }
                                else
                                {
                                    Func_PrbDown(false);
                                    m_Delay.Set_Delay(GV.PRB_DELAY);//191002 ksg :
                                    _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");
                                    _SetLog("Probe up cycle retry.  Count : " + m_iPrbUpCnt);

                                    return false;
                                }
                            }

                            // 200920 jym : 프로브 업 체크 카운트 초기화
                            m_iPrbUpCnt = 0;
                        }

                        //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                        dtmp = CPrb.It.Read_Val(m_eWy);

                        if (CIO.It.Get_X(m_eIn1) && (dtmp >= GV.dProbeUpHeight))
                        {
                            // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                            if (iIdx == (int)EMeaStep.Before/*0*/)
                            {
                                if (m_iRow >= CData.Dev.iRow * CData.Dev.iWinCnt)
                                {
                                    m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];

                                    m_iCol++;
                                    m_iRow = 0;

                                    CMot.It.Mv_N(m_iY, m_dPosY);
                                    _SetLog("Y axis move position(before)." + m_dPosY);

                                    m_iStep = 28;
                                    return false;
                                }

                                //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                                if (CData.Parts[m_iPart].b18PMeasure)   { bMeasure = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].bUse18P; }
                                else                                    { bMeasure = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].bUse; }

                                if (bMeasure)
                                {
                                    // 2021.08.02 SungTae Start : [추가] Measure(Before/After/One-point) 시 측정 위치에 대한 Offset 설정 추가(ASE-KR VOC)
                                    //m_dPosY = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dY;
                                    //_SetLog("Measure point(before).  Y axis position : " + m_dPosY + "mm");

                                    m_dPosY = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dY + CData.Dev.dMeasOffsetY;
                                    _SetLog("Measure point(before).  Y axis position : " + m_dPosY + "mm  (" + CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dY + "mm + " + CData.Dev.dMeasOffsetY + "mm (Offset Y))");
                                    // 2021.08.02 SungTae End

                                    m_iStep++;
                                }
                                else
                                {
                                    m_iRow++;

                                    if (m_iRow < CData.Dev.iRow * CData.Dev.iWinCnt)
                                    {
                                        return false;
                                    }
                                    else
                                    {
                                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                        
                                        m_iCol++;
                                        m_iRow = 0;
                                        
                                        _SetLog("Row end(before).  Col : " + m_iCol);

                                        m_iStep = 28;
                                    }
                                }
                                // 2021.08.02 SungTae End
                            }
                            else
                            {
                                if (m_iRow >= CData.Dev.iRow * CData.Dev.iWinCnt)
                                {
                                    m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                    
                                    m_iCol++;
                                    m_iRow = 0;
                                    
                                    CMot.It.Mv_N(m_iY, m_dPosY);
                                    _SetLog("Y axis move position(after)." + m_dPosY);

                                    m_iStep = 28;
                                    return false;
                                }

                                //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                                if (CData.Parts[m_iPart].b18PMeasure)   { bMeasure = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].bUse18P; }
                                else                                    { bMeasure = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].bUse; }

                                if (bMeasure)
                                {
                                    // 2021.08.02 SungTae Start : [추가] Measure(Before/After/One-point) 시 측정 위치에 대한 Offset 설정 추가(ASE-KR VOC)
                                    //m_dPosY = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dY;
                                    //_SetLog("Measure point(after).  Y axis position : " + m_dPosY + "mm");

                                    m_dPosY = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dY + CData.Dev.dMeasOffsetY;
                                    _SetLog("Measure point(after).  Y axis position : " + CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dY + "mm  Offset Y = " + CData.Dev.dMeasOffsetY + "mm");
                                    // 2021.08.02 SungTae End

                                    m_iStep++;
                                }
                                else
                                {
                                    m_iRow++;

                                    if (m_iRow < CData.Dev.iRow * CData.Dev.iWinCnt)
                                    {
                                        return false;
                                    }
                                    else
                                    {
                                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                        
                                        m_iCol++;
                                        m_iRow = 0;
                                        
                                        _SetLog("Row end(after).  Col : " + m_iCol);

                                        m_iStep = 28;
                                    }
                                }
                            }
                        }

                        CMot.It.Mv_N(m_iY, m_dPosY);
                        _SetLog("Y axis move position.", m_dPosY);

                        return false;
                    }

                case 34:
                    {//테이블 Y축 자재 측정 위치 이동 확인, 프로브 에어 온
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY)) { return false; }

                        Func_PrbAir(true);
                        _SetLog("Probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 35:
                    {//프로브 에어 온 확인, 프로브 다운
                        if (!Func_PrbAir(true)) { return false; }

                        Func_PrbDown(true);
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 36:
                    {//프로브 다운 확인, 프로브 에어 오프
                        if (!CIO.It.Get_X(m_eIn1))
                        {
                            Func_PrbAir(false);
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);

                            _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }
                        return false;
                    }

                case 37:
                    {//== 반복 종료 시점 == 프로브 에어 오프 확인, 자재 높이 측정, 프로브 업, 다음 행 설정(m_iRow++), m_iStep = 28로 이동
                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            m_PbOfset = CPrb.It.Read_Val(m_eWy);

                            _SetLog(">> Read Probe Value : " + m_PbOfset + "mm");
                            
                            if (iIdx == (int)EMeaStep.Before/*0*/)     // 2021.09.17 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                            {
                                double dGap = m_PbOfset - (m_InspOffset - m_InspZeroOffset);
                                
                                if (CData.GrData[m_iWy].aOldOnPont[0] < dGap)
                                {
                                    CData.GrData[m_iWy].aOldOnPont[0] = m_PbOfset - (m_InspOffset - m_InspZeroOffset);
                                }
                                
                                //_SetLog(string.Format("Ori : {0}mm  Gap : {1}mm", m_PbOfset, dGap), true);
                                _SetLog(string.Format("Ori(Read Value) : {0}mm  Gap(Read Value - InspOffset) : {1}mm  InspOffset : {2}mm  InspZeroOffset : {3}mm", m_PbOfset, dGap, m_InspOffset, m_InspZeroOffset), true);
                            }

                            // 2021.09.29 SungTae : [추가]
                            _SetLog(string.Format(">> Probe Value ({0}mm) = Read Value ({1}mm) + RNR ({2}mm)", m_PbOfset + CData.Dev.aData[m_iWy].dPrbOffset, m_PbOfset, CData.Dev.aData[m_iWy].dPrbOffset), true);

                            // 측정 위치의 Probe 값 = 측정 위치의 Probe 값 + Device에서 Setting한 RNR Value
                            m_PbOfset = m_PbOfset + CData.Dev.aData[m_iWy].dPrbOffset; //CData.MPos[0].dPRB_OFFSET;

                            // 2020.09.14 JSKim St
                            if (CData.Parts[m_iPart].bExistStrip == false || CSQ_Main.It.m_iStat == EStatus.Manual) //201014 jhc : Manual 모드
                            {
                                CData.Parts[m_iPart].dDfMin = 0.0;
                                CData.Parts[m_iPart].dDfMax = 0.0;
                                CData.Parts[m_iPart].dDfAvg = 0.0;

                                CData.Parts[m_iPart].dPcbMin = 0.0;
                                CData.Parts[m_iPart].dPcbMax = 0.0;
                                CData.Parts[m_iPart].dPcbMean = 0.0;
                            }
                            // 2020.09.14 JSKim Ed

                            if (CData.Dev.bDynamicSkip)
                            {//다이나믹 펑션 스킵
                                /// - SECSGEM 사용시 Top 의 AF 값을 BTM 진행 시 DF 대시 사용키 위함 20200301 LCY
                                /// 1. SECSGEM 사용 시 Btm Side 경우 Host에서 top Side 의 Af 값을 Down 
                                /// 2. Strip Top 측정 값 - Host에서 Down 값
                                dTemp = 0.0;

                                if (CData.Opt.bSecsUse)
                                {
                                    if (CData.Dynamic.iHeightType == 0)
                                    {
                                        dTemp = CData.Parts[m_iPart].dPcbMax;
                                        _SetLog("SECS/GEM use.  PCB Max : " + dTemp + "mm");
                                    }
                                    else
                                    {
                                        dTemp = CData.Parts[m_iPart].dPcbMean;
                                        _SetLog("SECS/GEM use.  PCB Mean : " + dTemp + "mm");
                                    }
                                }

                                m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - dTemp;
                                
                                // 2021.09.29 SungTae : [추가]
                                _SetLog(string.Format("Point-[{0}, {1}] Measure value ({2}mm) = Probe Value ({3}mm) - PCB Thickness ({4}mm)", m_iRow, m_iCol, m_aInspTemp[m_iRow, m_iCol], m_PbOfset, dTemp), true);
                            }
                            else
                            {//다이나믹 펑션 사용 
                                if (CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                {//DF 서버 사용시 DF측정 안할 경우 Max값으로 고정
                                    CData.Dynamic.iHeightType = 0;
                                }

                                if (CData.Dynamic.iHeightType == 0)
                                {//측정한 PCB 값중 MAX 사용
                                    if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                                    {//[GL2, GL3]
                                        m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - CData.Parts[m_iPart].dDfMax;
                                        _SetLog("DF Max : " + CData.Parts[m_iPart].dDfMax + "mm");
                                    }
                                    else
                                    {//[GL1]
                                        if (CDataOption.MeasureDf == eDfServerType.MeasureDf)
                                        {//DF 사용시 측정 사용 할경우[GL1]
                                            m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - CData.Parts[m_iPart].dPcbMax;
                                            _SetLog("PCB Max : " + CData.Parts[m_iPart].dPcbMax + "mm");
                                        }
                                        else
                                        {//DF 사용시 측정 사용 안할 경우
                                            m_aInspTemp[m_iRow, m_iCol] = m_PbOfset;
                                        }
                                    }
                                }
                                else
                                {
                                    if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                                    {
                                        m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - CData.Parts[m_iPart].dDfAvg;
                                        _SetLog("DF Avg : " + CData.Parts[m_iPart].dDfAvg + "mm");
                                    }
                                    else
                                    {
                                        m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - CData.Parts[m_iPart].dPcbMean;
                                        _SetLog("PCB Mean : " + CData.Parts[m_iPart].dPcbMean + "mm");
                                    }
                                }
                            }
                            //190514 ksg : 센터도 옵셋 적용 가능
                            m_aInspTemp[m_iRow, m_iCol] -= (m_InspOffset - m_InspZeroOffset);
                            _SetLog("Measure value : " + m_aInspTemp[m_iRow, m_iCol] + "mm", true);

                            double dLimitMax = 0.0;
                            double dLimitMin = 0.0;
                            
                            // 2022.08.07 SungTae Start : [추가] (ASE-KR 개조건)
                            // 최종 Target 두께 별도 입력하여 Grinding 최종 Target과 일치하지 않을 경우 Alarm 발생 기능 추가 개발 요청건
                            double dFinalLimitMax = 0.0;    
                            double dFinalLimitMin = 0.0;
                            // 2022.08.07 SungTae End

                            //자재 높이 범위 검사
                            if (iIdx == (int)EMeaStep.Before/*0*/)     // 2021.09.17 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                            {
                                //다이나믹 펑션 스킵, DF사용시 DF 측정 안할 경우
                                if (CData.Dev.bDynamicSkip || CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                {
                                    dLimitMax = CData.Dev.aData[(int)EWay.L].dTotalTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                                    dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dBfLimit;

                                    // 2021.09.29 SungTae Start: [추가]
                                    if (CData.Dev.eMoldSide == ESide.Top)
                                    {
                                        _SetLog(string.Format("[BEFORE][TOP][NORMAL] Max Limit ({0}mm) = Total Thick ({1}mm) + Limit Value ({2}mm)", dLimitMax, CData.Dev.aData[(int)EWay.L].dTotalTh, CData.Dev.aData[(int)EWay.L].dBfLimit), true);
                                        _SetLog(string.Format("[BEFORE][TOP][NORMAL] Min Limit ({0}mm) = Total Thick ({1}mm) - Limit Value ({2}mm)", dLimitMin, CData.Dev.aData[(int)EWay.L].dTotalTh, CData.Dev.aData[(int)EWay.L].dBfLimit), true);
                                    }
                                    // 2021.09.29 SungTae End

                                    if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                                    {
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dBfLimitLower;
                                    }

#if true //201014 jhc : ASE-Kr TOP 그라인딩 결과 두께 > SECS/GEM > BTM 그라인딩
                                    //ASE-Kr Bottom Mold 기준 그라인딩 시 옵션
                                    if ((CData.CurCompany == ECompany.ASE_KR) &&                            //ASE-Kr
                                        (CData.Dev.bDynamicSkip) &&                                         //DF기능 비활성(ASE-Kr)
                                        ((CDataOption.SecsUse == eSecsGem.Use) && CData.Opt.bSecsUse) &&    //SECS/GEM 사용(TOP 두께 수신)
                                        (CData.Dev.eMoldSide == ESide.Btm) &&                         //BTM 그라인딩
                                        (CSQ_Main.It.m_iStat != EStatus.Manual))                            //AUTO-RUNNING
                                    {
                                        dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dBfLimit;

                                        // 2021.09.29 SungTae Start: [추가]
                                        _SetLog(string.Format("[BEFORE][BTM][NORMAL] Max Limit ({0}mm) = Mold Thick ({1}mm) + Limit Value ({2}mm)", dLimitMax, CData.Dev.aData[(int)EWay.L].dMoldTh, CData.Dev.aData[(int)EWay.L].dBfLimit), true);
                                        _SetLog(string.Format("[BEFORE][BTM][NORMAL] Min Limit ({0}mm) = Mold Thick ({1}mm) - Limit Value ({2}mm)", dLimitMin, CData.Dev.aData[(int)EWay.L].dMoldTh, CData.Dev.aData[(int)EWay.L].dBfLimit), true);
                                        // 2021.09.29 SungTae End
                                    }
#endif
                                }
                                else
                                {//다이나믹 펑션 사용
                                    dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                                    dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dBfLimit;

                                    if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                                    {
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dBfLimitLower;
                                    }

                                    // 2021.09.29 SungTae Start: [추가]
                                    _SetLog(string.Format("[BEFORE][DF Use][NORMAL] Max Limit ({0}mm) = Mold Thick ({1}mm) + Limit Value ({2}mm)", dLimitMax, CData.Dev.aData[(int)EWay.L].dMoldTh, CData.Dev.aData[(int)EWay.L].dBfLimit), true);
                                    _SetLog(string.Format("[BEFORE][DF Use][NORMAL] Min Limit ({0}mm) = Mold Thick ({1}mm) - Limit Value ({2}mm)", dLimitMin, CData.Dev.aData[(int)EWay.L].dMoldTh, CData.Dev.aData[(int)EWay.L].dBfLimit), true);
                                    // 2021.09.29 SungTae End
                                }

                                // jhLee, Multi-LOT의 경우 SPC 기록
                                if (CData.IsMultiLOT())
                                {
                                    m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dBfLimit.ToString();
                                }
                                else
                                {
                                    CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dBfLimit.ToString();
                                }

                                if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                {
                                    if (CData.Dev.bDynamicSkip || CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                    {//다이나믹 펑션 스킵, DF 사용시 DF 측정 안할 경우
                                        dLimitMax = CData.Dev.aData[m_iWy].dTotalTh + CData.Dev.aData[m_iWy].dBfLimit;
                                        dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dBfLimit;

                                        // 2021.09.29 SungTae Start: [추가]
                                        if (CData.Dev.eMoldSide == ESide.Top)
                                        {
                                            _SetLog(string.Format("[BEFORE][TOP][DUAL] Max Limit ({0}mm) = Total Thick ({1}mm) + Limit Value ({2}mm)", dLimitMax, CData.Dev.aData[(int)EWay.L].dTotalTh, CData.Dev.aData[(int)EWay.L].dBfLimit), true);
                                            _SetLog(string.Format("[BEFORE][TOP][DUAL] Min Limit ({0}mm) = Total Thick ({1}mm) - Limit Value ({2}mm)", dLimitMin, CData.Dev.aData[(int)EWay.L].dTotalTh, CData.Dev.aData[(int)EWay.L].dBfLimit), true);
                                        }
                                        // 2021.09.29 SungTae End

                                        if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                                        {
                                            dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dBfLimitLower;
                                        }


#if true //201014 jhc : ASE-Kr TOP 그라인딩 결과 두께 > SECS/GEM > BTM 그라인딩
                                        //ASE-Kr Bottom Mold 기준 그라인딩 시 옵션
                                        if ((CData.CurCompany == ECompany.ASE_KR) &&                            //ASE-Kr
                                            (CData.Dev.bDynamicSkip) &&                                         //DF기능 비활성(ASE-Kr)
                                            ((CDataOption.SecsUse == eSecsGem.Use) && CData.Opt.bSecsUse) &&    //SECS/GEM 사용(TOP 두께 수신)
                                            (CData.Dev.eMoldSide == ESide.Btm) &&                         //BTM 그라인딩
                                            (CSQ_Main.It.m_iStat != EStatus.Manual))                            //AUTO-RUNNING
                                        {
                                            dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dBfLimit;
                                            dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dBfLimit;

                                            // 2021.09.29 SungTae Start: [추가]
                                            _SetLog(string.Format("[BEFORE][BTM][DUAL] Max Limit ({0}mm) = Mold Thick ({1}mm) + Limit Value ({1}mm)", dLimitMax, CData.Dev.aData[(int)EWay.L].dMoldTh, CData.Dev.aData[(int)EWay.L].dBfLimit), true);
                                            _SetLog(string.Format("[BEFORE][BTM][DUAL] Min Limit ({0}mm) = Mold Thick ({1}mm) - Limit Value ({1}mm)", dLimitMin, CData.Dev.aData[(int)EWay.L].dMoldTh, CData.Dev.aData[(int)EWay.L].dBfLimit), true);
                                            // 2021.09.29 SungTae End
                                        }
#endif
                                    }
                                    else
                                    {//다이나믹 펑션 사용
                                        dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dBfLimit;
                                        dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dBfLimit;

                                        if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                                        {
                                            dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dBfLimitLower;
                                        }

                                        // 2021.09.29 SungTae Start: [추가]
                                        _SetLog(string.Format("[BEFORE][DF Use] Max Limit ({0}mm) = Mold Thick ({1}mm) + Limit Value ({1}mm)", dLimitMax, CData.Dev.aData[(int)EWay.L].dMoldTh, CData.Dev.aData[(int)EWay.L].dBfLimit), true);
                                        _SetLog(string.Format("[BEFORE][DF Use] Min Limit ({0}mm) = Mold Thick ({1}mm) - Limit Value ({1}mm)", dLimitMin, CData.Dev.aData[(int)EWay.L].dMoldTh, CData.Dev.aData[(int)EWay.L].dBfLimit), true);
                                        // 2021.09.29 SungTae End
                                    }

                                    // jhLee, Multi-LOT의 경우 SPC 기록
                                    if (CData.IsMultiLOT())
                                    {
                                        m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[m_iWy].dBfLimit.ToString();
                                    }
                                    else
                                    {
                                        CData.SpcData.sTargetLim = CData.Dev.aData[m_iWy].dBfLimit.ToString();
                                    }
                                }

                                _SetLog(string.Format("Before.  Limit min : {0}mm  Limit max : {1}mm", dLimitMin, dLimitMax));

                                if (m_eWy == EWay.L)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dBfLimit != 0)
                                    {
                                        if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                        {//범위 벗어 났을 경우 에러 발생
                                            m_abMeaBfErr[m_iRow, m_iCol] = true;
                                            m_bMeaErrBf_L = true;
                                            _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                        }
                                    }
                                }
                                else
                                {
                                    if (CData.Dev.bDual != eDual.Dual)
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dBfLimit != 0)
                                        {
                                            if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                            {//범위 벗어 났을 경우 에러 발생
                                                m_abMeaBfErr[m_iRow, m_iCol] = true;
                                                m_bMeaErrBf_R = true;
                                                _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (CData.Dev.aData[m_iWy].dBfLimit != 0)
                                        {
                                            if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                            {//범위 벗어 났을 경우 에러 발생
                                                m_abMeaBfErr[m_iRow, m_iCol] = true;
                                                m_bMeaErrBf_R = true;
                                                _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                            }
                                        }
                                    }
                                }

                                CData.GrData[m_iWy].aMeaBf[m_iRow, m_iCol] = m_aInspTemp[m_iRow, m_iCol];
                            }
                            else
                            {//After
                                //자재 높이 범위 검사
                                double dTarget = 0.0;

                                for (int i = m_iStepMaxCnt - 1; i >= 0; i--)        // 2020.09.08 SungTae : modify
                                {
                                    if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                    {
                                        if (CData.Dev.aData[m_iWy].aSteps[i].bUse) // Right
                                        {
                                            //20191206 ghk_cal_debug -> 20201017 ksg : 원복함
                                            dTarget = CData.GrData[m_iWy].aTar[i];
                                            _SetLog(string.Format("Dual.  Target : {0}mm  Col : {1}  Row : {2}", dTarget, m_iCol, m_iRow));
                                            break;
                                        }
                                    }
                                    else
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                        {
                                            //if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.Top && (m_eWy == EWay.R))
                                            if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown && (m_eWy == EWay.R)) //190717 ksg :
                                            {
                                                //20191206 ghk_cal_debug -> 20201017 ksg : 원복함
                                                dTarget = CData.GrData[(int)EWay.R].aTar[i];
                                                _SetLog(string.Format("Topdown.  Target : {0}mm  Col : {1}  Row : {2}", dTarget, m_iCol, m_iRow));
                                                break;
                                            }
                                            else
                                            {
                                                dTarget = CData.GrData[m_iWy].aTar[i];
                                                _SetLog(string.Format("Target : {0}mm  Col : {1}  Row : {2}", dTarget, m_iCol, m_iRow));
                                                break;
                                            }
                                        }
                                    }
                                }

                                dLimitMax = dTarget + CData.Dev.aData[(int)EWay.L].dAfLimit;
                                dLimitMin = dTarget - CData.Dev.aData[(int)EWay.L].dAfLimit;

                                // 2022.08.07 SungTae Start : [수정] (ASE-KR 개조건)
                                // 최종 Target 두께 별도 입력하여 Grinding 최종 Target과 일치하지 않을 경우 Alarm 발생 기능 추가 개발 요청건
                                dFinalLimitMax = CData.Dev.aData[(int)EWay.L].dFinalTarget + CData.Dev.aData[(int)EWay.L].dAfLimit;
                                dFinalLimitMin = CData.Dev.aData[(int)EWay.L].dFinalTarget - CData.Dev.aData[(int)EWay.L].dAfLimit;

                                string sMeas = (iIdx == (int)EMeaStep.Before) ? "BEFORE" : "AFTER";
                                string sDual = (CData.Dev.bDual == eDual.Dual) ? "DUAL" : "NORMAL";
                                
                                if (CData.Dev.bDual != eDual.Dual)
                                {
                                    //_SetLog(string.Format("[AFTER][NORMAL][{0}] Max Limit ({1}mm) = Target Thick ({2}mm) + Limit Value ({3}mm)",
                                    //                                    m_eWy.ToString(), dLimitMax, dTarget, CData.Dev.aData[(int)EWay.L].dAfLimit), true);
                                    //_SetLog(string.Format("[AFTER][NORMAL][{0}] Min Limit ({1}mm) = Target Thick ({2}mm) - Limit Value ({3}mm)",
                                    //                                    m_eWy.ToString(), dLimitMin, dTarget, CData.Dev.aData[(int)EWay.L].dAfLimit), true);

                                    _SetLog($"[{sMeas}][{sDual}][{m_eWy}] Max Limit = Target( {dTarget}mm ) + Limit( {CData.Dev.aData[(int)EWay.L].dAfLimit}mm ) = {dLimitMax}mm", true);
                                    _SetLog($"[{sMeas}][{sDual}][{m_eWy}] Min Limit = Target( {dTarget}mm ) - Limit( {CData.Dev.aData[(int)EWay.L].dAfLimit}mm ) = {dLimitMin}mm", true);

                                    _SetLog($"[{sMeas}][{sDual}][{m_eWy}] Final Max Limit = Final Target( {CData.Dev.aData[(int)EWay.L].dFinalTarget}mm ) + Limit( {CData.Dev.aData[(int)EWay.L].dAfLimit}mm ) = {dFinalLimitMax}mm", true);
                                    _SetLog($"[{sMeas}][{sDual}][{m_eWy}] Final Min Limit = Final Target( {CData.Dev.aData[(int)EWay.L].dFinalTarget}mm ) - Limit( {CData.Dev.aData[(int)EWay.L].dAfLimit}mm ) = {dFinalLimitMin}mm", true);

                                }

                                // jhLee, Multi-LOT의 경우 SPC 기록
                                if (CData.IsMultiLOT())
                                {
                                    m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();
                                }
                                else
                                {
                                    CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();
                                }

                                if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                {
                                    dLimitMax = dTarget + CData.Dev.aData[m_iWy].dAfLimit;
                                    dLimitMin = dTarget - CData.Dev.aData[m_iWy].dAfLimit;

                                    dFinalLimitMax = CData.Dev.aData[m_iWy].dFinalTarget + CData.Dev.aData[m_iWy].dAfLimit;
                                    dFinalLimitMin = CData.Dev.aData[m_iWy].dFinalTarget - CData.Dev.aData[m_iWy].dAfLimit;

                                    //_SetLog(string.Format("[AFTER][DUAL][{0}] Max Limit ({1}mm) = Target Thick ({2}mm) + Limit Value ({3}mm)",
                                    //                                        m_eWy.ToString(), dLimitMax, dTarget, CData.Dev.aData[(int)EWay.L].dAfLimit), true);
                                    //_SetLog(string.Format("[AFTER][DUAL][{0}] Min Limit ({1}mm) = Target Thick ({2}mm) - Limit Value ({3}mm)",
                                    //                                        m_eWy.ToString(), dLimitMin, dTarget, CData.Dev.aData[(int)EWay.L].dAfLimit), true);

                                    _SetLog($"[{sMeas}][{sDual}][{m_eWy}] Max Limit = Target( {dTarget}mm ) + Limit( {CData.Dev.aData[m_iWy].dAfLimit}mm ) = {dLimitMax}mm", true);
                                    _SetLog($"[{sMeas}][{sDual}][{m_eWy}] Min Limit = Target( {dTarget}mm ) - Limit( {CData.Dev.aData[m_iWy].dAfLimit}mm ) = {dLimitMin}mm", true);

                                    _SetLog($"[{sMeas}][{sDual}][{m_eWy}] Final Max Limit = Final Target( {CData.Dev.aData[m_iWy].dFinalTarget}mm ) + Limit( {CData.Dev.aData[m_iWy].dAfLimit}mm ) = {dFinalLimitMax}mm", true);
                                    _SetLog($"[{sMeas}][{sDual}][{m_eWy}] Final Min Limit = Final Target( {CData.Dev.aData[m_iWy].dFinalTarget}mm ) - Limit( {CData.Dev.aData[m_iWy].dAfLimit}mm ) = {dFinalLimitMin}mm", true);


                                    // jhLee, Multi-LOT의 경우 SPC 기록
                                    if (CData.IsMultiLOT())
                                    {
                                        m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();
                                    }
                                    else
                                    {
                                        CData.SpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();
                                    }
                                }
                                // 2022.08.07 SungTae End

                                _SetLog(string.Format("After.  Limit min : {0}mm  Limit max : {1}mm", dLimitMin, dLimitMax));

                                if (m_eWy == EWay.L)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                    {
                                        // 2022.08.15 SungTae Start : [수정] (ASE-KR 개조건)
                                        if (CData.CurCompany == ECompany.ASE_KR)
                                        {
                                            if((m_aInspTemp[m_iRow, m_iCol] > dFinalLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dFinalLimitMin))
                                            {
                                                m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                m_bMeaErr_FinalTarget_L = true;
                                        
                                                _SetLog(string.Format("Final target mismatch error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                            }
                                        }
                                        else
                                        {
                                            if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                            {//범위 벗어 났을 경우 에러 발생
                                                m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                m_bMeaErrAf_L = true;
                                                _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                            }
                                        }
                                        // 2022.08.15 SungTae End
                                    }
                                }
                                else
                                {
                                    if (CData.Dev.bDual != eDual.Dual)
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                        {
                                            // 2022.08.15 SungTae Start : [수정] (ASE-KR 개조건)
                                            if (CData.CurCompany == ECompany.ASE_KR)
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dFinalLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dFinalLimitMin))
                                                {
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErr_FinalTarget_R = true;

                                                    _SetLog($"[{sMeas}][{sDual}] Final target mismatch error.  Col : {m_iCol}  Row : {m_iRow}");
                                                }
                                            }
                                            else
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                                {//범위 벗어 났을 경우 에러 발생
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErrAf_R = true;
                                                    _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                                }
                                            }
                                            // 2022.08.15 SungTae End
                                        }
                                    }
                                    else
                                    {
                                        if (CData.Dev.aData[m_iWy].dAfLimit != 0)
                                        {
                                            // 2022.08.15 SungTae Start : [수정] (ASE-KR 개조건)
                                            if (CData.CurCompany == ECompany.ASE_KR)
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dFinalLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dFinalLimitMin))
                                                {
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErr_FinalTarget_R = true;

                                                    _SetLog($"[{sMeas}][{sDual}] Final Target Mismatch Error.  Col : {m_iCol}  Row : {m_iRow}");
                                                }
                                            }
                                            else
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                                {//범위 벗어 났을 경우 에러 발생
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErrAf_R = true;
                                                    _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                                }
                                            }
                                            // 2022.08.15 SungTae End
                                        }
                                    }
                                }

                                CData.GrData[m_iWy].aMeaAf[m_iRow, m_iCol] = m_aInspTemp[m_iRow, m_iCol];
                                
                                // 2022.08.15 SungTae Start : [수정] (ASE-KR 개조건)
                                //_SetLog("Measure value : " + m_aInspTemp[m_iRow, m_iCol] + "mm", true);
                                _SetLog($"[{sMeas}][{sDual}] Measure value : {m_aInspTemp[m_iRow, m_iCol]}mm", true);
                                // 2022.08.15 SungTae End
                            }

                            Func_PrbDown(false);

                            m_Delay.Set_Delay(GV.PRB_DELAY); //191002 ksg :

                            _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

                            // 2021.09.17 SungTae Start : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                            if (iIdx == (int)EMeaStep.Before/*0*/)  { Array.Copy(m_aInspTemp, m_aInspBf, m_aInspTemp.Length); }
                            else                                    { Array.Copy(m_aInspTemp, m_aInspAf, m_aInspTemp.Length); }

                            m_iRow++;

                            m_iStep = 33;
                        }

                        return false;
                    }

                case 38:
                    {//프로브 x축 포지션 0으로 이동
                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                        _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                        if (CSpc.It.ChkOpenSaveDataCsv(m_eWy))
                        {
                            m_Delay.Set_Delay(1000);
                            _SetLog("Set delay : 1000ms");
                        }
                        else
                        {
                            m_Delay.Set_Delay(0);
                            _SetLog("Set delay : 0ms");
                        }

                        if ((CData.Opt.bSecsUse == true) && (CData.GemForm != null))
                        {
                            // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                            // 2021.07.19 SungTae Start : [수정] Data Shift 시 확인이 용이하도록 수정
                            if (iIdx == (int)EMeaStep.Before/*0*/)
                            {// Before Measure
                                if (m_eWy == EWay.L)
                                {
                                    //CData.GemForm.Strip_Data_Shift(6, 7);// L Chuck Data -> Befor Data 로 이동
                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRL_TBL_CHUCK/*6*/, (int)EDataShift.GRL_BF_MEAS/*7*/);// L Chuck Data -> Befor Data 로 이동
                                }
                                else
                                {
                                    //CData.GemForm.Strip_Data_Shift(12, 13);// R Chuck Data -> R Befor Data 로 이동
                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_TBL_CHUCK/*12*/, (int)EDataShift.GRR_BF_MEAS/*13*/);// R Chuck Data -> R Befor Data 로 이동
                                }
                            }
                            else
                            {// After Measure
                                if (m_eWy == EWay.L)
                                {
                                    //CData.GemForm.Strip_Data_Shift(7, 10);// L Before Data -> L After Data 로 이동
                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRL_BF_MEAS/*7*/, (int)EDataShift.GRL_AF_MEAS/*10*/);// L Before Data -> L After Data 로 이동
                                }
                                else
                                {
                                    //if (CData.Dev.bDShiftPSkip) CData.GemForm.Strip_Data_Shift(12, 13);// R Chuck Data -> R Befor Data 로 이동
                                    //CData.GemForm.Strip_Data_Shift(13, 16);// R Befor Data -> R After Data 로 이동
                                    if (CData.Dev.bDShiftPSkip)
                                    {
                                        CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_TBL_CHUCK/*12*/, (int)EDataShift.GRR_BF_MEAS/*13*/);// R Chuck Data -> R Befor Data 로 이동
                                    }

                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_BF_MEAS/*13*/, (int)EDataShift.GRR_AF_MEAS/*16*/);// R Befor Data -> R After Data 로 이동
                                }
                            }
                            // 2021.07.19 SungTae End
                        }

                        m_iStep++;
                        return false;
                    }

                case 39:
                    {
                        if (!m_Delay.Chk_Delay())
                        { return false; }
                        _SetLog("Check delay.");

                        m_iStep++;
                        return false;
                    }

                case 40:
                    {//Temp 측정 값 Before or After에 복사, m_iCol = 0, m_iRow = 0, m_iStep = 0;
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)  // Before
                        {
                            Array.Copy(m_aInspTemp, m_aInspBf, m_aInspTemp.Length);

                            CSpc.It.SaveDataCsv(m_eWy, "BEFORE", m_aInspBf, CData.Parts[m_iPart].dPcb);

                            if (CData.LotInfo.bLotOpen && CSQ_Main.It.m_iStat != EStatus.Manual) //191115 ksg :
                            {
                                CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "BEFORE", m_aInspBf, CData.Parts[m_iPart].dPcb);
                            }

                            // 200722 jym : min max avg 계산
                            double dMax = 0;
                            double dMin = 0;
                            double dAvg = 0;

                            _Cal_MMA(m_aInspBf, out dMin, out dMax, out dAvg);

                            CData.PbResultVal[m_iWy].dBMax = dMax;
                            CData.PbResultVal[m_iWy].dBMin = dMin;
                            CData.PbResultVal[m_iWy].dBAvg = dAvg;

                            if (m_eWy == EWay.L)
                            {
                                if (m_bMeaErrBf_L)
                                {
                                    CErr.Show(eErr.LEFT_GRIND_RANGEOVER_WHEN_BEFORE_MEASURE_STRIP);
                                    _SetLog("Error : Range over when before measure strip.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (m_bMeaErrBf_R)
                                {
                                    CErr.Show(eErr.RIGHT_GRIND_RANGEOVER_WHEN_BEFORE_MEASURE_STRIP);
                                    _SetLog("Error : Range over when before measure strip.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }
                        else  // After
                        {
                            Array.Copy(m_aInspTemp, m_aInspAf, m_aInspTemp.Length);
                            //190528 ksg :
                            if (m_eWy == EWay.L)
                            { Array.Copy(m_aInspTemp, m_aInspShift, m_aInspTemp.Length); } //190528 ksg :

                            CSpc.It.SaveDataCsv(m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb);
                            
                            if (CData.LotInfo.bLotOpen && CSQ_Main.It.m_iStat != EStatus.Manual) //191115 ksg :
                            { CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb); }

                            // 200722 jym : min max avg 계산
                            double dMax = 0;
                            double dMin = 0;
                            double dAvg = 0;

                            _Cal_MMA(m_aInspAf, out dMin, out dMax, out dAvg);

                            CData.PbResultVal[m_iWy].dAMax = dMax;
                            CData.PbResultVal[m_iWy].dAMin = dMin;
                            CData.PbResultVal[m_iWy].dAAvg = dAvg;

                            //============================================================================//
                            // 2022.08.15 SungTae Start : [수정] (ASE-KR 개조건)
                            if (m_eWy == EWay.L)
                            {
                                //if (m_bMeaErrAf_L)
                                if (m_bMeaErrAf_L || m_bMeaErr_FinalTarget_L)
                                {
                                    // SECSGEM Host에 Data Upload 진행  20200301 LCY
                                    // Top Side : Mold_높이 + DF 측정 Data
                                    // Bottom Side : Mold 높이
                                    if (CData.Dev.eMoldSide == ESide.Top)       dTemp = CData.Parts[(int)EPart.GRDL].dPcbMean;
                                    else                                        dTemp = 0.0;

                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Min_Data[4] = dMax + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Max_Data[4] = dMin + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Avr_Data[4] = dAvg + dTemp;

                                    _SetLog("Func Call : CData.GemForm.OnCarrierGrindFinished(1) - Happen Alarm");

                                    if (!CData.bChkGrdM)
                                    {
                                        CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N1);
                                    }

                                    if (CData.CurCompany == ECompany.ASE_KR && m_bMeaErr_FinalTarget_L)
                                    {
                                        CErr.Show(eErr.L_TOP_GRIND_DATA_FINAL_TARGET_COMPARE_ERROR);
                                        _SetLog("Error : L_TOP_GRIND_DATA_FINAL_TARGET_COMPARE_ERROR");
                                    }
                                    else
                                    {
                                        CErr.Show(eErr.LEFT_GRIND_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                        _SetLog("Error : Range over when after measure strip.");
                                    }

                                    // 201009 jym : Before 측정 시에만 적용
                                    //m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (m_bMeaErrAf_R || m_bMeaErr_FinalTarget_R)
                                {
                                    // SECSGEM Host에 Data Upload 진행  20200301 LCY
                                    // Top Side : Mold_높이 + DF 측정 Data
                                    // Bottom Side : Mold 높이
                                    if (CData.Dev.eMoldSide == ESide.Top)       dTemp = CData.Parts[(int)EPart.GRDR].dPcbMean;
                                    else                                        dTemp = 0.0;

                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Min_Data[6] = dMax + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Max_Data[6] = dMin + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Avr_Data[6] = dAvg + dTemp;

                                    _SetLog("Func Call : CData.GemForm.OnCarrierGrindFinished(2) - Happen Alarm");

                                    if (!CData.bChkGrdM)
                                    {
                                        CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N2);
                                    }

                                    if (CData.CurCompany == ECompany.ASE_KR && m_bMeaErr_FinalTarget_R)
                                    {
                                        if (CData.Dev.bDual == eDual.Normal)
                                        {
                                            CErr.Show(eErr.R_TOP_GRIND_DATA_FINAL_TARGET_COMPARE_ERROR);
                                            _SetLog("Error : R_TOP_GRIND_DATA_FINAL_TARGET_COMPARE_ERROR");
                                        }
                                        else
                                        {
                                            CErr.Show(eErr.BTM_GRIND_DATA_FINAL_TARGET_COMPARE_ERROR);
                                            _SetLog($"Error : BTM_GRIND_DATA_FINAL_TARGET_COMPARE_ERROR");
                                        }
                                    }
                                    else
                                    {
                                        CErr.Show(eErr.RIGHT_GRIND_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                        _SetLog("Error : Range over when after measure strip.");
                                    }

                                    // 201009 jym : Before 측정 시에만 적용
                                    //m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }
                        // 2022.08.15 SungTae End
                        //============================================================================//

                        //20190618 ghk_dfserver
                        if (m_eWy == EWay.L && CData.Dev.bDual == eDual.Dual && iIdx == (int)EMeaStep.After/*1*/)
                        {
                            m_iStep = 45;
                            return false;
                        }

                        if (m_eWy == EWay.R && CData.Dev.bDual == eDual.Dual && iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            m_iStep = 45;
                            return false;
                        }

                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            m_iCol = 0;
                            m_iRow = 0;
                            m_sRowData = "";
                            _SetLog("DF Server.");

                            m_iStep++;
                        }
                        else
                        {
                            _SetLog("DF Server not use.");
                            m_iStep = 45;
                        }

                        return false;
                    }

                case 41:
                    {
                        if (m_eWy == EWay.L)    { CData.GRLDfData.sRow = "R" + m_iRow.ToString("D2"); }
                        else                    { CData.GRRDfData.sRow = "R" + m_iRow.ToString("D2"); }

                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            if (m_iRow < m_aInspBf.GetLength(0))
                            {
                                if (m_iCol < m_aInspBf.GetLength(1))
                                {
                                    if (m_aInspBf[m_iRow, m_iCol] == 0)
                                    {
                                        m_sRowData += ".";
                                    }
                                    else
                                    {
                                        m_sRowData += m_aInspBf[m_iRow, m_iCol];
                                    }
                                    if (m_iCol < (m_aInspBf.GetLength(1) - 1))
                                    {
                                        m_sRowData += ",";
                                    }
                                    m_iCol++;
                                }
                                else
                                { m_iStep++; }
                                return false;
                            }
                            else
                            {
                                if (!CData.dfInfo.bBusy)
                                {
                                    if (m_eWy == EWay.L)
                                    {
                                        CDf.It.SendBfEnd("LGD");
                                        m_iStep = 44;
                                    }
                                    else
                                    {
                                        CDf.It.SendBfEnd("RGD");
                                        m_iStep = 44;
                                    }
                                }
                                else
                                { return false; }
                            }
                        }
                        else
                        {
                            if (m_iRow < m_aInspAf.GetLength(0))
                            {
                                if (m_iCol < m_aInspAf.GetLength(1))
                                {
                                    if (m_aInspAf[m_iRow, m_iCol] == 0)
                                    {
                                        m_sRowData += ".";
                                    }
                                    else
                                    {
                                        m_sRowData += m_aInspAf[m_iRow, m_iCol];
                                    }
                                    if (m_iCol < (m_aInspAf.GetLength(1) - 1))
                                    {
                                        m_sRowData += ",";
                                    }
                                    m_iCol++;
                                }
                                else
                                { m_iStep++; }
                                return false;
                            }
                            else
                            {
                                if (!CData.dfInfo.bBusy)
                                {
                                    if (m_eWy == EWay.L)
                                    {
                                        CDf.It.SendAfEnd("LGD");
                                        m_iStep = 44;
                                    }
                                    else
                                    {
                                        CDf.It.SendAfEnd("RGD");
                                        m_iStep = 44;
                                    }
                                }
                                else
                                { return false; }
                            }
                        }
                        return false;
                    }

                case 42:
                    {
                        if (m_eWy == EWay.L)
                        {
                            if (!CData.dfInfo.bBusy)
                            {
                                CDf.It.SendGrdRowData("LGD", m_sRowData);
                                m_iStep++;
                            }
                        }
                        else
                        {
                            if (!CData.dfInfo.bBusy)
                            {
                                CDf.It.SendGrdRowData("RGD", m_sRowData);
                                m_iStep++;
                            }
                        }

                        return false;
                    }

                case 43:
                    {
                        if (m_eWy == EWay.L)
                        {
                            if (CDf.It.ReciveAckGRL((int)ECMD.scRowL))
                            {
                                m_sRowData = "";
                                m_iRow++;
                                m_iCol = 0;
                                m_iStep = 41;
                            }
                        }
                        else
                        {
                            if (CDf.It.ReciveAckGRR((int)ECMD.scRowR))
                            {
                                m_sRowData = "";
                                m_iRow++;
                                m_iCol = 0;
                                m_iStep = 41;
                            }
                        }
                        return false;
                    }

                case 44:
                    {
                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            if (m_eWy == EWay.L)
                            {
                                if (!CDf.It.ReciveAckGRL((int)ECMD.scBfEndL))
                                { return false; }
                            }
                            else
                            {
                                if (!CDf.It.ReciveAckGRR((int)ECMD.scBfEndR))
                                { return false; }
                            }
                        }
                        else
                        {
                            if (m_eWy == EWay.L)
                            {
                                if (!CDf.It.ReciveAckGRL((int)ECMD.scAfEndL))
                                { return false; }
                            }
                            else
                            {
                                if (!CDf.It.ReciveAckGRR((int)ECMD.scAfEndR))
                                { return false; }
                            }
                        }

                        m_iStep++;
                        return false;
                    }

                case 45:
                    {
                        m_iCol = 0;
                        m_iRow = 0;

                        //190319 ksg : Bf / Af Max, Min, Ttv 표시 해야 됨
                        if (iIdx == (int)EMeaStep.Before/*0*/) // Before 측정 Data
                        {
                            double dMax = CData.PbResultVal[m_iWy].dBMax;
                            double dMin = CData.PbResultVal[m_iWy].dBMin;
                            double dMean = CData.PbResultVal[m_iWy].dBAvg;
                            int iCnt = 0;

                            for (int iRow = 0; iRow < m_aInspBf.GetLength(0); iRow++)
                            {
                                for (int iCol = 0; iCol < m_aInspBf.GetLength(1); iCol++)
                                {
                                    if (m_aInspBf[iRow, iCol] != 0)
                                    {
                                        CData.m_dPbVal[m_iWy].m_BFVal.Add(m_aInspBf[iRow, iCol]); //191120 ksg :
                                                                                                  //191118 ksg :
                                        if (CData.GemForm != null)
                                        {//Before 측정 Data 
                                            if (m_eWy == EWay.L)
                                            {
                                                CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Data[1, iCnt] = m_aInspBf[iRow, iCol];// Left 측정 Data
                                                CData.GemForm.Log_wt(string.Format("Left before Data = {0},{1}", iCnt, float.Parse(CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Data[1, iCnt].ToString())));
                                            }
                                            else
                                            {
                                                CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Data[5, iCnt] = m_aInspBf[iRow, iCol];// Right 측정 Data
                                                CData.GemForm.Log_wt(string.Format("Right before Data = {0},{1}", iCnt, float.Parse(CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Data[5, iCnt].ToString())));
                                            }
                                        }
                                        iCnt++;
                                    }
                                }
                            }

                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)
                                {
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].nMeasure_Count[1] = iCnt;
                                    CData.GemForm.Log_wt(string.Format("Left before Cnt = {0},{1}", iCnt, CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].nMeasure_Count[1]));
                                }
                                else
                                {
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].nMeasure_Count[5] = iCnt;
                                    CData.GemForm.Log_wt(string.Format("Right before Cnt = {0},{1}", iCnt, CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].nMeasure_Count[5]));
                                }
                            }

                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)
                                {// Left Befor
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Min_Data[1] = dMin;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Max_Data[1] = dMax;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Avr_Data[1] = dMean;
                                }
                                else
                                {// Right Befor
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Min_Data[5] = dMin;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Max_Data[5] = dMax;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Avr_Data[5] = dMean;
                                }
                            }

                            //20190531 ghk
                            CData.PbResultVal[m_iWy].dBMean = Math.Round(((dMax + dMin) / 2), 4); //190502 ksg :
                            if (m_eWy == EWay.L)
                            {
                                if (CData.Dev.bDynamicSkip)
                                {
                                    if (CData.PbResultVal[m_iWy].dBMax <= CData.MPos[0].dPCBThickness || CData.PbResultVal[m_iWy].dBMin >= 999)
                                    {
                                        CErr.Show(eErr.LEFT_BEFORE_PROBE_DATA_LOST);

                                        m_bSubErr = true;

                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                                else
                                {
                                    if ((CData.PbResultVal[m_iWy].dBMax + CData.Parts[(int)EPart.GRDL].dPcbMax) <= CData.MPos[0].dPCBThickness || (CData.PbResultVal[m_iWy].dBMin + CData.Parts[(int)EPart.GRDL].dPcbMax) >= 999)
                                    {
                                        CErr.Show(eErr.LEFT_BEFORE_PROBE_DATA_LOST);

                                        m_bSubErr = true;

                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                            }
                            else // Right
                            {
                                if (CData.Dev.bDynamicSkip)
                                {
                                    if (CData.PbResultVal[m_iWy].dBMax <= CData.MPos[0].dPCBThickness || CData.PbResultVal[m_iWy].dBMin >= 999)
                                    {
                                        CErr.Show(eErr.RIGHT_BEFORE_PROBE_DATA_LOST);

                                        m_bSubErr = true;

                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                                else
                                {
                                    if ((CData.PbResultVal[m_iWy].dBMax + CData.Parts[(int)EPart.GRDR].dPcbMax) <= CData.MPos[0].dPCBThickness || (CData.PbResultVal[m_iWy].dBMin + CData.Parts[(int)EPart.GRDL].dPcbMax) >= 999)
                                    {
                                        CErr.Show(eErr.RIGHT_BEFORE_PROBE_DATA_LOST);

                                        m_bSubErr = true;

                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                            }
                        }

                        else //After 측정 Data
                        {
                            double dMax = CData.PbResultVal[m_iWy].dAMax;
                            double dMin = CData.PbResultVal[m_iWy].dAMin;
                            double dMean = CData.PbResultVal[m_iWy].dAAvg;
                            int iCnt = 0;

                            // 2021-05-14, jhLee, Multi-LOT, 현재 가공중인 Strip의 LOT Name을 사용하도록 한다.
                            if (CData.IsMultiLOT())
                            {
                                // Multi-LOT일 경우 가공중인 Strip의 Lot 이름을 사용한다. 이미 개별 LOT Info를 사용하게 되어있으나 이중화 차원에서 별도 지정도 해준다.
                                CData.SpcData.sLotName = CData.Parts[m_iPart].sLotName;
                            }
                            else
                            {
                                CData.SpcData.sLotName = CData.LotInfo.sLotName;
                            }

                            for (int iRow = 0; iRow < m_aInspAf.GetLength(0); iRow++)
                            {
                                for (int iCol = 0; iCol < m_aInspAf.GetLength(1); iCol++)
                                {
                                    if (m_aInspAf[iRow, iCol] != 0)
                                    {
                                        CData.m_dPbVal[m_iWy].m_AFVal.Add(m_aInspAf[iRow, iCol]); //191120 ksg :

                                        if (CData.GemForm != null)
                                        {
                                            if (m_eWy == EWay.L)
                                            {
                                                CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Data[4, iCnt] = m_aInspAf[iRow, iCol];
                                                CData.GemForm.Log_wt(string.Format("Left After Data = {0},{1}", iCnt, float.Parse(CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Data[4, iCnt].ToString())));
                                            }
                                            else
                                            {
                                                CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Data[6, iCnt] = m_aInspAf[iRow, iCol];
                                                CData.GemForm.Log_wt(string.Format("Right After Data = {0},{1}", iCnt, float.Parse(CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Data[6, iCnt].ToString())));
                                            }
                                        }
                                        iCnt++;
                                    }
                                }
                            }

                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)
                                {
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].nMeasure_Count[4] = iCnt;
                                    CData.GemForm.Log_wt(string.Format("Left After Cnt = {0},{1}", iCnt, CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].nMeasure_Count[4]));
                                }
                                else
                                {
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].nMeasure_Count[6] = iCnt;
                                    CData.GemForm.Log_wt(string.Format("Right After Cnt = {0},{1}", iCnt, CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].nMeasure_Count[6]));
                                }
                            }

                            if (m_eWy == EWay.L)
                            {
                                // jhLee, Multi-LOT의 경우 SPC 기록
                                if (CData.IsMultiLOT()) {   m_myLotInfo.rSpcData.sTtvLim    = CData.Dev.aData[(int)EWay.L].dTTV.ToString(); }
                                else                    {   CData.SpcData.sTtvLim           = CData.Dev.aData[(int)EWay.L].dTTV.ToString(); }

                                if (CData.Dev.aData[(int)EWay.L].dTTV != 0)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dTTV < (dMax - dMin))
                                    {
                                        CErr.Show(eErr.LEFT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                        _SetLog("Error : TTV Range over when after measure strip.");

                                        // 201009 jym : Before 측정 시에만 적용
                                        //m_bSubErr = true;

                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                            }
                            else
                            {
                                if (CData.Dev.bDual == eDual.Dual)
                                {
                                    // jhLee, Multi-LOT의 경우 SPC 기록
                                    if (CData.IsMultiLOT()) {   m_myLotInfo.rSpcData.sTtvLim    = CData.Dev.aData[m_iWy].dTTV.ToString();   }
                                    else                    {   CData.SpcData.sTtvLim           = CData.Dev.aData[m_iWy].dTTV.ToString();   }

                                    if (CData.Dev.aData[m_iWy].dTTV != 0)
                                    {
                                        if (CData.Dev.aData[m_iWy].dTTV < (dMax - dMin))
                                        {
                                            CErr.Show(eErr.RIGHT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                            _SetLog("Error : TTV Range over when after measure strip.");

                                            // 201009 jym : Before 측정 시에만 적용
                                            //m_bSubErr = true;

                                            m_iStep = 0;
                                            return true;
                                        }
                                    }
                                }
                                else
                                {
                                    // jhLee, Multi-LOT의 경우 SPC 기록
                                    if (CData.IsMultiLOT()) {   m_myLotInfo.rSpcData.sTtvLim    = CData.Dev.aData[(int)EWay.L].dTTV.ToString(); }
                                    else                    {   CData.SpcData.sTtvLim           = CData.Dev.aData[(int)EWay.L].dTTV.ToString(); }

                                    if (CData.Dev.aData[(int)EWay.L].dTTV != 0)
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dTTV < (dMax - dMin))
                                        {
                                            CErr.Show(eErr.RIGHT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                            _SetLog("Error : TTV Range over when after measure strip.");

                                            // 201009 jym : Before 측정 시에만 적용
                                            //m_bSubErr = true;

                                            m_iStep = 0;
                                            return true;
                                        }
                                    }
                                }
                            }

                            if (CData.GemForm != null)
                            {
                                //dTemp = (CData.Dev.eMoldSide == ESide.Top) ? CData.Parts[m_iPart].dPcbMean : 0.0;   // 2020.09.11 JSKim Del
                                if (m_eWy == EWay.L)
                                {   // SECSGEM Host에 Data Upload 진행  20200301 LCY 
                                    // Top Side : Mold_높이 + DF 측정 Data
                                    // Bottom Side : Mold 높이
                                    
                                    if      (CData.Dev.eMoldSide == ESide.Top)    dTemp = CData.Parts[(int)EPart.GRDL].dPcbMean;
                                    else                                          dTemp = 0.0;

                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Min_Data[4] = dMin + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Max_Data[4] = dMax + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Avr_Data[4] = dMean + dTemp;
                                    
                                    _SetLog("Func Call : CData.GemForm.OnCarrierGrindFinished(1)");

                                    // 2021.10.19 SungTae Start : [수정] (ASE-KR VOC) SECS/GEM Issue 관련 조건 추가
                                    //CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N1);
                                    if (!CData.bChkGrdM)
                                    {
                                        CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N1);
                                    }
                                    // 2021.10.19 SungTae End
                                }
                                else
                                {   // SECSGEM Host에 Data Upload 진행  20200301 LCY
                                    // Top Side : Mold_높이 + DF 측정 Data
                                    // Bottom Side : Mold 높이
                                    if      (CData.Dev.eMoldSide == ESide.Top)    dTemp = CData.Parts[(int)EPart.GRDR].dPcbMean;
                                    else                                          dTemp = 0.0;

                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Min_Data[6] = dMin + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Max_Data[6] = dMax + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Avr_Data[6] = dMean + dTemp;
                                    
                                    _SetLog("Func Call : CData.GemForm.OnCarrierGrindFinished(2)");

                                    // 2021.10.19 SungTae Start : [수정] (ASE-KR VOC) SECS/GEM Issue 관련 조건 추가
                                    //CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N2);
                                    if (!CData.bChkGrdM)
                                    {
                                        CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N2);
                                    }
                                    // 2021.10.19 SungTae End
                                }
                            }

                            if (CData.PbResultVal[m_iWy].dBMax <= 0 || CData.PbResultVal[m_iWy].dBMin >= 999)
                            {
                                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_BEFORE_PROBE_DATA_LOST :
                                                              eErr.RIGHT_BEFORE_PROBE_DATA_LOST);
                                _SetLog("Error : Probe data lost.");

                                //201010 jhc : Before 측정 시에만 적용
                                //m_bSubErr = true;

                                m_iStep = 0;
                                return true;
                            }

                            // 2021-05-17, jhLee, Multi-LOT의 경우에도 SPC 기록
                            if (CData.IsMultiLOT())
                            {
                                SetMyLotInfo();     // 내부 사용 LotInfo  대입

                                m_myLotInfo.rSpcData.sMgzNo     = CData.Parts[m_iPart].iMGZ_No.ToString();
                                m_myLotInfo.rSpcData.sSlotNo    = CData.Parts[m_iPart].iSlot_No.ToString();
                                m_myLotInfo.rSpcData.sTable     = (m_eWy == EWay.L) ? "L" : "R";
                                m_myLotInfo.rSpcData.sBcr       = CData.Parts[m_iPart].sBcr;
                                m_myLotInfo.rSpcData.sMode      = (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown) ? "TopDown" : "Target";

                                if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                {
                                    CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_AfterMeaStrip : ESeq.GRR_AfterMeaStrip;
                                }

                                m_myLotInfo.rSpcData.sMax   = dMax.ToString();
                                m_myLotInfo.rSpcData.sMin   = dMin.ToString();
                                m_myLotInfo.rSpcData.sMean  = dMean.ToString();
                                m_myLotInfo.rSpcData.sTtv   = (dMax - dMin).ToString();
                                m_myLotInfo.rSpcData.sBMax  = CData.PbResultVal[m_iWy].dBMax.ToString();
                                m_myLotInfo.rSpcData.sBMin  = CData.PbResultVal[m_iWy].dBMin.ToString();
                                m_myLotInfo.rSpcData.sBAvg  = CData.PbResultVal[m_iWy].dBAvg.ToString();

                                for (int i = m_iStepMaxCnt - 1; i >= 0; i--)
                                {
                                    if (CData.Dev.bDual == eDual.Dual)
                                    {
                                        if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                        {
                                            m_myLotInfo.rSpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                            m_myLotInfo.rSpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                            break;
                                        }
                                    }
                                    else
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].eGrdMod == eGrdMode.TopDown)
                                            {
                                                m_myLotInfo.rSpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                m_myLotInfo.rSpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                            }
                                            else
                                            {
                                                m_myLotInfo.rSpcData.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                m_myLotInfo.rSpcInfo.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                            }
                                            break;
                                        }
                                    }
                                }

                                if (CData.CurCompany == ECompany.ASE_KR)    {   CSpc.It.SaveLotData_Add(ref m_myLotInfo); }
                                else 										{   CSpc.It.SaveLotData(m_myLotInfo);         }

                                //190529 ksg :
                                if (m_eWy == EWay.L && CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown)
                                {
                                    if (CData.IsMultiLOT()) {   double.TryParse(m_myLotInfo.rSpcInfo.sTarget,   out CData.Parts[(int)EPart.GRDL].dShiftT);  }
                                    else                    {   double.TryParse(CData.SpcInfo.sTarget,          out CData.Parts[(int)EPart.GRDL].dShiftT);  }
                                }

                                //200325 ksg : Data Shift Probe Skip
                                if (m_eWy == EWay.L && CData.Dev.bDShiftPSkip && CData.Dev.bDual == eDual.Dual)
                                {
                                    CData.Parts[(int)EPart.GRDL].dShiftT = dMax;

                                    // 2022.08.17 SungTae
                                    string sMeas = (iIdx == 0) ? "BEFORE" : "AFTER";
                                    _SetLog($"---------> [확인용]({sMeas}) Part[GRDL].ShiftT = {dMax}");
                                }
                            }  // end : if (CData.IsMultiLOT())
                            else  // if (CData.IsMultiLOT())의 else 
                            {
                                if (CData.LotInfo.bLotOpen)
                                {
                                    CData.SpcData.sMgzNo    = CData.Parts[m_iPart].iMGZ_No.ToString();
                                    CData.SpcData.sSlotNo   = CData.Parts[m_iPart].iSlot_No.ToString();
                                    CData.SpcData.sTable    = (m_eWy == EWay.L) ? "L" : "R";
                                    CData.SpcData.sBcr      = CData.Parts[m_iPart].sBcr;
                                    CData.SpcData.sMode     = (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown) ? "TopDown" : "Target";

                                    if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                    {
                                        CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_AfterMeaStrip : ESeq.GRR_AfterMeaStrip;
                                    }

                                    CData.SpcData.sMax  = dMax.ToString();
                                    CData.SpcData.sMin  = dMin.ToString();
                                    CData.SpcData.sMean = dMean.ToString();
                                    CData.SpcData.sTtv  = (dMax - dMin).ToString();
                                    CData.SpcData.sBMax = CData.PbResultVal[m_iWy].dBMax.ToString();
                                    CData.SpcData.sBMin = CData.PbResultVal[m_iWy].dBMin.ToString();
                                    CData.SpcData.sBAvg = CData.PbResultVal[m_iWy].dBAvg.ToString();

                                    for (int i = m_iStepMaxCnt - 1; i >= 0; i--)
                                    {
                                        if (CData.Dev.bDual == eDual.Dual)
                                        {
                                            if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                            {
                                                CData.SpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                CData.SpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                            {
                                                if (CData.Dev.aData[(int)EWay.L].eGrdMod == eGrdMode.TopDown)
                                                {
                                                    CData.SpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                    CData.SpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                }
                                                else
                                                {
                                                    CData.SpcData.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                    CData.SpcInfo.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                }
                                                break;
                                            }
                                        }
                                    }

                                    if (CData.CurCompany == ECompany.ASE_KR)	{ CSpc.It.SaveLotData_Add();    }
                                    else 										{ CSpc.It.SaveLotData();        }

                                    if (m_eWy == EWay.L && CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown)
                                    {
                                        if (CData.IsMultiLOT()) {   double.TryParse(m_myLotInfo.rSpcInfo.sTarget,   out CData.Parts[(int)EPart.GRDL].dShiftT);  }
                                        else                    {   double.TryParse(CData.SpcInfo.sTarget,          out CData.Parts[(int)EPart.GRDL].dShiftT);  }
                                    }

                                    //200325 ksg : Data Shift Probe Skip
                                    if (m_eWy == EWay.L && CData.Dev.bDShiftPSkip && CData.Dev.bDual == eDual.Dual)
                                    {
                                        CData.Parts[(int)EPart.GRDL].dShiftT = dMax;
                                    }
                                }
                            } // end : if (CData.IsMultiLOT())의 else
                        }

                        if (CData.LotInfo.bLotOpen)
                        {
                            SetMyLotInfo();     // 내부 사용 LotInfo  대입

                            string sTemp = (iIdx == 0) ? "BEFORE" : "AFTER";
                            CSpc.It.SaveDataIni(ref m_myLotInfo, m_eWy, sTemp, m_aInspTemp);

                            if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                            {
                                CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_AfterMeaStrip : ESeq.GRR_AfterMeaStrip;
                            }
                        }

                        _SetLog("Finish.  Status : " + CData.Parts[m_iPart].iStat);

                        m_iStep = 0;
                        return true;
                    }

                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스
                case 100:
                    {//Z축 대기 위치 이동, 프로브 에어 오프
                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running)	{ m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy]; }
                        else 												{ m_dPosZ = CData.SPos.dGRD_Z_Wait[m_iWy]; }

                        CMot.It.Stop(m_iZ);
                        CMot.It.Mv_N(m_iZ, m_dPosZ);

                        _SetLog("Z axis move position.", m_dPosZ);

                        Func_PrbAir(false);

                        m_iStep++;
                        return false;
                    }

                case 101:
                    {//Z축 대기 위치 이동 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }

                        if (m_iPickerVacErr == 1)	{ CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else 						{ CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        _SetLog("ERROR : Picker Vacuum : " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            m_bSubErr = true;
                        }

                        m_iStep = 0;
                        return true;
                    }
                    ///////////////////////////////////////////////////////////////////////////////////////
            }
        }


        /// <summary>
        /// Strip Thickness Measure
        /// 스트립 두께 측정 함수 0:Before, 1:After
        /// </summary>
        /// <param name="iIdx"></param>
        /// <returns></returns>
        public bool Cyl_MeaStrip_T2(int iBfAf) //200625 jhc : ASE-KR은 스트립 측정 시 테이블 한 번만 측정 <- Cyl_MeaStrip()
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            {
                m_mTimeout.Set_Delay(TIMEOUT);
            }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (iBfAf == 0)
                    {
                        if (m_eWy == EWay.L)    { CErr.Show(eErr.LEFT_GRIND_STRIP_INSPECTION_BEFORE_TIMEOUT); }
                        else                    { CErr.Show(eErr.RIGHT_GRIND_STRIP_INSPECTION_BEFORE_TIMEOUT); }
                        
                        _SetLog("Error : Timeout(Before).");
                    }
                    else
                    {
                        if (m_eWy == EWay.L)    { CErr.Show(eErr.LEFT_GRIND_STRIP_INSPECTION_AFTER_TIMEOUT); }
                        else                    { CErr.Show(eErr.RIGHT_GRIND_STRIP_INSPECTION_AFTER_TIMEOUT); }

                        _SetLog("Error : Timeout(After).");
                    }

                    //m_bSubErr = true;

                    m_iStep = 0;
                    return true;
                }
            }

            if (!Chk_Strip())
            {
                if (m_eWy == EWay.L)    { CErr.Show(eErr.LEFT_GRIND_VACUUM_ERROR);  }
                else                    { CErr.Show(eErr.RIGHT_GRIND_VACUUM_ERROR); }
                
                _SetLog("Error : Vacuum fail.");

                // 201009 jym : Before 측정 시에만 적용
                if (iBfAf == 0) { m_bSubErr = true; }

                m_iStep = 0;
                return true;
            }

            m_iPreStep = m_iStep;

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if ((CData.CurCompany == ECompany.ASE_KR) && 
                (m_iStep == 14 || m_iStep == 15 || m_iStep == 28 || m_iStep == 29 || m_iStep == 33 || m_iStep == 34))
            {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크

                if (0 != m_iPickerVacErr)
                {
                    CMot.It.EStop(m_iY); //Table Y축 즉시 Stop

                    _SetLog("ERROR : Picker Vacuum : " + m_siY + " STOP : " + CMot.It.Get_FP(m_iY).ToString());

                    m_iStep = 100; //정리 스텝으로
                    return false;
                }
            }
            ///////////////////////////////////////////////////////////////////////////////////////

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10: // 축 상태 체크
                    {
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            if (CData.Opt.bWheelStopWaitSkip == false)   // 2021.02.20 lhs : true = 기다리지 않음, false = 기다림 (JCET VOC)
                            {
                                return false;
                            }
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }

                        m_bMeaErrBf_L = false;
                        m_bMeaErrAf_L = false;
                        m_bMeaErrBf_R = false;
                        m_bMeaErrAf_R = false;

                        ProbeClearVal(iBfAf);

                        // 데이터 클리어 요청
                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if(CData.CurCompany == ECompany.Qorvo || (CData.CurCompany == ECompany.Qorvo_DZ) || CData.CurCompany == ECompany.SST) && iBfAf == 0)
                        if((CData.CurCompany == ECompany.Qorvo      || CData.CurCompany == ECompany.Qorvo_DZ ||
                            CData.CurCompany == ECompany.Qorvo_RT   || CData.CurCompany == ECompany.Qorvo_NC ||
                            CData.CurCompany == ECompany.SST) && iBfAf == 0)
                        {
                            ProbeClearVal(iBfAf + 1);
                        }

                        InitPbValue(m_iWy, iBfAf);

                        // 200920 jym : 프로브 업 체크 카운트 초기화
                        m_iPrbUpCnt = 0;

                        m_bSubErr = false;

                        _SetLog("Check axes.");

                        m_iStep++;
                        return false;
                    }

                case 11: // IO 초기화
                    {
                        _InitCycle();
                        _SetLog("Init Cycle.");

                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            if (!CData.dfInfo.bBusy)
                            {
                                if (m_eWy == EWay.L)
                                {
                                    if (iBfAf == 0)
                                    {
                                        CData.GRLDfData.sBcr = CData.Parts[(int)EPart.GRDL].sBcr;
                                        CDf.It.SendBfStart("LGD");
                                    }
                                    else
                                    {
                                        if (CData.Dev.bDual == eDual.Normal)
                                        {
                                            CData.GRLDfData.sBcr = CData.Parts[(int)EPart.GRDL].sBcr;
                                            CDf.It.SendAfStart("LGD");
                                        }
                                    }
                                }
                                else
                                {
                                    if (iBfAf == 0 && CData.Dev.bDual == eDual.Normal)
                                    {
                                        CData.GRRDfData.sBcr = CData.Parts[(int)EPart.GRDR].sBcr;
                                        CDf.It.SendBfStart("RGD");
                                    }
                                    else if (iBfAf == 1 )
                                    {
                                        CData.GRRDfData.sBcr = CData.Parts[(int)EPart.GRDR].sBcr;
                                        CDf.It.SendAfStart("RGD");
                                    }
                                }
                            }
                            else
                            { return false; }
                        }

                        m_iStep++;
                        return false;
                    }

                case 12: // 데이터 저장 변수 초기화
                    {                       
                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            if (m_eWy == EWay.L)
                            {
                                if (iBfAf == 0)
                                {
                                    if (!CDf.It.ReciveAckGRL((int)ECMD.scBfStartL))
                                    { return false; }
                                }
                                else
                                {
                                    if (CData.Dev.bDual == eDual.Normal)
                                    {
                                        if (!CDf.It.ReciveAckGRL((int)ECMD.scAfStartL))
                                        { return false; }
                                    }
                                }

                                if (CData.dfInfo.sGl == "GL1" && iBfAf == 0 && CDataOption.MeasureDf == eDfServerType.MeasureDf)
                                {//GL1이고, Before측정이고, DF서버 사용시 DF 측정 할때
                                    if (!CData.dfInfo.bBusy)
                                    {
                                        CData.GRLDfData.dPcb1 = CData.Parts[(int)EPart.GRDL].dPcb[0];
                                        CData.GRLDfData.dPcb2 = CData.Parts[(int)EPart.GRDL].dPcb[1];
                                        CData.GRLDfData.dPcb3 = CData.Parts[(int)EPart.GRDL].dPcb[2];

                                        if      (CData.Dynamic.iHeightType == 0)    { CData.GRLDfData.sPcbUse = "Max"; }
                                        else if (CData.Dynamic.iHeightType == 1)    { CData.GRLDfData.sPcbUse = "Avg"; }

                                        CDf.It.SendPcbData("LGD");
                                    }
                                    else
                                    { return false; }
                                }
                            }
                            else
                            {
                                if (iBfAf == 0 && CData.Dev.bDual == eDual.Normal)
                                {
                                    if (!CDf.It.ReciveAckGRR((int)ECMD.scBfStartR))
                                    { return false; }
                                }
                                else if(iBfAf==1)
                                {
                                    if (!CDf.It.ReciveAckGRR((int)ECMD.scAfStartR))
                                    { return false; }
                                }

                                if (CData.dfInfo.sGl == "GL1" && iBfAf == 0 && CData.Dev.bDual == eDual.Normal && CDataOption.MeasureDf == eDfServerType.MeasureDf)
                                {//GL1이고, Before측정이고, Step모드 아니고, DF서버 사용시 DF 측정 할때
                                    if (!CData.dfInfo.bBusy)
                                    {
                                        CData.GRRDfData.dPcb1 = CData.Parts[(int)EPart.GRDR].dPcb[0];
                                        CData.GRRDfData.dPcb2 = CData.Parts[(int)EPart.GRDR].dPcb[1];
                                        CData.GRRDfData.dPcb3 = CData.Parts[(int)EPart.GRDR].dPcb[2];

                                        if      (CData.Dynamic.iHeightType == 0)    { CData.GRRDfData.sPcbUse = "Max"; }
                                        else if (CData.Dynamic.iHeightType == 1)    { CData.GRRDfData.sPcbUse = "Avg"; }

                                        CDf.It.SendPcbData("RGD");
                                    }
                                    else
                                    { return false; }
                                }
                            }
                        }

                        m_iRow = 0;
                        m_iCol = 0;
                        m_dPosX = CData.SPos.dGRD_X_Zero[m_iWy];
                        m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS;
                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];

                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_ProbeDn ;
                            m_eOt2 = eY.GRDL_ProbeAir;
                            m_eIn1 = eX.GRDL_ProbeAMP;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_ProbeDn ;
                            m_eOt2 = eY.GRDR_ProbeAir;
                            m_eIn1 = eX.GRDR_ProbeAMP;
                        }

                        if (iBfAf == 0) // Before
                        {
                            m_aInspBf      = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            m_aInspTotalBf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];    // 2020.09.14 JSKim Add
                            m_abMeaBfErr   = new bool  [CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol]; 
                            CData.GrData[m_iWy].aMeaBf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            
                            // 새로운 자재 투입시 전후 데이터 클리어
                            if (CData.CurCompany == ECompany.Qorvo      || CData.CurCompany == ECompany.Qorvo_DZ ||
                                CData.CurCompany == ECompany.Qorvo_RT   || CData.CurCompany == ECompany.Qorvo_NC || // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                                CData.CurCompany == ECompany.SST)
                            {
                                m_aInspAf    = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                                m_abMeaAfErr = new bool  [CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                                CData.GrData[m_iWy].aMeaAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            }                            
                        }
                        else    // After
                        {
                            m_aInspAf      = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            m_aInspTotalAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];     // 2020.09.14 JSKim Add
                            m_abMeaAfErr   = new bool  [CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            CData.GrData[m_iWy].aMeaAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            if(m_eWy == EWay.L)
                            {
                                m_aInspShift = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            }
                        }

                        m_aInspTemp       = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                        m_aInspTotalTemp  = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];  // 2020.09.14 JSKim Add

                        _SetLog("Init data.");

                        //2021.08.06 syc : Up상태일때 Probe 값 정상 범위 인지 확인
                        //- Qorvo 프로브 앰프값 자동으로 바뀌는 이슈에 대한 방지책
                        //- Probe 값이 18.9xxx ~ 19.0xxx 범위 이탈시 알람
                        if (Chk_ProbeUpVal())
                        {
                            m_bSubErr = true;//211006 pjh : 측정 Error 시 Cycle Stop

                            m_iStep = 0;
                            return true;
                        }

                        m_iStep++;
                        return false;
                    }

                case 13: // Z축 측정 위치 이동
                    {
                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl == "GL1" && iBfAf == 0 && CSQ_Main.It.m_iStat == EStatus.Auto_Running && CDataOption.MeasureDf == eDfServerType.MeasureDf)
                        {
                            if (m_eWy == EWay.L)
                            {
                                if (!CDf.It.ReciveAckGRL((int)ECMD.scPcbL))
                                { return false; }
                            }
                            else
                            {
                                if (CData.Dev.bDual == eDual.Normal)
                                {
                                    if (!CDf.It.ReciveAckGRR((int)ECMD.scPcbR))
                                    { return false; }
                                }
                            }
                        }
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move position.", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 14: // Z축 테이블 측정 위치 이동 확인, Y축 Table 상단 측정 위치 이동
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]);
                        _SetLog("Y axis move measure table.", CData.SPos.dGRD_Y_TblInsp[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 15: // Y축 Table 상단 측정 위치 이동 확인, X축 0으로 이동
                    {
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]))
                        { return false; }

                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                        _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 16: // X축 0으로 이동 확인, 프로브 에어 온
                    {
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }

                        Func_PrbAir(true);
                        _SetLog("Porbe air on.");

                        m_iStep++;
                        return false;
                    }

                case 17: //프로브 에어 온 확인, 프로브 다운
                    {
                        if (!Func_PrbAir(true))
                        { return false; }

                        Func_PrbDown(true);
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 18: //프로브 다운 확인, 프로브 에어 오프
                    {
                        if (!CIO.It.Get_X(m_eIn1))
                        {
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            Func_PrbAir(false);
                            _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }

                        return false;
                    }

                case 19: //프로브 에어 오프 확인, 프로브 값 획득 후 테이블 높이 계산
                    {
                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            CData.Tbl_Af[m_iWy, 0] = CPrb.It.Read_Val(m_eWy) + GV.EQP_TABLE_MIN_THICKNESS;
                            _SetLog("Table thickness : " + CData.Tbl_Af[m_iWy, 0] + "mm", true);

                            if (CData.Tbl_Af[m_iWy, 0] > (GV.EQP_TABLE_MIN_THICKNESS + 4))
                            {
                                CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_MANUALZIG_ON_THE_TABLE :
                                                                   eErr.RIGHT_GRIND_MANUALZIG_ON_THE_TABLE);
                                _SetLog("Error : Manual zig on table.");

                                m_bSubErr = true;

                                m_iStep = 0;
                                m_iGStep = 0;
                                return true;
                            }

                            m_iStep++;
                        }

                        return false;
                    }

                case 20: //프로브 업
                    {
                        //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(true);
                        }
                        Func_PrbDown(false);
                        //
                        m_Delay.Set_Delay(GV.PRB_DELAY);//191002 ksg :
                        _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

                        //211028 syc : Qorvo Probe Up Time Check
                        if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ)
                        {
                            sStopwatch.Restart(); 
                        }                       
                        // syc end

                        m_iStep++;
                        return false;
                    }

                case 21: //프로브 업 확인, Z축 자재 측정 위치로 이동
                    {
                        bool bReadProbeVal = false; //201020 jhc : 단위 Case 문 내에서 프로브 1번만 읽기 위함 (불필요 delay 방지)

                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if(CData.CurCompany != ECompany.Qorvo && (CData.CurCompany != ECompany.Qorvo_DZ) && CData.CurCompany != ECompany.SST)
                        if (CData.CurCompany != ECompany.Qorvo && CData.CurCompany != ECompany.Qorvo_DZ &&
                            CData.CurCompany != ECompany.Qorvo_RT && CData.CurCompany != ECompany.Qorvo_NC &&
                            CData.CurCompany != ECompany.SST)
                        { 
                            //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                            dtmp = CPrb.It.Read_Val(m_eWy);
                            bReadProbeVal = true; //201020 jhc : 단위 Case 문 내에서 프로브 1번만 읽기 위함 (불필요 delay 방지)
                            if ((!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)) && m_Delay.Chk_Delay())
                            {
                                m_iPrbUpCnt++;
                                if (m_iPrbUpCnt == 3)
                                {
                                    CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET :
                                                                       eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                                    //_SetLog("Error : Probe up not complete.");
                                    //210907 pjh : Probe Up Log 추가
                                    _SetLog("Error : Probe up not complete. Probe Height : " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                                    //

                                    // 201009 jym : Before 측정 시에만 적용
                                    if (iBfAf == 0)	{ m_bSubErr = true; }

                                    m_iStep = 0;
                                    return true;
                                }
                                else
                                {
                                    Func_PrbDown(false);
                                    m_Delay.Set_Delay(GV.PRB_DELAY);//191002 ksg :
                                    //_SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");
                                    //210907 pjh : Probe Up Log 추가
                                    _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms" + " Probe Height : " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                                    //
                                    _SetLog("Probe up cycle retry.  Count : " + m_iPrbUpCnt);
                                    
                                    return false;
                                }
                            }

                            // 200920 jym : 프로브 업 체크 카운트 초기화
                            m_iPrbUpCnt = 0;
                        }

                        // Data Shift Probe Skip
                        if(CData.Dev.bDShiftPSkip && m_eWy == EWay.R && iBfAf == 0 && CSQ_Main.It.m_bRun && CData.Dev.bDual == eDual.Dual) //200428 ksg : Data Shift Probe Skip 조건 추가
                        {
#if true //201020 jhc : Data Shift전 Probe Up 후 Delay 필요
                            if (!bReadProbeVal) { dtmp = CPrb.It.Read_Val(m_eWy); } //bReadProbeVal : 단위 Case 문 내에서 프로브 1번만 읽기 위함 (불필요 delay 방지)
                            if ((!m_Delay.Chk_Delay()) && (!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)))
                            {
                                 return false; //Data Shift 인 경우 프로브 업 대기
                            }
#endif
                            //200513 myk : Dats Shift 시 One Point 강제 셋팅
                            CData.GrData[(int)EWay.R].aOldOnPont[0] = CData.Parts[(int)EPart.GRDR].dShiftT;
                            //_SetLog("Data shift.");
                            _SetLog("Data shift -> OldOnePoint = " + CData.GrData[(int)EWay.R].aOldOnPont[0].ToString());  // 2021.12.07 lhs 로그수정

                            //210907 pjh : Probe Up Log 추가
                            _SetLog("Probe Height: " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                            //

                            m_iStep = 0;
                            return true;
                        }

                        //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                        dtmp = CPrb.It.Read_Val(m_eWy);
                        if (CIO.It.Get_X(m_eIn1) && (dtmp >= GV.dProbeUpHeight))
                        {
                            //211227 pjh : Ejector off
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(false);
                            }
                            //
                            m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0];
                            CMot.It.Mv_N(m_iZ, m_dPosZ);    //프로브 테이블 측정시 0인 위치로 이동
                            _SetLog("Z axis move position.", m_dPosZ);
                            //210907 pjh : Probe Up Log 추가
                            _SetLog("Probe Height: " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                            //

                            //211028 syc : Qorvo Probe Up Time Check
                            if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ)
                            {
                                sStopwatch.Stop();
                                _SetLog("Probe Up Time : " + sStopwatch.ElapsedMilliseconds,true);
                            }
                            // syc end

                            m_iStep++;
                        }

                        return false;
                    }

                case 22: //Z축 자재 측정 위치로 이동 확인, 프로브 에어 온
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        Func_PrbAir(true);
                        _SetLog("Probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 23: //프로브 에어 온 확인, 프로브 다운
                    {
                        if (!Func_PrbAir(true))
                        { return false; }

                        Func_PrbDown(true);
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 24: //프로브 다운 확인, 프로브 에어 오프
                    {
                        if (!CIO.It.Get_X(m_eIn1))
                        {
                            Func_PrbAir(false);
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }

                        return false;
                    }

                case 25: //프로브 에어 오프 확인, 프로브 값 획득 후 테이블 높이 계산
                    {
                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            m_InspZeroOffset = CPrb.It.Read_Val(m_eWy);
                            _SetLog("m_InspZeroOffset : " + m_InspZeroOffset + "mm", true);

                            m_iStep++;
                        }

                        return false;
                        
                    }

                case 26: //프로브 업
                    {
                        //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(true);
                        }
                        Func_PrbDown(false);
                        m_Delay.Set_Delay(GV.PRB_DELAY);//191002 ksg :
                        _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 27: //프로브 업 확인, Z축 자재 측정 위치로 이동
                    {
                        if (CData.CurCompany != ECompany.Qorvo      && CData.CurCompany != ECompany.Qorvo_DZ &&
                            CData.CurCompany != ECompany.Qorvo_RT   && CData.CurCompany != ECompany.Qorvo_NC && // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                            CData.CurCompany != ECompany.SST)
                        { 
                            //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                            dtmp = CPrb.It.Read_Val(m_eWy);
                            if ((!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)) && m_Delay.Chk_Delay())
                            {
                                m_iPrbUpCnt++;
                                if (m_iPrbUpCnt == 3)
                                {
                                    CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET :
                                                                       eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                                    //_SetLog("Error : Probe up not complete.");
                                    //210907 pjh : Probe Up Log 추가
                                    _SetLog("Error : Probe up not complete. Probe Height: " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                                    //
                                    // 201009 jym : Before 측정 시에만 적용
                                    if (iBfAf == 0)
                                    { m_bSubErr = true; }

                                    m_iStep = 0;
                                    return true;
                                }
                                else
                                {
                                    Func_PrbDown(false);
                                    m_Delay.Set_Delay(GV.PRB_DELAY);//191002 ksg :
                                    //_SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");
                                    //210907 pjh : Probe Up Log 추가
                                    _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms" + " Probe Height : " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                                    //
                                    _SetLog("Probe up cycle retry.  Count : " + m_iPrbUpCnt);

                                    return false;

                                }
                            }

                            // 200920 jym : 프로브 업 체크 카운트 초기화
                            m_iPrbUpCnt = 0;
                        }

                        //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                        dtmp = CPrb.It.Read_Val(m_eWy);
                        if (CIO.It.Get_X(m_eIn1) && (dtmp >= GV.dProbeUpHeight))
                        {
                            //211227 pjh : Ejector off
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(false);
                            }
                            //
                            //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                            //여기에서 스트립 측정 포인트 18 포인트(Leading Strip)인지? 일반(Main Strip)인지? 결정
                            if (CDataOption.Use18PointMeasure)
                            {
                                if (iBfAf == 0) //200713 jhc : Before인 경우에만 18 포인트 스트립 여부 검사
                                {
                                    this._checkIf18PStrip(ref CData.Parts[m_iPart].b18PMeasure, true);
                                }
                                else
                                {//After인 경우에는 현재 설정된 18 포인트 스트립 여부값을 참조
                                    //Nothing to do
                                }
                                _SetLog("18 point measure : " + CData.Parts[m_iPart].b18PMeasure);
                            }
                            else
                            { CData.Parts[m_iPart].b18PMeasure = false; }
                            _SetLog("Check probe up.");
                            //210907 pjh : Probe Up Log 추가
                            _SetLog("Probe Height: " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                            //

                            //211028 syc : Qorvo Probe Up Time Check
                            if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ)
                            {
                                sStopwatch.Stop();
                                _SetLog("Probe Up Time : " + sStopwatch.ElapsedMilliseconds, true);
                            }
                            // syc end

                            //----------------------
                            // 2022.03.23 lhs Start : 2004U, Dummy 초기화
                            if (CDataOption.Use2004U)
                            {
                                int nRow = CData.Dev.aData[m_iWy].bDummy.GetLength(0);
                                int nCol = CData.Dev.aData[m_iWy].bDummy.GetLength(1);

                                if (iBfAf == 0) // Before만 초기화
                                {
                                    if (CData.Dev.bDual == eDual.Normal) // Normal은 Left, Right 초기화
                                    {
										if (m_iWy == 0) {   CData.Parts[(int)EPart.GRDL].bCarrierWithDummy = false; } // Before, Normal, Left   : 초기화
                                        else            {   CData.Parts[(int)EPart.GRDR].bCarrierWithDummy = false; } // Before, Normal, Right  : 초기화

                                        for (int nR = 0; nR < nRow; nR++)
                                        {
                                            for (int nC = 0; nC < nCol; nC++)
                                            {
                                                CData.Dev.aData[m_iWy].bDummy[nR, nC]   = false;    // Dummy 초기화
                                            }
                                        }
                                    }
                                    else // Dual은 Left만 초기화
                                    {
                                        if (m_iWy == 0) 
                                        {   
                                            CData.Parts[(int)EPart.GRDL].bCarrierWithDummy = false; // Before, Dual, Left  : 초기화
                                            for (int nR = 0; nR < nRow; nR++)
                                            {
                                                for (int nC = 0; nC < nCol; nC++)
                                                {
                                                    CData.Dev.aData[m_iWy].bDummy[nR, nC]   = false;    // Dummy 초기화
                                                    CData.Dev.bCopyDummy[nR, nC]            = false;    // CopyDummy 초기화
                                                }
                                            }
                                        } 
                                    }
                                }
							}
                            // 2022.03.23 lhs End : 2004U, Dummy 초기화
                            //----------------------


                            m_iStep++;
                        }             
                        return false;           
                    }
                //1. m_iCol < CData.Dev.iCol 인지 확인
                //2. [m_iRow, m_iCol].bUse = true 인지 확인 for(int i = 0; i < CData.Dev.iRow)
                //3. [m_iRow, m_iCol].dX = Probe X축 Zero 위치와 같은지 확인
                //4. X축 [m_iRow, m_iCol].dX 위치로 이동
                //5. 테이블 상단 측정 후 프로브 X축 Zero일때 테이블 위치와 차이값 계산(m_InspOffset)
                //6. m_iRow < CData.Dev.iRow일때 m_iRow++ 하면서 bUse = true 일경우 프로브값 - m_InspOffset = 해당 위치 자재 높이
                //7. m_iCol++ 후 1번부터 반복
                //case 23:
                case 28: //== 반복 시작 지점 == 테이블 Y축 자재 측정 위치 이동 확인, m_iCol < CData.Dev.iCol 인지 확인, m_iCol열에서 사용자 설정 위치 있는지 확인, 있을 경우 프로브 X축 테이블 측정 위치와 같은지 확인, 같지 않을 경우 프로브 X축 해당 열위치로 이동
                    {                       
                        bool bMeasure = false;
                        if (iBfAf == 0) //Before 자재 측정 
                        {
                            if (m_iCol < CData.Dev.iCol)    //측정 열이 사용자가 설정한 열보다 작은지 확인
                            {
                                for (int i = 0; i < CData.Dev.iRow * CData.Dev.iWinCnt; i++)  //해당 열의 모든행에 사용자가 설정한 측정 포인트가 있는지 검사
                                {
                                    //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                                    if (CData.Parts[m_iPart].b18PMeasure)   { bMeasure = CData.Dev.aData[m_iWy].aPosBf[i, m_iCol].bUse18P;   }
                                    else                                    { bMeasure = CData.Dev.aData[m_iWy].aPosBf[i, m_iCol].bUse;      }
                                    
                                    //----------------------
                                    // 2022.01.24 lhs Start : 2004U, Carrier내 Dummy이면 측정 안함, Cyl_MeaStrip_T2에만 추가
                                    if (CDataOption.Use2004U)
                                    {
                                        if (bMeasure)
                                        {
                                            bool bDummyCarrier = false;
                                            if (m_iWy == 0) { bDummyCarrier = CData.Parts[(int)EPart.GRDL].bCarrierWithDummy; } // Before, Left,  case 28
                                            else            { bDummyCarrier = CData.Parts[(int)EPart.GRDR].bCarrierWithDummy; } // Before, Right, case 28
                                            if (bDummyCarrier)
                                            {
                                                if (CData.Dev.aData[m_iWy].bDummy[i, m_iCol]) { bMeasure = false; }
                                            }
                                        }
                                    }
                                    // 2022.01.24 lhs End 
                                    //----------------------

                                    if (bMeasure) { break; }
                                }

                                if (bMeasure)
                                {//해당 열 사용자 설정 측정 위치 있을 경우 해당 열이 센터와 같은지 확인 후 다를 경우 프로브 X축 해당 열 측정 위치로 이동
                                    if (m_dPosX == CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX)
                                    {
                                        /* m_iRow 자재 측정 위치로 이동 */
                                    }
                                    else
                                    {//프로브 X축 [m_iCol] 열 테이블 측정 위치로 이동
                                        m_dPosX = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX;
                                        CMot.It.Mv_N(m_iX, m_dPosX);    _SetLog("X axis move position.", m_dPosX);
                                        CMot.It.Mv_N(m_iY, m_dPosY);    _SetLog("Y axis move position.", m_dPosY);
                                    }
                                    _SetLog(string.Format("Use point(before).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                    m_iStep++;
                                }
                                else
                                {//해당 열에 사용자설정 측정 위치 없을 경우 m_iCol++ 후 반복
                                    m_iCol++;
                                    return false;
                                }
                            }
                            else
                            {
                                _SetLog(string.Format("Column end(before).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                m_iStep = 38;
                            }
                        }
                        else  //After 자재 측정
                        {
                            if (m_iCol < CData.Dev.iCol)    //측정 열이 사용자가 설정한 열보다 작은지 확인
                            {
                                for (int i = 0; i < CData.Dev.iRow * CData.Dev.iWinCnt; i++)    //해당 열의 모든행에 사용자가 설정한 측정 포인트가 있는지 검사
                                {
                                    //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                                    if (CData.Parts[m_iPart].b18PMeasure)   { bMeasure = CData.Dev.aData[m_iWy].aPosAf[i, m_iCol].bUse18P; }
                                    else                                    { bMeasure = CData.Dev.aData[m_iWy].aPosAf[i, m_iCol].bUse;    }

                                    //-----------
                                    // 2022.01.24 lhs Start : 2004U, Carrier내 Dummy이면 측정 안함, Cyl_MeaStrip_T2에만 추가
                                    if (CDataOption.Use2004U)
                                    {
                                        if (bMeasure)
                                        {
                                            bool bDummyCarrier = false;
                                            if (m_iWy == 0) { bDummyCarrier = CData.Parts[(int)EPart.GRDL].bCarrierWithDummy; } // After, Left,  case 28
                                            else            { bDummyCarrier = CData.Parts[(int)EPart.GRDR].bCarrierWithDummy; } // After, Right, case 28
                                            if (bDummyCarrier)
                                            {
                                                if (CData.Dev.aData[m_iWy].bDummy[i, m_iCol]) { bMeasure = false; }
                                            }
                                        }
                                    }
                                    // 2022.01.24 lhs End 
                                    //-----------

                                    if (bMeasure) { break; }
                                }

                                if (bMeasure)
                                {//해당 열 사용자 설정 측정 위치 있을 경우 해당 열이 센터와 같은지 확인 후 다를 경우 프로브 X축 해당 열 측정 위치로 이동
                                    if (m_dPosX == CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX)
                                    {/* m_iRow 자재 측정 위치로 이동 */}
                                    else
                                    {//프로브 X축 [m_iCol] 열 테이블 측정 위치로 이동
                                        m_dPosX = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX;
                                        CMot.It.Mv_N(m_iX, m_dPosX);
                                        _SetLog("X axis move position.", m_dPosX);
                                        CMot.It.Mv_N(m_iY, m_dPosY);
                                        _SetLog("Y axis move position.", m_dPosY);
                                    }
                                    _SetLog(string.Format("Use point(after).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                    m_iStep++;
                                }
                                else
                                {//해당 열에 사용자설정 측정 위치 없을 경우 m_iCol++ 후 반복
                                    m_iCol++;
                                    return false;
                                }
                            }
                            else
                            {
                                _SetLog(string.Format("Column end(after).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                m_iStep = 38;
                            }
                        }
                        return false;
                    }
                case 29: // X축 해당열 테이블 측정 위치로 이동 확인, 프로브 에어 온
                    {
                        if (!CMot.It.Get_Mv(m_iX, m_dPosX))
                        { 
                            CMot.It.Mv_N(m_iX, m_dPosX);
                            return false; 
                        }
                        if(!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { 
                            CMot.It.Mv_N(m_iY, m_dPosY);    
                            return false; 
                        }

                        Func_PrbAir(true);
                        _SetLog("Probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 30: // 프로브 에어 온 확인, 프로브 다운
                    {
                        if (!Func_PrbAir(true))
                        { return false; }

                        Func_PrbDown(true);
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 31: // 프로브 다운 확인 및 딜레이 설정, 프로브 에어 오프
                    {
                        if (!CIO.It.Get_X(m_eIn1))
                        {
                            Func_PrbAir(false);
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }
                        return false;
                    }

                case 32: // 프로브 에어 오프 확인, 테이블 높이 측정, 테이블 센터와의 옵셋 값 계산, 프로브 업
                    {
                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            m_InspOffset = CPrb.It.Read_Val(m_eWy);
                            _SetLog("Probe value : " + m_InspOffset + "mm", true);
                            //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(true);
                            }
                            Func_PrbDown(false);
                            m_Delay.Set_Delay(GV.PRB_DELAY);
                            _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

                            //211028 syc : Qorvo Probe Up Time Check
                            if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ)
                            {
                                sStopwatch.Restart(); //211028 syc : Qorvo Probe Up Time Check
                                m_bPrbUptimeChk = true;
                            }
                            // syc end

                            m_iStep++;
                        }
                        return false;
                    }

                case 33: // == 자재 행(m_iRow) 측정 반복 시점 == 프로브 업 확인, 테이블 Y축 자재 측정 위치로 이동
                    {
                        bool bMeasure = false; //200712 jhc : 18 포인트 측정 (ASE-KR VOC)

                        if (CData.CurCompany != ECompany.Qorvo      && CData.CurCompany != ECompany.Qorvo_DZ &&
                            CData.CurCompany != ECompany.Qorvo_RT   && CData.CurCompany != ECompany.Qorvo_NC &&   // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                            CData.CurCompany != ECompany.SST)
                        { 
                            //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                            dtmp = CPrb.It.Read_Val(m_eWy);
                            if ((!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)) && m_Delay.Chk_Delay())
                            {
                                m_iPrbUpCnt++;
                                if (m_iPrbUpCnt == 3)
                                {
                                    CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET :
                                                                       eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                                    //_SetLog("Error : Probe up not complete.");
                                    //210907 pjh : Probe Up Log 추가
                                    _SetLog("Error : Probe up not complete. Probe Height: " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                                    //

                                    // 201009 jym : Before 측정 시에만 적용
                                    if (iBfAf == 0)
                                    { m_bSubErr = true; }

                                    m_iStep = 0;
                                    return true;
                                }
                                else
                                {
                                    Func_PrbDown(false);
                                    m_Delay.Set_Delay(GV.PRB_DELAY);//191002 ksg :
                                    //_SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");
                                    //210907 pjh : Probe Up Log 추가
                                    _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms" + " Probe Height : " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                                    //
                                    _SetLog("Probe up cycle retry.  Count : " + m_iPrbUpCnt);

                                    return false;

                                }
                            }
                            // 200920 jym : 프로브 업 체크 카운트 초기화
                            m_iPrbUpCnt = 0;
                        }

                        //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                        dtmp = CPrb.It.Read_Val(m_eWy);
                        if (CIO.It.Get_X(m_eIn1) && (dtmp >= GV.dProbeUpHeight))
                        {
                        	//211227 pjh : Ejector Off
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(false);
                            }

                            //211028 syc : Qorvo Probe Up Time Check
                            if (m_bPrbUptimeChk)
                            {                                
                                if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ)
                                {
                                    sStopwatch.Stop();
                                    _SetLog("Probe Up Time : " + sStopwatch.ElapsedMilliseconds, true);
                                    m_bPrbUptimeChk = false;
                                }                                
                            }
                            // syc end

                            if (iBfAf == 0) // Before
                            {
                                if (m_iRow >= CData.Dev.iRow * CData.Dev.iWinCnt)
                                {
                                    m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                    m_iCol++;
                                    m_iRow = 0;
                                    CMot.It.Mv_N(m_iY, m_dPosY);
                                    _SetLog("Y axis move position(before)." + m_dPosY);

                                    m_iStep = 28;
                                    return false;
                                }

                                //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                                if (CData.Parts[m_iPart].b18PMeasure)   { bMeasure = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].bUse18P; }
                                else                                    { bMeasure = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].bUse;    }

                                // 2022.01.24 lhs Start : 2004U, Carrier내 Dummy이면 측정 안함, Cyl_MeaStrip_T2에만 추가
                                if (CDataOption.Use2004U)
                                {
                                    if (bMeasure)
                                    {
                                        bool bDummyCarrier = false;
                                        if (m_iWy == 0) { bDummyCarrier = CData.Parts[(int)EPart.GRDL].bCarrierWithDummy; } // Before, Left,  case 33
                                        else            { bDummyCarrier = CData.Parts[(int)EPart.GRDR].bCarrierWithDummy; } // Before, Right, case 33
                                        if (bDummyCarrier)
                                        {
                                            if (CData.Dev.aData[m_iWy].bDummy[m_iRow, m_iCol]) { bMeasure = false; }
                                        }
                                    }
                                }
                                // 2022.01.24 lhs End 

                                if (bMeasure)
                                {
                                    m_dPosY = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dY;
                                    _SetLog("Measure point(before).  Y axis position : " + m_dPosY + "mm");

                                    m_iStep++;
                                }
                                else
                                {
                                    m_iRow++;
                                    if (m_iRow < CData.Dev.iRow * CData.Dev.iWinCnt)
                                    { 
                                        return false; 
                                    }
                                    else
                                    {
                                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                        m_iCol++;
                                        m_iRow = 0;
                                        _SetLog("Row end(before).  Col : " + m_iCol);

                                        m_iStep = 28;
                                    }
                                }
                            }
                            else    // After
                            {
                                if (m_iRow >= CData.Dev.iRow * CData.Dev.iWinCnt)
                                {
                                    m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                    m_iCol++;
                                    m_iRow = 0;
                                    CMot.It.Mv_N(m_iY, m_dPosY);
                                    _SetLog("Y axis move position(after)." + m_dPosY);

                                    m_iStep = 28;
                                    return false;
                                }

                                //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                                if (CData.Parts[m_iPart].b18PMeasure)   { bMeasure = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].bUse18P; }
                                else                                    { bMeasure = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].bUse;    }

                                // 2022.01.24 lhs Start : 2004U, Carrier내 Dummy이면 측정 안함, Cyl_MeaStrip_T2에만 추가
                                if (CDataOption.Use2004U)
                                {
                                    if (bMeasure)
                                    {
                                        bool bDummyCarrier = false;
                                        if (m_iWy == 0) { bDummyCarrier = CData.Parts[(int)EPart.GRDL].bCarrierWithDummy; } // After, Left,  case 33
                                        else            { bDummyCarrier = CData.Parts[(int)EPart.GRDR].bCarrierWithDummy; } // After, Right, case 33

                                        if (bDummyCarrier)
                                        {
                                            if (CData.Dev.aData[m_iWy].bDummy[m_iRow, m_iCol]) { bMeasure = false; }
                                        }
                                    }
                                }
                                // 2022.01.24 lhs End 

                                if (bMeasure)
                                {
                                    m_dPosY = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dY;
                                    _SetLog("Measure point(after).  Y axis position : " + m_dPosY + "mm");
                                    m_iStep++;
                                }
                                else
                                {
                                    m_iRow++;
                                    if (m_iRow < CData.Dev.iRow * CData.Dev.iWinCnt)
                                    { 
                                        return false; 
                                    }
                                    else
                                    {
                                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                        m_iCol++;
                                        m_iRow = 0;
                                        _SetLog("Row end(after).  Col : " + m_iCol);

                                        m_iStep = 28;
                                    }
                                }
                            }
                        }

                        CMot.It.Mv_N(m_iY, m_dPosY);
                        _SetLog("Y axis move position.", m_dPosY);
                        //210907 pjh : Probe Up Log 추가
                        _SetLog("Probe Height: " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                        //

                        return false;
                    }

                case 34: //테이블 Y축 자재 측정 위치 이동 확인, 프로브 에어 온
                    {
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        Func_PrbAir(true);
                        _SetLog("Probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 35: //프로브 에어 온 확인, 프로브 다운
                    {
                        if (!Func_PrbAir(true))
                        { return false; }

                        Func_PrbDown(true);
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 36: //프로브 다운 확인, 프로브 에어 오프
                    {
                        if (!CIO.It.Get_X(m_eIn1))
                        {
                            Func_PrbAir(false);
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }
                        return false;
                    }

                case 37: //== 반복 종료 시점 == 프로브 에어 오프 확인, 자재 높이 측정, 프로브 업, 다음 행 설정(m_iRow++), m_iStep = 28로 이동
                    {
                        // jhLee, Multi-LOT의 경우에도 SPC 기록
                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            m_PbOfset = CPrb.It.Read_Val(m_eWy);

                            //-------------------------------------
                            // 2022.03.25 lhs Start : 설정한 Dummy 높이 이하이면 Dummy로 판단
                            if (CDataOption.Use2004U)
                            {
                                if (m_PbOfset < CData.Opt.dDummyThick)
                                {
                                    if (m_eWy == EWay.L)    { CData.Parts[(int)EPart.GRDL].bCarrierWithDummy = true; } // Dummy Carrier로 판단, LT, Normal/Dual Before
                                    else                    { CData.Parts[(int)EPart.GRDR].bCarrierWithDummy = true; } // Dummy Carrier로 판단, RT, Normal/Dual Before

                                    CData.Dev.aData[m_iWy].bDummy[m_iRow, m_iCol] = true; // Dummy로 판단

                                    _SetLog(string.Format("Set Dummy : Col = {0}, Row = {1}, Table = {2}, bDual = {3}, BfAf = {4}", 
                                                                        m_iCol,   m_iRow,    m_eWy.ToString(), CData.Dev.bDual.ToString(), iBfAf));

                                    Func_PrbDown(false);    // Dummy이면 Probe Up
                                    m_Delay.Set_Delay(GV.PRB_DELAY);
                                    _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

                                    m_iStep = 33;   // Row 반복 Step
                                    return false;
                                }
                            }
                            // 2022.03.25 lhs End : 설정한 Dummy 높이 이하이면 Dummy로 판단
                            //-------------------------------------

                            if (iBfAf == 0)
                            {
                                double dGap = m_PbOfset - (m_InspOffset - m_InspZeroOffset);
                                if (CData.GrData[m_iWy].aOldOnPont[0] < dGap)
                                { CData.GrData[m_iWy].aOldOnPont[0] = m_PbOfset - (m_InspOffset - m_InspZeroOffset); }
                                _SetLog(string.Format("Ori : {0}mm  Gap : {1}mm", m_PbOfset, dGap), true);
                            }

                            m_PbOfset = m_PbOfset + CData.Dev.aData[m_iWy].dPrbOffset; //CData.MPos[0].dPRB_OFFSET;
                            m_aInspTotalTemp[m_iRow, m_iCol] = m_PbOfset;   // 2020.09.14 JSKim Add

                            //syc : Qorvo After Measure
                            if (CDataOption.IsFakeAf && iBfAf == 1)
                            {
                                m_PbOfset += CData.MPos[m_iWy].fake;
                                _SetLog("AFOFF : " + CData.MPos[m_iWy].fake + "mm");
                            }

                            // 2020.09.14 JSKim St
                            if (CData.Parts[m_iPart].bExistStrip == false || CSQ_Main.It.m_iStat == EStatus.Manual) //201014 jhc : Manual 모드
                            {
                                CData.Parts[m_iPart].dDfMin = 0.0;
                                CData.Parts[m_iPart].dDfMax = 0.0;
                                CData.Parts[m_iPart].dDfAvg = 0.0;

                                CData.Parts[m_iPart].dPcbMin  = 0.0;
                                CData.Parts[m_iPart].dPcbMax  = 0.0;
                                CData.Parts[m_iPart].dPcbMean = 0.0;
                            }
                            // 2020.09.14 JSKim Ed

                            if (CData.Dev.bDynamicSkip)
                            {//다이나믹 펑션 스킵
                                /// - SECSGEM 사용시 Top 의 AF 값을 BTM 진행 시 DF 대시 사용키 위함 20200301 LCY
                                /// 1. SECSGEM 사용 시 Btm Side 경우 Host에서 top Side 의 Af 값을 Down 
                                /// 2. Strip Top 측정 값 - Host에서 Down 값
                                dTemp = 0.0;
                                if (CData.Opt.bSecsUse)
                                {
                                    if (CData.Dynamic.iHeightType == 0) {   dTemp = CData.Parts[m_iPart].dPcbMax;   _SetLog("SECS/GEM use.  PCB Max : " + dTemp + "mm");    }
                                    else                                {   dTemp = CData.Parts[m_iPart].dPcbMean;  _SetLog("SECS/GEM use.  PCB Mean : " + dTemp + "mm");   }
                                }
                                //210819 pjh : D/F Server Bottom Grinding 진행 시 측정값은 받아온 측정 Data(PCB 두께, 그라인딩 후 측정 두께)를 제외한 높이로 표시
                                else if (CDataOption.UseDFDataServer && CData.Dev.eMoldSide != ESide.Top && !CData.Opt.bSecsUse)
                                {
                                    //220111 pjh : DF Server 사용 시 Top Mold Thickness 저장 변수 변경
                                    if (CData.Dynamic.iHeightType == 0) { dTemp = CData.Parts[m_iPart].dPcbMax + CData.Parts[m_iPart].dTopMoldMax;  _SetLog("D/F Data Server use.  PCB Max : " + dTemp + "mm"); }
                                    else                                { dTemp = CData.Parts[m_iPart].dPcbMean + CData.Parts[m_iPart].dTopMoldAvg; _SetLog("D/F Data Server use.  PCB Mean : " + dTemp + "mm"); }
                                    //
                                }
                                //
                                m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - dTemp;
                            }
                            else //다이나믹 펑션 사용
                            { 
                                if (CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                {//DF 서버 사용시 DF측정 안할 경우 Max값으로 고정
                                    CData.Dynamic.iHeightType = 0;
                                }

                                if (CData.Dynamic.iHeightType == 0) //측정한 PCB 값중 MAX 사용
                                {
                                    if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                                    {//[GL2, GL3]
                                        m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - CData.Parts[m_iPart].dDfMax;
                                        _SetLog("DF Max : " + CData.Parts[m_iPart].dDfMax + "mm");
                                    }
                                    else
                                    {//[GL1]
                                        if (CDataOption.MeasureDf == eDfServerType.MeasureDf)
                                        {//DF 사용시 측정 사용 할경우[GL1]
                                            m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - CData.Parts[m_iPart].dPcbMax;
                                            _SetLog("PCB Max : " + CData.Parts[m_iPart].dPcbMax + "mm");
                                        }
                                        else
                                        {//DF 사용시 측정 사용 안할 경우
                                            m_aInspTemp[m_iRow, m_iCol] = m_PbOfset;
                                        }
                                    }
                                }
                                else
                                {
                                    if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                                    {
                                        m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - CData.Parts[m_iPart].dDfAvg;
                                        _SetLog("DF Avg : " + CData.Parts[m_iPart].dDfAvg + "mm");
                                    }
                                    else
                                    {
                                        m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - CData.Parts[m_iPart].dPcbMean;
                                        _SetLog("PCB Mean : " + CData.Parts[m_iPart].dPcbMean + "mm");
                                    }
                                }
                            }

                            // 센터도 옵셋 적용 가능
                            m_aInspTemp[m_iRow, m_iCol] -= (m_InspOffset - m_InspZeroOffset);
                            _SetLog("Measure value : " + m_aInspTemp[m_iRow, m_iCol] + "mm", true);

                            m_aInspTotalTemp[m_iRow, m_iCol] -= (m_InspOffset - m_InspZeroOffset);              // 2020.09.14 JSKim Add
                            _SetLog("Measure Total value : " + m_aInspTotalTemp[m_iRow, m_iCol] + "mm", true);  // 2020.09.14 JSKim Add

                            double dLimitMax = 0.0;
                            double dLimitMin = 0.0;

                            if (iBfAf == 0) //Before
                            {
                             //자재 높이 범위 검사
                                if (CData.Dev.bDynamicSkip || CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                {//다이나믹 펑션 스킵, DF사용시 DF 측정 안할 경우
                                    dLimitMax = CData.Dev.aData[(int)EWay.L].dTotalTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                                    dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dBfLimit;
                                    if (CData.CurCompany == ECompany.SkyWorks ) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                                    {
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dBfLimitLower;
                                    }

                                    //220111 pjh : D/F Server를 사용한 Bottom Grinding 시 Mold 기준으로 Data 비교
                                    if (CDataOption.UseDFDataServer && !CData.Opt.bSecsUse && 
                                        CData.Dev.eMoldSide == ESide.Btm && CSQ_Main.It.m_iStat != EStatus.Manual)
                                    {
                                        dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dBfLimit;
                                    }
                                    //

                                    //220321 pjh : ASE KH Bottom Grinding 시 Mold 설정값 기준으로 Error 발생하도록 변경
                                    if(CData.CurCompany == ECompany.ASE_K12 && CData.Opt.bSecsUse &&
                                       CData.Dev.eMoldSide == ESide.Btm     && CSQ_Main.It.m_iStat != EStatus.Manual)
                                    {
                                        dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dBfLimit;
                                    }    
                                    
#if false //201014 jhc : ASE-Kr TOP 그라인딩 결과 두께 > SECS/GEM > BTM 그라인딩 (일단 적용 보류 : 본 건의 파급효과 파악 안 된 상태, ASE-Kr은 Cyl_MeaStrip_T1() 만 사용하므로)
                                    //ASE-Kr Bottom Mold 기준 그라인딩 시 옵션
                                    if ((CData.CurCompany == ECompany.ASE_KR) &&                            //ASE-Kr
                                        (CData.Dev.bDynamicSkip) &&                                         //DF기능 비활성(ASE-Kr)
                                        ((CDataOption.SecsUse == eSecsGem.Use) && CData.Opt.bSecsUse) &&    //SECS/GEM 사용(TOP 두께 수신)
                                        (CData.Dev.eMoldSide == ESide.Btm) &&                         //BTM 그라인딩
                                        (CSQ_Main.It.m_iStat != EStatus.Manual))                            //AUTO-RUNNING
                                    {
                                        dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dBfLimit;
                                    }
#endif
                                }
                                else //다이나믹 펑션 사용
                                {
                                    dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                                    dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dBfLimit;
                                    if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                                    {
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dBfLimitLower;
                                    }
                                }

                                // jhLee, Multi-LOT의 경우 SPC 기록
                                if (CData.IsMultiLOT()) {   m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dBfLimit.ToString(); }
                                else                    {   CData.SpcData.sTargetLim        = CData.Dev.aData[(int)EWay.L].dBfLimit.ToString(); }

                                if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                {
                                    if (CData.Dev.bDynamicSkip || CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                    {//다이나믹 펑션 스킵, DF 사용시 DF 측정 안할 경우
                                        dLimitMax = CData.Dev.aData[m_iWy].dTotalTh + CData.Dev.aData[m_iWy].dBfLimit;
                                        dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dBfLimit;

                                        if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                                        {
                                            dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dBfLimitLower;
                                        }

                                        //220111 pjh : D/F Server를 사용한 Bottom Grinding 시 Mold 기준으로 Data 비교
                                        if (CDataOption.UseDFDataServer && !CData.Opt.bSecsUse &&
                                            CData.Dev.eMoldSide == ESide.Btm && CSQ_Main.It.m_iStat != EStatus.Manual)
                                        {
                                            dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dBfLimit;
                                            dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dBfLimit;
                                        }
                                        //

                                        //220321 pjh : ASE KH Bottom Grinding 시 Mold 설정값 기준으로 Error 발생하도록 변경
                                        if (CData.CurCompany == ECompany.ASE_K12 && CData.Opt.bSecsUse &&
                                           CData.Dev.eMoldSide == ESide.Btm && CSQ_Main.It.m_iStat != EStatus.Manual)
                                        {
                                            dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dBfLimit;
                                            dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dBfLimit;
                                        }
#if false //201014 jhc : ASE-Kr TOP 그라인딩 결과 두께 > SECS/GEM > BTM 그라인딩 (일단 적용 보류 : 본 건의 파급효과 파악 안 된 상태, ASE-Kr은 Cyl_MeaStrip_T1() 만 사용하므로)
                                    //ASE-Kr Bottom Mold 기준 그라인딩 시 옵션
                                    if ((CData.CurCompany == ECompany.ASE_KR) &&                            //ASE-Kr
                                        (CData.Dev.bDynamicSkip) &&                                         //DF기능 비활성(ASE-Kr)
                                        ((CDataOption.SecsUse == eSecsGem.Use) && CData.Opt.bSecsUse) &&    //SECS/GEM 사용(TOP 두께 수신)
                                        (CData.Dev.eMoldSide == ESide.Btm) &&                         //BTM 그라인딩
                                        (CSQ_Main.It.m_iStat != EStatus.Manual))                            //AUTO-RUNNING
                                        {
                                            dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dBfLimit;
                                            dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dBfLimit;
                                        }
#endif
                                    }
                                    else //다이나믹 펑션 사용
                                    {
                                        dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dBfLimit;
                                        dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dBfLimit;

                                        if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                                        {
                                            dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dBfLimitLower;
                                        }
                                    }

                                    // jhLee, Multi-LOT의 경우 SPC 기록
                                    if (CData.IsMultiLOT()) {   m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[m_iWy].dBfLimit.ToString();   }
                                    else                    {   CData.SpcData.sTargetLim        = CData.Dev.aData[m_iWy].dBfLimit.ToString();   }
                                }

                                _SetLog(string.Format("Before.  Limit min : {0}mm  Limit max : {1}mm", dLimitMin, dLimitMax));

                                if (m_eWy == EWay.L) // Before, Left
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dBfLimit != 0)
									{
										if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
										{//범위 벗어 났을 경우 에러 발생
											m_abMeaBfErr[m_iRow, m_iCol] = true;
											m_bMeaErrBf_L = true;
											_SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
										}
									}
								}
                                else    // Before, Right
                                {
                                    if (CData.Dev.bDual == eDual.Normal)
									{
										if (CData.Dev.aData[(int)EWay.L].dBfLimit != 0)
										{
											if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
											{//범위 벗어 났을 경우 에러 발생
												m_abMeaBfErr[m_iRow, m_iCol] = true;
												m_bMeaErrBf_R = true;
												_SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
											}
										}
									}
									else // Dual (Before, Right)
									{
										if (CData.Dev.aData[m_iWy].dBfLimit != 0)
										{
											if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
											{//범위 벗어 났을 경우 에러 발생
												m_abMeaBfErr[m_iRow, m_iCol] = true;
												m_bMeaErrBf_R = true;
												_SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
											}
										}
									}
								}

								CData.GrData[m_iWy].aMeaBf[m_iRow, m_iCol] = m_aInspTemp[m_iRow, m_iCol];
                            }  /// end } if (iBfAf == 0) : before
                            else // After
                            {
                                //자재 높이 범위 검사
                                // 2020.09.14 JSKim St - MeasureMode인 경우에는 Bf 랑 동일하게 검사해야 한다. 아니면 AfLimit 설정을 0으로 하던지
                                if (CData.Dev.bMeasureMode)  // lhs, 일단 2004U는 MeasureMode 사용안함.
                                {
                                    //자재 높이 범위 검사
                                    if (CData.Dev.bDynamicSkip || CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                    {//다이나믹 펑션 스킵, DF사용시 DF 측정 안할 경우
                                        dLimitMax = CData.Dev.aData[(int)EWay.L].dTotalTh + CData.Dev.aData[(int)EWay.L].dAfLimit;
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dAfLimit;

                                        //220111 pjh : D/F Server를 사용한 Bottom Grinding 시 Mold 기준으로 Data 비교
                                        if (CDataOption.UseDFDataServer && !CData.Opt.bSecsUse &&
                                            CData.Dev.eMoldSide == ESide.Btm && CSQ_Main.It.m_iStat != EStatus.Manual)
                                        {
                                            dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dAfLimit;
                                            dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dAfLimit;
                                        }
                                        //

                                        //220321 pjh : ASE KH Bottom Grinding 시 Mold 설정값 기준으로 Error 발생하도록 변경
                                        if (CData.CurCompany == ECompany.ASE_K12 && CData.Opt.bSecsUse &&
                                           CData.Dev.eMoldSide == ESide.Btm && CSQ_Main.It.m_iStat != EStatus.Manual)
                                        {
                                            dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dAfLimit;
                                            dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dAfLimit;
                                        }
                                    }
                                    else
                                    {//다이나믹 펑션 사용
                                        dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dAfLimit;
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dAfLimit;
                                    }

                                    // jhLee, Multi-LOT의 경우 SPC 기록
                                    if (CData.IsMultiLOT()) {   m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString(); }
                                    else                    {   CData.SpcData.sTargetLim        = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString(); }

                                    if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                    {
                                        if (CData.Dev.bDynamicSkip || CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                        {//다이나믹 펑션 스킵, DF 사용시 DF 측정 안할 경우
                                            dLimitMax = CData.Dev.aData[m_iWy].dTotalTh + CData.Dev.aData[m_iWy].dAfLimit;
                                            dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dAfLimit;

                                            //220111 pjh : D/F Server를 사용한 Bottom Grinding 시 Mold 기준으로 Data 비교
                                            if (CDataOption.UseDFDataServer && !CData.Opt.bSecsUse &&
                                                CData.Dev.eMoldSide == ESide.Btm && CSQ_Main.It.m_iStat != EStatus.Manual)
                                            {
                                                dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dAfLimit;
                                                dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dAfLimit;
                                            }
                                            //

                                            //220321 pjh : ASE KH Bottom Grinding 시 Mold 설정값 기준으로 Error 발생하도록 변경
                                            if (CData.CurCompany == ECompany.ASE_K12 && CData.Opt.bSecsUse &&
                                               CData.Dev.eMoldSide == ESide.Btm && CSQ_Main.It.m_iStat != EStatus.Manual)
                                            {
                                                dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dAfLimit;
                                                dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dAfLimit;
                                            }
                                        }
                                        else
                                        {//다이나믹 펑션 사용
                                            dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dAfLimit;
                                            dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dAfLimit;
                                        }

                                        // jhLee, Multi-LOT의 경우 SPC 기록
                                        if (CData.IsMultiLOT()) {   m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();   }
                                        else                    {   CData.SpcData.sTargetLim        = CData.Dev.aData[m_iWy].dAfLimit.ToString();   }  
                                    }

                                    _SetLog(string.Format("After MeasureMode.  Limit min : {0}mm  Limit max : {1}mm", dLimitMin, dLimitMax));

                                    if (m_eWy == EWay.L)    // After, Left
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                        {
                                            if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                            {//범위 벗어 났을 경우 에러 발생
                                                m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                m_bMeaErrAf_L = true;
                                                _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                            }
                                        }
                                    }
                                    else    // After, Right
                                    {
                                        if (CData.Dev.bDual == eDual.Normal)
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                                {//범위 벗어 났을 경우 에러 발생
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErrAf_R = true;
                                                    _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                                }
                                            }
                                        }
                                        else
                                        {
                                            if (CData.Dev.aData[m_iWy].dAfLimit != 0)
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                                {//범위 벗어 났을 경우 에러 발생
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErrAf_R = true;
                                                    _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                                }
                                            }
                                        }
                                    }
                                }
                                else   // if (CData.Dev.bMeasureMode)의 else
                                {
                                // 2020.09.14 JSKim Ed
                                    double dTarget = 0.0;
                                    for (int i = m_iStepMaxCnt - 1; i >= 0; i--)        // 2020.09.08 SungTae : modify
                                    {
                                        if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                        {
                                            if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                            {
                                                dTarget = CData.GrData[m_iWy].aTar[i];
                                                _SetLog(string.Format("Dual.  Target : {0}mm  Col : {1}  Row : {2}", dTarget, m_iCol, m_iRow));
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                            {
                                                if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown && (m_eWy == EWay.R))
                                                {
                                                    dTarget = CData.GrData[(int)EWay.R].aTar[i];
                                                    _SetLog(string.Format("Topdown.  Target : {0}mm  Col : {1}  Row : {2}", dTarget, m_iCol, m_iRow));
                                                    break;
                                                }
                                                else
                                                {
                                                    dTarget = CData.GrData[m_iWy].aTar[i];
                                                    _SetLog(string.Format("Target : {0}mm  Col : {1}  Row : {2}", dTarget, m_iCol, m_iRow));
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                    dLimitMax = dTarget + CData.Dev.aData[(int)EWay.L].dAfLimit;
                                    dLimitMin = dTarget - CData.Dev.aData[(int)EWay.L].dAfLimit;

                                    // jhLee, Multi-LOT의 경우 SPC 기록
                                    if (CData.IsMultiLOT())
                                    {
                                        m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();

                                        if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                        {
                                            dLimitMax = dTarget + CData.Dev.aData[m_iWy].dAfLimit;
                                            dLimitMin = dTarget - CData.Dev.aData[m_iWy].dAfLimit;

                                            m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();
                                        }
                                    }
                                    else
                                    {
                                        CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();

                                        if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                        {
                                            dLimitMax = dTarget + CData.Dev.aData[m_iWy].dAfLimit;
                                            dLimitMin = dTarget - CData.Dev.aData[m_iWy].dAfLimit;

                                            CData.SpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();
                                        }
                                    }

                                    _SetLog(string.Format("After.  Limit min : {0}mm  Limit max : {1}mm", dLimitMin, dLimitMax));

                                    if (m_eWy == EWay.L)    // After, Left
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
										{
											if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
											{//범위 벗어 났을 경우 에러 발생
												m_abMeaAfErr[m_iRow, m_iCol] = true;
												m_bMeaErrAf_L = true;
												_SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
											}
										}
									}
                                    else    // After, Right
                                    {
                                        if (CData.Dev.bDual == eDual.Normal)    // After, Right, Normal
										{
											if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
											{
												if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
												{//범위 벗어 났을 경우 에러 발생
													m_abMeaAfErr[m_iRow, m_iCol] = true;
													m_bMeaErrAf_R = true;
													_SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
												}
											}
										}
										else                                    // After, Right, Dual
										{
											if (CData.Dev.aData[m_iWy].dAfLimit != 0)
											{
												if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
												{//범위 벗어 났을 경우 에러 발생
													m_abMeaAfErr[m_iRow, m_iCol] = true;
													m_bMeaErrAf_R = true;
													_SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
												}
											}
										}
									}
									// 2020.09.14 JSKim St
								}  /// if(measuremode)의 else end }
                                // 2020.09.14 JSKim Ed

                                CData.GrData[m_iWy].aMeaAf[m_iRow, m_iCol] = m_aInspTemp[m_iRow, m_iCol];
                                _SetLog("Measure value : " + m_aInspTemp[m_iRow, m_iCol] + "mm", true);
                            }  // end after

                            //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(true);
                            }
                            Func_PrbDown(false);
                            m_Delay.Set_Delay(GV.PRB_DELAY);

                            //211028 syc : Qorvo Probe Up Time Check
                            if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ)
                            {
                                sStopwatch.Restart(); //211028 syc : Qorvo Probe Up Time Check
                                m_bPrbUptimeChk = true;
                            }
                            // syc end

                            _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

                            if (iBfAf == 0)
                            {
                                Array.Copy(m_aInspTemp,         m_aInspBf,         m_aInspTemp.Length);
                                Array.Copy(m_aInspTotalTemp,    m_aInspTotalBf,    m_aInspTemp.Length);     // 2020.09.14 JSKim Add
                            }
                            else
                            {
                                Array.Copy(m_aInspTemp,         m_aInspAf,          m_aInspTemp.Length);
                                Array.Copy(m_aInspTotalTemp,    m_aInspTotalAf,     m_aInspTemp.Length);    // 2020.09.14 JSKim Add
                            }
                            m_iRow++;

                            m_iStep = 33;  // Row 반복 Step

                        } /// end : if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())

                        return false;
                    }

                case 38: //프로브 x축 포지션 0으로 이동
                    {
                        //211229 pjh : Probe Up Check					
                        if(!CIO.It.Get_X(m_eIn1) && !m_Delay.Chk_Delay())
                        { return false; }

                        //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(false);
                        }
                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                        _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                        if (CSpc.It.ChkOpenSaveDataCsv(m_eWy))
                        {
                            m_Delay.Set_Delay(1000);
                            _SetLog("Set delay : 1000ms");
                        }
                        else
                        {
                            m_Delay.Set_Delay(0);
                            _SetLog("Set delay : 0ms");
                        }

                        if ((CData.Opt.bSecsUse == true) && (CData.GemForm != null))
                        {
                            // 2021.07.19 SungTae Start : [수정] Data Shift 시 확인이 용이하도록 수정
                            if (iBfAf == 0) // Before Measure
                            {
                                if (m_eWy == EWay.L)    { CData.GemForm.Strip_Data_Shift((int)EDataShift.GRL_TBL_CHUCK/*6*/,  (int)EDataShift.GRL_BF_MEAS/*7*/);  }    // L Chuck Data -> Befor Data 로 이동
                                else                    { CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_TBL_CHUCK/*12*/, (int)EDataShift.GRR_BF_MEAS/*13*/); }    // R Chuck Data -> R Befor Data 로 이동
                            }
                            else // After Measure
                            {
                                if (m_eWy == EWay.L)    { CData.GemForm.Strip_Data_Shift((int)EDataShift.GRL_BF_MEAS/*7*/,     (int)EDataShift.GRL_AF_MEAS/*10*/); }   // L Before Data -> L After Data 로 이동
                                else                    
                                {   if (CData.Dev.bDShiftPSkip)                                    
                                    {
                                        CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_TBL_CHUCK/*12*/, (int)EDataShift.GRR_BF_MEAS/*13*/); // R Chuck Data -> R Befor Data 로 이동
                                    }
                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_BF_MEAS/*13*/, (int)EDataShift.GRR_AF_MEAS/*16*/);       // R Befor Data -> R After Data 로 이동
                                }
                            }
                            // 2021.07.19 SungTae End
                        }

                        m_iStep++;
                        return false;
                    }

                case 39: // 체크 딜레이
                    {
                        if (!m_Delay.Chk_Delay())
                        { return false; }
                        _SetLog("Check delay.");

                        m_iStep++;
                        return false;
                    }

                case 40: //Temp 측정 값 Before or After에 복사, m_iCol = 0, m_iRow = 0, m_iStep = 0;
                    {
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        if (iBfAf == 0)
                        {
                            Array.Copy(m_aInspTemp,         m_aInspBf,      m_aInspTemp.Length);
                            Array.Copy(m_aInspTotalTemp,    m_aInspTotalBf, m_aInspTemp.Length);     // 2020.09.14 JSKim Add
                            CSpc.It.SaveDataCsv(m_eWy, "BEFORE", m_aInspBf, CData.Parts[m_iPart].dPcb);
                            if (CData.LotInfo.bLotOpen && CSQ_Main.It.m_iStat != EStatus.Manual) //191115 ksg :
                            {
                                SetMyLotInfo();     // 내부 사용 LotInfo  대입

                                // 2020.09.14 JSKim St
                                //CSpc.It.SaveLotDataCsv(m_eWy, "BEFORE", m_aInspBf, CData.Parts[m_iPart].dPcb);
                                if (CData.CurCompany == ECompany.SCK || CData.CurCompany == ECompany.JSCK)
                                {
                                    CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "BEFORE", m_aInspBf, CData.Parts[m_iPart].dPcb, m_aInspTotalBf);
                                }
                                else
                                {
                                    CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "BEFORE", m_aInspBf, CData.Parts[m_iPart].dPcb);
                                }
                                // 2020.09.14 JSKim Ed
                            }

                            // 200722 jym : min max avg 계산
                            double dMax   = 0;
                            double dMin   = 0;
                            double dAvg   = 0;

                            _Cal_MMA(m_aInspBf, out dMin, out dMax, out dAvg);

                            CData.PbResultVal[m_iWy].dBMax = dMax;
                            CData.PbResultVal[m_iWy].dBMin = dMin;
                            CData.PbResultVal[m_iWy].dBAvg = dAvg;

                            SetMyLotInfo();     // 내부 사용 LotInfo  대입

                            //2020.12.09 lhs Start  
                            // Error Strip 도 저장 (Skyworks VOC)
                            if (CData.CurCompany == ECompany.SkyWorks)
                            {
                                if (CData.LotInfo.bLotOpen)
                                {
                                    if (m_bMeaErrBf_L || m_bMeaErrBf_R)
                                    {
                                        string sTemp = (iBfAf == 0) ? "BEFORE_ERROR" : "AFTER_ERROR";
                                        CSpc.It.SaveDataIni(ref m_myLotInfo, m_eWy, sTemp, m_aInspTemp);  // Error Strip 
                                    }
                                }
                            }
                            //2020.12.09 lhs End

                            if (m_eWy == EWay.L)
                            {
                                if (m_bMeaErrBf_L)
                                {
                                    CErr.Show(eErr.LEFT_GRIND_RANGEOVER_WHEN_BEFORE_MEASURE_STRIP);
                                    _SetLog("Error : Range over when before measure strip.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (m_bMeaErrBf_R)
                                {
                                    CErr.Show(eErr.RIGHT_GRIND_RANGEOVER_WHEN_BEFORE_MEASURE_STRIP);
                                    _SetLog("Error : Range over when before measure strip.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }
                        else  // After
                        {                            
                            Array.Copy(m_aInspTemp, m_aInspAf, m_aInspTemp.Length);
                            Array.Copy(m_aInspTotalTemp, m_aInspTotalAf, m_aInspTemp.Length);   // 2020.09.14 JSKim Add
                            //190528 ksg :
                            if (m_eWy == EWay.L)
                            {
                                Array.Copy(m_aInspTemp, m_aInspShift, m_aInspTemp.Length); //190528 ksg :
                            }

                            CSpc.It.SaveDataCsv(m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb);
                            if (CData.LotInfo.bLotOpen && CSQ_Main.It.m_iStat != EStatus.Manual) //191115 ksg :
                            {
                                // 2020.09.14 JSKim St
                                //CSpc.It.SaveLotDataCsv(m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb);
                                if (CData.CurCompany == ECompany.SCK || CData.CurCompany == ECompany.JSCK)
                                {
                                    CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb, m_aInspTotalAf);
                                }
                                else
                                {
                                    CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb);
                                }
                                // 2020.09.14 JSKim Ed
                            }

                            // 200722 jym : min max avg 계산
                            double dMax   = 0;
                            double dMin   = 0;
                            double dAvg   = 0;

                            _Cal_MMA(m_aInspAf, out dMin, out dMax, out dAvg);

                            CData.PbResultVal[m_iWy].dAMax = dMax;
                            CData.PbResultVal[m_iWy].dAMin = dMin;
                            CData.PbResultVal[m_iWy].dAAvg = dAvg;

                            //2020.12.09 lhs Start  
                            // Error Strip 도 저장 (Skyworks VOC)
                            if (CData.CurCompany == ECompany.SkyWorks)
                            {
                                if (CData.LotInfo.bLotOpen)
                                {
                                    if (m_bMeaErrAf_L || m_bMeaErrAf_R)
                                    {
                                        string sTemp = (iBfAf == 0) ? "BEFORE_ERROR" : "AFTER_ERROR";
                                        CSpc.It.SaveDataIni(ref m_myLotInfo, m_eWy, sTemp, m_aInspTemp);  // Error Strip 
                                    }
                                }
                            }
                            //2020.12.09 lhs End

                            if (m_eWy == EWay.L)
                            {
                                if (m_bMeaErrAf_L)
                                {
                                    CErr.Show(eErr.LEFT_GRIND_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                    _SetLog("Error : Range over when after measure strip.");

                                    // 201008 jym : After range over 에러 시 이어서 동작하기 위해 에러 처리 안함
                                    //m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (m_bMeaErrAf_R)
                                {
                                    CErr.Show(eErr.RIGHT_GRIND_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                    _SetLog("Error : Range over when after measure strip.");

                                    // 201008 jym : After range over 에러 시 이어서 동작하기 위해 에러 처리 안함
                                    //m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        } // End : else // After

                        if (m_eWy == EWay.L && CData.Dev.bDual == eDual.Dual && iBfAf == 1) {   m_iStep = 45;   return false;   }
                        if (m_eWy == EWay.R && CData.Dev.bDual == eDual.Dual && iBfAf == 0) {   m_iStep = 45;   return false;   }

                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            m_iCol = 0;
                            m_iRow = 0;
                            m_sRowData = "";
                            _SetLog("DF Server.");

                            m_iStep++;
                        }
                        else
                        {
                            _SetLog("DF Server not use.");
                            m_iStep = 45;
                        }
                        return false;
                    }

                case 41:  // DF Server
                    {
                        if (m_eWy == EWay.L)    {   CData.GRLDfData.sRow = "R" + m_iRow.ToString("D2"); }
                        else                    {   CData.GRRDfData.sRow = "R" + m_iRow.ToString("D2"); }

                        if (iBfAf == 0)
                        {
                            if (m_iRow < m_aInspBf.GetLength(0))
                            {
                                if (m_iCol < m_aInspBf.GetLength(1))
                                {
                                    if (m_aInspBf[m_iRow, m_iCol] == 0)         {   m_sRowData += ".";                          }
                                    else                                        {   m_sRowData += m_aInspBf[m_iRow, m_iCol];    }

                                    if (m_iCol < (m_aInspBf.GetLength(1) - 1))  {   m_sRowData += ",";                          }
                                    m_iCol++;
                                }
                                else
                                { m_iStep++; }
                                return false;
                            }
                            else
                            {
                                if (!CData.dfInfo.bBusy)
                                {
                                    CDf.It.SendBfEnd((m_eWy == EWay.L) ? "LGD" : "RGD");
                                    m_iStep = 44;
                                }
                                else
                                { return false; }
                            }
                        }
                        else
                        {
                            if (m_iRow < m_aInspAf.GetLength(0))
                            {
                                if (m_iCol < m_aInspAf.GetLength(1))
                                {
                                    if (m_aInspAf[m_iRow, m_iCol] == 0)         {   m_sRowData += ".";                          }
                                    else                                        {   m_sRowData += m_aInspAf[m_iRow, m_iCol];    }
                                    if (m_iCol < (m_aInspAf.GetLength(1) - 1))  {   m_sRowData += ",";                          }
                                    m_iCol++;
                                }
                                else
                                {
                                    m_iStep++;
                                }
                                return false;
                            }
                            else
                            {
                                if (!CData.dfInfo.bBusy)
                                {
                                    CDf.It.SendAfEnd((m_eWy == EWay.L) ? "LGD" : "RGD");
                                    m_iStep = 44;
                                }
                                else
                                { return false; }
                            }
                        }

                        return false;
                    }

                case 42: // DF Server 
                    {
                        if (!CData.dfInfo.bBusy)
                        {
                            CDf.It.SendGrdRowData((m_eWy == EWay.L) ? "LGD" : "RGD", m_sRowData);
                            m_iStep++;
                        }

                        return false;
                    }

                case 43: // DF Server 
                    {
                        if(m_eWy == EWay.L)
                        {
                            if (CDf.It.ReciveAckGRL((int)ECMD.scRowL))
                            {
                                m_sRowData = "";
                                m_iRow++;
                                m_iCol = 0;
                                m_iStep = 41;
                            }
                        }
                        else
                        {
                            if (CDf.It.ReciveAckGRR((int)ECMD.scRowR))
                            {
                                m_sRowData = "";
                                m_iRow++;
                                m_iCol = 0;
                                m_iStep = 41;
                            }
                        }
                        return false;
                    }

                case 44: // DF Server
                    {
                        if(iBfAf == 0)
                        {
                            if (m_eWy == EWay.L)    {   if (!CDf.It.ReciveAckGRL((int)ECMD.scBfEndL))   { return false; }   }
                            else                    {   if (!CDf.It.ReciveAckGRR((int)ECMD.scBfEndR))   { return false; }   }
                        }
                        else
                        {
                            if (m_eWy == EWay.L)    {   if (!CDf.It.ReciveAckGRL((int)ECMD.scAfEndL))   { return false; }   }
                            else                    {   if (!CDf.It.ReciveAckGRR((int)ECMD.scAfEndR))   { return false; }   }
                        }

                        m_iStep++;
                        return false;
                    }

                case 45: // Max, Min, TTV 체크, OnCarrierGrindFinished, SaveLotData, SaveDataIni
                    { 
                        m_iCol  = 0;
                        m_iRow  = 0;

                        // jhLee, Multi-LOT의 경우에도 SPC 기록
                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        //190319 ksg : Bf / Af Max, Min, Ttv 표시 해야 됨
                        if(iBfAf == 0)  // Before 측정 Data
                        {
                            double dMax   = CData.PbResultVal[m_iWy].dBMax;
                            double dMin   = CData.PbResultVal[m_iWy].dBMin;
                            double dMean  = CData.PbResultVal[m_iWy].dBAvg;
                            int iCnt = 0;

                            for (int iRow = 0; iRow < m_aInspBf.GetLength(0); iRow++)
                            {
                                for (int iCol = 0; iCol < m_aInspBf.GetLength(1); iCol++)
                                {
                                    if (m_aInspBf[iRow, iCol] != 0)
                                    {
                                        CData.m_dPbVal[m_iWy].m_BFVal.Add(m_aInspBf[iRow, iCol]); //191120 ksg :
                                                                                                  //191118 ksg :
                                        if (CData.GemForm != null)
                                        {//Before 측정 Data 
                                            if (m_eWy == EWay.L)    {   CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Data[1, iCnt]  = m_aInspBf[iRow, iCol]; }   // Left 측정 Data
                                            else                    {   CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Data[5, iCnt] = m_aInspBf[iRow, iCol]; }   // Right 측정 Data
                                        }
                                        iCnt++;
                                    }
                                }
                            }

                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)    {   CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].nMeasure_Count[1] = iCnt;     }
                                else                    {   CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].nMeasure_Count[5] = iCnt;    }
                            }

                            if(CData.GemForm != null)
                            {
                                if(m_eWy == EWay.L)
                                {// Left Befor
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Min_Data[1] = dMin ;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Max_Data[1] = dMax ;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Avr_Data[1] = dMean;
                                }
                                else
                                {// Right Befor
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Min_Data[5] = dMin ;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Max_Data[5] = dMax ;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Avr_Data[5] = dMean;
                                }
                            }

                            //20190531 ghk
                            CData.PbResultVal[m_iWy].dBMean = Math.Round(((dMax + dMin) / 2), 4); //190502 ksg :
                            if (m_eWy == EWay.L)
                            {
                                if(CData.Dev.bDynamicSkip)
                                {
                                    if(CData.PbResultVal[m_iWy].dBMax <= CData.MPos[0].dPCBThickness || CData.PbResultVal[m_iWy].dBMin >= 999)
                                    {
                                        CErr.Show(eErr.LEFT_BEFORE_PROBE_DATA_LOST);
                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                                else
                                {
                                    if((CData.PbResultVal[m_iWy].dBMax + CData.Parts[(int)EPart.GRDL].dPcbMax) <= CData.MPos[0].dPCBThickness || (CData.PbResultVal[m_iWy].dBMin + CData.Parts[(int)EPart.GRDL].dPcbMax) >= 999)
                                    {
                                        CErr.Show(eErr.LEFT_BEFORE_PROBE_DATA_LOST);
                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                            }
                            else
                            {
                                if(CData.Dev.bDynamicSkip)
                                {
                                    if(CData.PbResultVal[m_iWy].dBMax <= CData.MPos[0].dPCBThickness || CData.PbResultVal[m_iWy].dBMin >= 999)
                                    {
                                        CErr.Show(eErr.RIGHT_BEFORE_PROBE_DATA_LOST);
                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                                else
                                {
                                    if((CData.PbResultVal[m_iWy].dBMax + CData.Parts[(int)EPart.GRDR].dPcbMax) <= CData.MPos[0].dPCBThickness || (CData.PbResultVal[m_iWy].dBMin + CData.Parts[(int)EPart.GRDL].dPcbMax)>= 999)
                                    {
                                        CErr.Show(eErr.RIGHT_BEFORE_PROBE_DATA_LOST);
                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                            }
                            
                        }

                        if (iBfAf == 1)  //After 측정 Data
                        {
                            double dMax   = CData.PbResultVal[m_iWy].dAMax;
                            double dMin   = CData.PbResultVal[m_iWy].dAMin;
                            double dMean  = CData.PbResultVal[m_iWy].dAAvg;
                            int    iCnt   = 0    ;


                            // 2021-05-17, jhLee, Multi-LOT, 현재 가공중인 Strip의 LOT Name을 사용하도록 한다.
                            if (CData.IsMultiLOT())
                            {
                                // 현재 Strip Data에 지정된 Lot Name으로 LOT Information pointer를 조회한다.
                                if (!CData.LotMgr.GetLotInfoName(CData.Parts[m_iPart].sLotName, ref m_myLotInfo))
                                {
                                    // Lot Info 할당에 실패할 경우 기존에 사용하고 있는 대표 LotInfo를 사용한다.
                                    m_myLotInfo = CData.LotInfo;
                                }

                                // Multi-LOT일 경우 가공중인 Strip의 Lot 이름을 사용한다.
                                CData.SpcData.sLotName = CData.Parts[m_iPart].sLotName;
                            }
                            else
                            {
                                m_myLotInfo = CData.LotInfo;
                                CData.SpcData.sLotName = CData.LotInfo.sLotName;
                            }

                            for(int iRow = 0; iRow < m_aInspAf.GetLength(0); iRow++)
                            {
                                for(int iCol = 0; iCol < m_aInspAf.GetLength(1); iCol++)
                                {
                                    if (m_aInspAf[iRow, iCol] != 0)
                                    {
                                        CData.m_dPbVal[m_iWy].m_AFVal.Add(m_aInspAf[iRow, iCol]); //191120 ksg :

                                        //191118 ksg :
                                        if(CData.GemForm != null)
                                        {
                                            if (m_eWy == EWay.L)    {   CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Data[4, iCnt] = m_aInspAf[iRow, iCol]; }
                                            else                    {   CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Data[6, iCnt] = m_aInspAf[iRow, iCol]; }
                                         }
                                        iCnt++;
                                    }
                                }
                            }
                            if(CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)    {   CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].nMeasure_Count[4] = iCnt;    }
                                else                    {   CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].nMeasure_Count[6] = iCnt;    }
                            }

                            if (m_eWy == EWay.L)
                            {

                                // jhLee, Multi-LOT의 경우 SPC 기록
                                if (CData.IsMultiLOT())
                                {
                                    m_myLotInfo.rSpcData.sTtvLim = CData.Dev.aData[(int)EWay.L].dTTV.ToString();
                                }
                                else
                                {
                                    CData.SpcData.sTtvLim = CData.Dev.aData[(int)EWay.L].dTTV.ToString();
                                }

                                if (CData.Dev.aData[(int)EWay.L].dTTV != 0)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dTTV < (dMax - dMin))
                                    {
                                        //2020.12.09 lhs Start  
                                        // Error Strip 도 저장 (Skyworks VOC)
                                        if (CData.CurCompany == ECompany.SkyWorks)
                                        {
                                            if (CData.LotInfo.bLotOpen)
                                            {
                                                string sTemp = (iBfAf == 0) ? "BEFORE_ERROR" : "AFTER_ERROR";
                                                CSpc.It.SaveDataIni(ref m_myLotInfo, m_eWy, sTemp, m_aInspTemp);  // Error Strip 
                                            }
                                        }
                                        //2020.12.09 lhs End

                                        CErr.Show(eErr.LEFT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                        _SetLog("Error : TTV Range over when after measure strip.");

                                        // 201009 jym : Before 측정 시에만 적용
                                        //m_bSubErr = true;

                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                            } //if (m_eWy == EWay.L)
                            else  // EWay.R
                            {
                                if(CData.Dev.bDual == eDual.Dual)
                                {

                                    // jhLee, Multi-LOT의 경우 SPC 기록
                                    if (CData.IsMultiLOT())
                                    {
                                        m_myLotInfo.rSpcData.sTtvLim = CData.Dev.aData[m_iWy].dTTV.ToString();
                                    }
                                    else
                                    {
                                        CData.SpcData.sTtvLim = CData.Dev.aData[m_iWy].dTTV.ToString();
                                    }

                                    if (CData.Dev.aData[m_iWy].dTTV != 0)
                                    {
                                        if(CData.Dev.aData[m_iWy].dTTV < (dMax - dMin))
                                        {
                                            // 2020.12.09 lhs Start  
                                            // Error Strip 도 저장 (Skyworks VOC)
                                            if (CData.CurCompany == ECompany.SkyWorks)
                                            {
                                                if (CData.LotInfo.bLotOpen)
                                                {
                                                    string sTemp = (iBfAf == 0) ? "BEFORE_ERROR" : "AFTER_ERROR";
                                                    CSpc.It.SaveDataIni(ref m_myLotInfo, m_eWy, sTemp, m_aInspTemp);  // Error Strip 
                                                }
                                            }
                                            // 2020.12.09 lhs End

                                            CErr.Show(eErr.RIGHT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                            _SetLog("Error : TTV Range over when after measure strip.");

                                            // 201009 jym : Before 측정 시에만 적용
                                            //m_bSubErr = true;

                                            m_iStep = 0;
                                            return true;
                                        }
                                    }
                                } // if(CData.Dev.bDual == eDual.Dual)
                                else  // eDual.Normal
                                {
                                    // jhLee, Multi-LOT의 경우 SPC 기록
                                    if (CData.IsMultiLOT())
                                    {
                                        m_myLotInfo.rSpcData.sTtvLim = CData.Dev.aData[(int)EWay.L].dTTV.ToString();
                                    }
                                    else
                                    {
                                        CData.SpcData.sTtvLim = CData.Dev.aData[(int)EWay.L].dTTV.ToString();
                                    }

                                    if (CData.Dev.aData[(int)EWay.L].dTTV != 0)
                                    {
                                        if(CData.Dev.aData[(int)EWay.L].dTTV < (dMax - dMin))
                                        {
                                            // 2020.12.09 lhs Start  
                                            // Error Strip 도 저장 (Skyworks VOC)
                                            if (CData.CurCompany == ECompany.SkyWorks)
                                            {
                                                if (CData.LotInfo.bLotOpen)
                                                {
                                                    string sTemp = (iBfAf == 0) ? "BEFORE_ERROR" : "AFTER_ERROR";
                                                    CSpc.It.SaveDataIni(ref m_myLotInfo, m_eWy, sTemp, m_aInspTemp);  // Error Strip 
                                                }
                                            }
                                            // 2020.12.09 lhs End

                                            CErr.Show(eErr.RIGHT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                            _SetLog("Error : TTV Range over when after measure strip.");

                                            // 201009 jym : Before 측정 시에만 적용
                                            //m_bSubErr = true;

                                            m_iStep = 0;
                                            return true;
                                        }
                                    }
                                } // end : eDual.Normal
                            } // end : EWay.L

                            if (CData.GemForm != null)
                            {
                                //dTemp = (CData.Dev.eMoldSide == ESide.Top) ? CData.Parts[(int)EPart.GRDL].dPcbMean : 0.0;   // 2020.09.11 JSKim Del
                                if (m_eWy == EWay.L)
                                {   // SECSGEM Host에 Data Upload 진행  20200301 LCY 
                                    // Top Side : Mold_높이 + DF 측정 Data
                                    // Bottom Side : Mold 높이
                                    if  (CData.Dev.eMoldSide == ESide.Top)  dTemp = CData.Parts[(int)EPart.GRDL].dPcbMean;
                                    else                                    dTemp = 0.0;

                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Min_Data[4] = dMin + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Max_Data[4] = dMax + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Avr_Data[4] = dMean + dTemp;
                                    
                                    _SetLog("Func Call : CData.GemForm.OnCarrierGrindFinished(1)");

                                    // 2021.10.19 SungTae Start : [수정] (ASE-KR VOC) SECS/GEM Issue 관련 조건 추가
                                    //CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N1);
                                    if (!CData.bChkGrdM)
                                    {
                                        CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N1);
                                    }
                                    // 2021.10.19 SungTae End
                                }
                                else
                                {   // SECSGEM Host에 Data Upload 진행  20200301 LCY
                                    // Top Side : Mold_높이 + DF 측정 Data
                                    // Bottom Side : Mold 높이
                                    if  (CData.Dev.eMoldSide == ESide.Top)  dTemp = CData.Parts[(int)EPart.GRDR].dPcbMean;
                                    else                                    dTemp = 0.0;

                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Min_Data[6] = dMin + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Max_Data[6] = dMax + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Avr_Data[6] = dMean + dTemp;
                                    
                                    _SetLog("Func Call : CData.GemForm.OnCarrierGrindFinished(2)");

                                    // 2021.10.19 SungTae Start : [수정] (ASE-KR VOC) SECS/GEM Issue 관련 조건 추가
                                    //CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N2);
                                    if (!CData.bChkGrdM)
                                    {
                                        CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N2);
                                    }
                                    // 2021.10.19 SungTae End
                                }
                            }

                            // 2021.05.30 SungTae Start : [추가]
                            //if (CData.CurCompany == ECompany.Qorvo_NC && CData.Dev.eMoldSide == ESide.Top)
                            if (CDataOption.UseDFDataServer && CData.Dev.eMoldSide == ESide.Top && !CData.Opt.bSecsUse)//210818 pjh : D/F Data server 기능 License로 구분
                            {
                                if (m_eWy == EWay.L)
                                {
                                    CData.SaveDFServerData(m_eWy, (int)CData.Dev.eMoldSide, EPart.GRDL);
                                    _SetLog(">>>>> [DFSERVER] : Normal Mode. CData.SaveDFServerData((int)EWay.L, (int)CData.Dev.bTopMoldSide, (int)EPart.GRDL)");
                                }
                                else
                                {
                                    if (CData.Dev.bDual == eDual.Dual)
                                    {
                                        if (m_eWy == EWay.L)
                                        {
                                            CData.SaveDFServerData(m_eWy, (int)CData.Dev.eMoldSide, EPart.GRDL);
                                            _SetLog(">>>>> [DFSERVER] : Dual Mode. CData.SaveDFServerData((int)EWay.L, (int)CData.Dev.bTopMoldSide, (int)EPart.GRDL)");
                                        }
                                        else
                                        {
                                            CData.SaveDFServerData(m_eWy, (int)CData.Dev.eMoldSide, EPart.GRDR);
                                            _SetLog(">>>>> [DFSERVER] : Dual Mode. CData.SaveDFServerData((int)EWay.R, (int)CData.Dev.bTopMoldSide, (int)EPart.GRDR)");
                                        }
                                    }
                                    else
                                    {
                                        CData.SaveDFServerData(m_eWy, (int)CData.Dev.eMoldSide, EPart.GRDR);
                                        _SetLog(">>>>> [DFSERVER] : Normal Mode(R). CData.SaveDFServerData((int)EWay.R, (int)CData.Dev.bTopMoldSide, (int)EPart.GRDR)");
                                    }
                                }
                            }
                            // 2021.05.30 SungTae End

                            if (CData.PbResultVal[m_iWy].dBMax <= 0 || CData.PbResultVal[m_iWy].dBMin >= 999)
                            {
                                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_BEFORE_PROBE_DATA_LOST :
                                                              eErr.RIGHT_BEFORE_PROBE_DATA_LOST);
                                _SetLog("Error : Before probe data lost.");

                                //201010 jhc : Before 측정 시에만 적용
                                //m_bSubErr = true;

                                m_iStep = 0;
                                return true;
                            }

                            if (CData.LotInfo.bLotOpen)
                            {
                                // jhLee, Multi-LOT의 경우 SPC 기록
                                if (CData.IsMultiLOT())
                                {
                                    m_myLotInfo.rSpcData.sMgzNo  = CData.Parts[m_iPart].iMGZ_No.ToString();
                                    m_myLotInfo.rSpcData.sSlotNo = CData.Parts[m_iPart].iSlot_No.ToString();
                                    m_myLotInfo.rSpcData.sTable  = (m_eWy == EWay.L) ? "L" : "R";
                                    m_myLotInfo.rSpcData.sBcr    = CData.Parts[m_iPart].sBcr;
                                    m_myLotInfo.rSpcData.sMode   = (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown) ? "TopDown" : "Target";

                                    if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                    {
                                        CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_AfterMeaStrip : ESeq.GRR_AfterMeaStrip;
                                    }

                                    m_myLotInfo.rSpcData.sMax   = dMax.ToString();
                                    m_myLotInfo.rSpcData.sMin   = dMin.ToString();
                                    m_myLotInfo.rSpcData.sMean  = dMean.ToString();
                                    m_myLotInfo.rSpcData.sTtv   = (dMax - dMin).ToString();
                                    m_myLotInfo.rSpcData.sBMax  = CData.PbResultVal[m_iWy].dBMax.ToString();
                                    m_myLotInfo.rSpcData.sBMin  = CData.PbResultVal[m_iWy].dBMin.ToString();
                                    m_myLotInfo.rSpcData.sBAvg  = CData.PbResultVal[m_iWy].dBAvg.ToString();

                                    //for(int i = GV.StepMaxCnt - 1; i >= 0; i--)
                                    for (int i = m_iStepMaxCnt - 1; i >= 0; i--)        // 2020.09.08 SungTae : modify
                                    {
                                        if (CData.Dev.bDual == eDual.Dual)
                                        {
                                            if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                            {
                                                m_myLotInfo.rSpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                m_myLotInfo.rSpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                            {
                                                if (CData.Dev.aData[(int)EWay.L].eGrdMod == eGrdMode.TopDown)
                                                {
                                                    m_myLotInfo.rSpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                    m_myLotInfo.rSpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                }
                                                else
                                                {
                                                    m_myLotInfo.rSpcData.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                    m_myLotInfo.rSpcInfo.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                }
                                                break;
                                            }
                                        }
                                    }

                                    // 2021-12-06, jhLee : SPC 기록시 빈칸 기록 수정
                                    if (CData.CurCompany == ECompany.ASE_KR)    {   CSpc.It.SaveLotData_Add(ref m_myLotInfo);   }
                                    else                                        {   CSpc.It.SaveLotData(m_myLotInfo);           }                                  

                                } // if (CData.IsMultiLOT())

                                else  // if (CData.IsMultiLOT())의 else
                                {
                                    CData.SpcData.sMgzNo    = CData.Parts[m_iPart].iMGZ_No.ToString();
                                    CData.SpcData.sSlotNo   = CData.Parts[m_iPart].iSlot_No.ToString();
                                    CData.SpcData.sTable    = (m_eWy == EWay.L) ? "L" : "R";
                                    CData.SpcData.sBcr      = CData.Parts[m_iPart].sBcr;
                                    CData.SpcData.sMode     = (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown) ? "TopDown" : "Target";

                                    if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                    {
                                        CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_AfterMeaStrip : ESeq.GRR_AfterMeaStrip;
                                    }
                                    
                                    CData.SpcData.sMax  = dMax.ToString();
                                    CData.SpcData.sMin  = dMin.ToString();
                                    CData.SpcData.sMean = dMean.ToString();
                                    CData.SpcData.sTtv  = (dMax - dMin).ToString();
                                    CData.SpcData.sBMax = CData.PbResultVal[m_iWy].dBMax.ToString();
                                    CData.SpcData.sBMin = CData.PbResultVal[m_iWy].dBMin.ToString();
                                    CData.SpcData.sBAvg = CData.PbResultVal[m_iWy].dBAvg.ToString();

                                    //for(int i = GV.StepMaxCnt - 1; i >= 0; i--)
                                    for (int i = m_iStepMaxCnt - 1; i >= 0; i--)        // 2020.09.08 SungTae : modify
                                    {
                                        if (CData.Dev.bDual == eDual.Dual)
                                        {
                                            if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                            {
                                                CData.SpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                CData.SpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                            {
                                                if (CData.Dev.aData[(int)EWay.L].eGrdMod == eGrdMode.TopDown)
                                                {
                                                    CData.SpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                    CData.SpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                }
                                                else
                                                {
                                                    CData.SpcData.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                    CData.SpcInfo.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                }
                                                break;
                                            }
                                        }
                                    }

                                    if (CData.CurCompany == ECompany.ASE_KR)    { CSpc.It.SaveLotData_Add();    }
                                    else                                        { CSpc.It.SaveLotData();        }
                                }


                                //190529 ksg :
                                if (m_eWy == EWay.L && CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown)
                                {
                                    if (CData.IsMultiLOT())
                                    {
                                        double.TryParse(m_myLotInfo.rSpcInfo.sTarget, out CData.Parts[(int)EPart.GRDL].dShiftT);
                                    }
                                    else
                                    {
                                        double.TryParse(CData.SpcInfo.sTarget, out CData.Parts[(int)EPart.GRDL].dShiftT);
                                    }

                                    //old CData.Parts[(int)EPart.GRDL].dShiftT = Convert.ToDouble(CData.SpcInfo.sTarget);
                                }

                                //200325 ksg : Data Shift Probe Skip
                                if (m_eWy == EWay.L && CData.Dev.bDShiftPSkip && CData.Dev.bDual == eDual.Dual)
                                {
                                    CData.Parts[(int)EPart.GRDL].dShiftT = dMax;
                                }
                            }
                        }

                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        if (CData.LotInfo.bLotOpen)
                        {
                            string sTemp = (iBfAf == 0) ? "BEFORE" : "AFTER";
                            CSpc.It.SaveDataIni(ref m_myLotInfo, m_eWy, sTemp, m_aInspTemp);

                            if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                            {
                                CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_AfterMeaStrip : ESeq.GRR_AfterMeaStrip;
                            }
                        }

                        _SetLog("Finish.  Status : " + CData.Parts[m_iPart].iStat);

                        m_iStep = 0;
                        return true;
                    }

                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스
                case 100: //Z축 대기 위치 이동, 프로브 에어 오프
                    {
                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running)	{ m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy]; }
                        else 												{ m_dPosZ = CData.SPos.dGRD_Z_Wait[m_iWy]; }
                        
						CMot.It.Stop(m_iZ);
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        
						_SetLog("Z axis move position.", m_dPosZ);
						
                        Func_PrbAir(false);

                        m_iStep++;
                        return false;
                    }

                case 101: //Z축 대기 위치 이동 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }

                        if (m_iPickerVacErr == 1)
                        { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else
                        { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        _SetLog("Picker Vacuum ERROR " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        // 201009 jym : Before 측정 시에만 적용
                        if (iBfAf == 0)
                        { m_bSubErr = true; }

                        m_iStep = 0;
                        return true;
                    }
                ///////////////////////////////////////////////////////////////////////////////////////

            }
        }

        // 2021.07.29 lhs Start : UseNewSckGrindProc용 측정함수 별도로 만들기
        /// <summary>
        /// Strip Thickness Measure (UseNewSckGrindProc용. SCK전용)
        /// 스트립 두께 측정 함수 0:Before, 1:After
        /// </summary>
        /// <param name="iIdx"></param>
        /// <returns></returns>
        public bool Cyl_MeaStrip_NewSck(int iBfAf) // UseNewSckGrindProc용으로 사용(SCK 전용)
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (iBfAf == 0)
                    {
                        if (m_eWy == EWay.L)    { CErr.Show(eErr.LEFT_GRIND_STRIP_INSPECTION_BEFORE_TIMEOUT);   }
                        else                    { CErr.Show(eErr.RIGHT_GRIND_STRIP_INSPECTION_BEFORE_TIMEOUT);  }
                        _SetLog("Error : Timeout(Before).");
                    }
                    else
                    {
                        if (m_eWy == EWay.L)    { CErr.Show(eErr.LEFT_GRIND_STRIP_INSPECTION_AFTER_TIMEOUT);    }
                        else                    { CErr.Show(eErr.RIGHT_GRIND_STRIP_INSPECTION_AFTER_TIMEOUT);   }
                        _SetLog("Error : Timeout(After).");
                    }
                    //m_bSubErr = true;

                    m_iStep = 0;
                    return true;
                }
            }

            if (!Chk_Strip())
            {
                if (m_eWy == EWay.L)    { CErr.Show(eErr.LEFT_GRIND_VACUUM_ERROR);  }
                else                    { CErr.Show(eErr.RIGHT_GRIND_VACUUM_ERROR); }
                _SetLog("Error : Vacuum fail.");

                // 201009 jym : Before 측정 시에만 적용
                if (iBfAf == 0)         {   m_bSubErr = true;   }

                m_iStep = 0;
                return true;
            }

			m_iPreStep = m_iStep;

            ///////////////////////////////////////////////////////////////////////////////////////

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10: // 축 상태 체크
                    {
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);
                            
                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            if (CData.Opt.bWheelStopWaitSkip == false)   // 2021.02.20 lhs : true = 기다리지 않음, false = 기다림 (JCET VOC)
                            {
                                return false;
                            }
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }

                        m_bMeaErrBf_L = false;
                        m_bMeaErrAf_L = false;
                        m_bMeaErrBf_R = false;
                        m_bMeaErrAf_R = false;

                        ProbeClearVal(iBfAf);
            
                        InitPbValue(m_iWy, iBfAf);

                        // 200920 jym : 프로브 업 체크 카운트 초기화
                        m_iPrbUpCnt = 0;

                        m_bSubErr = false;

                        _SetLog("Check axes.");

                        m_iStep++;
                        return false;
                    }

                case 11: // IO 초기화
                    {
                        _InitCycle();
                        _SetLog("Init Cycle.");

                        m_iStep++;
                        return false;
                    }

                case 12: // 데이터 저장 변수 초기화
                    {

                        m_iRow = 0;
                        m_iCol = 0;
                        m_dPosX = CData.SPos.dGRD_X_Zero[m_iWy];
                        m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS;
                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];

                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_ProbeDn;
                            m_eOt2 = eY.GRDL_ProbeAir;
                            m_eIn1 = eX.GRDL_ProbeAMP;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_ProbeDn;
                            m_eOt2 = eY.GRDR_ProbeAir;
                            m_eIn1 = eX.GRDR_ProbeAMP;
                        }

                        if (iBfAf == 0) // Before
                        {
                            m_aInspBf                   = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            m_aInspTotalBf              = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];    // 2020.09.14 JSKim Add
                            m_abMeaBfErr                = new bool  [CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            CData.GrData[m_iWy].aMeaBf  = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];

                        }
                        else    // After
                        {
                            m_aInspAf                   = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            m_aInspTotalAf              = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];     // 2020.09.14 JSKim Add
                            m_abMeaAfErr                = new bool  [CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            CData.GrData[m_iWy].aMeaAf  = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            if (m_eWy == EWay.L)
                            {
                                m_aInspShift            = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            }
                        }
                        m_aInspTemp                     = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                        m_aInspTotalTemp                = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];  // 2020.09.14 JSKim Add

                        // 2021.08.01 lhs Start : TopMold, BtmMold의 Avg, Max 계산을 위한 저장용
                        m_listTopMoldTh = new List<double>();
                        m_listBtmMoldTh                 = new List<double>();
                        // 2021.08.01 lhs End

                        _SetLog("Init data.");

                        m_iStep++;
                        return false;
                    }

                case 13: // Z축 측정 위치 이동
                    {
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move position.", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 14: // Z축 테이블 측정 위치 이동 확인, Y축 Table 상단 측정 위치 이동
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]);
                        _SetLog("Y axis move measure table.", CData.SPos.dGRD_Y_TblInsp[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 15: // Y축 Table 상단 측정 위치 이동 확인, X축 0으로 이동
                    {
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]))
                        { return false; }

                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                        _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 16: // X축 0으로 이동 확인, 프로브 에어 온
                    {
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }

                        Func_PrbAir(true);
                        _SetLog("Porbe air on.");

                        m_iStep++;
                        return false;
                    }

                case 17: //프로브 에어 온 확인, 프로브 다운
                    {
                        if (!Func_PrbAir(true))
                        { return false; }

                        Func_PrbDown(true);
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 18: //프로브 다운 확인, 프로브 에어 오프
                    {
                        if (!CIO.It.Get_X(m_eIn1))
                        {
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            Func_PrbAir(false);
                            _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }

                        return false;
                    }

                case 19: //프로브 에어 오프 확인, 프로브 값 획득 후 테이블 높이 계산
                    {
                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            CData.Tbl_Af[m_iWy, 0] = CPrb.It.Read_Val(m_eWy) + GV.EQP_TABLE_MIN_THICKNESS; // Table 높이
                            _SetLog("Table thickness : " + CData.Tbl_Af[m_iWy, 0] + "mm", true);

                            if (CData.Tbl_Af[m_iWy, 0] > (GV.EQP_TABLE_MIN_THICKNESS + 4))      // 지그가 있는지 체크
                            {
                                CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_MANUALZIG_ON_THE_TABLE : eErr.RIGHT_GRIND_MANUALZIG_ON_THE_TABLE);
                                _SetLog("Error : Manual zig on table.");

                                if(iBfAf == 0)  m_bSubErr = true;

                                m_iStep = 0;
                                m_iGStep = 0;
                                return true;
                            }

                            m_iStep++;
                        }

                        return false;
                    }

                case 20: //프로브 업
                    {
                        Func_PrbDown(false);
                        m_Delay.Set_Delay(GV.PRB_DELAY);//191002 ksg :
                        _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 21: //프로브 업 확인, Z축 자재 측정 위치로 이동
                    {
                        bool bReadProbeVal = false; //201020 jhc : 단위 Case 문 내에서 프로브 1번만 읽기 위함 (불필요 delay 방지)

                        // Data Shift Probe Skip
                        if (CData.Dev.bDShiftPSkip && m_eWy == EWay.R && iBfAf == 0 && CSQ_Main.It.m_bRun && CData.Dev.bDual == eDual.Dual) //200428 ksg : Data Shift Probe Skip 조건 추가
                        {
#if true //201020 jhc : Data Shift전 Probe Up 후 Delay 필요
                            if (!bReadProbeVal) { dtmp = CPrb.It.Read_Val(m_eWy); } //bReadProbeVal : 단위 Case 문 내에서 프로브 1번만 읽기 위함 (불필요 delay 방지)
                            if ((!m_Delay.Chk_Delay()) && (!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)))
                            {
                                return false; //Data Shift 인 경우 프로브 업 대기
                            }
#endif
                            //200513 myk : Dats Shift 시 One Point 강제 셋팅
                            CData.GrData[(int)EWay.R].aOldOnPont[0] = CData.Parts[(int)EPart.GRDR].dShiftT;
                            //_SetLog("Data shift.");
                            _SetLog("Data shift -> OldOnePoint = " + CData.GrData[(int)EWay.R].aOldOnPont[0].ToString());  // 2021.12.07 lhs 로그수정

                            m_iStep = 0;
                            return true;
                        }

                        //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                        dtmp = CPrb.It.Read_Val(m_eWy);
                        if (CIO.It.Get_X(m_eIn1) && (dtmp >= GV.dProbeUpHeight))
                        {
                            m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0];
                            CMot.It.Mv_N(m_iZ, m_dPosZ);    //프로브 테이블 측정시 0인 위치로 이동
                            _SetLog("Z axis move position.", m_dPosZ);

                            m_iStep++;
                        }

                        return false;
                    }

                case 22: //Z축 자재 측정 위치로 이동 확인, 프로브 에어 온
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        Func_PrbAir(true);
                        _SetLog("Probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 23: //프로브 에어 온 확인, 프로브 다운
                    {
                        if (!Func_PrbAir(true))
                        { return false; }

                        Func_PrbDown(true);
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 24: //프로브 다운 확인, 프로브 에어 오프
                    {
                        if (!CIO.It.Get_X(m_eIn1))
                        {
                            Func_PrbAir(false);
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }

                        return false;
                    }

                case 25: //프로브 에어 오프 확인, 프로브 값 획득 후 테이블 높이 계산
                    {
                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            m_InspZeroOffset = CPrb.It.Read_Val(m_eWy);
                            _SetLog("m_InspZeroOffset : " + m_InspZeroOffset + "mm", true);

                            m_iStep++;
                        }
                        return false;
                    }

                case 26: //프로브 업
                    {
                        Func_PrbDown(false);
                        m_Delay.Set_Delay(GV.PRB_DELAY);//191002 ksg :
                        _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 27: //프로브 업 확인, Z축 자재 측정 위치로 이동
                    {
                        //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                        dtmp = CPrb.It.Read_Val(m_eWy);
                        if (CIO.It.Get_X(m_eIn1) && (dtmp >= GV.dProbeUpHeight))
                        {
                            _SetLog("Check probe up.");
                            m_iStep++;
                        }
                        return false;
                    }
                //1. m_iCol < CData.Dev.iCol 인지 확인
                //2. [m_iRow, m_iCol].bUse = true 인지 확인 for(int i = 0; i < CData.Dev.iRow)
                //3. [m_iRow, m_iCol].dX = Probe X축 Zero 위치와 같은지 확인
                //4. X축 [m_iRow, m_iCol].dX 위치로 이동
                //5. 테이블 상단 측정 후 프로브 X축 Zero일때 테이블 위치와 차이값 계산(m_InspOffset)
                //6. m_iRow < CData.Dev.iRow일때 m_iRow++ 하면서 bUse = true 일경우 프로브값 - m_InspOffset = 해당 위치 자재 높이
                //7. m_iCol++ 후 1번부터 반복
                //case 23:
                case 28: //== 반복 시작 지점 == 테이블 Y축 자재 측정 위치 이동 확인, m_iCol < CData.Dev.iCol 인지 확인, m_iCol열에서 사용자 설정 위치 있는지 확인, 있을 경우 프로브 X축 테이블 측정 위치와 같은지 확인, 같지 않을 경우 프로브 X축 해당 열위치로 이동
                    {
                        bool bTemp = false;
                        if (iBfAf == 0) //Before 자재 측정 
                        {
                            if (m_iCol < CData.Dev.iCol)
                            {//측정 열이 사용자가 설정한 열보다 작은지 확인
                                for (int i = 0; i < CData.Dev.iRow * CData.Dev.iWinCnt; i++)
                                {//해당 열의 모든행에 사용자가 설정한 측정 포인트가 있는지 검사

                                    bTemp = CData.Dev.aData[m_iWy].aPosBf[i, m_iCol].bUse; 
                                    if (bTemp) { break; }
                                }

                                if (bTemp)
                                {//해당 열 사용자 설정 측정 위치 있을 경우 해당 열이 센터와 같은지 확인 후 다를 경우 프로브 X축 해당 열 측정 위치로 이동
                                    if (m_dPosX == CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX)
                                    {/* m_iRow 자재 측정 위치로 이동 */}
                                    else
                                    {//프로브 X축 [m_iCol] 열 테이블 측정 위치로 이동
                                        m_dPosX = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX;
                                        CMot.It.Mv_N(m_iX, m_dPosX);    _SetLog("X axis move position.", m_dPosX);
                                        CMot.It.Mv_N(m_iY, m_dPosY);    _SetLog("Y axis move position.", m_dPosY);
                                    }
                                    _SetLog(string.Format("Use point(before).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                    m_iStep++;
                                }
                                else
                                {//해당 열에 사용자설정 측정 위치 없을 경우 m_iCol++ 후 반복
                                    m_iCol++;
                                    return false;
                                }
                            }
                            else
                            {
                                _SetLog(string.Format("Column end(before).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                m_iStep = 38;
                            }
                        }
                        else  //After 자재 측정
                        {
                            if (m_iCol < CData.Dev.iCol)
                            {//측정 열이 사용자가 설정한 열보다 작은지 확인
                                for (int i = 0; i < CData.Dev.iRow * CData.Dev.iWinCnt; i++)
                                {//해당 열의 모든행에 사용자가 설정한 측정 포인트가 있는지 검사

                                    bTemp = CData.Dev.aData[m_iWy].aPosAf[i, m_iCol].bUse; 
                                    if (bTemp) { break; }
                                }

                                if (bTemp)
                                {//해당 열 사용자 설정 측정 위치 있을 경우 해당 열이 센터와 같은지 확인 후 다를 경우 프로브 X축 해당 열 측정 위치로 이동
                                    if (m_dPosX == CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX)
                                    {/* m_iRow 자재 측정 위치로 이동 */}
                                    else
                                    {//프로브 X축 [m_iCol] 열 테이블 측정 위치로 이동
                                        m_dPosX = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX;
                                        CMot.It.Mv_N(m_iX, m_dPosX);    _SetLog("X axis move position.", m_dPosX);
                                        CMot.It.Mv_N(m_iY, m_dPosY);    _SetLog("Y axis move position.", m_dPosY);
                                    }
                                    _SetLog(string.Format("Use point(after).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                    m_iStep++;
                                }
                                else
                                {//해당 열에 사용자설정 측정 위치 없을 경우 m_iCol++ 후 반복
                                    m_iCol++;
                                    return false;
                                }
                            }
                            else
                            {
                                _SetLog(string.Format("Column end(after).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                m_iStep = 38;
                            }
                        }
                        return false;
                    }
                case 29: // X축 해당열 테이블 측정 위치로 이동 확인, 프로브 에어 온
                    {
                        if (!CMot.It.Get_Mv(m_iX, m_dPosX))
                        {
                            CMot.It.Mv_N(m_iX, m_dPosX);
                            return false;
                        }
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        {
                            CMot.It.Mv_N(m_iY, m_dPosY);
                            return false;
                        }

                        Func_PrbAir(true);
                        _SetLog("Probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 30: // 프로브 에어 온 확인, 프로브 다운
                    {
                        if (!Func_PrbAir(true))
                        { return false; }

                        Func_PrbDown(true);
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 31: // 프로브 다운 확인 및 딜레이 설정, 프로브 에어 오프
                    {
                        if (!CIO.It.Get_X(m_eIn1))
                        {
                            Func_PrbAir(false);
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }
                        return false;
                    }

                case 32: // 프로브 에어 오프 확인, 테이블 높이 측정, 테이블 센터와의 옵셋 값 계산, 프로브 업
                    {
                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            m_InspOffset = CPrb.It.Read_Val(m_eWy);     _SetLog("Probe value : " + m_InspOffset + "mm", true);
                            Func_PrbDown(false);
                            m_Delay.Set_Delay(GV.PRB_DELAY);            _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }
                        return false;
                    }

                case 33: // == 자재 행(m_iRow) 측정 반복 시점 == 프로브 업 확인, 테이블 Y축 자재 측정 위치로 이동
                    {

                        bool bMeasure = false; //200712 jhc : 18 포인트 측정 (ASE-KR VOC)

                        //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                        dtmp = CPrb.It.Read_Val(m_eWy);
                        if (CIO.It.Get_X(m_eIn1) && (dtmp >= GV.dProbeUpHeight))
                        {
                            if (iBfAf == 0) // Before
                            {
                                if (m_iRow >= CData.Dev.iRow * CData.Dev.iWinCnt)
                                {
                                    m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                    m_iCol++;
                                    m_iRow = 0;
                                    CMot.It.Mv_N(m_iY, m_dPosY);
                                    _SetLog("Y axis move position(before)." + m_dPosY);

                                    m_iStep = 28;   // 반복 시작 시점
                                    return false;
                                }

                                bMeasure = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].bUse; 

                                if (bMeasure)
                                {
                                    m_dPosY = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dY;
                                    _SetLog("Measure point(before).  Y axis position : " + m_dPosY + "mm");

                                    m_iStep++;
                                }
                                else
                                {
                                    m_iRow++;
                                    if (m_iRow < CData.Dev.iRow * CData.Dev.iWinCnt)
                                    { return false; }
                                    else
                                    {
                                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                        m_iCol++;
                                        m_iRow = 0;
                                        _SetLog("Row end(before).  Col : " + m_iCol);

                                        m_iStep = 28;   // 반복 시작 시점
                                    }
                                }
                            }
                            else    // After
                            {
                                if (m_iRow >= CData.Dev.iRow * CData.Dev.iWinCnt)
                                {
                                    m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                    m_iCol++;
                                    m_iRow = 0;
                                    CMot.It.Mv_N(m_iY, m_dPosY);
                                    _SetLog("Y axis move position(after)." + m_dPosY);

                                    m_iStep = 28;   // 반복 시작 시점
                                    return false;
                                }

                                bMeasure = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].bUse; 

                                if (bMeasure)
                                {
                                    m_dPosY = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dY;
                                    _SetLog("Measure point(after).  Y axis position : " + m_dPosY + "mm");
                                    m_iStep++;
                                }
                                else
                                {
                                    m_iRow++;
                                    if (m_iRow < CData.Dev.iRow * CData.Dev.iWinCnt)
                                    { return false; }
                                    else
                                    {
                                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                        m_iCol++;
                                        m_iRow = 0;
                                        _SetLog("Row end(after).  Col : " + m_iCol);

                                        m_iStep = 28;   // 반복 시작 시점
                                    }
                                }
                            }
                        }
                        CMot.It.Mv_N(m_iY, m_dPosY);
                        _SetLog("Y axis move position.", m_dPosY);

                        return false;
                    }

                case 34: //테이블 Y축 자재 측정 위치 이동 확인, 프로브 에어 온
                    {
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        Func_PrbAir(true);
                        _SetLog("Probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 35: //프로브 에어 온 확인, 프로브 다운
                    {
                        if (!Func_PrbAir(true))
                        { return false; }

                        Func_PrbDown(true);
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 36: //프로브 다운 확인, 프로브 에어 오프
                    {
                        if (!CIO.It.Get_X(m_eIn1))
                        {
                            Func_PrbAir(false);
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }
                        return false;
                    }

                case 37: //== 반복 종료 시점 == 프로브 에어 오프 확인, 자재 높이 측정, 프로브 업, 다음 행 설정(m_iRow++), m_iStep = 28로 이동
                    {
                        // jhLee, Multi-LOT의 경우에도 SPC 기록    
                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            m_PbOfset = CPrb.It.Read_Val(m_eWy);

                            if (iBfAf == 0)
                            {
                                double dGap = m_PbOfset - (m_InspOffset - m_InspZeroOffset);
                                if (CData.GrData[m_iWy].aOldOnPont[0] < dGap)
                                { 
                                    CData.GrData[m_iWy].aOldOnPont[0] = dGap; 
                                }
                                _SetLog(string.Format("Ori : {0}mm  Gap : {1}mm", m_PbOfset, dGap), true);
                            }

                            m_PbOfset += CData.Dev.aData[m_iWy].dPrbOffset;     // Probe RNR    //CData.MPos[0].dPRB_OFFSET;
                            

                            //syc : Qorvo After Measure
                            if (CDataOption.IsFakeAf && iBfAf == 1)
                            {
                                m_PbOfset += CData.MPos[m_iWy].fake;
                                _SetLog("AFOFF : " + CData.MPos[m_iWy].fake + "mm");
                            }
                            //<- 여기까지 측정값에 Offset 적용 (RNR or Fake)

                            m_aInspTemp[m_iRow, m_iCol]         = m_PbOfset;
                            m_aInspTotalTemp[m_iRow, m_iCol]    = m_PbOfset;       // 2020.09.14 JSKim Add

                            // 자재 측정값에 테이블 측정값 보정
                            m_aInspTemp[m_iRow, m_iCol]         -= (m_InspOffset - m_InspZeroOffset);
                            m_aInspTotalTemp[m_iRow, m_iCol]    -= (m_InspOffset - m_InspZeroOffset);              // 2020.09.14 JSKim Add
																												   //<- 여기까지 측정값에 Offset 적용 (RNR or Fake) 및 테이블 보정값 적용


							// 2020.09.14 JSKim St
							if (CData.Parts[m_iPart].bExistStrip == false || CSQ_Main.It.m_iStat == EStatus.Manual) //201014 jhc : Manual 모드
							{
								CData.Parts[m_iPart].dDfMin = 0.0;
								CData.Parts[m_iPart].dDfMax = 0.0;
								CData.Parts[m_iPart].dDfAvg = 0.0;

								CData.Parts[m_iPart].dPcbMin = 0.0;
								CData.Parts[m_iPart].dPcbMax = 0.0;     // lhs 확인 필요
								CData.Parts[m_iPart].dPcbMean = 0.0;
								
                                CData.Parts[m_iPart].dTopMoldAvg = 0.0;
                                CData.Parts[m_iPart].dTopMoldMax = 0.0;
                                CData.Parts[m_iPart].dBtmMoldAvg = 0.0;
                                CData.Parts[m_iPart].dBtmMoldMax = 0.0;

							}
							// 2020.09.14 JSKim Ed

							// Manual모드 : TopDown 모드(Total Thick), Target 모드(Total)만 가능
							// 나머지 모드는 리턴해 버리자...


							////////////////////////////////////////////////
							// 2021.07.29 lhs : Side별 측정값 계산
							////////////////////////////////////////////////
							// SecsGem 사용 여부 체크
							// Manual 여부 체크

							double dPcbTemp     = 0.0;    // Pcb 값
                            double dTopMoldTemp = 0.0;    // TopMold 값
                            double dBtmMoldTemp = 0.0;    // BtmMold 값
                            string sLogMsg  = "";

                            // Pcb값은 초기값 = 0.0, 
                            // DF 측정시나 SecsGem 사용시 Pcb값이 존재 

                            if (CData.Dev.bDynamicSkip) { sLogMsg += "DF Not Measured, ";   }   else    { sLogMsg += "DF Measured, ";       }
                            if (CData.Opt.bSecsUse)     { sLogMsg += "SECS/GEM Use, ";      }   else    { sLogMsg += "SECS/GEM Not Use, ";  }

                            if (CData.Dynamic.iHeightType == 0) { dPcbTemp = CData.Parts[m_iPart].dPcbMax;  sLogMsg += string.Format("PCB Max = {0}, ",  dPcbTemp); }
                            else                                { dPcbTemp = CData.Parts[m_iPart].dPcbMean; sLogMsg += string.Format("PCB Mean = {0}, ", dPcbTemp); }

                            // 일단 계산시 TopMold와 BtmMold는 Avg 값을 사용하자
                            dTopMoldTemp = CData.Parts[m_iPart].dTopMoldAvg;        sLogMsg += string.Format("TopMold Avg = {0}. ", dTopMoldTemp);
                            dBtmMoldTemp = CData.Parts[m_iPart].dBtmMoldAvg;        sLogMsg += string.Format("BtmMold Avg = {0}. ", dBtmMoldTemp);

                            _SetLog(sLogMsg);

                            bool bPcbErr = false;
                            bool bMoldErr = false;

                            if (CData.Dev.aData[m_iWy].eBaseOnThick == EBaseOnThick.Total)
                            {
                                // m_aInspTemp[m_iRow, m_iCol] 그대로. (Top/BtmS/TopD/BtmD)

                            }
                            else  // Mold 기준
                            {
                                if (dPcbTemp <= 0 && CData.Dynamic.dPcbRange != 0)
                                {
                                    bPcbErr = true;
                                }

                                bool bApplyLimit = false;

                                if (iBfAf == 0) {  bApplyLimit = CData.Dev.aData[m_iWy].dBfLimit != 0;  }
                                else            {  bApplyLimit = CData.Dev.aData[m_iWy].dAfLimit != 0;  }

                                if (CData.Dev.eMoldSide == ESide.Top || CData.Dev.eMoldSide == ESide.BtmS)  // Single
                                {
                                    // Mold 기준이므로 DF 측정이나 SecsGem으로 Pcb 알아야 됨.
                                    // 만약 Pcb = 0 이면 에러처리 하자 
                                    m_aInspTemp[m_iRow, m_iCol] -= dPcbTemp;
                                }
                                else if (CData.Dev.eMoldSide == ESide.TopD) // Double
                                {
                                    if ( dTopMoldTemp <= 0 && dBtmMoldTemp <= 0 && bApplyLimit ) {   bMoldErr = true; }

                                    // 이전에 Top Single(MTM/Grinding)이었다면 Pcb, TopMold의 값만 알 수 있고 BtmMold는 알 수 없으므로 계산을 해야 함.
                                    if (dPcbTemp > 0 && dTopMoldTemp > 0 && dBtmMoldTemp == 0)
                                    {
                                        dBtmMoldTemp = m_aInspTemp[m_iRow, m_iCol] - dPcbTemp - dTopMoldTemp;
                                        m_listBtmMoldTh.Add(dBtmMoldTemp);  // dBtmMoldTemp가 포인트 값이므로 나중에 평균을 내자

                                        _SetLog(string.Format("Top Double Side : calculated BtmMold thickness = {0}", dBtmMoldTemp));
                                    }
                                    m_aInspTemp[m_iRow, m_iCol] -= (dPcbTemp + dBtmMoldTemp);
                                }
                                else if (CData.Dev.eMoldSide == ESide.Btm)  // Double
                                {
                                    if (dTopMoldTemp <= 0 && dBtmMoldTemp <= 0 && bApplyLimit) { bMoldErr = true; }

                                    // 이전에 Btm Single(MTM/Grinding)이었다면 Pcb, BtmMold의 값만 알 수 있고 TopMold는 알 수 없으므로 계산을 해야 함.
                                    if (dPcbTemp > 0 && dBtmMoldTemp > 0 && dTopMoldTemp == 0)
                                    {
                                        dTopMoldTemp = m_aInspTemp[m_iRow, m_iCol] - dPcbTemp - dBtmMoldTemp;
                                        m_listTopMoldTh.Add(dTopMoldTemp);  // dTopMoldTemp가 포인트 값이므로 나중에 평균을 내자
                                        _SetLog(string.Format("Btm Double Side : calculated TopMold thickness = {0}", dTopMoldTemp));
                                    }
                                    m_aInspTemp[m_iRow, m_iCol] -= (dPcbTemp + dTopMoldTemp);
                                }
                                else { }
                            }

                            // 에러처리 : Pcb, Topmold, btmMold
                            if (bPcbErr || bMoldErr)
                            {
                                if (iBfAf == 0)
                                {
                                    if (m_eWy == EWay.L) m_bMeaErrBf_L = true;
                                    if (m_eWy == EWay.R) m_bMeaErrBf_R = true;
                                }
                                else
                                {
                                    if (m_eWy == EWay.L) m_bMeaErrAf_L = true;
                                    if (m_eWy == EWay.R) m_bMeaErrAf_R = true;
                                }

                                if(bPcbErr)     _SetLog(string.Format("Pcb error. Pcb thick = {0}", dPcbTemp));
                                if(bMoldErr)    _SetLog(string.Format("TopMold & BtmMold error. TopMold thick = {0}, BtmMold = {1}", dTopMoldTemp, dBtmMoldTemp));
                            }
                            /////

                            _SetLog("Measure value : "          + m_aInspTemp[m_iRow, m_iCol]       + "mm", true);
                            _SetLog("Measure Total value : "    + m_aInspTotalTemp[m_iRow, m_iCol]  + "mm", true);  // 2020.09.14 JSKim Add

                            double dLimitMax = 0.0;
                            double dLimitMin = 0.0;

                            if (iBfAf == 0) //Before
                            {
                                // 자재 높이 범위 검사
                                // Limit Max / Min 얻기
                                if(CData.Dev.aData[(int)EWay.L].eBaseOnThick == EBaseOnThick.Total) // Total 기준
                                {
                                    dLimitMax = CData.Dev.aData[(int)EWay.L].dTotalTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                                    dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dBfLimit;
                                }
                                else // Mold 기준
                                {
                                    dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                                    dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dBfLimit;
                                }

                                // jhLee, Multi-LOT의 경우 SPC 기록
                                if (CData.IsMultiLOT())
                                {
                                    m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dBfLimit.ToString();
                                }
                                else
                                {
                                    CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dBfLimit.ToString();
                                }

                                if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                {
                                    if (CData.Dev.aData[m_iWy].eBaseOnThick == EBaseOnThick.Total)  // Total 기준
                                    {
                                        dLimitMax = CData.Dev.aData[m_iWy].dTotalTh + CData.Dev.aData[m_iWy].dBfLimit;
                                        dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dBfLimit;
                                    }
                                    else  // Mold 기준
                                    {
                                        dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dBfLimit;
                                        dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dBfLimit;
                                    }

                                    // jhLee, Multi-LOT의 경우 SPC 기록
                                    if (CData.IsMultiLOT()) 
                                    {
                                        m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[m_iWy].dBfLimit.ToString();
                                    }
                                    else
                                    {
                                        CData.SpcData.sTargetLim = CData.Dev.aData[m_iWy].dBfLimit.ToString();
                                    }
                                }

                                _SetLog(string.Format("Before.  Limit min : {0}mm  Limit max : {1}mm", dLimitMin, dLimitMax));

                                // Limit Max / Min 를 벗어났는지 체크
                                if (m_eWy == EWay.L)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dBfLimit != 0)
                                    {
                                        if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                        {//범위 벗어 났을 경우 에러 발생
                                            m_abMeaBfErr[m_iRow, m_iCol] = true;
                                            m_bMeaErrBf_L = true;
                                            _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                        }
                                    }
                                }
                                else  // Right
                                {
                                    if (CData.Dev.bDual == eDual.Normal)  // Normal
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dBfLimit != 0)
                                        {
                                            if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                            {//범위 벗어 났을 경우 에러 발생
                                                m_abMeaBfErr[m_iRow, m_iCol] = true;
                                                m_bMeaErrBf_R = true;
                                                _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                            }
                                        }
                                    }
                                    else    // Dual
                                    {
                                        if (CData.Dev.aData[m_iWy].dBfLimit != 0)
                                        {
                                            if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                            {//범위 벗어 났을 경우 에러 발생
                                                m_abMeaBfErr[m_iRow, m_iCol] = true;
                                                m_bMeaErrBf_R = true;
                                                _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                            }
                                        }
                                    }
                                }

                                CData.GrData[m_iWy].aMeaBf[m_iRow, m_iCol] = m_aInspTemp[m_iRow, m_iCol];
                                _SetLog("Measure Before Value : " + m_aInspTemp[m_iRow, m_iCol] + "mm", true);

                            }  
                            else    //After
                            {
                                //자재 높이 범위 검사
                                // 2020.09.14 JSKim St - MeasureMode인 경우에는 Bf 랑 동일하게 검사해야 한다. 아니면 AfLimit 설정을 0으로 하던지
                                if (CData.Dev.bMeasureMode)
                                {
                                    //자재 높이 범위 검사
                                    // Limit Max / Min 얻기
                                    if (CData.Dev.aData[(int)EWay.L].eBaseOnThick == EBaseOnThick.Total) // Total 기준
                                    {
                                        dLimitMax = CData.Dev.aData[(int)EWay.L].dTotalTh + CData.Dev.aData[(int)EWay.L].dAfLimit;
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dAfLimit;
                                    }
                                    else    // Mold 기준
                                    {
                                        dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dAfLimit;
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dAfLimit;
                                    }
                                    // jhLee, Multi-LOT의 경우 SPC 기록
                                    if (CData.IsMultiLOT())
                                    {
                                        m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();
                                    }
                                    else
                                    {
                                        CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();
                                    }

                                    if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                    {
                                        if (CData.Dev.aData[m_iWy].eBaseOnThick == EBaseOnThick.Total) // Total 기준
                                        {
                                            dLimitMax = CData.Dev.aData[m_iWy].dTotalTh + CData.Dev.aData[m_iWy].dAfLimit;
                                            dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dAfLimit;
                                        }
                                        else  // Mold 기준
                                        {
                                            dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dAfLimit;
                                            dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dAfLimit;
                                        }
                                        // jhLee, Multi-LOT의 경우 SPC 기록
                                        if (CData.IsMultiLOT())
                                        {
                                            m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();
                                        }
                                        else
                                        {
                                            CData.SpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();
                                        }
                                    }

                                    _SetLog(string.Format("After MeasureMode.  Limit min : {0}mm  Limit max : {1}mm", dLimitMin, dLimitMax));

                                    // Limit Max / Min 를 벗어났는지 체크
                                    if (m_eWy == EWay.L)
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                        {
                                            if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                            {//범위 벗어 났을 경우 에러 발생
                                                m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                m_bMeaErrAf_L = true;
                                                _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (CData.Dev.bDual == eDual.Normal) // Nomal
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                                {//범위 벗어 났을 경우 에러 발생
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErrAf_R = true;
                                                    _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                                }
                                            }
                                        }
                                        else    // Dual
                                        {
                                            if (CData.Dev.aData[m_iWy].dAfLimit != 0)
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                                {//범위 벗어 났을 경우 에러 발생
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErrAf_R = true;
                                                    _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                                }
                                            }
                                        }
                                    }
                                }
                                else   // MeasureMode가 아닐 경우
                                {
                                // 2020.09.14 JSKim Ed

                                    //--------------------------------
                                    // Limit Max / Min 얻기
                                    double dTarget = 0.0;
                                    for (int i = m_iStepMaxCnt - 1; i >= 0; i--)        // 맨 마지막 Rough
                                    {
                                        if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))  // Dual & Right => Right 레시피 사용
                                        {
                                            if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                            {
                                                dTarget = CData.GrData[m_iWy].aTar[i];
                                                _SetLog(string.Format("Dual.  Target : {0}mm  Col : {1}  Row : {2}", dTarget, m_iCol, m_iRow));
                                                break;
                                            }
                                        }
                                        else    // Dual & Left, Normal Left, Normal Right => Left 레시피 사용
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                            {
                                                if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown && (m_eWy == EWay.R))
                                                {
                                                    dTarget = CData.GrData[(int)EWay.R].aTar[i];
                                                    _SetLog(string.Format("Topdown.  Target : {0}mm  Col : {1}  Row : {2}", dTarget, m_iCol, m_iRow));
                                                    break;
                                                }
                                                else
                                                {
                                                    dTarget = CData.GrData[m_iWy].aTar[i];
                                                    _SetLog(string.Format("Target : {0}mm  Col : {1}  Row : {2}", dTarget, m_iCol, m_iRow));
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                    // default
                                    dLimitMax = dTarget + CData.Dev.aData[(int)EWay.L].dAfLimit;
                                    dLimitMin = dTarget - CData.Dev.aData[(int)EWay.L].dAfLimit;


                                    // jhLee, Multi-LOT의 경우 SPC 기록
                                    if (CData.IsMultiLOT())
                                    {
                                        m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();

                                        if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                        {
                                            dLimitMax = dTarget + CData.Dev.aData[m_iWy].dAfLimit;
                                            dLimitMin = dTarget - CData.Dev.aData[m_iWy].dAfLimit;

                                            m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();
                                        }
                                    }
                                    else
                                    {
                                        CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();

                                        if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                        {
                                            dLimitMax = dTarget + CData.Dev.aData[m_iWy].dAfLimit;
                                            dLimitMin = dTarget - CData.Dev.aData[m_iWy].dAfLimit;

                                            CData.SpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();
                                        }
                                    }
                                    
                                    _SetLog(string.Format("After.  Limit min : {0}mm  Limit max : {1}mm", dLimitMin, dLimitMax));
                                    
                                    //--------------------------------
                                    // Limit Max / Min 를 벗어났는지 체크
                                    if (m_eWy == EWay.L)
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                        {
                                            if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                            {//범위 벗어 났을 경우 에러 발생
                                                m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                m_bMeaErrAf_L = true;
                                                _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                            }
                                        }
                                    }
                                    else  // Right
                                    {
                                        if (CData.Dev.bDual != eDual.Dual)
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                                {//범위 벗어 났을 경우 에러 발생
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErrAf_R = true;
                                                    _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                                }
                                            }
                                        }
                                        else
                                        {
                                            if (CData.Dev.aData[m_iWy].dAfLimit != 0)
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                                {//범위 벗어 났을 경우 에러 발생
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErrAf_R = true;
                                                    _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                                }
                                            }
                                        }
                                    } // end : Right
                                    //--------------------------------

                                } // end : else of if(measuremode)

                                CData.GrData[m_iWy].aMeaAf[m_iRow, m_iCol] = m_aInspTemp[m_iRow, m_iCol];
                                _SetLog("Measure After Value : " + m_aInspTemp[m_iRow, m_iCol] + "mm", true);
                            } // end : After

                            Func_PrbDown(false);
                            m_Delay.Set_Delay(GV.PRB_DELAY); //191002 ksg :
                            _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

                            if (iBfAf == 0) // Before
                            {
                                Array.Copy(m_aInspTemp,         m_aInspBf,      m_aInspTemp.Length);
                                Array.Copy(m_aInspTotalTemp,    m_aInspTotalBf, m_aInspTemp.Length);     // 2020.09.14 JSKim Add
                            }
                            else            // After
                            {
                                Array.Copy(m_aInspTemp,         m_aInspAf,      m_aInspTemp.Length);
                                Array.Copy(m_aInspTotalTemp,    m_aInspTotalAf, m_aInspTemp.Length);     // 2020.09.14 JSKim Add
                            }
                            m_iRow++;

                            m_iStep = 33;
                        } /// end : if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())

                        return false;
                    }

                case 38: //프로브 x축 포지션 0으로 이동
                    {
                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                        _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                        if (CSpc.It.ChkOpenSaveDataCsv(m_eWy))
                        {
                            m_Delay.Set_Delay(1000);
                            _SetLog("Set delay : 1000ms");
                        }
                        else
                        {
                            m_Delay.Set_Delay(0);
                            _SetLog("Set delay : 0ms");
                        }

                        if ((CData.Opt.bSecsUse == true) && (CData.GemForm != null))
                        {
                            if (iBfAf == 0) // Before Measure
                            {
                                if (m_eWy == EWay.L)    { CData.GemForm.Strip_Data_Shift(6,   7);   }   // L Chuck Data -> Befor Data 로 이동
                                else                    { CData.GemForm.Strip_Data_Shift(12, 13);   }   // R Chuck Data -> R Befor Data 로 이동
                            }
                            else            // After Measure
                            {
                                if (m_eWy == EWay.L)    { CData.GemForm.Strip_Data_Shift(7, 10);    }   // L Before Data -> L After Data 로 이동
                                else
                                {
                                    if (CData.Dev.bDShiftPSkip)
                                    {
                                        CData.GemForm.Strip_Data_Shift(12, 13);     // R Chuck Data -> R Befor Data 로 이동
                                    }
                                    CData.GemForm.Strip_Data_Shift(13, 16);         // R Befor Data -> R After Data 로 이동
                                }
                            }
                        }

                        m_iStep++;
                        return false;
                    }

                case 39: // 체크 딜레이
                    {
                        if (!m_Delay.Chk_Delay())
                        { return false; }
                        _SetLog("Check delay.");

                        m_iStep++;
                        return false;
                    }

                case 40: //Temp 측정 값 Before or After에 복사, m_iCol = 0, m_iRow = 0, m_iStep = 0;
                    {
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        if (iBfAf == 0)  // Before
                        {
                            Array.Copy(m_aInspTemp,         m_aInspBf,      m_aInspTemp.Length);
                            Array.Copy(m_aInspTotalTemp,    m_aInspTotalBf, m_aInspTemp.Length);     // 2020.09.14 JSKim Add
                            CSpc.It.SaveDataCsv(m_eWy, "BEFORE", m_aInspBf, CData.Parts[m_iPart].dPcb);

                            if (CData.LotInfo.bLotOpen && CSQ_Main.It.m_iStat != EStatus.Manual) //191115 ksg :
                            {
                                if (CData.CurCompany == ECompany.SCK || CData.CurCompany == ECompany.JSCK)
                                {
                                    CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "BEFORE", m_aInspBf, CData.Parts[m_iPart].dPcb, m_aInspTotalBf);
                                }
                                else
                                {
                                    CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "BEFORE", m_aInspBf, CData.Parts[m_iPart].dPcb);
                                }
                            }

                            // 200722 jym : min max avg 계산
                            double dMax = 0;
                            double dMin = 0;
                            double dAvg = 0;

                            _Cal_MMA(m_aInspBf, out dMin, out dMax, out dAvg);

                            CData.PbResultVal[m_iWy].dBMax = dMax;
                            CData.PbResultVal[m_iWy].dBMin = dMin;
                            CData.PbResultVal[m_iWy].dBAvg = dAvg;

                            //-------------------------------
                            // Before TopMold, BtmMold 구하기
                            CalcTopMoldBtmMold(iBfAf, dMax, dAvg); // Before // 내부에서 m_bMeaErrBf_L, m_bMeaErrBf_R 도 변경 
                            //-------------------------------

                            if (m_eWy == EWay.L)
                            {
                                if (m_bMeaErrBf_L)
                                {
                                    CErr.Show(eErr.LEFT_GRIND_RANGEOVER_WHEN_BEFORE_MEASURE_STRIP);
                                    _SetLog("Error : Range over when before measure strip.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (m_bMeaErrBf_R)
                                {
                                    CErr.Show(eErr.RIGHT_GRIND_RANGEOVER_WHEN_BEFORE_MEASURE_STRIP);
                                    _SetLog("Error : Range over when before measure strip.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }
                        else  // After
                        {
                            Array.Copy(m_aInspTemp,         m_aInspAf,      m_aInspTemp.Length);
                            Array.Copy(m_aInspTotalTemp,    m_aInspTotalAf, m_aInspTemp.Length);   // 2020.09.14 JSKim Add
                            //190528 ksg :
                            if (m_eWy == EWay.L)
                            {
                                Array.Copy(m_aInspTemp, m_aInspShift, m_aInspTemp.Length); //190528 ksg :
                            }

                            CSpc.It.SaveDataCsv(m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb);
                            if (CData.LotInfo.bLotOpen && CSQ_Main.It.m_iStat != EStatus.Manual) //191115 ksg :
                            {
                                // 2020.09.14 JSKim St
                                //CSpc.It.SaveLotDataCsv(m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb);
                                if (CData.CurCompany == ECompany.SCK || CData.CurCompany == ECompany.JSCK)
                                {
                                    CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb, m_aInspTotalAf);
                                }
                                else
                                {
                                    CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb);
                                }
                                // 2020.09.14 JSKim Ed
                            }

                            // 200722 jym : min max avg 계산
                            double dMax = 0;
                            double dMin = 0;
                            double dAvg = 0;

                            _Cal_MMA(m_aInspAf, out dMin, out dMax, out dAvg);

                            CData.PbResultVal[m_iWy].dAMax = dMax;
                            CData.PbResultVal[m_iWy].dAMin = dMin;
                            CData.PbResultVal[m_iWy].dAAvg = dAvg;

                            //-------------------------------
                            // After TopMold, BtmMold 구하기
                            CalcTopMoldBtmMold(iBfAf, dMax, dAvg);  // After // 내부에서 m_bMeaErrAf_L, m_bMeaErrAf_R 도 변경 
                            //-------------------------------

                            if (m_eWy == EWay.L)
                            {
                                if (m_bMeaErrAf_L)
                                {
                                    CErr.Show(eErr.LEFT_GRIND_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                    _SetLog("Error : Range over when after measure strip.");

                                    // 201008 jym : After range over 에러 시 이어서 동작하기 위해 에러 처리 안함
                                    //m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (m_bMeaErrAf_R)
                                {
                                    CErr.Show(eErr.RIGHT_GRIND_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                    _SetLog("Error : Range over when after measure strip.");

                                    // 201008 jym : After range over 에러 시 이어서 동작하기 위해 에러 처리 안함
                                    //m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        } // End : else // After

                        if (m_eWy == EWay.L && CData.Dev.bDual == eDual.Dual && iBfAf == 1) { m_iStep = 45; return false; }
                        if (m_eWy == EWay.R && CData.Dev.bDual == eDual.Dual && iBfAf == 0) { m_iStep = 45; return false; }

						_SetLog("DF Server not use.");
						m_iStep = 45;

						return false;
					}

                case 45: // Max, Min, TTV 체크, OnCarrierGrindFinished, SaveLotData, SaveDataIni
                    {
                        m_iCol = 0;
                        m_iRow = 0;

                        // jhLee, Multi-LOT의 경우에도 SPC 기록
                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        //190319 ksg : Bf / Af Max, Min, Ttv 표시 해야 됨
                        if (iBfAf == 0)  // Before 측정 Data
                        {
                            double  dMax    = CData.PbResultVal[m_iWy].dBMax;
                            double  dMin    = CData.PbResultVal[m_iWy].dBMin;
                            double  dMean   = CData.PbResultVal[m_iWy].dBAvg;
                            int     iCnt    = 0;

                            
                            for (int iRow = 0; iRow < m_aInspBf.GetLength(0); iRow++)
                            {
                                for (int iCol = 0; iCol < m_aInspBf.GetLength(1); iCol++)
                                {
                                    if (m_aInspBf[iRow, iCol] != 0)
                                    {
                                        CData.m_dPbVal[m_iWy].m_BFVal.Add(m_aInspBf[iRow, iCol]); //191120 ksg :
                                                                                                  //191118 ksg :
                                        if (CData.GemForm != null)
                                        {//Before 측정 Data 
                                            if (m_eWy == EWay.L)    { CData.JSCK_Gem_Data[7].fMeasure_Data[1, iCnt]  = m_aInspBf[iRow, iCol]; }   // Left 측정 Data   // [7 =L Bf].[1=L Bf]
                                            else                    { CData.JSCK_Gem_Data[13].fMeasure_Data[5, iCnt] = m_aInspBf[iRow, iCol]; }   // Right 측정 Data  // [13=R Bf].[5=R Bf]
                                        }
                                        iCnt++;
                                    }
                                }
                            }

                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)    { CData.JSCK_Gem_Data[7].nMeasure_Count[1]  = iCnt; }  // Left Before
                                else                    { CData.JSCK_Gem_Data[13].nMeasure_Count[5] = iCnt; }  // Right Before
                            }

                            if (CData.GemForm != null)
                            {
                                // Before의 Min, Max, Avr 은 BaseOnThick가 Total 기준일 경우 Total 값, Mold 기준일 경우 Mold 값임

                                if (m_eWy == EWay.L)    // Left Before
                                {
                                    CData.JSCK_Gem_Data[7].fMeasure_Min_Data[1] = dMin;     // [7 = L Before].[1 = L Before]
                                    CData.JSCK_Gem_Data[7].fMeasure_Max_Data[1] = dMax;     // [7 = L Before].[1 = L Before]
                                    CData.JSCK_Gem_Data[7].fMeasure_Avr_Data[1] = dMean;    // [7 = L Before].[1 = L Before]

                                    CData.JSCK_Gem_Data[7].dMeasure_TopMold_Max = CData.Parts[m_iPart].dTopMoldMax;     // [7 = L Before].TopMold Max
                                    CData.JSCK_Gem_Data[7].dMeasure_TopMold_Avg = CData.Parts[m_iPart].dTopMoldAvg;     // [7 = L Before].TopMold Avg
                                    CData.JSCK_Gem_Data[7].dMeasure_BtmMold_Max = CData.Parts[m_iPart].dBtmMoldMax;     // [7 = L Before].BtmMold Max
                                    CData.JSCK_Gem_Data[7].dMeasure_BtmMold_Avg = CData.Parts[m_iPart].dBtmMoldAvg;     // [7 = L Before].BtmMold Avg
                                }
                                else    // Right Before
                                {
                                    CData.JSCK_Gem_Data[13].fMeasure_Min_Data[5] = dMin;    // [13 = R Before].[5 = R Before]        
                                    CData.JSCK_Gem_Data[13].fMeasure_Max_Data[5] = dMax;    // [13 = R Before].[5 = R Before]        
                                    CData.JSCK_Gem_Data[13].fMeasure_Avr_Data[5] = dMean;   // [13 = R Before].[5 = R Before]        

                                    CData.JSCK_Gem_Data[13].dMeasure_TopMold_Max = CData.Parts[m_iPart].dTopMoldMax;    // [13 = R Before].TopMold Max        
                                    CData.JSCK_Gem_Data[13].dMeasure_TopMold_Avg = CData.Parts[m_iPart].dTopMoldAvg;    // [13 = R Before].TopMold Avg        
                                    CData.JSCK_Gem_Data[13].dMeasure_BtmMold_Max = CData.Parts[m_iPart].dBtmMoldMax;    // [13 = R Before].BtmMold Max        
                                    CData.JSCK_Gem_Data[13].dMeasure_BtmMold_Avg = CData.Parts[m_iPart].dBtmMoldAvg;    // [13 = R Before].BtmMold Avg        
                                }
                            }

                            //20190531 ghk
                            CData.PbResultVal[m_iWy].dBMean = Math.Round(((dMax + dMin) / 2), 4); //190502 ksg : ????

                            //-----------------------
                            // 기존 로직을 간단하게 구현
                            double dThickMax = 0.0;
                            double dThickMin = 0.0;

                            if (CData.Dev.aData[m_iWy].eBaseOnThick == EBaseOnThick.Total)
                            {
                                dThickMax = CData.PbResultVal[m_iWy].dBMax;
                                dThickMin = CData.PbResultVal[m_iWy].dBMin;
                            }
                            else  // Mold
                            {
                                dThickMax = CData.PbResultVal[m_iWy].dBMax + CData.Parts[m_iPart].dPcbMax;
                                dThickMin = CData.PbResultVal[m_iWy].dBMin + CData.Parts[m_iPart].dPcbMax;
                            }

                            if (dThickMax <= CData.MPos[0].dPCBThickness || dThickMin >= 999)  // MPos[0] 만 있음
                            {
                                if (m_eWy == EWay.L)    { CErr.Show(eErr.LEFT_BEFORE_PROBE_DATA_LOST);  }
                                else                    { CErr.Show(eErr.RIGHT_BEFORE_PROBE_DATA_LOST); }
                                
                                m_iStep = 0;
                                return true;
                            }
                            //-----------------------
                        }
                        else if (iBfAf == 1)  //After 측정 Data
                        {
                            double  dMax    = CData.PbResultVal[m_iWy].dAMax;
                            double  dMin    = CData.PbResultVal[m_iWy].dAMin;
                            double  dMean   = CData.PbResultVal[m_iWy].dAAvg;
                            int     iCnt    = 0;

                            // 2021-05-17, jhLee, Multi-LOT, 현재 가공중인 Strip의 LOT Name을 사용하도록 한다.
                            if (CData.IsMultiLOT())
                            {
                                // 현재 Strip Data에 지정된 Lot Name으로 LOT Information pointer를 조회한다.
                                if (!CData.LotMgr.GetLotInfoName(CData.Parts[m_iPart].sLotName, ref m_myLotInfo))
                                {
                                    // Lot Info 할당에 실패할 경우 기존에 사용하고 있는 대표 LotInfo를 사용한다.
                                    m_myLotInfo = CData.LotInfo;
                                }

                                // Multi-LOT일 경우 가공중인 Strip의 Lot 이름을 사용한다.
                                CData.SpcData.sLotName = CData.Parts[m_iPart].sLotName;
                            }
                            else
                            {
                                m_myLotInfo = CData.LotInfo;
                                CData.SpcData.sLotName = CData.LotInfo.sLotName;
                            }

                            for (int iRow = 0; iRow < m_aInspAf.GetLength(0); iRow++)
                            {
                                for (int iCol = 0; iCol < m_aInspAf.GetLength(1); iCol++)
                                {
                                    if (m_aInspAf[iRow, iCol] != 0)
                                    {
                                        CData.m_dPbVal[m_iWy].m_AFVal.Add(m_aInspAf[iRow, iCol]); //191120 ksg :

                                        //191118 ksg :
                                        if (CData.GemForm != null)
                                        {
                                            if (m_eWy == EWay.L)    { CData.JSCK_Gem_Data[10].fMeasure_Data[4, iCnt] = m_aInspAf[iRow, iCol]; } // Left  After
                                            else                    { CData.JSCK_Gem_Data[16].fMeasure_Data[6, iCnt] = m_aInspAf[iRow, iCol]; } // Right After
                                        }
                                        iCnt++;
                                    }
                                }
                            }
                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)    { CData.JSCK_Gem_Data[10].nMeasure_Count[4] = iCnt; }
                                else                    { CData.JSCK_Gem_Data[16].nMeasure_Count[6] = iCnt; }
                            }
                            if (m_eWy == EWay.L)
                            {
                                // jhLee, Multi-LOT의 경우 SPC 기록
                                if (CData.IsMultiLOT())
                                {
                                    m_myLotInfo.rSpcData.sTtvLim = CData.Dev.aData[(int)EWay.L].dTTV.ToString();
                                }
                                else
                                {
                                    CData.SpcData.sTtvLim = CData.Dev.aData[(int)EWay.L].dTTV.ToString();
                                }

                                if (CData.Dev.aData[(int)EWay.L].dTTV != 0)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dTTV < (dMax - dMin))
                                    {
                                        CErr.Show(eErr.LEFT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                        _SetLog("Error : TTV Range over when after measure strip.");

                                        // 201009 jym : Before 측정 시에만 적용
                                        //m_bSubErr = true;

                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                            }
                            else  // Right
                            {
                                if (CData.Dev.bDual == eDual.Dual)
                                {
                                    // jhLee, Multi-LOT의 경우 SPC 기록
                                    if (CData.IsMultiLOT())
                                    {
                                        m_myLotInfo.rSpcData.sTtvLim = CData.Dev.aData[m_iWy].dTTV.ToString();
                                    }
                                    else
                                    {
                                        CData.SpcData.sTtvLim = CData.Dev.aData[m_iWy].dTTV.ToString();
                                    }

                                    if (CData.Dev.aData[m_iWy].dTTV != 0)
                                    {
                                        if (CData.Dev.aData[m_iWy].dTTV < (dMax - dMin))
                                        {
                                            CErr.Show(eErr.RIGHT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                            _SetLog("Error : TTV Range over when after measure strip.");

                                            // 201009 jym : Before 측정 시에만 적용
                                            //m_bSubErr = true;

                                            m_iStep = 0;
                                            return true;
                                        }
                                    }
                                }
                                else    // eDual.Normal
                                {
                                    // jhLee, Multi-LOT의 경우 SPC 기록
                                    if (CData.IsMultiLOT())
                                    {
                                        m_myLotInfo.rSpcData.sTtvLim = CData.Dev.aData[(int)EWay.L].dTTV.ToString();
                                    }
                                    else
                                    {
                                        CData.SpcData.sTtvLim = CData.Dev.aData[(int)EWay.L].dTTV.ToString();
                                    }

                                    if (CData.Dev.aData[(int)EWay.L].dTTV != 0)
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dTTV < (dMax - dMin))
                                        {
                                            CErr.Show(eErr.RIGHT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                            _SetLog("Error : TTV Range over when after measure strip.");

                                            // 201009 jym : Before 측정 시에만 적용
                                            //m_bSubErr = true;

                                            m_iStep = 0;
                                            return true;
                                        }
                                    }
                                }
                            }

                            if (CData.GemForm != null)
                            {
                                // Before의 Min, Max, Avr 은 BaseOnThick가 Total 기준일 경우 Total 값, Mold 기준일 경우 Mold 값임
                                // 그러나 여기서는  After의 Measure Min, Max, Avr 을 모두 Total 값으로 하자.
                                double dPcbTemp     = CData.Parts[m_iPart].dPcbMean;
                                double dTopMoldTemp = CData.Parts[m_iPart].dTopMoldAvg;
                                double dBtmMoldTemp = CData.Parts[m_iPart].dBtmMoldAvg;
                                double dOtherTemp   = 0.0;
                                
                                if(CData.Dev.aData[m_iWy].eBaseOnThick == EBaseOnThick.Total)
                                {
                                    dOtherTemp = 0.0;
                                }
                                else  // Mold 기준
                                {
                                    if      (CData.Dev.eMoldSide == ESide.Top)  {   dOtherTemp = dPcbTemp;                 }   // Single
                                    else if (CData.Dev.eMoldSide == ESide.BtmS) {   dOtherTemp = dPcbTemp;                 }   // Single 
                                    else if (CData.Dev.eMoldSide == ESide.TopD) {   dOtherTemp = dPcbTemp + dBtmMoldTemp;  }   // Double
                                    else if (CData.Dev.eMoldSide == ESide.Btm)  {   dOtherTemp = dPcbTemp + dTopMoldTemp;  }   // Double
                                }

                                if (m_eWy == EWay.L)
                                {
                                    // After 측정 Min, Max, Avg는 Total 값으로 Host에 올리자
                                    CData.JSCK_Gem_Data[10].fMeasure_Min_Data[4] = dMin     + dOtherTemp;              // [10 = L After].[4 = L After]
                                    CData.JSCK_Gem_Data[10].fMeasure_Max_Data[4] = dMax     + dOtherTemp;              // [10 = L After].[4 = L After] 
                                    CData.JSCK_Gem_Data[10].fMeasure_Avr_Data[4] = dMean    + dOtherTemp;              // [10 = L After].[4 = L After] 
                                    // After TopMold, BtmMold
                                    CData.JSCK_Gem_Data[10].dMeasure_TopMold_Max = CData.Parts[m_iPart].dTopMoldMax;    // [10 = L After].TopMold Max
                                    CData.JSCK_Gem_Data[10].dMeasure_TopMold_Avg = CData.Parts[m_iPart].dTopMoldAvg;    // [10 = L After].TopMold Avg
                                    CData.JSCK_Gem_Data[10].dMeasure_BtmMold_Max = CData.Parts[m_iPart].dBtmMoldMax;    // [10 = L After].BtmMold Max
                                    CData.JSCK_Gem_Data[10].dMeasure_BtmMold_Avg = CData.Parts[m_iPart].dBtmMoldAvg;    // [10 = L After].BtmMold Avg

                                    _SetLog("Func Call : CData.GemForm.OnCarrierGrindFinished(1)");

                                    // 2021.10.19 SungTae Start : [수정] (ASE-KR VOC) SECS/GEM Issue 관련 조건 추가
                                    //CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N1);
                                    if (!CData.bChkGrdM)
                                    {
                                        CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N1);
                                    }
                                    // 2021.10.19 SungTae End
                                }
                                else    // Right 
                                {
                                    // After 측정 Min, Max, Avg는 Total 값으로 Host에 올리자
                                    CData.JSCK_Gem_Data[16].fMeasure_Min_Data[6] = dMin  + dOtherTemp;             // [16 = R After].[6 = R After]
                                    CData.JSCK_Gem_Data[16].fMeasure_Max_Data[6] = dMax  + dOtherTemp;             // [16 = R After].[6 = R After]
                                    CData.JSCK_Gem_Data[16].fMeasure_Avr_Data[6] = dMean + dOtherTemp;             // [16 = R After].[6 = R After]
                                    // After TopMold, BtmMold
                                    CData.JSCK_Gem_Data[16].dMeasure_TopMold_Max = CData.Parts[m_iPart].dTopMoldMax;    // [16 = R After].TopMold Max
                                    CData.JSCK_Gem_Data[16].dMeasure_TopMold_Avg = CData.Parts[m_iPart].dTopMoldAvg;    // [16 = R After].TopMold Avg
                                    CData.JSCK_Gem_Data[16].dMeasure_BtmMold_Max = CData.Parts[m_iPart].dBtmMoldMax;    // [16 = R After].BtmMold Max
                                    CData.JSCK_Gem_Data[16].dMeasure_BtmMold_Avg = CData.Parts[m_iPart].dBtmMoldAvg;    // [16 = R After].BtmMold Avg

                                    _SetLog("Func Call : CData.GemForm.OnCarrierGrindFinished(2)");

                                    // 2021.10.19 SungTae Start : [수정] (ASE-KR VOC) SECS/GEM Issue 관련 조건 추가
                                    //CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N2);
                                    if (!CData.bChkGrdM)
                                    {
                                        CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N2);
                                    }
                                    // 2021.10.19 SungTae End
                                }
                            }

                            if (CData.PbResultVal[m_iWy].dBMax <= 0 || CData.PbResultVal[m_iWy].dBMin >= 999)
                            {
                                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_BEFORE_PROBE_DATA_LOST :
                                                              eErr.RIGHT_BEFORE_PROBE_DATA_LOST);
                                _SetLog("Error : Before probe data lost.");

                                //201010 jhc : Before 측정 시에만 적용
                                //m_bSubErr = true;

                                m_iStep = 0;
                                return true;
                            }

                            if (CData.LotInfo.bLotOpen)
                            {
                                // jhLee, Multi-LOT의 경우 SPC 기록
                                if (CData.IsMultiLOT())
                                {
                                    m_myLotInfo.rSpcData.sMgzNo  = CData.Parts[m_iPart].iMGZ_No.ToString();
                                    m_myLotInfo.rSpcData.sSlotNo = CData.Parts[m_iPart].iSlot_No.ToString();
                                    m_myLotInfo.rSpcData.sTable  = (m_eWy == EWay.L) ? "L" : "R";
                                    m_myLotInfo.rSpcData.sBcr    = CData.Parts[m_iPart].sBcr;
                                    m_myLotInfo.rSpcData.sMode   = (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown) ? "TopDown" : "Target";

                                    if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                    {
                                        CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_AfterMeaStrip : ESeq.GRR_AfterMeaStrip;
                                    }

                                    m_myLotInfo.rSpcData.sMax = dMax.ToString();
                                    m_myLotInfo.rSpcData.sMin = dMin.ToString();
                                    m_myLotInfo.rSpcData.sMean = dMean.ToString();
                                    m_myLotInfo.rSpcData.sTtv = (dMax - dMin).ToString();
                                    m_myLotInfo.rSpcData.sBMax = CData.PbResultVal[m_iWy].dBMax.ToString();
                                    m_myLotInfo.rSpcData.sBMin = CData.PbResultVal[m_iWy].dBMin.ToString();
                                    m_myLotInfo.rSpcData.sBAvg = CData.PbResultVal[m_iWy].dBAvg.ToString();

                                    //for(int i = GV.StepMaxCnt - 1; i >= 0; i--)
                                    for (int i = m_iStepMaxCnt - 1; i >= 0; i--)        // 2020.09.08 SungTae : modify
                                    {
                                        if (CData.Dev.bDual == eDual.Dual)
                                        {
                                            if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                            {
                                                m_myLotInfo.rSpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                m_myLotInfo.rSpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                            {
                                                if (CData.Dev.aData[(int)EWay.L].eGrdMod == eGrdMode.TopDown)
                                                {
                                                    m_myLotInfo.rSpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                    m_myLotInfo.rSpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                }
                                                else
                                                {
                                                    m_myLotInfo.rSpcData.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                    m_myLotInfo.rSpcInfo.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                }
                                                break;
                                            }
                                        }
                                    }

                                    if (CData.CurCompany == ECompany.ASE_KR)    {   CSpc.It.SaveLotData_Add(ref m_myLotInfo);   }
                                    else                                        {   CSpc.It.SaveLotData(m_myLotInfo);           }

                                } //if (CData.IsMultiLOT())
                                else    // if (CData.IsMultiLOT())의 else
                                {
                                    CData.SpcData.sMgzNo = CData.Parts[m_iPart].iMGZ_No.ToString();
                                    CData.SpcData.sSlotNo = CData.Parts[m_iPart].iSlot_No.ToString();
                                    CData.SpcData.sTable = (m_eWy == EWay.L) ? "L" : "R";
                                    CData.SpcData.sBcr = CData.Parts[m_iPart].sBcr;
                                    CData.SpcData.sMode = (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown) ? "TopDown" : "Target";
                                    if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                    {
                                        CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_AfterMeaStrip : ESeq.GRR_AfterMeaStrip;
                                    }
                                    CData.SpcData.sMax = dMax.ToString();
                                    CData.SpcData.sMin = dMin.ToString();
                                    CData.SpcData.sMean = dMean.ToString();
                                    CData.SpcData.sTtv = (dMax - dMin).ToString();
                                    CData.SpcData.sBMax = CData.PbResultVal[m_iWy].dBMax.ToString();
                                    CData.SpcData.sBMin = CData.PbResultVal[m_iWy].dBMin.ToString();
                                    CData.SpcData.sBAvg = CData.PbResultVal[m_iWy].dBAvg.ToString();

                                    for (int i = m_iStepMaxCnt - 1; i >= 0; i--)
                                    {
                                        if (CData.Dev.bDual == eDual.Dual)
                                        {
                                            if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                            {
                                                CData.SpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                CData.SpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                break;
                                            }
                                        }
                                        else // Normal
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                            {
                                                if (CData.Dev.aData[(int)EWay.L].eGrdMod == eGrdMode.TopDown)
                                                {
                                                    CData.SpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                    CData.SpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                }
                                                else // Target
                                                {
                                                    CData.SpcData.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                    CData.SpcInfo.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                }
                                                break;
                                            }
                                        }
                                    }

                                    if (CData.CurCompany == ECompany.ASE_KR)    { CSpc.It.SaveLotData_Add();    }
                                    else                                        { CSpc.It.SaveLotData();        }

                                } // end : if (CData.IsMultiLOT())의 else


                                if (m_eWy == EWay.L && CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown)
                                {
                                    if (CData.IsMultiLOT())
                                    {
                                        double.TryParse(m_myLotInfo.rSpcInfo.sTarget, out CData.Parts[(int)EPart.GRDL].dShiftT);
                                    }
                                    else
                                    {
                                        double.TryParse(CData.SpcInfo.sTarget, out CData.Parts[(int)EPart.GRDL].dShiftT);
                                    }
                                    //old CData.Parts[(int)EPart.GRDL].dShiftT = Convert.ToDouble(CData.SpcInfo.sTarget);
                                }


                                //200325 ksg : Data Shift Probe Skip
                                if (m_eWy == EWay.L && CData.Dev.bDShiftPSkip && CData.Dev.bDual == eDual.Dual)
                                { 
                                    CData.Parts[(int)EPart.GRDL].dShiftT = dMax; 
                                }

                            } // end : if (CData.LotInfo.bLotOpen)
                        } // end : if (iBfAf == 1)

                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        if (CData.LotInfo.bLotOpen)
                        {
                            string sTemp = (iBfAf == 0) ? "BEFORE" : "AFTER";
                            CSpc.It.SaveDataIni(ref m_myLotInfo, m_eWy, sTemp, m_aInspTemp);

                            if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                            {
                                CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_AfterMeaStrip : ESeq.GRR_AfterMeaStrip;
                            }
                        }

                        _SetLog("Finish.  Status : " + CData.Parts[m_iPart].iStat);

                        m_iStep = 0;
                        return true;
                    }

                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스
                case 100: //Z축 대기 위치 이동, 프로브 에어 오프
                    {
                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        { m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy]; }
                        else
                        { m_dPosZ = CData.SPos.dGRD_Z_Wait[m_iWy]; }
                        CMot.It.Stop(m_iZ);
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move position.", m_dPosZ);
                        Func_PrbAir(false);

                        m_iStep++;
                        return false;
                    }

                case 101: //Z축 대기 위치 이동 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }

                        if (m_iPickerVacErr == 1)
                        { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else
                        { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        _SetLog("Picker Vacuum ERROR " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        // 201009 jym : Before 측정 시에만 적용
                        if (iBfAf == 0) { m_bSubErr = true; }

                        m_iStep = 0;
                        return true;
                    }
                    ///////////////////////////////////////////////////////////////////////////////////////

            }// end : switch (m_iStep)
        } // end : public bool Cyl_MeaStrip_NewSck(int iBfAf)
        // 2021.07.29 lhs End

        /// <summary>
        /// 2020-12-14, 기존 Cyl_MeaStrip_T2() 과 Cyl_MeaStrip_T2()를 통합하였다.
        /// Strip Thickness Measure : Probe의 Cylinder를 Up/Down 시킨다.
        /// 스트립 두께 측정 함수 0:Before, 1:After 
        /// 초기 Table 1번만 측정하게 수정 (200427 jym) 
        /// </summary>
        /// <param name="iIdx"></param>
        /// <returns></returns>
        public bool Cyl_MeaStrip_Probe(int iIdx)
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                    if (iIdx == (int)EMeaStep.Before/*0*/)
                    {
                        CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_STRIP_INSPECTION_BEFORE_TIMEOUT :
                                                           eErr.RIGHT_GRIND_STRIP_INSPECTION_BEFORE_TIMEOUT);
                        _SetLog("Error : Before timeout.");
                        // 201009 jym : Before 측정 시에만 적용
                        m_bSubErr = true;
                    }
                    else
                    {
                        CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_STRIP_INSPECTION_AFTER_TIMEOUT :
                                                           eErr.RIGHT_GRIND_STRIP_INSPECTION_AFTER_TIMEOUT);
                        _SetLog("Error : After timeout.");
                    }

                    m_iStep = 0;
                    return true;
                }
            }

            if (!Chk_Strip())
            {
                if (m_eWy == EWay.L)
                { CErr.Show(eErr.LEFT_GRIND_VACUUM_ERROR); }
                else
                { CErr.Show(eErr.RIGHT_GRIND_VACUUM_ERROR); }
                _SetLog("Error : Vacuum fail.");

                // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                if (iIdx == (int)EMeaStep.Before/*0*/)
                {
                    m_bSubErr = true;
                }

                m_iStep = 0;
                return true;
            }

            m_iPreStep = m_iStep;

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if ((CData.CurCompany == ECompany.ASE_KR) &&
                (m_iStep == 14 || m_iStep == 15 || m_iStep == 28 || m_iStep == 29 || m_iStep == 33 || m_iStep == 34))
            {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                if (0 != m_iPickerVacErr)
                {
                    CMot.It.EStop(m_iY); //Table Y축 즉시 Stop

                    _SetLog("ERROR : Picker Vacuum : " + m_siY + " STOP : " + CMot.It.Get_FP(m_iY).ToString());

                    m_iStep = 100; //정리 스텝으로
                    return false;
                }
            }
            ///////////////////////////////////////////////////////////////////////////////////////

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10:
                    {// 축 상태 체크

                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            if (CData.Opt.bWheelStopWaitSkip == false)   // 2021.02.20 lhs : true = 기다리지 않음, false = 기다림 (JCET VOC)
                            {
                                return false;
                            }
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }

                        _SetLog("===== Measure Strip Start =====");

                        m_bMeaErrBf_L = false;
                        m_bMeaErrAf_L = false;
                        m_bMeaErrBf_R = false;
                        m_bMeaErrAf_R = false;

                        //190319 ksg :
                        ProbeClearVal(iIdx);

                        //190717 ksg : 데이터 클리어 요청
                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if ((CData.CurCompany == ECompany.Qorvo || (CData.CurCompany == ECompany.Qorvo_DZ) || CData.CurCompany == ECompany.SST) && iIdx == 0)
                        if((CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ ||
                            CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC ||
                            CData.CurCompany == ECompany.SST) && iIdx == 0)
                        {
                            ProbeClearVal(iIdx + 1);
                        }

                        //191120 ksg :
                        InitPbValue(m_iWy, iIdx);

                        // 200920 jym : 프로브 업 체크 카운트 초기화
                        m_iPrbUpCnt = 0;

                        m_bSubErr = false;

                        _SetLog("Check axes.");

                        m_iStep++;
                        return false;
                    }

                case 11:
                    {// IO 초기화
                        _InitCycle();
                        _SetLog("Init Cycle.");

                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            if (!CData.dfInfo.bBusy)
                            {
                                if (m_eWy == EWay.L)
                                {
                                    // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                                    if (iIdx == (int)EMeaStep.Before/*0*/)
                                    {
                                        CData.GRLDfData.sBcr = CData.Parts[(int)EPart.GRDL].sBcr;
                                        CDf.It.SendBfStart("LGD");
                                    }
                                    else
                                    {
                                        if (CData.Dev.bDual == eDual.Normal)
                                        {
                                            CData.GRLDfData.sBcr = CData.Parts[(int)EPart.GRDL].sBcr;
                                            CDf.It.SendAfStart("LGD");
                                        }
                                    }
                                }
                                else
                                {
                                    if (iIdx == 0 && CData.Dev.bDual == eDual.Normal)
                                    {
                                        CData.GRRDfData.sBcr = CData.Parts[(int)EPart.GRDR].sBcr;
                                        CDf.It.SendBfStart("RGD");
                                    }
                                    else if (iIdx == 1)
                                    {
                                        CData.GRRDfData.sBcr = CData.Parts[(int)EPart.GRDR].sBcr;
                                        CDf.It.SendAfStart("RGD");
                                    }
                                }
                            }
                            else
                            { return false; }
                        }

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {// 데이터 저장 변수 초기화                       
                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            if (m_eWy == EWay.L)
                            {
                                // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                                if (iIdx == (int)EMeaStep.Before/*0*/)
                                {
                                    if (!CDf.It.ReciveAckGRL((int)ECMD.scBfStartL))
                                    { return false; }
                                }
                                else
                                {
                                    if (CData.Dev.bDual == eDual.Normal)
                                    {
                                        if (!CDf.It.ReciveAckGRL((int)ECMD.scAfStartL))
                                        { return false; }
                                    }
                                }

                                if (CData.dfInfo.sGl == "GL1" && iIdx == 0 && CDataOption.MeasureDf == eDfServerType.MeasureDf)
                                {//GL1이고, Before측정이고, DF서버 사용시 DF 측정 할때
                                    if (!CData.dfInfo.bBusy)
                                    {
                                        CData.GRLDfData.dPcb1 = CData.Parts[(int)EPart.GRDL].dPcb[0];
                                        CData.GRLDfData.dPcb2 = CData.Parts[(int)EPart.GRDL].dPcb[1];
                                        CData.GRLDfData.dPcb3 = CData.Parts[(int)EPart.GRDL].dPcb[2];

                                        if (CData.Dynamic.iHeightType == 0)
                                        { CData.GRLDfData.sPcbUse = "Max"; }
                                        else if (CData.Dynamic.iHeightType == 1)
                                        { CData.GRLDfData.sPcbUse = "Avg"; }

                                        CDf.It.SendPcbData("LGD");
                                    }
                                    else
                                    { return false; }
                                }
                            }
                            else
                            {
                                if (iIdx == 0 && CData.Dev.bDual == eDual.Normal)
                                {
                                    if (!CDf.It.ReciveAckGRR((int)ECMD.scBfStartR))
                                    { return false; }
                                }
                                else if (iIdx == 1)
                                {
                                    if (!CDf.It.ReciveAckGRR((int)ECMD.scAfStartR))
                                    { return false; }
                                }

                                //20191029 ghk_dfserver_notuse_df
                                //if (CData.dfInfo.sGl == "GL1" && iIdx == 0 && CData.Dev.bDual == eDual.Normal)
                                if (CData.dfInfo.sGl == "GL1" && iIdx == 0 && CData.Dev.bDual == eDual.Normal && CDataOption.MeasureDf == eDfServerType.MeasureDf)
                                {//GL1이고, Before측정이고, Step모드 아니고, DF서버 사용시 DF 측정 할때
                                    if (!CData.dfInfo.bBusy)
                                    {
                                        CData.GRRDfData.dPcb1 = CData.Parts[(int)EPart.GRDR].dPcb[0];
                                        CData.GRRDfData.dPcb2 = CData.Parts[(int)EPart.GRDR].dPcb[1];
                                        CData.GRRDfData.dPcb3 = CData.Parts[(int)EPart.GRDR].dPcb[2];

                                        if (CData.Dynamic.iHeightType == 0)
                                        { CData.GRRDfData.sPcbUse = "Max"; }
                                        else if (CData.Dynamic.iHeightType == 1)
                                        { CData.GRRDfData.sPcbUse = "Avg"; }

                                        CDf.It.SendPcbData("RGD");
                                    }
                                    else
                                    { return false; }
                                }
                            }
                        }
                        //

                        m_iRow = 0;
                        m_iCol = 0;
                        m_dPosX = CData.SPos.dGRD_X_Zero[m_iWy];
                        m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS;
                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];

                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_ProbeDn;
                            m_eOt2 = eY.GRDL_ProbeAir;
                            m_eIn1 = eX.GRDL_ProbeAMP;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_ProbeDn;
                            m_eOt2 = eY.GRDR_ProbeAir;
                            m_eIn1 = eX.GRDR_ProbeAMP;
                        }

                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            m_aInspBf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            m_aInspTotalBf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];    // 2020.09.14 JSKim Add
                            m_abMeaBfErr = new bool[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            CData.GrData[m_iWy].aMeaBf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            //190717 ksg : 새로운 자재 투입시 전후 데이터 클리어
                            // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                            //if(CData.CurCompany == ECompany.Qorvo || (CData.CurCompany == ECompany.Qorvo_DZ) || CData.CurCompany == ECompany.SST) //191202 ksg :
                            if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ ||
                                CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC ||
                                CData.CurCompany == ECompany.SST)
                            {
                                m_aInspAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                                m_abMeaAfErr = new bool[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                                CData.GrData[m_iWy].aMeaAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            }

                        }
                        else
                        {
                            m_aInspAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            m_aInspTotalAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];     // 2020.09.14 JSKim Add
                            m_abMeaAfErr = new bool[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            CData.GrData[m_iWy].aMeaAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            //190528 ksg :
                            if (m_eWy == EWay.L)
                            {
                                m_aInspShift = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            }
                        }

                        m_aInspTemp = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                        m_aInspTotalTemp = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];  // 2020.09.14 JSKim Add

                        _SetLog("Init data.");

                        m_iStep++;
                        return false;
                    }

                case 13:
                    {// Z축 측정 위치 이동
                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl == "GL1" && iIdx == 0 && CSQ_Main.It.m_iStat == EStatus.Auto_Running && CDataOption.MeasureDf == eDfServerType.MeasureDf)
                        {
                            if (m_eWy == EWay.L)
                            {
                                if (!CDf.It.ReciveAckGRL((int)ECMD.scPcbL))
                                { return false; }
                            }
                            else
                            {
                                if (CData.Dev.bDual == eDual.Normal)
                                {
                                    if (!CDf.It.ReciveAckGRR((int)ECMD.scPcbR))
                                    { return false; }
                                }
                            }
                        }
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move position.", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 14:
                    {// Z축 테이블 측정 위치 이동 확인, Y축 Table 상단 측정 위치 이동
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]);
                        _SetLog("Y axis move measure table.", CData.SPos.dGRD_Y_TblInsp[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 15:
                    {// Y축 Table 상단 측정 위치 이동 확인, X축 0으로 이동
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]))
                        { return false; }

                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                        _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 16:
                    {// X축 0으로 이동 확인, 프로브 에어 온
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }

                        Func_PrbAir(true);
                        _SetLog("Porbe air on.");

                        m_iStep++;
                        return false;
                    }

                case 17:
                    {//프로브 에어 온 확인, 프로브 다운
                        if (!Func_PrbAir(true))
                        { return false; }

                        Func_PrbDown(true);
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 18:
                    {//프로브 다운 확인, 프로브 에어 오프
                        if (!CIO.It.Get_X(m_eIn1))
                        {
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            Func_PrbAir(false);
                            _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }

                        return false;
                    }

                case 19:
                    {//프로브 에어 오프 확인, 프로브 값 획득 후 테이블 높이 계산
                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            m_InspZeroOffset = CPrb.It.Read_Val(m_eWy);
                            CData.Tbl_Af[m_iWy, 0] = m_InspZeroOffset + GV.EQP_TABLE_MIN_THICKNESS;
                            _SetLog("Table thickness : " + CData.Tbl_Af[m_iWy, 0] + "mm", true);

                            if (CData.Tbl_Af[m_iWy, 0] > (GV.EQP_TABLE_MIN_THICKNESS + 4))
                            {
                                CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_MANUALZIG_ON_THE_TABLE :
                                                                   eErr.RIGHT_GRIND_MANUALZIG_ON_THE_TABLE);
                                _SetLog("Error : Manual zig on table.");

                                m_bSubErr = true;

                                m_iStep = 0;
                                m_iGStep = 0;
                                return true;
                            }


                            m_InspZeroOffset = 0; //20200506 jym : DEBUG
                            m_iStep++;
                        }

                        return false;
                    }

                case 20:
                    {//프로브 업
                        //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(true);
                        }
                        Func_PrbDown(false);
                        m_Delay.Set_Delay(GV.PRB_DELAY);//191002 ksg :
                        _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 21:
                    {//프로브 업 확인, Z축 자재 측정 위치로 이동

                        bool bReadProbeVal = false; //201020 jhc : 단위 Case 문 내에서 프로브 1번만 읽기 위함 (불필요 delay 방지)

                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if(CData.CurCompany != ECompany.Qorvo && (CData.CurCompany != ECompany.Qorvo_DZ) && CData.CurCompany != ECompany.SST)
                        if (CData.CurCompany != ECompany.Qorvo && CData.CurCompany != ECompany.Qorvo_DZ &&
                            CData.CurCompany != ECompany.Qorvo_RT && CData.CurCompany != ECompany.Qorvo_NC &&
                            CData.CurCompany != ECompany.SST)
                        {
                            //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                            dtmp = CPrb.It.Read_Val(m_eWy);
                            bReadProbeVal = true; //201020 jhc : 단위 Case 문 내에서 프로브 1번만 읽기 위함 (불필요 delay 방지)
                            if ((!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)) && m_Delay.Chk_Delay())
                            {
                                m_iPrbUpCnt++;
                                if (m_iPrbUpCnt == 3)
                                {
                                    CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET :
                                                                       eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                                    _SetLog("Error : Probe up not complete.");

                                    // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                                    if (iIdx == (int)EMeaStep.Before/*0*/)
                                    {
                                        m_bSubErr = true;
                                    }

                                    m_iStep = 0;
                                    return true;
                                }
                                else
                                {
                                    Func_PrbDown(false);
                                    m_Delay.Set_Delay(GV.PRB_DELAY);//191002 ksg :
                                    _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");
                                    _SetLog("Probe up cycle retry.  Count : " + m_iPrbUpCnt);

                                    return false;
                                }
                            }

                            // 200920 jym : 프로브 업 체크 카운트 초기화
                            m_iPrbUpCnt = 0;
                        }

                        //200325 ksg : Data Shift Probe Skip
                        if (CData.Dev.bDShiftPSkip && m_eWy == EWay.R && iIdx == 0 && CSQ_Main.It.m_bRun && CData.Dev.bDual == eDual.Dual) //200428 ksg : Data Shift Probe Skip 조건 추가
                        {
#if true //201020 jhc : Data Shift전 Probe Up 후 Delay 필요
                            if (!bReadProbeVal) { dtmp = CPrb.It.Read_Val(m_eWy); } //bReadProbeVal : 단위 Case 문 내에서 프로브 1번만 읽기 위함 (불필요 delay 방지)

                            if ((!m_Delay.Chk_Delay()) && (!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)))
                            {
                                return false; //Data Shift 인 경우 프로브 업 대기
                            }
#endif
                            //200513 myk : Dats Shift 시 One Point 강제 셋팅
                            CData.GrData[(int)EWay.R].aOldOnPont[0] = CData.Parts[(int)EPart.GRDR].dShiftT;
                            //_SetLog("Data shift.");
                            _SetLog("Data shift -> OldOnePoint = " + CData.GrData[(int)EWay.R].aOldOnPont[0].ToString());  // 2021.12.07 lhs 로그수정

                            m_iStep = 0;
                            return true;
                        }

                        //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                        dtmp = CPrb.It.Read_Val(m_eWy);
                        if (CIO.It.Get_X(m_eIn1) && (dtmp >= GV.dProbeUpHeight))
                        {
                            //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(false);
                            }

                            _SetLog("Check probe up.");

                            m_iStep = 27;
                        }

                        return false;
                    }
                case 27:
                    {//프로브 업 확인, Z축 자재 측정 위치로 이동
                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if(CData.CurCompany != ECompany.Qorvo && (CData.CurCompany != ECompany.Qorvo_DZ) && CData.CurCompany != ECompany.SST)
                        if (CData.CurCompany != ECompany.Qorvo && CData.CurCompany != ECompany.Qorvo_DZ &&
                            CData.CurCompany != ECompany.Qorvo_RT && CData.CurCompany != ECompany.Qorvo_NC &&
                            CData.CurCompany != ECompany.SST)
                        {
                            //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                            dtmp = CPrb.It.Read_Val(m_eWy);
                            if ((!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)) && m_Delay.Chk_Delay())
                            {
                                m_iPrbUpCnt++;
                                if (m_iPrbUpCnt == 3)
                                {
                                    CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET :
                                                                       eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                                    _SetLog("Error : Probe up not complete.");

                                    // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                                    if (iIdx == (int)EMeaStep.Before/*0*/)
                                    {
                                        m_bSubErr = true;
                                    }

                                    m_iStep = 0;
                                    return true;
                                }
                                else
                                {
                                    Func_PrbDown(false);
                                    m_Delay.Set_Delay(GV.PRB_DELAY);//191002 ksg :
                                    _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");
                                    _SetLog("Probe up cycle retry.  Count : " + m_iPrbUpCnt);

                                    return false;
                                }
                            }

                            // 200920 jym : 프로브 업 체크 카운트 초기화
                            m_iPrbUpCnt = 0;
                        }

                        //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                        dtmp = CPrb.It.Read_Val(m_eWy);
                        if (CIO.It.Get_X(m_eIn1) && (dtmp >= GV.dProbeUpHeight))
                        {
                            //211227 pjh : Ejector off
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(false);
                            }
                            //
                            //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                            //여기에서 스트립 측정 포인트 18 포인트(Leading Strip)인지? 일반(Main Strip)인지? 결정
                            if (CDataOption.Use18PointMeasure)
                            {
                                // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                                if (iIdx == (int)EMeaStep.Before/*0*/) //200713 jhc : Before인 경우에만 18 포인트 스트립 여부 검사
                                {
                                    this._checkIf18PStrip(ref CData.Parts[m_iPart].b18PMeasure, true);
                                }
                                else
                                {//After인 경우에는 현재 설정된 18 포인트 스트립 여부값을 참조
                                    //Nothing to do
                                }
                                _SetLog("18 point measure : " + CData.Parts[m_iPart].b18PMeasure);
                            }
                            else
                            { CData.Parts[m_iPart].b18PMeasure = false; }

                            _SetLog("Check probe up.");

                            m_iStep++;
                        }
                        return false;
                    }
                //1. m_iCol < CData.Dev.iCol 인지 확인
                //2. [m_iRow, m_iCol].bUse = true 인지 확인 for(int i = 0; i < CData.Dev.iRow)
                //3. [m_iRow, m_iCol].dX = Probe X축 Zero 위치와 같은지 확인
                //4. X축 [m_iRow, m_iCol].dX 위치로 이동
                //5. 테이블 상단 측정 후 프로브 X축 Zero일때 테이블 위치와 차이값 계산(m_InspOffset)
                //6. m_iRow < CData.Dev.iRow일때 m_iRow++ 하면서 bUse = true 일경우 프로브값 - m_InspOffset = 해당 위치 자재 높이
                //7. m_iCol++ 후 1번부터 반복
                //case 23:
                case 28:
                    {//== 반복 시작 지점 == 테이블 Y축 자재 측정 위치 이동 확인, m_iCol < CData.Dev.iCol 인지 확인, m_iCol열에서 사용자 설정 위치 있는지 확인, 있을 경우 프로브 X축 테이블 측정 위치와 같은지 확인, 같지 않을 경우 프로브 X축 해당 열위치로 이동                       
                        bool bTemp = false;

                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {//Before 자재 측정
                            if (m_iCol < CData.Dev.iCol)
                            {//측정 열이 사용자가 설정한 열보다 작은지 확인
                                for (int i = 0; i < CData.Dev.iRow * CData.Dev.iWinCnt; i++)
                                {//해당 열의 모든행에 사용자가 설정한 측정 포인트가 있는지 검사

                                    //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                                    if (CData.Parts[m_iPart].b18PMeasure)
                                    { bTemp = CData.Dev.aData[m_iWy].aPosBf[i, m_iCol].bUse18P; }
                                    else
                                    { bTemp = CData.Dev.aData[m_iWy].aPosBf[i, m_iCol].bUse; }

                                    if (bTemp) { break; }
                                }

                                if (bTemp)
                                {//해당 열 사용자 설정 측정 위치 있을 경우 해당 열이 센터와 같은지 확인 후 다를 경우 프로브 X축 해당 열 측정 위치로 이동
                                    if (m_dPosX == CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX)
                                    {/* m_iRow 자재 측정 위치로 이동 */}
                                    else
                                    {//프로브 X축 [m_iCol] 열 테이블 측정 위치로 이동
                                        m_dPosX = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX;
                                        CMot.It.Mv_N(m_iX, m_dPosX);
                                        _SetLog("X axis move position.", m_dPosX);
                                        CMot.It.Mv_N(m_iY, m_dPosY);
                                        _SetLog("Y axis move position.", m_dPosY);
                                    }

                                    _SetLog(string.Format("Use point(before).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                    m_iStep++;
                                }
                                else
                                {//해당 열에 사용자설정 측정 위치 없을 경우 m_iCol++ 후 반복
                                    m_iCol++;
                                    return false;
                                }
                            }
                            else
                            {
                                _SetLog(string.Format("Column end(before).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                m_iStep = 38;
                            }
                        }
                        else
                        {//After 자재 측정
                            if (m_iCol < CData.Dev.iCol)
                            {//측정 열이 사용자가 설정한 열보다 작은지 확인
                                for (int i = 0; i < CData.Dev.iRow * CData.Dev.iWinCnt; i++)
                                {//해당 열의 모든행에 사용자가 설정한 측정 포인트가 있는지 검사

                                    //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                                    if (CData.Parts[m_iPart].b18PMeasure)
                                    { bTemp = CData.Dev.aData[m_iWy].aPosAf[i, m_iCol].bUse18P; }
                                    else
                                    { bTemp = CData.Dev.aData[m_iWy].aPosAf[i, m_iCol].bUse; }

                                    if (bTemp) { break; }
                                }

                                if (bTemp)
                                {//해당 열 사용자 설정 측정 위치 있을 경우 해당 열이 센터와 같은지 확인 후 다를 경우 프로브 X축 해당 열 측정 위치로 이동
                                    if (m_dPosX == CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX)
                                    {/* m_iRow 자재 측정 위치로 이동 */}
                                    else
                                    {//프로브 X축 [m_iCol] 열 테이블 측정 위치로 이동
                                        m_dPosX = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX;
                                        //CMot.It.Mv_MN(m_iY, m_dPosY,m_iX, m_dPosX);
                                        CMot.It.Mv_N(m_iX, m_dPosX);
                                        _SetLog("X axis move position.", m_dPosX);
                                        CMot.It.Mv_N(m_iY, m_dPosY);
                                        _SetLog("Y axis move position.", m_dPosY);
                                    }

                                    _SetLog(string.Format("Use point(after).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                    m_iStep++;
                                }
                                else
                                {//해당 열에 사용자설정 측정 위치 없을 경우 m_iCol++ 후 반복
                                    m_iCol++;
                                    return false;
                                }
                            }
                            else
                            {
                                _SetLog(string.Format("Column end(after).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                m_iStep = 38;
                            }
                        }
                        return false;
                    }

                case 29:
                    {// X축 해당열 테이블 측정 위치로 이동 확인, 프로브 에어 온
                        if (!CMot.It.Get_Mv(m_iX, m_dPosX))
                        {
                            CMot.It.Mv_N(m_iX, m_dPosX);
                            return false;
                        }
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        {
                            CMot.It.Mv_N(m_iY, m_dPosY);
                            return false;
                        }

                        Func_PrbAir(true);
                        _SetLog("Probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 30:
                    {// 프로브 에어 온 확인, 프로브 다운
                        if (!Func_PrbAir(true))
                        { return false; }

                        Func_PrbDown(true);
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 31:
                    {// 프로브 다운 확인 및 딜레이 설정, 프로브 에어 오프
                        if (!CIO.It.Get_X(m_eIn1))
                        {
                            Func_PrbAir(false);
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }
                        return false;
                    }

                case 32:
                    {// 프로브 에어 오프 확인, 테이블 높이 측정, 테이블 센터와의 옵셋 값 계산, 프로브 업
                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            m_InspOffset = CPrb.It.Read_Val(m_eWy);
                            _SetLog("Probe value (m_InspOffset) : " + m_InspOffset + "mm", true);
                            //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(true);
                            }
                            Func_PrbDown(false);
                            m_Delay.Set_Delay(GV.PRB_DELAY);
                            _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }
                        return false;
                    }

                case 33:
                    {// == 자재 행(m_iRow) 측정 반복 시점 == 프로브 업 확인, 테이블 Y축 자재 측정 위치로 이동

                        bool bMeasure = false; //200712 jhc : 18 포인트 측정 (ASE-KR VOC)

                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if(CData.CurCompany != ECompany.Qorvo && (CData.CurCompany != ECompany.Qorvo_DZ) && CData.CurCompany != ECompany.SST)
                        if (CData.CurCompany != ECompany.Qorvo && CData.CurCompany != ECompany.Qorvo_DZ &&
                            CData.CurCompany != ECompany.Qorvo_RT && CData.CurCompany != ECompany.Qorvo_NC &&
                            CData.CurCompany != ECompany.SST)
                        {
                            //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                            dtmp = CPrb.It.Read_Val(m_eWy);
                            if ((!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)) && m_Delay.Chk_Delay())
                            {
                                m_iPrbUpCnt++;
                                if (m_iPrbUpCnt == 3)
                                {
                                    CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET :
                                                                       eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                                    _SetLog("Error : Probe up not complete.");

                                    // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                                    if (iIdx == (int)EMeaStep.Before/*0*/)
                                    {
                                        m_bSubErr = true;
                                    }

                                    m_iStep = 0;
                                    return true;
                                }
                                else
                                {
                                    Func_PrbDown(false);
                                    m_Delay.Set_Delay(GV.PRB_DELAY);//191002 ksg :
                                    _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");
                                    _SetLog("Probe up cycle retry.  Count : " + m_iPrbUpCnt);

                                    return false;
                                }
                            }

                            // 200920 jym : 프로브 업 체크 카운트 초기화
                            m_iPrbUpCnt = 0;
                        }

                        //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                        dtmp = CPrb.It.Read_Val(m_eWy);
                        if (CIO.It.Get_X(m_eIn1) && (dtmp >= GV.dProbeUpHeight))
                        {
                            //211227 pjh : Ejector off
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(false);
                            }
                            //
                            // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                            if (iIdx == (int)EMeaStep.Before/*0*/)
                            {
                                if (m_iRow >= CData.Dev.iRow * CData.Dev.iWinCnt)
                                {
                                    m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                    m_iCol++;
                                    m_iRow = 0;

                                    CMot.It.Mv_N(m_iY, m_dPosY);
                                    _SetLog("Y axis move position(before)." + m_dPosY);

                                    m_iStep = 28;
                                    return false;
                                }

                                //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                                if (CData.Parts[m_iPart].b18PMeasure)
                                { bMeasure = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].bUse18P; }
                                else
                                { bMeasure = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].bUse; }

                                if (bMeasure)
                                {
                                    m_dPosY = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dY;
                                    _SetLog("Measure point(before).  Y axis position : " + m_dPosY + "mm");
                                    m_iStep++;
                                }
                                else
                                {
                                    m_iRow++;
                                    if (m_iRow < CData.Dev.iRow * CData.Dev.iWinCnt)
                                    { return false; }
                                    else
                                    {
                                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                        m_iCol++;
                                        m_iRow = 0;
                                        _SetLog("Row end(before).  Col : " + m_iCol);

                                        m_iStep = 28;
                                    }
                                }
                            }
                            else
                            {
                                if (m_iRow >= CData.Dev.iRow * CData.Dev.iWinCnt)
                                {
                                    m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                    m_iCol++;
                                    m_iRow = 0;
                                    CMot.It.Mv_N(m_iY, m_dPosY);
                                    _SetLog("Y axis move position(after)." + m_dPosY);

                                    m_iStep = 28;
                                    return false;
                                }

                                //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                                if (CData.Parts[m_iPart].b18PMeasure)
                                { bMeasure = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].bUse18P; }
                                else
                                { bMeasure = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].bUse; }

                                if (bMeasure)
                                {
                                    m_dPosY = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dY;
                                    _SetLog("Measure point(after).  Y axis position : " + m_dPosY + "mm");
                                    m_iStep++;
                                }
                                else
                                {
                                    m_iRow++;
                                    if (m_iRow < CData.Dev.iRow * CData.Dev.iWinCnt)
                                    { return false; }
                                    else
                                    {
                                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                        m_iCol++;
                                        m_iRow = 0;
                                        _SetLog("Row end(after).  Col : " + m_iCol);

                                        m_iStep = 28;
                                    }
                                }
                            }
                        }
                        CMot.It.Mv_N(m_iY, m_dPosY);
                        _SetLog("Y axis move position.", m_dPosY);

                        return false;
                    }

                case 34:
                    {//테이블 Y축 자재 측정 위치 이동 확인, 프로브 에어 온
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        Func_PrbAir(true);
                        _SetLog("Probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 35:
                    {//프로브 에어 온 확인, 프로브 다운
                        if (!Func_PrbAir(true))
                        { return false; }

                        Func_PrbDown(true);
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 36:
                    {//프로브 다운 확인, 프로브 에어 오프
                        if (!CIO.It.Get_X(m_eIn1))
                        {
                            Func_PrbAir(false);
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }
                        return false;
                    }

                case 37:
                    {//== 반복 종료 시점 == 프로브 에어 오프 확인, 자재 높이 측정, 프로브 업, 다음 행 설정(m_iRow++), m_iStep = 28로 이동
                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            // jhLee, Multi-LOT의 경우에도 SPC 기록
                            SetMyLotInfo();     // 내부 사용 LotInfo  대입

                            m_PbOfset = CPrb.It.Read_Val(m_eWy);

                            // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                            if (iIdx == (int)EMeaStep.Before/*0*/)
                            {
                                double dGap = m_PbOfset - (m_InspOffset - m_InspZeroOffset);
                                if (CData.GrData[m_iWy].aOldOnPont[0] < dGap)
                                { CData.GrData[m_iWy].aOldOnPont[0] = m_PbOfset - (m_InspOffset - m_InspZeroOffset); }
                                _SetLog(string.Format("Ori : {0}mm  Gap : {1}mm", m_PbOfset, dGap), true);
                            }

                            m_PbOfset = m_PbOfset + CData.Dev.aData[m_iWy].dPrbOffset; //CData.MPos[0].dPRB_OFFSET;
                            m_aInspTotalTemp[m_iRow, m_iCol] = m_PbOfset;   // 2020.09.14 JSKim Add

                            // 2020.09.14 JSKim St
                            if (CData.Parts[m_iPart].bExistStrip == false || CSQ_Main.It.m_iStat == EStatus.Manual) //201014 jhc : Manual 모드
                            {
                                CData.Parts[m_iPart].dDfMin = 0.0;
                                CData.Parts[m_iPart].dDfMax = 0.0;
                                CData.Parts[m_iPart].dDfAvg = 0.0;

                                CData.Parts[m_iPart].dPcbMin = 0.0;
                                CData.Parts[m_iPart].dPcbMax = 0.0;
                                CData.Parts[m_iPart].dPcbMean = 0.0;

                            }
                            // 2020.09.14 JSKim Ed

                            if (CData.Dev.bDynamicSkip)
                            {//다이나믹 펑션 스킵
                                /// - SECSGEM 사용시 Top 의 AF 값을 BTM 진행 시 DF 대시 사용키 위함 20200301 LCY
                                /// 1. SECSGEM 사용 시 Btm Side 경우 Host에서 top Side 의 Af 값을 Down 
                                /// 2. Strip Top 측정 값 - Host에서 Down 값
                                dTemp = 0.0;
                                if (CData.Opt.bSecsUse)
                                {
                                    if (CData.Dynamic.iHeightType == 0)
                                    {
                                        dTemp = CData.Parts[m_iPart].dPcbMax;
                                        _SetLog("SECS/GEM use.  PCB Max : " + dTemp + "mm");
                                    }
                                    else
                                    {
                                        dTemp = CData.Parts[m_iPart].dPcbMean;
                                        _SetLog("SECS/GEM use.  PCB Mean : " + dTemp + "mm");
                                    }
                                }

                                m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - dTemp;
                            }
                            else
                            {//다이나믹 펑션 사용 
                                if (CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                {//DF 서버 사용시 DF측정 안할 경우 Max값으로 고정
                                    CData.Dynamic.iHeightType = 0;
                                }

                                if (CData.Dynamic.iHeightType == 0)
                                {//측정한 PCB 값중 MAX 사용
                                    if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                                    {//[GL2, GL3]
                                        m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - CData.Parts[m_iPart].dDfMax;
                                        _SetLog("DF Max : " + CData.Parts[m_iPart].dDfMax + "mm");
                                    }
                                    else
                                    {//[GL1]
                                        if (CDataOption.MeasureDf == eDfServerType.MeasureDf)
                                        {//DF 사용시 측정 사용 할경우[GL1]
                                            m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - CData.Parts[m_iPart].dPcbMax;
                                            _SetLog("PCB Max : " + CData.Parts[m_iPart].dPcbMax + "mm");
                                        }
                                        else
                                        {//DF 사용시 측정 사용 안할 경우
                                            m_aInspTemp[m_iRow, m_iCol] = m_PbOfset;
                                        }
                                    }
                                }
                                else
                                {
                                    if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                                    {
                                        m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - CData.Parts[m_iPart].dDfAvg;
                                        _SetLog("DF Avg : " + CData.Parts[m_iPart].dDfAvg + "mm");
                                    }
                                    else
                                    {
                                        m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - CData.Parts[m_iPart].dPcbMean;
                                        _SetLog("PCB Mean : " + CData.Parts[m_iPart].dPcbMean + "mm");
                                    }
                                }
                            }

                            // 센터도 옵셋 적용 가능
                            m_aInspTemp[m_iRow, m_iCol] -= (m_InspOffset - m_InspZeroOffset);
                            _SetLog("Measure value : " + m_aInspTemp[m_iRow, m_iCol] + "mm", true);

                            m_aInspTotalTemp[m_iRow, m_iCol] -= (m_InspOffset - m_InspZeroOffset);   // 2020.09.14 JSKim Add
                            _SetLog("Measure Total value : " + m_aInspTotalTemp[m_iRow, m_iCol] + "mm", true);   // 2020.09.14 JSKim Add

                            double dLimitMax = 0.0;
                            double dLimitMin = 0.0;

                            // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                            if (iIdx == (int)EMeaStep.Before/*0*/)
                            {//Before
                             //자재 높이 범위 검사
                                if (CData.Dev.bDynamicSkip || CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                {//다이나믹 펑션 스킵, DF사용시 DF 측정 안할 경우
                                    dLimitMax = CData.Dev.aData[(int)EWay.L].dTotalTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                                    dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dBfLimit;

                                    if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                                    {
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dBfLimitLower;
                                    }


#if true //201014 jhc : ASE-Kr TOP 그라인딩 결과 두께 > SECS/GEM > BTM 그라인딩
                                    //ASE-Kr Bottom Mold 기준 그라인딩 시 옵션
                                    if ((CData.CurCompany == ECompany.ASE_KR) &&                            //ASE-Kr
                                        (CData.Dev.bDynamicSkip) &&                                         //DF기능 비활성(ASE-Kr)
                                        ((CDataOption.SecsUse == eSecsGem.Use) && CData.Opt.bSecsUse) &&    //SECS/GEM 사용(TOP 두께 수신)
                                        (CData.Dev.eMoldSide == ESide.Btm) &&                         //BTM 그라인딩
                                        (CSQ_Main.It.m_iStat != EStatus.Manual))                            //AUTO-RUNNING
                                    {
                                        dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dBfLimit;
                                    }
#endif
                                }
                                else
                                {//다이나믹 펑션 사용
                                    dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                                    dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dBfLimit;

                                    if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                                    {
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dBfLimitLower;
                                    }

                                }

                                // jhLee, Multi-LOT의 경우 처리
                                if (CData.IsMultiLOT())
                                {
                                    m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dBfLimit.ToString();
                                }
                                else
                                {
                                    CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dBfLimit.ToString();
                                }

                                if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                {
                                    if (CData.Dev.bDynamicSkip || CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                    {//다이나믹 펑션 스킵, DF 사용시 DF 측정 안할 경우
                                        dLimitMax = CData.Dev.aData[m_iWy].dTotalTh + CData.Dev.aData[m_iWy].dBfLimit;
                                        dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dBfLimit;

                                        if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                                        {
                                            dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dBfLimitLower;
                                        }

#if true //201014 jhc : ASE-Kr TOP 그라인딩 결과 두께 > SECS/GEM > BTM 그라인딩
                                        //ASE-Kr Bottom Mold 기준 그라인딩 시 옵션
                                        if ((CData.CurCompany == ECompany.ASE_KR) &&                            //ASE-Kr
                                            (CData.Dev.bDynamicSkip) &&                                         //DF기능 비활성(ASE-Kr)
                                            ((CDataOption.SecsUse == eSecsGem.Use) && CData.Opt.bSecsUse) &&    //SECS/GEM 사용(TOP 두께 수신)
                                            (CData.Dev.eMoldSide == ESide.Btm) &&                               //BTM 그라인딩
                                            (CSQ_Main.It.m_iStat != EStatus.Manual))                            //AUTO-RUNNING
                                        {
                                            dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dBfLimit;
                                            dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dBfLimit;
                                        }
#endif
                                    }
                                    else
                                    {//다이나믹 펑션 사용
                                        dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dBfLimit;
                                        dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dBfLimit;

                                        if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                                        {
                                            dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dBfLimitLower;
                                        }
                                    }

                                    // jhLee, Multi-LOT의 경우 처리
                                    if (CData.IsMultiLOT())
                                    {
                                        m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[m_iWy].dBfLimit.ToString();
                                    }
                                    else
                                    {
                                        CData.SpcData.sTargetLim = CData.Dev.aData[m_iWy].dBfLimit.ToString();
                                    }
                                }

                                _SetLog(string.Format("Before.  Limit min : {0}mm  Limit max : {1}mm", dLimitMin, dLimitMax));

                                if (m_eWy == EWay.L)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dBfLimit != 0)
                                    {
                                        if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                        {//범위 벗어 났을 경우 에러 발생
                                            m_abMeaBfErr[m_iRow, m_iCol] = true;
                                            m_bMeaErrBf_L = true;

                                            _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                        }
                                    }
                                }
                                else
                                {
                                    if (CData.Dev.bDual != eDual.Dual)
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dBfLimit != 0)
                                        {
                                            if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                            {//범위 벗어 났을 경우 에러 발생
                                                m_abMeaBfErr[m_iRow, m_iCol] = true;
                                                m_bMeaErrBf_R = true;

                                                _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (CData.Dev.aData[m_iWy].dBfLimit != 0)
                                        {
                                            if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                            {//범위 벗어 났을 경우 에러 발생
                                                m_abMeaBfErr[m_iRow, m_iCol] = true;
                                                m_bMeaErrBf_R = true;

                                                _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                            }
                                        }
                                    }
                                }

                                CData.GrData[m_iWy].aMeaBf[m_iRow, m_iCol] = m_aInspTemp[m_iRow, m_iCol];
                            }
                            else
                            {//After
                                //자재 높이 범위 검사
                                // 2020.09.14 JSKim St - MeasureMode인 경우에는 Bf 랑 동일하게 검사해야 한다. 아니면 AfLimit 설정을 0으로 하던지
                                if (CData.Dev.bMeasureMode)
                                {
                                    //자재 높이 범위 검사
                                    if (CData.Dev.bDynamicSkip || CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                    {//다이나믹 펑션 스킵, DF사용시 DF 측정 안할 경우
                                        dLimitMax = CData.Dev.aData[(int)EWay.L].dTotalTh + CData.Dev.aData[(int)EWay.L].dAfLimit;
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dAfLimit;
                                    }
                                    else
                                    {//다이나믹 펑션 사용
                                        dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dAfLimit;
                                        dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dAfLimit;
                                    }

                                    // jhLee, Multi-LOT의 경우 처리
                                    if (CData.IsMultiLOT())
                                    {
                                        m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();
                                    }
                                    else
                                    {
                                        CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();
                                    }

                                    if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                    {
                                        if (CData.Dev.bDynamicSkip || CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                        {//다이나믹 펑션 스킵, DF 사용시 DF 측정 안할 경우
                                            dLimitMax = CData.Dev.aData[m_iWy].dTotalTh + CData.Dev.aData[m_iWy].dAfLimit;
                                            dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dAfLimit;
                                        }
                                        else
                                        {//다이나믹 펑션 사용
                                            dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dAfLimit;
                                            dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dAfLimit;
                                        }

                                        // jhLee, Multi-LOT의 경우 처리
                                        if (CData.IsMultiLOT())
                                        {
                                            m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();
                                        }
                                        else
                                        {
                                            CData.SpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();
                                        }
                                    }

                                    _SetLog(string.Format("After MeasureMode.  Limit min : {0}mm  Limit max : {1}mm", dLimitMin, dLimitMax));

                                    if (m_eWy == EWay.L)
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                        {
                                            if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                            {//범위 벗어 났을 경우 에러 발생
                                                m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                m_bMeaErrAf_L = true;
                                                _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (CData.Dev.bDual != eDual.Dual)
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                                {//범위 벗어 났을 경우 에러 발생
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErrAf_R = true;
                                                    _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                                }
                                            }
                                        }
                                        else
                                        {
                                            if (CData.Dev.aData[m_iWy].dAfLimit != 0)
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                                {//범위 벗어 났을 경우 에러 발생
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErrAf_R = true;
                                                    _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                                }
                                            }
                                        }
                                    }
                                }
                                else    // MeasureMode가 아닐때
                                {
                                    // 2020.09.14 JSKim Ed
                                    double dTarget = 0.0;
                                    for (int i = m_iStepMaxCnt - 1; i >= 0; i--)
                                    {
                                        if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                        {
                                            if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                            {
                                                //20191206 ghk_cal_debug -> 20201017 ksg : 원복함
                                                dTarget = CData.GrData[m_iWy].aTar[i];
                                                _SetLog(string.Format("Dual.  Target : {0}mm  Col : {1}  Row : {2}", dTarget, m_iCol, m_iRow));
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                            {
                                                //if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.Top && (m_eWy == EWay.R))
                                                if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown && (m_eWy == EWay.R)) //190717 ksg :
                                                {
                                                    //20191206 ghk_cal_debug -> 20201017 ksg : 원복함
                                                    dTarget = CData.GrData[(int)EWay.R].aTar[i];
                                                    _SetLog(string.Format("Topdown.  Target : {0}mm  Col : {1}  Row : {2}", dTarget, m_iCol, m_iRow));
                                                    break;
                                                }
                                                else
                                                {
                                                    dTarget = CData.GrData[m_iWy].aTar[i];
                                                    _SetLog(string.Format("Target : {0}mm  Col : {1}  Row : {2}", dTarget, m_iCol, m_iRow));
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                    dLimitMax = dTarget + CData.Dev.aData[(int)EWay.L].dAfLimit;  // 디폴트
                                    dLimitMin = dTarget - CData.Dev.aData[(int)EWay.L].dAfLimit;

                                    // jhLee, Multi-LOT의 경우 처리
                                    if (CData.IsMultiLOT())
                                    {
                                        m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString(); // 디폴트
                                    }
                                    else
                                    {
                                        CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();
                                    }

                                    if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                    {
                                        dLimitMax = dTarget + CData.Dev.aData[m_iWy].dAfLimit;
                                        dLimitMin = dTarget - CData.Dev.aData[m_iWy].dAfLimit;

                                        // jhLee, Multi-LOT의 경우 처리
                                        if (CData.IsMultiLOT())
                                        {
                                            //m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();
                                            m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();     // 2021.08.31 lhs : 오류 수정 (int)EWay.L -> m_iWy
                                        }
                                        else
                                        {
                                            //CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();
                                            CData.SpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();            // 2021.08.31 lhs : 오류 수정 (int)EWay.L -> m_iWy                
                                        }
                                    }

                                    _SetLog(string.Format("After.  Limit min : {0}mm  Limit max : {1}mm", dLimitMin, dLimitMax));

                                    if (m_eWy == EWay.L)
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                        {
                                            if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                            {//범위 벗어 났을 경우 에러 발생
                                                m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                m_bMeaErrAf_L = true;
                                                _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (CData.Dev.bDual != eDual.Dual)
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                                {//범위 벗어 났을 경우 에러 발생
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErrAf_R = true;
                                                    _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                                }
                                            }
                                        }
                                        else
                                        {
                                            if (CData.Dev.aData[m_iWy].dAfLimit != 0)
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                                {//범위 벗어 났을 경우 에러 발생
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErrAf_R = true;
                                                    _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                                }
                                            }
                                        }
                                    }
                                    // 2020.09.14 JSKim St
                                }
                                // 2020.09.14 JSKim Ed

                                CData.GrData[m_iWy].aMeaAf[m_iRow, m_iCol] = m_aInspTemp[m_iRow, m_iCol];
                                _SetLog("Measure value : " + m_aInspTemp[m_iRow, m_iCol] + "mm", true);
                            }
                            //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(true);
                            }
                            Func_PrbDown(false);
                            m_Delay.Set_Delay(GV.PRB_DELAY); //191002 ksg :
                            _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

                            // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                            if (iIdx == (int)EMeaStep.Before/*0*/)
                            {
                                Array.Copy(m_aInspTemp, m_aInspBf, m_aInspTemp.Length);
                                Array.Copy(m_aInspTotalTemp, m_aInspTotalBf, m_aInspTemp.Length);     // 2020.09.14 JSKim Add
                            }
                            else
                            {
                                Array.Copy(m_aInspTemp, m_aInspAf, m_aInspTemp.Length);
                                Array.Copy(m_aInspTotalTemp, m_aInspTotalAf, m_aInspTemp.Length);     // 2020.09.14 JSKim Add
                            }
                            m_iRow++;

                            m_iStep = 33;
                        }

                        return false;
                    }

                case 38:
                    {//프로브 x축 포지션 0으로 이동
                        //211229 pjh : Probe Up Check
                        if(!CIO.It.Get_X(m_eIn1) && !m_Delay.Chk_Delay())
                        { return false; }
                        //
                        //211227 pjh : Ejector off
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(false);
                        }
                        //

                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                        _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                        if (CSpc.It.ChkOpenSaveDataCsv(m_eWy))
                        {
                            m_Delay.Set_Delay(1000);
                            _SetLog("Set delay : 1000ms");
                        }
                        else
                        {
                            m_Delay.Set_Delay(0);
                            _SetLog("Set delay : 0ms");
                        }

                        if ((CData.Opt.bSecsUse == true) && (CData.GemForm != null))
                        {
                            // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                            // 2021.07.19 SungTae Start : [수정] Data Shift 시 확인이 용이하도록 수정
                            if (iIdx == (int)EMeaStep.Before/*0*/)
                            {// Before Measure
                                if (m_eWy == EWay.L)
                                {
                                    //CData.GemForm.Strip_Data_Shift(6, 7);// L Chuck Data -> Befor Data 로 이동
                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRL_TBL_CHUCK/*6*/, (int)EDataShift.GRL_BF_MEAS/*7*/);// L Chuck Data -> Befor Data 로 이동
                                }
                                else
                                {
                                    //CData.GemForm.Strip_Data_Shift(12, 13);// R Chuck Data -> R Befor Data 로 이동
                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_TBL_CHUCK/*12*/, (int)EDataShift.GRR_BF_MEAS/*13*/);// R Chuck Data -> R Befor Data 로 이동
                                }
                            }
                            else
                            {// After Measure
                                if (m_eWy == EWay.L)
                                {
                                    //CData.GemForm.Strip_Data_Shift(7, 10);// L Before Data -> L After Data 로 이동
                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRL_BF_MEAS/*7*/, (int)EDataShift.GRL_AF_MEAS/*10*/);// L Before Data -> L After Data 로 이동
                                }
                                else
                                {
                                    //if (CData.Dev.bDShiftPSkip) CData.GemForm.Strip_Data_Shift(12, 13);// R Chuck Data -> R Befor Data 로 이동
                                    //CData.GemForm.Strip_Data_Shift(13, 16);// R Befor Data -> R After Data 로 이동
                                    if (CData.Dev.bDShiftPSkip)
                                    {
                                        CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_TBL_CHUCK/*12*/, (int)EDataShift.GRR_BF_MEAS/*13*/);// R Chuck Data -> R Befor Data 로 이동
                                    }

                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_BF_MEAS/*13*/, (int)EDataShift.GRR_AF_MEAS/*16*/);// R Befor Data -> R After Data 로 이동
                                }
                            }
                            // 2021.07.19 SungTae End
                        }

                        m_iStep++;
                        return false;
                    }

                case 39:
                    {
                        if (!m_Delay.Chk_Delay())
                        { return false; }
                        _SetLog("Check delay.");

                        m_iStep++;
                        return false;
                    }

                case 40:    //Temp 측정 값 Before or After에 복사, m_iCol = 0, m_iRow = 0, m_iStep = 0;        
                    {
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            Array.Copy(m_aInspTemp, m_aInspBf, m_aInspTemp.Length);
                            Array.Copy(m_aInspTotalTemp, m_aInspTotalBf, m_aInspTemp.Length);     // 2020.09.14 JSKim Add
                            CSpc.It.SaveDataCsv(m_eWy, "BEFORE", m_aInspBf, CData.Parts[m_iPart].dPcb);
                            if (CData.LotInfo.bLotOpen && CSQ_Main.It.m_iStat != EStatus.Manual) //191115 ksg :
                            {
                                // 2020.09.14 JSKim St
                                //CSpc.It.SaveLotDataCsv(m_eWy, "BEFORE", m_aInspBf, CData.Parts[m_iPart].dPcb);
                                if (CData.CurCompany == ECompany.SCK || CData.CurCompany == ECompany.JSCK)
                                {
                                    CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "BEFORE", m_aInspBf, CData.Parts[m_iPart].dPcb, m_aInspTotalBf);
                                }
                                else
                                {
                                    CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "BEFORE", m_aInspBf, CData.Parts[m_iPart].dPcb);
                                }
                                // 2020.09.14 JSKim Ed
                            }

                            // 200722 jym : min max avg 계산
                            double dMax = 0;
                            double dMin = 0;
                            double dAvg = 0;

                            _Cal_MMA(m_aInspBf, out dMin, out dMax, out dAvg);

                            CData.PbResultVal[m_iWy].dBMax = dMax;
                            CData.PbResultVal[m_iWy].dBMin = dMin;
                            CData.PbResultVal[m_iWy].dBAvg = dAvg;

                            //2020.12.09 lhs Start  
                            // Error Strip 도 저장 (Skyworks VOC)
                            if (CData.CurCompany == ECompany.SkyWorks)
                            {
                                if (CData.LotInfo.bLotOpen)
                                {
                                    if (m_bMeaErrBf_L || m_bMeaErrBf_R)
                                    {
                                        string sTemp = (iIdx == 0) ? "BEFORE_ERROR" : "AFTER_ERROR";
                                        CSpc.It.SaveDataIni(ref m_myLotInfo, m_eWy, sTemp, m_aInspTemp);  // Error Strip 
                                    }
                                }
                            }
                            //2020.12.09 lhs End

                            if (m_eWy == EWay.L)
                            {
                                if (m_bMeaErrBf_L)
                                {
                                    CErr.Show(eErr.LEFT_GRIND_RANGEOVER_WHEN_BEFORE_MEASURE_STRIP);
                                    _SetLog("Error : Range over when before measure strip.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (m_bMeaErrBf_R)
                                {
                                    CErr.Show(eErr.RIGHT_GRIND_RANGEOVER_WHEN_BEFORE_MEASURE_STRIP);
                                    _SetLog("Error : Range over when before measure strip.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }
                        else
                        {
                            Array.Copy(m_aInspTemp, m_aInspAf, m_aInspTemp.Length);
                            Array.Copy(m_aInspTotalTemp, m_aInspTotalAf, m_aInspTemp.Length);   // 2020.09.14 JSKim Add
                            //190528 ksg :
                            if (m_eWy == EWay.L)
                            {
                                Array.Copy(m_aInspTemp, m_aInspShift, m_aInspTemp.Length); //190528 ksg :
                            }

                            CSpc.It.SaveDataCsv(m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb);
                            if (CData.LotInfo.bLotOpen && CSQ_Main.It.m_iStat != EStatus.Manual) //191115 ksg :
                            {
                                // 2020.09.14 JSKim St
                                //CSpc.It.SaveLotDataCsv(m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb);
                                if (CData.CurCompany == ECompany.SCK || CData.CurCompany == ECompany.JSCK)
                                // 2020.10.21 JSKim Ed
                                {
                                    CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb, m_aInspTotalAf);
                                }
                                else
                                {
                                    CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb);
                                }
                                // 2020.09.14 JSKim Ed
                            }

                            // 200722 jym : min max avg 계산
                            double dMax = 0;
                            double dMin = 0;
                            double dAvg = 0;

                            _Cal_MMA(m_aInspAf, out dMin, out dMax, out dAvg);

                            CData.PbResultVal[m_iWy].dAMax = dMax;
                            CData.PbResultVal[m_iWy].dAMin = dMin;
                            CData.PbResultVal[m_iWy].dAAvg = dAvg;

                            //2020.12.09 lhs Start  
                            // Error Strip 도 저장 (Skyworks VOC)
                            if (CData.CurCompany == ECompany.SkyWorks)
                            {
                                if (CData.LotInfo.bLotOpen)
                                {
                                    if (m_bMeaErrAf_L || m_bMeaErrAf_R)
                                    {
                                        string sTemp = (iIdx == 0) ? "BEFORE_ERROR" : "AFTER_ERROR";
                                        CSpc.It.SaveDataIni(ref m_myLotInfo, m_eWy, sTemp, m_aInspTemp);  // Error Strip 
                                    }
                                }
                            }
                            //2020.12.09 lhs End

                            if (m_eWy == EWay.L)
                            {
                                if (m_bMeaErrAf_L)
                                {
                                    CErr.Show(eErr.LEFT_GRIND_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                    _SetLog("Error : Range over when after measure strip.");

                                    // 201009 jym : Before 측정 시에만 적용
                                    //m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (m_bMeaErrAf_R)
                                {
                                    CErr.Show(eErr.RIGHT_GRIND_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                    _SetLog("Error : Range over when after measure strip.");

                                    // 201009 jym : Before 측정 시에만 적용
                                    //m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }

                        //20190618 ghk_dfserver
                        if (m_eWy == EWay.L && CData.Dev.bDual == eDual.Dual && iIdx == 1)
                        {
                            m_iStep = 45;
                            return false;
                        }

                        if (m_eWy == EWay.R && CData.Dev.bDual == eDual.Dual && iIdx == 0)
                        {
                            m_iStep = 45;
                            return false;
                        }

                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            m_iCol = 0;
                            m_iRow = 0;
                            m_sRowData = "";
                            _SetLog("DF Server.");

                            m_iStep++;
                        }
                        else
                        {
                            _SetLog("DF Server not use.");
                            m_iStep = 45;
                        }

                        return false;
                    }

                case 41:
                    {
                        if (m_eWy == EWay.L)
                        { CData.GRLDfData.sRow = "R" + m_iRow.ToString("D2"); }
                        else
                        { CData.GRRDfData.sRow = "R" + m_iRow.ToString("D2"); }

                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            if (m_iRow < m_aInspBf.GetLength(0))
                            {
                                if (m_iCol < m_aInspBf.GetLength(1))
                                {
                                    if (m_aInspBf[m_iRow, m_iCol] == 0)
                                    {
                                        m_sRowData += ".";
                                    }
                                    else
                                    {
                                        m_sRowData += m_aInspBf[m_iRow, m_iCol];
                                    }
                                    if (m_iCol < (m_aInspBf.GetLength(1) - 1))
                                    {
                                        m_sRowData += ",";
                                    }
                                    m_iCol++;
                                }
                                else
                                { m_iStep++; }
                                return false;
                            }
                            else
                            {
                                if (!CData.dfInfo.bBusy)
                                {
                                    CDf.It.SendBfEnd((m_eWy == EWay.L) ? "LGD" : "RGD");
                                    m_iStep = 44;
                                }
                                else
                                { return false; }
                            }
                        }
                        else
                        {
                            if (m_iRow < m_aInspAf.GetLength(0))
                            {
                                if (m_iCol < m_aInspAf.GetLength(1))
                                {
                                    if (m_aInspAf[m_iRow, m_iCol] == 0)
                                    {
                                        m_sRowData += ".";
                                    }
                                    else
                                    {
                                        m_sRowData += m_aInspAf[m_iRow, m_iCol];
                                    }
                                    if (m_iCol < (m_aInspAf.GetLength(1) - 1))
                                    {
                                        m_sRowData += ",";
                                    }
                                    m_iCol++;
                                }
                                else
                                { m_iStep++; }
                                return false;
                            }
                            else
                            {
                                if (!CData.dfInfo.bBusy)
                                {
                                    CDf.It.SendAfEnd((m_eWy == EWay.L) ? "LGD" : "RGD");
                                    m_iStep = 44;
                                }
                                else
                                { return false; }
                            }
                        }
                        return false;
                    }

                case 42:
                    {
                        if (!CData.dfInfo.bBusy)
                        {
                            CDf.It.SendGrdRowData((m_eWy == EWay.L) ? "LGD" : "RGD", m_sRowData);
                            m_iStep++;
                        }

                        return false;
                    }

                case 43:
                    {
                        if (m_eWy == EWay.L)
                        {
                            if (CDf.It.ReciveAckGRL((int)ECMD.scRowL))
                            {
                                m_sRowData = "";
                                m_iRow++;
                                m_iCol = 0;
                                m_iStep = 41;
                            }
                        }
                        else
                        {
                            if (CDf.It.ReciveAckGRR((int)ECMD.scRowR))
                            {
                                m_sRowData = "";
                                m_iRow++;
                                m_iCol = 0;
                                m_iStep = 41;
                            }
                        }
                        return false;
                    }

                case 44:
                    {
                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            if (m_eWy == EWay.L)
                            {
                                if (!CDf.It.ReciveAckGRL((int)ECMD.scBfEndL))
                                { return false; }
                            }
                            else
                            {
                                if (!CDf.It.ReciveAckGRR((int)ECMD.scBfEndR))
                                { return false; }
                            }
                        }
                        else
                        {
                            if (m_eWy == EWay.L)
                            {
                                if (!CDf.It.ReciveAckGRL((int)ECMD.scAfEndL))
                                { return false; }
                            }
                            else
                            {
                                if (!CDf.It.ReciveAckGRR((int)ECMD.scAfEndR))
                                { return false; }
                            }
                        }

                        m_iStep++;
                        return false;
                    }

                case 45:
                    {
                        m_iCol = 0;
                        m_iRow = 0;

                        // jhLee, Multi-LOT의 경우에도 SPC 기록
                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)  // Before 측정 Data
                        {
                            double dMax = CData.PbResultVal[m_iWy].dBMax;
                            double dMin = CData.PbResultVal[m_iWy].dBMin;
                            double dMean = CData.PbResultVal[m_iWy].dBAvg;
                            int iCnt = 0;

                            for (int iRow = 0; iRow < m_aInspBf.GetLength(0); iRow++)
                            {
                                for (int iCol = 0; iCol < m_aInspBf.GetLength(1); iCol++)
                                {
                                    if (m_aInspBf[iRow, iCol] != 0)
                                    {
                                        CData.m_dPbVal[m_iWy].m_BFVal.Add(m_aInspBf[iRow, iCol]); //191120 ksg :
                                                                                                  //191118 ksg :
                                        if (CData.GemForm != null)
                                        {//Before 측정 Data 
                                            if (m_eWy == EWay.L)
                                            {
                                                CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Data[1, iCnt] = m_aInspBf[iRow, iCol];// Left 측정 Data
                                                CData.GemForm.Log_wt(string.Format("Left before Data = {0},{1}", iCnt, float.Parse(CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Data[1, iCnt].ToString())));
                                            }
                                            else
                                            {
                                                CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Data[5, iCnt] = m_aInspBf[iRow, iCol];// Right 측정 Data
                                                CData.GemForm.Log_wt(string.Format("Right before Data = {0},{1}", iCnt, float.Parse(CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Data[5, iCnt].ToString())));
                                            }
                                        }
                                        iCnt++;
                                    }
                                }
                            }

                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)
                                {
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].nMeasure_Count[1] = iCnt;
                                    CData.GemForm.Log_wt(string.Format("Left before Cnt = {0},{1}", iCnt, CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].nMeasure_Count[1]));
                                }
                                else
                                {
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].nMeasure_Count[5] = iCnt;
                                    CData.GemForm.Log_wt(string.Format("Right before Cnt = {0},{1}", iCnt, CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].nMeasure_Count[5]));
                                }
                            }

                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)
                                {// Left Befor
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Min_Data[1] = dMin;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Max_Data[1] = dMax;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Avr_Data[1] = dMean;
                                }
                                else
                                {// Right Befor
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Min_Data[5] = dMin;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Max_Data[5] = dMax;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Avr_Data[5] = dMean;
                                }
                            }

                            //20190531 ghk
                            CData.PbResultVal[m_iWy].dBMean = Math.Round(((dMax + dMin) / 2), 4); //190502 ksg :
                            if (m_eWy == EWay.L)
                            {
                                if (CData.Dev.bDynamicSkip)
                                {
                                    if (CData.PbResultVal[m_iWy].dBMax <= CData.MPos[0].dPCBThickness || CData.PbResultVal[m_iWy].dBMin >= 999)
                                    {
                                        CErr.Show(eErr.LEFT_BEFORE_PROBE_DATA_LOST);

                                        m_bSubErr = true;

                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                                else
                                {
                                    if ((CData.PbResultVal[m_iWy].dBMax + CData.Parts[(int)EPart.GRDL].dPcbMax) <= CData.MPos[0].dPCBThickness || (CData.PbResultVal[m_iWy].dBMin + CData.Parts[(int)EPart.GRDL].dPcbMax) >= 999)
                                    {
                                        CErr.Show(eErr.LEFT_BEFORE_PROBE_DATA_LOST);

                                        m_bSubErr = true;

                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                            }
                            else
                            {
                                if (CData.Dev.bDynamicSkip)
                                {
                                    if (CData.PbResultVal[m_iWy].dBMax <= CData.MPos[0].dPCBThickness || CData.PbResultVal[m_iWy].dBMin >= 999)
                                    {
                                        CErr.Show(eErr.RIGHT_BEFORE_PROBE_DATA_LOST);

                                        m_bSubErr = true;

                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                                else
                                {
                                    if ((CData.PbResultVal[m_iWy].dBMax + CData.Parts[(int)EPart.GRDR].dPcbMax) <= CData.MPos[0].dPCBThickness || (CData.PbResultVal[m_iWy].dBMin + CData.Parts[(int)EPart.GRDL].dPcbMax) >= 999)
                                    {
                                        CErr.Show(eErr.RIGHT_BEFORE_PROBE_DATA_LOST);

                                        m_bSubErr = true;

                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                            }

                        }
                        else  //After 측정 Data
                        {
                            double dMax = CData.PbResultVal[m_iWy].dAMax;
                            double dMin = CData.PbResultVal[m_iWy].dAMin;
                            double dMean = CData.PbResultVal[m_iWy].dAAvg;
                            int iCnt = 0;

                            // 2021-05-14, jhLee, Multi-LOT, 현재 가공중인 Strip의 LOT Name을 사용하도록 한다.
                            if (CData.IsMultiLOT()) { CData.SpcData.sLotName = CData.Parts[m_iPart].sLotName;   } // Multi-LOT일 경우 가공중인 Strip의 Lot 이름을 사용한다.
                            else                    { CData.SpcData.sLotName = CData.LotInfo.sLotName;          }

                            for (int iRow = 0; iRow < m_aInspAf.GetLength(0); iRow++)
                            {
                                for (int iCol = 0; iCol < m_aInspAf.GetLength(1); iCol++)
                                {
                                    if (m_aInspAf[iRow, iCol] != 0)
                                    {
                                        CData.m_dPbVal[m_iWy].m_AFVal.Add(m_aInspAf[iRow, iCol]); //191120 ksg :

                                        if (CData.GemForm != null)
                                        {
                                            if (m_eWy == EWay.L)
                                            {
                                                CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Data[4, iCnt] = m_aInspAf[iRow, iCol];
                                                CData.GemForm.Log_wt(string.Format("Left After Data = {0},{1}", iCnt, float.Parse(CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Data[4, iCnt].ToString())));
                                            }
                                            else
                                            {
                                                CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Data[6, iCnt] = m_aInspAf[iRow, iCol];
                                                CData.GemForm.Log_wt(string.Format("Right After Data = {0},{1}", iCnt, float.Parse(CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Data[6, iCnt].ToString())));
                                            }
                                        }
                                        iCnt++;
                                    }
                                }
                            }
                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)
                                {
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].nMeasure_Count[4] = iCnt;
                                    CData.GemForm.Log_wt(string.Format("Left After Cnt = {0},{1}", iCnt, CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].nMeasure_Count[4]));
                                }
                                else
                                {
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].nMeasure_Count[6] = iCnt;
                                    CData.GemForm.Log_wt(string.Format("Right After Cnt = {0},{1}", iCnt, CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].nMeasure_Count[6]));
                                }
                            }
                            if (m_eWy == EWay.L)
                            {
                                // jhLee, Multi-LOT의 경우 처리
                                if (CData.IsMultiLOT()) {   m_myLotInfo.rSpcData.sTtvLim    = CData.Dev.aData[(int)EWay.L].dTTV.ToString(); }
                                else                    {   CData.SpcData.sTtvLim           = CData.Dev.aData[(int)EWay.L].dTTV.ToString(); }

                                if (CData.Dev.aData[(int)EWay.L].dTTV != 0)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dTTV < (dMax - dMin))
                                    {
                                        //2020.12.09 lhs Start  
                                        // Error Strip 도 저장 (Skyworks VOC)
                                        if (CData.CurCompany == ECompany.SkyWorks)
                                        {
                                            if (CData.LotInfo.bLotOpen)
                                            {
                                                string sTemp = (iIdx == 0) ? "BEFORE_ERROR" : "AFTER_ERROR";
                                                CSpc.It.SaveDataIni(ref m_myLotInfo, m_eWy, sTemp, m_aInspTemp);  // Error Strip 
                                            }
                                        }
                                        //2020.12.09 lhs End

                                        CErr.Show(eErr.LEFT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                        _SetLog("Error : TTV Range over when after measure strip.");

                                        // 201009 jym : Before 측정 시에만 적용
                                        //m_bSubErr = true;

                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                            }
                            else
                            {
                                if (CData.Dev.bDual == eDual.Dual)
                                {
                                    // jhLee, Multi-LOT의 경우 처리
                                    if (CData.IsMultiLOT()) {   m_myLotInfo.rSpcData.sTtvLim    = CData.Dev.aData[m_iWy].dTTV.ToString();   }
                                    else                    {   CData.SpcData.sTtvLim           = CData.Dev.aData[m_iWy].dTTV.ToString();   }

                                    if (CData.Dev.aData[m_iWy].dTTV != 0)
                                    {
                                        if (CData.Dev.aData[m_iWy].dTTV < (dMax - dMin))
                                        {
                                            // 2020.12.09 lhs Start  
                                            // Error Strip 도 저장 (Skyworks VOC)
                                            if (CData.CurCompany == ECompany.SkyWorks)
                                            {
                                                if (CData.LotInfo.bLotOpen)
                                                {
                                                    string sTemp = (iIdx == 0) ? "BEFORE_ERROR" : "AFTER_ERROR";
                                                    CSpc.It.SaveDataIni(ref m_myLotInfo, m_eWy, sTemp, m_aInspTemp);  // Error Strip 
                                                }
                                            }
                                            // 2020.12.09 lhs End

                                            CErr.Show(eErr.RIGHT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                            _SetLog("Error : TTV Range over when after measure strip.");

                                            // 201009 jym : Before 측정 시에만 적용
                                            //m_bSubErr = true;

                                            m_iStep = 0;
                                            return true;
                                        }
                                    }
                                }
                                else
                                {
                                    // jhLee, Multi-LOT의 경우 처리
                                    if (CData.IsMultiLOT()) {   m_myLotInfo.rSpcData.sTtvLim    = CData.Dev.aData[(int)EWay.L].dTTV.ToString(); }
                                    else                    {   CData.SpcData.sTtvLim           = CData.Dev.aData[(int)EWay.L].dTTV.ToString(); }

                                    if (CData.Dev.aData[(int)EWay.L].dTTV != 0)
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dTTV < (dMax - dMin))
                                        {
                                            // 2020.12.09 lhs Start  
                                            // Error Strip 도 저장 (Skyworks VOC)
                                            if (CData.CurCompany == ECompany.SkyWorks)
                                            {
                                                if (CData.LotInfo.bLotOpen)
                                                {
                                                    string sTemp = (iIdx == 0) ? "BEFORE_ERROR" : "AFTER_ERROR";
                                                    CSpc.It.SaveDataIni(ref m_myLotInfo, m_eWy, sTemp, m_aInspTemp);  // Error Strip 
                                                }
                                            }
                                            // 2020.12.09 lhs End

                                            CErr.Show(eErr.RIGHT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                            _SetLog("Error : TTV Range over when after measure strip.");

                                            // 201009 jym : Before 측정 시에만 적용
                                            //m_bSubErr = true;

                                            m_iStep = 0;
                                            return true;
                                        }
                                    }
                                }
                            }

                            if (CData.GemForm != null)
                            {
                                //dTemp = (CData.Dev.eMoldSide == ESide.Top) ? CData.Parts[m_iPart].dPcbMean : 0.0;   // 2020.09.11 JSKim Del
                                if (m_eWy == EWay.L)
                                {   // SECSGEM Host에 Data Upload 진행  20200301 LCY 
                                    // Top Side : Mold_높이 + DF 측정 Data
                                    // Bottom Side : Mold 높이
                                    if      (CData.Dev.eMoldSide == ESide.Top)    dTemp = CData.Parts[(int)EPart.GRDL].dPcbMean;
                                    else                                          dTemp = 0.0;

                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Min_Data[4] = dMin + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Max_Data[4] = dMax + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Avr_Data[4] = dMean + dTemp;
                                    
                                    _SetLog("Func Call : CData.GemForm.OnCarrierGrindFinished(1)");

                                    // 2021.10.19 SungTae Start : [수정] (ASE-KR VOC) SECS/GEM Issue 관련 조건 추가
                                    //CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N1);
                                    if (!CData.bChkGrdM)
                                    {
                                        CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N1);
                                    }
                                    // 2021.10.19 SungTae End
                                }
                                else
                                {   // SECSGEM Host에 Data Upload 진행  20200301 LCY
                                    // Top Side : Mold_높이 + DF 측정 Data
                                    // Bottom Side : Mold 높이
                                    if      (CData.Dev.eMoldSide == ESide.Top)    dTemp = CData.Parts[(int)EPart.GRDR].dPcbMean;
                                    else                                          dTemp = 0.0;

                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Min_Data[6] = dMin + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Max_Data[6] = dMax + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Avr_Data[6] = dMean + dTemp;
                                    
                                    _SetLog("Func Call : CData.GemForm.OnCarrierGrindFinished(2)");

                                    // 2021.10.19 SungTae Start : [수정] (ASE-KR VOC) SECS/GEM Issue 관련 조건 추가
                                    //CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N2);
                                    if (!CData.bChkGrdM)
                                    {
                                        CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N2);
                                    }
                                    // 2021.10.19 SungTae End
                                }
                            }

                            if (CData.PbResultVal[m_iWy].dBMax <= 0 || CData.PbResultVal[m_iWy].dBMin >= 999)
                            {
                                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_BEFORE_PROBE_DATA_LOST :
                                                              eErr.RIGHT_BEFORE_PROBE_DATA_LOST);
                                _SetLog("Error : Before probe data lost.");

                                //201010 jhc : Before 측정 시에만 적용
                                //m_bSubErr = true;

                                m_iStep = 0;
                                return true;
                            }

                            if (CData.LotInfo.bLotOpen)
                            {
                                // jhLee, Multi-LOT의 경우 처리
                                if (CData.IsMultiLOT())
                                {
                                    m_myLotInfo.rSpcData.sTtvLim = CData.Dev.aData[(int)EWay.L].dTTV.ToString();
                                    
                                    m_myLotInfo.rSpcData.sMgzNo  = CData.Parts[m_iPart].iMGZ_No.ToString();
                                    m_myLotInfo.rSpcData.sSlotNo = CData.Parts[m_iPart].iSlot_No.ToString();
                                    m_myLotInfo.rSpcData.sTable  = (m_eWy == EWay.L) ? "L" : "R";
                                    m_myLotInfo.rSpcData.sBcr    = CData.Parts[m_iPart].sBcr;
                                    m_myLotInfo.rSpcData.sMode   = (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown) ? "TopDown" : "Target";

                                    if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                    {
                                        CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_AfterMeaStrip : ESeq.GRR_AfterMeaStrip;
                                    }

                                    m_myLotInfo.rSpcData.sMax   = dMax.ToString();
                                    m_myLotInfo.rSpcData.sMin   = dMin.ToString();
                                    m_myLotInfo.rSpcData.sMean  = dMean.ToString();
                                    m_myLotInfo.rSpcData.sTtv   = (dMax - dMin).ToString();
                                    m_myLotInfo.rSpcData.sBMax  = CData.PbResultVal[m_iWy].dBMax.ToString();
                                    m_myLotInfo.rSpcData.sBMin  = CData.PbResultVal[m_iWy].dBMin.ToString();
                                    m_myLotInfo.rSpcData.sBAvg  = CData.PbResultVal[m_iWy].dBAvg.ToString();

                                    for (int i = m_iStepMaxCnt - 1; i >= 0; i--)
                                    {
                                        if (CData.Dev.bDual == eDual.Dual)
                                        {
                                            if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                            {
                                                m_myLotInfo.rSpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                m_myLotInfo.rSpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                            {
                                                if (CData.Dev.aData[(int)EWay.L].eGrdMod == eGrdMode.TopDown)
                                                {
                                                    m_myLotInfo.rSpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                    m_myLotInfo.rSpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                }
                                                else
                                                {
                                                    m_myLotInfo.rSpcData.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                    m_myLotInfo.rSpcInfo.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                }
                                                break;
                                            }
                                        }
                                    }

                                    if (CData.CurCompany == ECompany.ASE_KR)    {   CSpc.It.SaveLotData_Add(ref m_myLotInfo);   }
                                    else                                        {   CSpc.It.SaveLotData(m_myLotInfo);           }
                                }
                                else  // MultiLOT이 아닐 경우
                                {
                                    CData.SpcData.sMgzNo    = CData.Parts[m_iPart].iMGZ_No.ToString();
                                    CData.SpcData.sSlotNo   = CData.Parts[m_iPart].iSlot_No.ToString();
                                    CData.SpcData.sTable    = (m_eWy == EWay.L) ? "L" : "R";
                                    CData.SpcData.sBcr      = CData.Parts[m_iPart].sBcr;
                                    CData.SpcData.sMode     = (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown) ? "TopDown" : "Target";
                                    
                                    if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                    {
                                        CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_AfterMeaStrip : ESeq.GRR_AfterMeaStrip;
                                    }
                                    
                                    CData.SpcData.sMax      = dMax.ToString();
                                    CData.SpcData.sMin      = dMin.ToString();
                                    CData.SpcData.sMean     = dMean.ToString();
                                    CData.SpcData.sTtv      = (dMax - dMin).ToString();
                                    CData.SpcData.sBMax     = CData.PbResultVal[m_iWy].dBMax.ToString();
                                    CData.SpcData.sBMin     = CData.PbResultVal[m_iWy].dBMin.ToString();
                                    CData.SpcData.sBAvg     = CData.PbResultVal[m_iWy].dBAvg.ToString();

                                    for (int i = m_iStepMaxCnt - 1; i >= 0; i--)
                                    {
                                        if (CData.Dev.bDual == eDual.Dual)
                                        {
                                            if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                            {
                                                CData.SpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                CData.SpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                            {
                                                if (CData.Dev.aData[(int)EWay.L].eGrdMod == eGrdMode.TopDown)
                                                {
                                                    CData.SpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                    CData.SpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                }
                                                else
                                                {
                                                    CData.SpcData.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                    CData.SpcInfo.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                }
                                                break;
                                            }
                                        }
                                    }

                                    if (CData.CurCompany == ECompany.ASE_KR)    { CSpc.It.SaveLotData_Add();    }
                                    else                                        { CSpc.It.SaveLotData();        }
                                }


                                //190529 ksg :
                                if (m_eWy == EWay.L && CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown)
								{
                                    if (CData.IsMultiLOT())
                                    {
                                        double.TryParse(m_myLotInfo.rSpcInfo.sTarget, out CData.Parts[(int)EPart.GRDL].dShiftT);
                                    }
                                    else
                                    {
                                        double.TryParse(CData.SpcInfo.sTarget, out CData.Parts[(int)EPart.GRDL].dShiftT);
                                    }

                                    // CData.Parts[(int)EPart.GRDL].dShiftT = Convert.ToDouble(CData.SpcInfo.sTarget);
                                }

                                //200325 ksg : Data Shift Probe Skip
                                if (m_eWy == EWay.L && CData.Dev.bDShiftPSkip && CData.Dev.bDual == eDual.Dual)
                                { CData.Parts[(int)EPart.GRDL].dShiftT = dMax; }
                            }
                        } // end : After 측정 Data

                        if (CData.LotInfo.bLotOpen)
                        {
                            string sTemp = (iIdx == 0) ? "BEFORE" : "AFTER";
                            CSpc.It.SaveDataIni(ref m_myLotInfo, m_eWy, sTemp, m_aInspTemp);

                            if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                            {
                                CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_AfterMeaStrip : ESeq.GRR_AfterMeaStrip;
                            }
                        }

                        _SetLog("Finish.  Status : " + CData.Parts[m_iPart].iStat);

                        _SetLog("===== Measure Strip End =====");

                        m_iStep = 0;
                        return true;
                    }

                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스
                case 100:
                    {//Z축 대기 위치 이동, 프로브 에어 오프
                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        { m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy]; }
                        else
                        { m_dPosZ = CData.SPos.dGRD_Z_Wait[m_iWy]; }
                        CMot.It.Stop(m_iZ);
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move position.", m_dPosZ);
                        Func_PrbAir(false);

                        m_iStep++;
                        return false;
                    }

                case 101:
                    {//Z축 대기 위치 이동 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }

                        if (m_iPickerVacErr == 1)
                        { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else
                        { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        _SetLog("Picker Vacuum ERROR " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            m_bSubErr = true;
                        }

                        m_iStep = 0;
                        return true;
                    }
                    ///////////////////////////////////////////////////////////////////////////////////////
            }
        }
        //end of public bool Cyl_MeaStrip_Probe(int iIdx) 



        /// <summary>
        /// Unit Thickness Measure
        /// 유닛 두께 측정 함수 0:Before, 1:After
        /// </summary>
        /// <param name="iIdx"></param>
        /// <returns></returns>
        public bool Cyl_MeaUnit(int iIdx)
        {
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                    if (iIdx == (int)EMeaStep.Before/*0*/)
                    {
                        if (m_eWy == EWay.L)
                        { CErr.Show(eErr.LEFT_GRIND_STRIP_INSPECTION_BEFORE_TIMEOUT); }
                        else
                        { CErr.Show(eErr.RIGHT_GRIND_STRIP_INSPECTION_BEFORE_TIMEOUT); }
                        _SetLog("Error : Before timeout.");
                    }
                    else
                    {
                        if (m_eWy == EWay.L)
                        { CErr.Show(eErr.LEFT_GRIND_STRIP_INSPECTION_AFTER_TIMEOUT); }
                        else
                        { CErr.Show(eErr.RIGHT_GRIND_STRIP_INSPECTION_AFTER_TIMEOUT); }
                        _SetLog("Error : After timeout.");
                    }

                    m_bSubErr = true;

                    m_iStep = 0;
                    return true;
                }
            }

            // 200316 mjy : Unit 버큠 항시 체크
            if (!Chk_Unit())
            {
                if (m_eWy == EWay.L)
                { CErr.Show(eErr.LEFT_GRIND_VACUUM_ERROR); }
                else
                { CErr.Show(eErr.RIGHT_GRIND_VACUUM_ERROR); }
                _SetLog("Error : Check unit.");

                m_bSubErr = true;

                m_iStep = 0;
                return true;
            }

            m_iPreStep = m_iStep;

            if (m_eWy == EWay.L) m_LogVal.sStatus = "GRL_Cyl_MeaStrip";
            else m_LogVal.sStatus = "GRR_Cyl_MeaStrip";

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if ((CData.CurCompany == ECompany.ASE_KR) && 
                (m_iStep == 17 || m_iStep == 18 || m_iStep == 46 || m_iStep == 47 || m_iStep == 60 || m_iStep == 61))
            {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                if (0 != m_iPickerVacErr)
                {
                    CMot.It.EStop(m_iY); //Table Y축 즉시 Stop

                    _SetLog("ERROR : Picker Vacuum : " + m_siY + " STOP : " + CMot.It.Get_FP(m_iY).ToString());

                    m_iStep = 200; //정리 스텝으로
                    return false;
                }
            }
            ///////////////////////////////////////////////////////////////////////////////////////

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10: // Axes check
                    {
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes(true))
                        {
                            m_iStep = 0;
                            return true;
                        }

                        m_bSubErr = false;

                        _SetLog("Check axes.");

                        m_iStep++;
                        return false;
                    }

                case 11: // Variable initialize
                    {
                        m_iUnit = CData.Dev.iUnitCnt - 1;

                        m_bMeaErrBf_L = false;
                        m_bMeaErrAf_L = false;
                        m_bMeaErrBf_R = false;
                        m_bMeaErrAf_R = false;
                        _SetLog("Init variable.  Unit count : " + m_iUnit);

                        // jhLee, Multi-LOT의 경우에도 SPC 기록
                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        m_iStep++;
                        return false;
                    }

                case 12: // Probe array initialize
                    {
                        //190319 ksg :
                        ProbeClearVal(iIdx);

                        //190717 ksg : 데이터 클리어 요청
                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if(CData.CurCompany == ECompany.Qorvo || (CData.CurCompany == ECompany.Qorvo_DZ) || CData.CurCompany == ECompany.SST) && iIdx == 0)
                        if((CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ ||
                            CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC ||
                            CData.CurCompany == ECompany.SST) && iIdx == 0)
                        {
                            ProbeClearVal(iIdx + 1);
                        } //191202 ksg :

                        //191120 ksg :
                        InitPbValue(m_iWy, iIdx);
                        _SetLog("Init probe.");

                        m_iStep++;
                        return false;
                    }

                case 13: // IO initialize
                    {
                        _InitCycle();

                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_ProbeDn;
                            m_eOt2 = eY.GRDL_ProbeAir;
                            m_eIn1 = eX.GRDL_ProbeAMP;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_ProbeDn;
                            m_eOt2 = eY.GRDR_ProbeAir;
                            m_eIn1 = eX.GRDR_ProbeAMP;
                        }

                        _SetLog("Init cylce.");

                        m_iStep++;
                        return false;
                    }

                case 14: // Inspection data variable initialize
                    {
                        m_iRow = 0;
                        m_iCol = 0;
                        m_dPosX = CData.SPos.dGRD_X_Zero[m_iWy];
                        m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS;
                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];

                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            m_aInspBf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            m_abMeaBfErr = new bool[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];

                            CData.GrData[m_iWy].aMeaBf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            for (int iU = 0; iU < CData.Dev.iUnitCnt; iU++)
                            {
                                CData.GrData[m_iWy].aUnit[iU].aMeaBf = new double[CData.Dev.iRow, CData.Dev.iCol];
                                CData.GrData[m_iWy].aUnit[iU].aErrBf = new bool[CData.Dev.iRow, CData.Dev.iCol];
                            }

                            //190717 ksg : 새로운 자재 투입시 전후 데이터 클리어
                            // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                            //if(CData.CurCompany == ECompany.Qorvo || (CData.CurCompany == ECompany.Qorvo_DZ) || CData.CurCompany == ECompany.SST) //191202 ksg :
                            if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ ||
                                CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC ||
                                CData.CurCompany == ECompany.SST)
                            {
                                m_aInspAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                                m_abMeaAfErr = new bool[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];

                                CData.GrData[m_iWy].aMeaAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                                for (int iU = 0; iU < CData.Dev.iUnitCnt; iU++)
                                {
                                    CData.GrData[m_iWy].aUnit[iU].aMeaAf = new double[CData.Dev.iRow, CData.Dev.iCol];
                                    CData.GrData[m_iWy].aUnit[iU].aErrAf = new bool[CData.Dev.iRow, CData.Dev.iCol];
                                }
                            }

                        }
                        else
                        {
                            m_aInspAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            m_abMeaAfErr = new bool[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];

                            CData.GrData[m_iWy].aMeaAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            for (int iU = 0; iU < CData.Dev.iUnitCnt; iU++)
                            {
                                CData.GrData[m_iWy].aUnit[iU].aMeaAf = new double[CData.Dev.iRow, CData.Dev.iCol];
                                CData.GrData[m_iWy].aUnit[iU].aErrAf = new bool[CData.Dev.iRow, CData.Dev.iCol];
                            }

                            //190528 ksg :
                            if (m_eWy == EWay.L)
                            {
                                m_aInspShift = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            }
                        }

                        m_aInspTemp = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];

                        _SetLog("Init array.");

                        //2021.08.06 syc : Up상태일때 Probe 값 정상 범위 인지 확인
                        //- Qorvo 프로브 앰프값 자동으로 바뀌는 이슈에 대한 방지책
                        //- Probe 값이 18.9xxx ~ 19.0xxx 범위 이탈시 알람
                        if (Chk_ProbeUpVal())
                        {
                            m_bSubErr = true;//211006 pjh : 측정 Error 시 Cycle Stop

                            m_iStep = 0;
                            return true;
                        }

                        m_iStep++;
                        return false;
                    }

                case 15: // Z axis move inspection position
                    {
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move position.", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 16: // Z axis move inspection position check
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ)) 
                        { return false; }
                        _SetLog("Z axis move check.");

                        m_iStep++;
                        return false;
                    }

                case 17: // Y axis move table inspection position
                    {
                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]);
                        _SetLog("Y axis move table base.", CData.SPos.dGRD_Y_TblInsp[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 18: // Y axis move table inspection position check
                    {
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]))
                        { return false; }
                        _SetLog("Y axis move check.");

                        m_iStep++;
                        return false;
                    }

                case 19: // X axis move zero position
                    {
                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                        _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 20: // X axis move zero position check
                    {
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }
                        _SetLog("X axis move check.");

                        m_iStep++;
                        return false;
                    }

                case 21: // Probe air on check
                    {
                        if (!ActPrbAir(true))
                        { return false; }
                        _SetLog("Probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 22: // Probe down
                    {
                        if (!ActPrbDown(true))
                        { return false; }
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 23: // Probe down check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = !CIO.It.Get_X(eX.GRDL_ProbeAMP); }
                        else
                        { bRet = !CIO.It.Get_X(eX.GRDR_ProbeAMP); }

                        if (!bRet)
                        { return false; }
                        _SetLog("Probe down check.");

                        m_iStep++;
                        return false;
                    }

                case 24: // Probe air off check
                    {
                        if (ActPrbAir(false))
                        { return false; }
                        _SetLog("Probe air check.");

                        m_iStep++;
                        return false;
                    }

                case 25: // Probe down set delay
                    {
                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        _SetLog("Set delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 26: // Probe down delay check
                    {
                        if (!m_tmPrb.Chk_Delay())
                        { return false; }
                        _SetLog("Check delay.");

                        m_iStep++;
                        return false;
                    }

                case 27: // Read probe value and calculate table thickness
                    {
                        CData.Tbl_Af[m_iWy, 0] = CPrb.It.Read_Val(m_eWy) + GV.EQP_TABLE_MIN_THICKNESS;

                        // Manual zig 여부 판단
                        if (CData.Tbl_Af[m_iWy, 0] > (GV.EQP_TABLE_MIN_THICKNESS + 4))
                        {
                            if (m_iWy == (int)EWay.L)
                            { CErr.Show(eErr.LEFT_GRIND_MANUALZIG_ON_THE_TABLE); }
                            else
                            { CErr.Show(eErr.RIGHT_GRIND_MANUALZIG_ON_THE_TABLE); }
                            _SetLog("Error : Manual zig on table.  Table : " + CData.Tbl_Af[m_iWy, 0] + "mm");

                            m_bSubErr = true;

                            m_iStep = 0;
                            m_iGStep = 0;
                            return true;
                        }

                        _SetLog("Table : " + CData.Tbl_Af[m_iWy, 0] + "mm");

                        m_iStep++;
                        return false;
                    }

                case 28: // Probe up
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Set_Y(eY.GRDL_ProbeDn, false); }
                        else
                        { bRet = CIO.It.Set_Y(eY.GRDR_ProbeDn, false); }

                        if (!bRet) return false;
                        _SetLog("Probe up.");

                        m_iStep++;
                        return false;
                    }

                case 29: // Probe up set delay
                    {
                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        _SetLog("Set dealy : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 30: // Probe up check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Get_X(eX.GRDL_ProbeAMP); }
                        else
                        { bRet = CIO.It.Get_X(eX.GRDR_ProbeAMP); }

                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if(CData.CurCompany != ECompany.Qorvo && (CData.CurCompany != ECompany.Qorvo_DZ) && CData.CurCompany != ECompany.SST)
                        if (CData.CurCompany != ECompany.Qorvo && CData.CurCompany != ECompany.Qorvo_DZ &&
                            CData.CurCompany != ECompany.Qorvo_RT && CData.CurCompany != ECompany.Qorvo_NC &&
                            CData.CurCompany != ECompany.SST)
                        {
                            //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                            //if (!CIO.It.Get_X(m_eIn1) && m_tmPrb.Chk_Delay())
                            dtmp = CPrb.It.Read_Val(m_eWy);
                            if ((!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)) && m_tmPrb.Chk_Delay())
                            {
                                if (m_eWy == EWay.L)
                                {
                                    CErr.Show(eErr.LEFT_PROBE_UP_NOT_COMPLET);
                                    _SetLog("Error : Probe up not complete.");

                                    m_iStep = 0;
                                    return true;
                                }
                                else
                                {
                                    CErr.Show(eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                                    _SetLog("Error : Probe up not complete.");

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }

                        if (!bRet) return false;
                        _SetLog("Check probe up.");

                        m_iStep++;
                        return false;
                    }

                case 31: // Z axis move table base zero position
                    {
                        //프로브 테이블 측정시 0인 위치로 이동
                        m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0];
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move position.", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 32: // Z axis move table base zero position check
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }
                        _SetLog("Check Z axis move.");

                        m_iStep++;
                        return false;
                    }

                case 33: // Probe air on check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Set_Y(eY.GRDL_ProbeAir, true); }
                        else
                        { bRet = CIO.It.Set_Y(eY.GRDR_ProbeAir, true); }

                        if (!bRet) return false;
                        _SetLog("Check probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 34: // Probe down
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Set_Y(eY.GRDL_ProbeDn, true); }
                        else
                        { bRet = CIO.It.Set_Y(eY.GRDR_ProbeDn, true); }

                        if (!bRet) return false;
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 35: // Probe down check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = !CIO.It.Get_X(eX.GRDL_ProbeAMP); }
                        else
                        { bRet = !CIO.It.Get_X(eX.GRDR_ProbeAMP); }

                        if (!bRet) return false;
                        _SetLog("Check probe down.");

                        m_iStep++;
                        return false;
                    }

                case 36: // Probe air off check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Set_Y(eY.GRDL_ProbeAir, false); }
                        else
                        { bRet = CIO.It.Set_Y(eY.GRDR_ProbeAir, false); }

                        if (!bRet) return false;
                        _SetLog("Probe air off.");

                        m_iStep++;
                        return false;
                    }

                case 37: // Probe down set delay
                    {
                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        _SetLog("Set delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 38: // Probe down delay check
                    {
                        if (!m_tmPrb.Chk_Delay())
                        { return false; }
                        _SetLog("Check delay.");

                        m_iStep++;
                        return false;
                    }

                case 39: // Read probe value
                    {
                        m_InspZeroOffset = CPrb.It.Read_Val(m_eWy);
                        _SetLog("Probe value : " + m_InspZeroOffset + "mm");

                        m_iStep++;
                        return false;
                    }

                case 40: // Probe up
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Set_Y(eY.GRDL_ProbeDn, false); }
                        else
                        { bRet = CIO.It.Set_Y(eY.GRDR_ProbeDn, false); }

                        if (!bRet) return false;
                        _SetLog("Probe up.");

                        m_iStep++;
                        return false;
                    }

                case 41: // Probe up set delay
                    {
                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        _SetLog("Set delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 42: // Probe up check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Get_X(eX.GRDL_ProbeAMP); }
                        else
                        { bRet = CIO.It.Get_X(eX.GRDR_ProbeAMP); }

                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if(CData.CurCompany != ECompany.Qorvo && (CData.CurCompany != ECompany.Qorvo_DZ) && CData.CurCompany != ECompany.SST)
                        if (CData.CurCompany != ECompany.Qorvo && CData.CurCompany != ECompany.Qorvo_DZ &&
                            CData.CurCompany != ECompany.Qorvo_RT && CData.CurCompany != ECompany.Qorvo_NC &&
                            CData.CurCompany != ECompany.SST)
                        {
                            //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                            //if (!CIO.It.Get_X(m_eIn1) && m_tmPrb.Chk_Delay())
                            dtmp = CPrb.It.Read_Val(m_eWy);
                            if ((!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)) && m_tmPrb.Chk_Delay())
                            {
                                if (m_eWy == EWay.L)
                                {
                                    CErr.Show(eErr.LEFT_PROBE_UP_NOT_COMPLET);
                                    _SetLog("Error : Probe up not complete.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                                else
                                {
                                    CErr.Show(eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                                    _SetLog("Error : Probe up not complete.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }

                        if (!bRet) return false;
                        _SetLog("Check probe up.");

                        m_iStep++;
                        return false;
                    }

                // ======> 반복 시작
                case 43: // Column
                    {
                        bool bTemp = false;
                        if (m_iCol < CData.Dev.iCol)
                        {
                            for (int i = 0; i < CData.Dev.iRow; i++)
                            {//해당 열의 모든행에 사용자가 설정한 측정 포인트가 있는지 검사
                                // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                                if (iIdx == (int)EMeaStep.Before/*0*/)
                                { bTemp = CData.Dev.aData[m_iWy].aPosBf[i, m_iCol].bUse; }
                                else
                                { bTemp = CData.Dev.aData[m_iWy].aPosAf[i, m_iCol].bUse; }

                                // 측정 값 존재 시 for문 탈출
                                if (bTemp) { break; }
                            }

                            if (bTemp)
                            {   // 해당 열에 측정 포인트 존재 할 시 프로브축 포지션 획득
                                // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                                if (iIdx == (int)EMeaStep.Before/*0*/)
                                { m_dPosX = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX; }
                                else
                                { m_dPosX = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX; }

                                _SetLog(string.Format("Column : {0}  Row : {1}", m_iCol, m_iRow));

                                m_iStep++;
                            }
                            else
                            {   // 측정 포인트 없어 다음 열로 이동
                                m_iCol++;
                                return false;
                            }
                        }
                        else
                        {
                            // 측정 종료
                            _SetLog("Loop end.");
                            m_iStep = 100;
                        }

                        return false;
                    }

                case 44: // X axis move position
                    {
                        CMot.It.Mv_N(m_iX, m_dPosX);
                        _SetLog("X axis move position.", m_dPosX);

                        m_iStep++;
                        return false;
                    }

                case 45: // X axis move position check
                    {
                        if (!CMot.It.Get_Mv(m_iX, m_dPosX))
                        {
                            CMot.It.Mv_N(m_iX, m_dPosX);
                            return false;
                        }
                        _SetLog("Check X axis move.");

                        m_iStep++;
                        return false;
                    }

                case 46: // Y axis move table inspection position
                    {
                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]);
                        _SetLog("Y axis move table base.", CData.SPos.dGRD_Y_TblInsp[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 47: // Y axis move table inspection position check
                    {
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]))
                        {
                            CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]);
                            return false;
                        }
                        _SetLog("Check Y axis move.");

                        m_iStep++;
                        return false;
                    }

                case 48: // Probe air on check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Set_Y(eY.GRDL_ProbeAir, true); }
                        else
                        { bRet = CIO.It.Set_Y(eY.GRDR_ProbeAir, true); }

                        if (!bRet) return false;
                        _SetLog("Probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 49: // Probe down
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Set_Y(eY.GRDL_ProbeDn, true); }
                        else
                        { bRet = CIO.It.Set_Y(eY.GRDR_ProbeDn, true); }

                        if (!bRet) return false;
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 50: // Probe down check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = !CIO.It.Get_X(eX.GRDL_ProbeAMP); }
                        else
                        { bRet = !CIO.It.Get_X(eX.GRDR_ProbeAMP); }

                        if (!bRet) return false;
                        _SetLog("Check probe down.");

                        m_iStep++;
                        return false;
                    }

                case 51: // Probe air off check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Set_Y(eY.GRDL_ProbeAir, false); }
                        else
                        { bRet = CIO.It.Set_Y(eY.GRDR_ProbeAir, false); }

                        if (!bRet) return false;
                        _SetLog("Check probe air off");

                        m_iStep++;
                        return false;
                    }

                case 52: // Probe down set delay
                    {
                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        _SetLog("Set delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 53: // Probe down delay check
                    {
                        if (!m_tmPrb.Chk_Delay())
                        { return false; }
                        _SetLog("Check delay.");

                        m_iStep++;
                        return false;
                    }

                case 54: // Read probe value
                    {
                        // 200319 syc :  
                        m_InspOffset = CPrb.It.Read_Val(m_eWy);
                        _SetLog("Probe value : " + m_InspOffset + "mm");

                        m_iStep++;
                        return false;
                    }

                case 55: // Probe up
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Set_Y(eY.GRDL_ProbeDn, false); }
                        else
                        { bRet = CIO.It.Set_Y(eY.GRDR_ProbeDn, false); }

                        if (!bRet) return false;
                        _SetLog("Probe up.");

                        m_iStep++;
                        return false;
                    }

                case 56: // Probe up set delay
                    {
                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        _SetLog("Set delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 57: // Probe up check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Get_X(eX.GRDL_ProbeAMP); }
                        else
                        { bRet = CIO.It.Get_X(eX.GRDR_ProbeAMP); }

                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if(CData.CurCompany != ECompany.Qorvo && (CData.CurCompany != ECompany.Qorvo_DZ) && CData.CurCompany != ECompany.SST)
                        if (CData.CurCompany != ECompany.Qorvo && CData.CurCompany != ECompany.Qorvo_DZ &&
                            CData.CurCompany != ECompany.Qorvo_RT && CData.CurCompany != ECompany.Qorvo_NC &&
                            CData.CurCompany != ECompany.SST)
                        {
                            //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                            //if (!CIO.It.Get_X(m_eIn1) && m_tmPrb.Chk_Delay())
                            dtmp = CPrb.It.Read_Val(m_eWy);
                            if ((!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)) && m_tmPrb.Chk_Delay())
                            {
                                if (m_eWy == EWay.L)
                                {
                                    CErr.Show(eErr.LEFT_PROBE_UP_NOT_COMPLET);
                                    _SetLog("Error : Probe up not complete.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                                else
                                {
                                    CErr.Show(eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                                    _SetLog("Error : Probe up not complete.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }

                        if (!bRet) return false;
                        _SetLog("Check probe up.");

                        m_iStep++;
                        return false;
                    }

                case 58: // Find insepction unit index
                    {
                        // 200317 jhc : 배열 overflow 선 체크
                        if (m_iUnit < 0)
                        {
                            // 현재 Row, Column에서 Unit 검사 끝
                            m_iRow = 0;
                            m_iUnit = CData.Dev.iUnitCnt - 1;
                            m_iCol++;
                            _SetLog(string.Format("Loop1.  Col : {0}  Row : {1}  Unit : {2}", m_iCol, m_iRow, m_iUnit));

                            m_iStep = 43;
                            return false;
                        }
                        if (!CData.GrData[m_iWy].aUnitEx[m_iUnit])
                        {
                            m_iUnit -= 1;
                            return false;
                        }

                        _SetLog(string.Format("Loop2.  Col : {0}  Row : {1}  Unit : {2}", m_iCol, m_iRow, m_iUnit));
                        m_iStep++;
                        return false;
                    }

                case 59: // Row calculate
                    {
                        if (m_iRow >= CData.Dev.iRow)
                        {   // Row 갯수 만큼 검사 끝
                            m_iRow = 0;
                            // 200317 jhc : 다음 Unit 검사
                            m_iUnit--;
                            _SetLog(string.Format("Loop.  Col : {0}  Row : {1}  Unit : {2}", m_iCol, m_iRow, m_iUnit));

                            m_iStep = 58;
                            return false;
                        }

                        bool bTemp = false;

                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        { bTemp = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].bUse; }
                        else
                        { bTemp = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].bUse; }

                        if (bTemp)
                        {   // 현재 Row에 측정 값이 존재
                            // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                            if (iIdx == (int)EMeaStep.Before/*0*/)
                            { m_dPosY = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].aY[m_iUnit]; }
                            else
                            { m_dPosY = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].aY[m_iUnit]; }
                            
                            _SetLog(string.Format("Row find meausre point.  Col : {0}  Row : {1}", m_iCol, m_iRow));

                            m_iStep++;
                        }
                        else
                        {   // 현재 Row에 측정 값이 없어 다음 Row로 이동
                            m_iRow++;
                        }

                        return false;
                    }                

                case 60: // Y axis move inspection position
                    {
                        CMot.It.Mv_N(m_iY, m_dPosY);
                        _SetLog("Y axis move position.", m_dPosY);

                        m_iStep++;
                        return false;
                    }

                case 61: // Y axis move inspection position check
                    {
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }
                        _SetLog("Check Y axis move.");

                        m_iStep++;
                        return false;
                    }

                case 62: // Probe air on check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Set_Y(eY.GRDL_ProbeAir, true); }
                        else
                        { bRet = CIO.It.Set_Y(eY.GRDR_ProbeAir, true); }

                        if (!bRet) return false;
                        _SetLog("Probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 63: // Probe down
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Set_Y(eY.GRDL_ProbeDn, true); }
                        else
                        { bRet = CIO.It.Set_Y(eY.GRDR_ProbeDn, true); }

                        if (!bRet) return false;
                        _SetLog("Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 64: // Probe down check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = !CIO.It.Get_X(eX.GRDL_ProbeAMP); }
                        else
                        { bRet = !CIO.It.Get_X(eX.GRDR_ProbeAMP); }

                        if (!bRet) return false;
                        _SetLog("Check probe down.");

                        m_iStep++;
                        return false;
                    }

                case 65: // Probe air off check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Set_Y(eY.GRDL_ProbeAir, false); }
                        else
                        { bRet = CIO.It.Set_Y(eY.GRDR_ProbeAir, false); }

                        if (!bRet) return false;
                        _SetLog("Probe air off.");

                        m_iStep++;
                        return false;
                    }

                case 66: // Probe down set delay
                    {
                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        _SetLog("Set delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 67: // Probe down delay check
                    {
                        if (!m_tmPrb.Chk_Delay())
                        { return false; }
                        _SetLog("Check delay.");

                        m_iStep++;
                        return false;
                    }

                case 68: // Read probe value
                    {
                        double dLimitMax = 0.0;
                        double dLimitMin = 0.0;
                        double dVal = 0.0;

                        m_PbOfset = CPrb.It.Read_Val(m_eWy);

                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            double NewGap = m_PbOfset - (m_InspOffset - m_InspZeroOffset);
                            if (CData.GrData[m_iWy].aOldOnPont[0] < NewGap)
                            { CData.GrData[m_iWy].aOldOnPont[0] = m_PbOfset - (m_InspOffset - m_InspZeroOffset); }
                        }
                        _SetLog("Original value : " + m_PbOfset + "mm");

                        m_PbOfset = m_PbOfset + CData.Dev.aData[m_iWy].dPrbOffset; //190502 ksg : 
                        _SetLog("RNR : " + CData.Dev.aData[m_iWy].dPrbOffset + "mm");

                        /// - SECSGEM 사용시 Top 의 AF 값을 BTM 진행 시 DF 대시 사용키 위함 20200301 LCY
                        /// 1. SECSGEM 사용 시 Btm Side 경우 Host에서 top Side 의 Af 값을 Down 
                        /// 2. Strip Top 측정 값 - Host에서 Down 값
                        dTemp = 0.0;
                        if ((CData.Opt.bSecsUse) && (CData.Dev.eMoldSide == ESide.Top) && (m_eWy == EWay.L))
                        {
                            if (CData.Dynamic.iHeightType == 0)
                            { dTemp = CData.Parts[(int)EPart.GRDL].dPcbMax; }
                            else
                            { dTemp = CData.Parts[(int)EPart.GRDL].dPcbMean; }
                        }
                        dVal = m_PbOfset + dTemp;

                        //190514 ksg : 센터도 옵셋 적용 가능
                        //CData.GrData[m_iWy].aUnit[m_iUnit].aMeaBf[m_iRow, m_iCol] -= (m_InspOffset - m_InspZeroOffset);
                        dVal -= (m_InspOffset - m_InspZeroOffset);

                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            dLimitMax = CData.Dev.aData[(int)EWay.L].dTotalTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                            dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dBfLimit;
                            CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dBfLimit.ToString();

                            if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                            {
                                dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dBfLimitLower;
                            }


                            if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                            {
                                dLimitMax = CData.Dev.aData[m_iWy].dTotalTh + CData.Dev.aData[m_iWy].dBfLimit;
                                dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dBfLimit;
                                CData.SpcData.sTargetLim = CData.Dev.aData[m_iWy].dBfLimit.ToString();

                                if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                                {
                                    dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dBfLimitLower;
                                }
                            }

                            if (m_eWy == EWay.L)
                            {
                                if (CData.Dev.aData[(int)EWay.L].dBfLimit != 0)
                                {
                                    if ((dVal > dLimitMax) || (dVal < dLimitMin))
                                    {   //범위 벗어 났을 경우 에러 발생
                                        CData.GrData[m_iWy].aUnit[m_iUnit].aErrBf[m_iRow, m_iCol] = true;
                                        m_bMeaErrBf_L = true;
                                    }
                                }
                            }
                            else
                            {
                                if (CData.Dev.bDual != eDual.Dual)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dBfLimit != 0)
                                    {
                                        if ((dVal > dLimitMax) || (dVal < dLimitMin))
                                        {   //범위 벗어 났을 경우 에러 발생
                                            CData.GrData[m_iWy].aUnit[m_iUnit].aErrBf[m_iRow, m_iCol] = true;
                                            m_bMeaErrBf_R = true;
                                        }
                                    }
                                }
                                else
                                {
                                    if (CData.Dev.aData[m_iWy].dBfLimit != 0)
                                    {
                                        if ((dVal > dLimitMax) || (dVal < dLimitMin))
                                        {   //범위 벗어 났을 경우 에러 발생
                                            CData.GrData[m_iWy].aUnit[m_iUnit].aErrBf[m_iRow, m_iCol] = true;
                                            m_bMeaErrBf_R = true;
                                        }
                                    }
                                }
                            }

                            CData.GrData[m_iWy].aUnit[m_iUnit].aMeaBf[m_iRow, m_iCol] = Math.Round(dVal, GV.MEA_POINT);
                            _SetLog("Final value : " + dVal + "mm");
                        }
                        else
                        {
                            // 200708 jym : After data에 옵셋 기능 추가
                            if (CDataOption.IsFakeAf)
                            {
                                dVal += CData.Dev.aFake[m_iWy];
                                _SetLog("Fake offset : " + CData.Dev.aFake[m_iWy] + "mm");
                            }

                            // 210426 jym
                            if (CData.CurCompany == ECompany.Qorvo_DZ)
                            {
                                dVal += CData.MPos[m_iWy].fake;
                                _SetLog("After data offset : " + CData.MPos[m_iWy].fake + "mm");
                            }

                            //자재 높이 범위 검사
                            double dTarget = 0.0;
                            //200414 ksg : 12 Step  기능 추가
                            //for (int i = 3; i >= 0; i--)
                            //for(int i = GV.StepMaxCnt - 1; i >= 0; i--)
                            for (int i = m_iStepMaxCnt - 1; i >= 0; i--)        // 2020.09.08 SungTae : modify
                            {
                                if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                {
                                    if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                    {
                                        //191206 ghk_cal_debug -> 20201017 ksg : 원복함
                                        dTarget = CData.GrData[m_iWy].aTar[i];
                                        _SetLog("1. Target : " + dTarget + "mm  Step : " + i);
                                        break;
                                    }
                                }
                                else
                                {
                                    if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                    {
                                        if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown && (m_eWy == EWay.R)) //190717 ksg :
                                        {
                                            //20191206 ghk_cal_debug -> 20201017 ksg : 원복함
                                            dTarget = CData.GrData[(int)EWay.R].aTar[i];
                                            _SetLog("2. Target : " + dTarget + "mm  Step : " + i);
                                            break;
                                        }
                                        else if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.Target)
                                        {
                                            //200414 jym : 수정
                                            dTarget = CData.Dev.aData[(int)EWay.L].aSteps[i].dTotalDep;
                                            _SetLog("3. Target : " + dTarget + "mm  Step : " + i);
                                            break;
                                        }
                                        else
                                        {
                                            //200414 jym : 수정
                                            dTarget = CData.GrData[(int)EWay.L].aTar[i];
                                            _SetLog("4. Target : " + dTarget + "mm  Step : " + i);
                                            break;
                                        }
                                    }
                                }
                            }

                            dLimitMax = dTarget + CData.Dev.aData[(int)EWay.L].dAfLimit;
                            dLimitMin = dTarget - CData.Dev.aData[(int)EWay.L].dAfLimit;

                            CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();
                            if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                            {
                                dLimitMax = dTarget + CData.Dev.aData[m_iWy].dAfLimit;
                                dLimitMin = dTarget - CData.Dev.aData[m_iWy].dAfLimit;

                                CData.SpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();
                            }

                            if (m_eWy == EWay.L)
                            {
                                if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                {
                                    if ((dVal > dLimitMax) || (dVal < dLimitMin))
                                    {//범위 벗어 났을 경우 에러 발생
                                        CData.GrData[m_iWy].aUnit[m_iUnit].aErrAf[m_iRow, m_iCol] = true;
                                        m_bMeaErrAf_L = true;
                                        _SetLog(string.Format("Limit fail.  Min : {0}mm  Max : {1}mm  Val : {2}mm", dLimitMin, dLimitMax, dVal));
                                    }
                                }
                            }
                            else
                            {
                                if (CData.Dev.bDual != eDual.Dual)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                    {
                                        if ((dVal > dLimitMax) || (dVal < dLimitMin))
                                        {//범위 벗어 났을 경우 에러 발생
                                            CData.GrData[m_iWy].aUnit[m_iUnit].aErrAf[m_iRow, m_iCol] = true;
                                            m_bMeaErrAf_R = true;
                                            _SetLog(string.Format("Limit fail(normal).  Min : {0}mm  Max : {1}mm  Val : {2}mm", dLimitMin, dLimitMax, dVal));
                                        }
                                    }
                                }
                                else
                                {
                                    if (CData.Dev.aData[m_iWy].dAfLimit != 0)
                                    {
                                        if ((dVal > dLimitMax) || (dVal < dLimitMin))
                                        {//범위 벗어 났을 경우 에러 발생
                                            CData.GrData[m_iWy].aUnit[m_iUnit].aErrAf[m_iRow, m_iCol] = true;
                                            m_bMeaErrAf_R = true;
                                            _SetLog(string.Format("Limit fail(dual).  Min : {0}mm  Max : {1}mm  Val : {2}mm", dLimitMin, dLimitMax, dVal));
                                        }
                                    }
                                }
                            }

                            CData.GrData[m_iWy].aUnit[m_iUnit].aMeaAf[m_iRow, m_iCol] = Math.Round(dVal, GV.MEA_POINT);
                            _SetLog("Final value : " + dVal + "mm");
                        }

                        m_iStep++;
                        return false;
                    }

                case 69: // Probe up
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Set_Y(eY.GRDL_ProbeDn, false); }
                        else
                        { bRet = CIO.It.Set_Y(eY.GRDR_ProbeDn, false); }

                        if (!bRet) return false;
                        _SetLog("Probe up.");

                        m_iStep++;
                        return false;
                    }

                case 70: // Probe up set delay
                    {
                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        _SetLog("Set delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 71: // Probe up check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Get_X(eX.GRDL_ProbeAMP); }
                        else
                        { bRet = CIO.It.Get_X(eX.GRDR_ProbeAMP); }

                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if(CData.CurCompany != ECompany.Qorvo && (CData.CurCompany != ECompany.Qorvo_DZ) && CData.CurCompany != ECompany.SST)
                        if (CData.CurCompany != ECompany.Qorvo && CData.CurCompany != ECompany.Qorvo_DZ &&
                            CData.CurCompany != ECompany.Qorvo_RT && CData.CurCompany != ECompany.Qorvo_NC &&
                            CData.CurCompany != ECompany.SST)
                        {
                            //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                            //if (!CIO.It.Get_X(m_eIn1) && m_tmPrb.Chk_Delay())
                            dtmp = CPrb.It.Read_Val(m_eWy);
                            if ((!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)) && m_tmPrb.Chk_Delay())
                            {
                                if (m_eWy == EWay.L)
                                {
                                    CErr.Show(eErr.LEFT_PROBE_UP_NOT_COMPLET);
                                    _SetLog("Probe up not complete.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                                else
                                {
                                    CErr.Show(eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                                    _SetLog("Probe up not complete.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }

                        if (!bRet) return false;

                        // 현재 Row 측정 종료 다음 Row로 이동
                        m_iRow++;
                        _SetLog("Loop.  Row : " + m_iRow);

                        m_iStep = 59;
                        return false;
                    }

                // 측정 반복 종료
                case 100: // X axis move zero position
                    {
                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                        _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 101: // Check csv file
                    {
                        if (CSpc.It.ChkOpenSaveDataCsv(m_eWy))
                        {
                            m_Delay.Set_Delay(1000);
                            _SetLog("Set delay : 1000ms");
                        }
                        else
                        {
                            m_Delay.Set_Delay(0);
                            _SetLog("Set delay : 0ms");
                        }

                        m_iStep++;
                        return false;
                    }

                case 102: // SECSGEM
                    {
                        if ((CData.Opt.bSecsUse == true) && (CData.GemForm != null))
                        {
                            // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                            // 2021.07.19 SungTae Start : [수정] Data Shift 시 확인이 용이하도록 수정
                            if (iIdx == (int)EMeaStep.Before/*0*/)
                            {// Before Measure
                                if (m_eWy == EWay.L)
                                {
                                    //CData.GemForm.Strip_Data_Shift(6, 7);// L Chuck Data -> Befor Data 로 이동
                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRL_TBL_CHUCK/*6*/, (int)EDataShift.GRL_BF_MEAS/*7*/);// L Chuck Data -> Befor Data 로 이동
                                }
                                else
                                {
                                    //CData.GemForm.Strip_Data_Shift(12, 13);// R Chuck Data -> R Befor Data 로 이동
                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_TBL_CHUCK/*12*/, (int)EDataShift.GRR_BF_MEAS/*13*/);// R Chuck Data -> R Befor Data 로 이동
                                }
                            }
                            else
                            {// After Measure
                                if (m_eWy == EWay.L)
                                {
                                    //CData.GemForm.Strip_Data_Shift(7, 10);// L Before Data -> L After Data 로 이동
                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRL_BF_MEAS/*7*/, (int)EDataShift.GRL_AF_MEAS/*10*/);// L Before Data -> L After Data 로 이동
                                }
                                else
                                {
                                    //if (CData.Dev.bDShiftPSkip) CData.GemForm.Strip_Data_Shift(12, 13);// R Chuck Data -> R Befor Data 로 이동
                                    //CData.GemForm.Strip_Data_Shift(13, 16);// R Befor Data -> R After Data 로 이동
                                    if (CData.Dev.bDShiftPSkip)
                                    {
                                        CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_TBL_CHUCK/*12*/, (int)EDataShift.GRR_BF_MEAS/*13*/);// R Chuck Data -> R Befor Data 로 이동
                                    }

                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_BF_MEAS/*13*/, (int)EDataShift.GRR_AF_MEAS/*16*/);// R Befor Data -> R After Data 로 이동
                                }
                            }
                            // 2021.07.19 SungTae End
                        }

                        _SetLog("SECS/GEM");

                        m_iStep++;
                        return false;
                    }

                case 103: // Check delay
                    {
                        if (!m_Delay.Chk_Delay())
                        { return false; }
                        _SetLog("Check delay.");

                        m_iStep++;
                        return false;
                    }

                case 104: // X axis move zero position check
                    {
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }
                        _SetLog("Check X axis move.");

                        m_iStep++;
                        return false;
                    }

                case 105:
                    {//Temp 측정 값 Before or After에 복사, m_iCol = 0, m_iRow = 0, m_iStep = 0;

                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {   // Before
                            CSpc.It.SaveDataCsvU(m_eWy, "BEFORE");
                            if (CData.LotInfo.bLotOpen && CSQ_Main.It.m_iStat != EStatus.Manual) //191115 ksg :
                            { CSpc.It.SaveLotDataCsvU(ref m_myLotInfo, m_eWy, "BEFORE"); }

                            //190714 ksg : 저장 후 Error 발생
                            if (m_eWy == EWay.L)
                            {
                                if (m_bMeaErrBf_L)
                                {
                                    CErr.Show(eErr.LEFT_GRIND_RANGEOVER_WHEN_BEFORE_MEASURE_STRIP);
                                    _SetLog("Error : Before measure rangeover.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (m_bMeaErrBf_R)
                                {
                                    CErr.Show(eErr.RIGHT_GRIND_RANGEOVER_WHEN_BEFORE_MEASURE_STRIP);
                                    _SetLog("Error : Before measure rangeover.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }
                        else
                        {   // After
                            //190528 ksg :
                            if (m_eWy == EWay.L)
                            { Array.Copy(m_aInspTemp, m_aInspShift, m_aInspTemp.Length); } //190528 ksg :                            

                            CSpc.It.SaveDataCsvU(m_eWy, "AFTER");
                            if (CData.LotInfo.bLotOpen && CSQ_Main.It.m_iStat != EStatus.Manual) //191115 ksg :
                            { CSpc.It.SaveLotDataCsvU(ref m_myLotInfo, m_eWy, "AFTER"); }

                            //190714 ksg : 저장 후 알람 발생
                            if (m_eWy == EWay.L)
                            {
                                if (m_bMeaErrAf_L)
                                {
                                    CErr.Show(eErr.LEFT_GRIND_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                    _SetLog("Error : After measure rangeover.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (m_bMeaErrAf_R)
                                {
                                    CErr.Show(eErr.RIGHT_GRIND_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                    _SetLog("Error : After measure rangeover.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }

                        _SetLog("Data save.");

                        m_iStep++;
                        return false;
                    }

                case 106:
                    {
                        m_iCol = 0;
                        m_iRow = 0;
                        m_iStep = 0;
                        double dMax   = 0.0  ;
                        double dMin   = 999.999;
                        double dMean  = 0.0  ;
                        double dTotal = 0.0;
                        int iCnt = 0;
                        int iRowCnt =  CData.Dev.iRow;
                        int iColCnt =  CData.Dev.iCol;
                        
						SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {// Before 측정 Data   

                            for (int iRow = 0; iRow < iRowCnt; iRow++)
                            {
                                for (int iCol = 0; iCol < iColCnt; iCol++)
                                {
                                    for (int iU = 0; iU < CData.Dev.iUnitCnt; iU++)
                                    {
                                        double dVal = CData.GrData[m_iWy].aUnit[iU].aMeaBf[iRow, iCol];
                                        if (dVal != 0)
                                        {
                                            dMax = Math.Max(dMax, dVal);
                                            dMin = Math.Min(dMin, dVal);
                                            dTotal += dVal;
                                            CData.m_dPbVal[m_iWy].m_BFVal.Add(dVal); //191120 ksg :
                                                                                                           //191118 ksg :
                                            if (CData.GemForm != null)
                                            {//Before 측정 Data 
                                                if (m_eWy == EWay.L)	{ CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Data[1, iCnt] = dVal; }// Left 측정 Data
                                                else 					{ CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Data[5, iCnt] = dVal; }// Right 측정 Data
                                            }
                                            iCnt++;
                                        }
                                    }
                                }
                            }
                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)	{ CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].nMeasure_Count[1] = iCnt; }
                                else 					{ CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].nMeasure_Count[5] = iCnt; }
                            }

                            if (iCnt != 0)
                            { dMean = Math.Round((dTotal / iCnt), 4); }
                            else
                            { dMean = 0; }

                            CData.PbResultVal[m_iWy].dBMax = dMax;
                            CData.PbResultVal[m_iWy].dBMin = dMin;
                            CData.PbResultVal[m_iWy].dBAvg = dMean;

                            //191118 ksg :
                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)
                                {// Left Befor
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Min_Data[1] = dMin;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Max_Data[1] = dMax;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Avr_Data[1] = dMean;
                                }
                                else
                                {// Right Befor
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Min_Data[5] = dMin;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Max_Data[5] = dMax;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Avr_Data[5] = dMean;
                                }
                            }

                            //20190531 ghk
                            CData.PbResultVal[m_iWy].dBMean = Math.Round(((dMax + dMin) / 2), 4); //190502 ksg :
                            if (m_eWy == EWay.L)
                            {
                                if (CData.PbResultVal[m_iWy].dBMax <= CData.MPos[0].dPCBThickness || CData.PbResultVal[m_iWy].dBMin >= 999)
                                {
                                    CErr.Show(eErr.LEFT_BEFORE_PROBE_DATA_LOST);
                                    _SetLog("Error : Before data lost.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (CData.PbResultVal[m_iWy].dBMax <= CData.MPos[0].dPCBThickness || CData.PbResultVal[m_iWy].dBMin >= 999)
                                {
                                    CErr.Show(eErr.RIGHT_BEFORE_PROBE_DATA_LOST);
                                    _SetLog("Error : Before data lost.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }

                        if (iIdx == 1) //After 측정 Data
                        {
                            // 2021-05-17, jhLee, Multi-LOT, 현재 가공중인 Strip의 LOT Name을 사용하도록 한다.
                            if (CData.IsMultiLOT()) { CData.SpcData.sLotName = CData.Parts[m_iPart].sLotName;   } // Multi-LOT일 경우 가공중인 Strip의 Lot 이름을 사용한다.
                            else                    { CData.SpcData.sLotName = CData.LotInfo.sLotName;          }

                            for (int iRow = 0; iRow < iRowCnt; iRow++)
                            {
                                for (int iCol = 0; iCol < iColCnt; iCol++)
                                {
                                    for (int iU = 0; iU < CData.Dev.iUnitCnt; iU++)
                                    {
                                        double dVal = CData.GrData[m_iWy].aUnit[iU].aMeaAf[iRow, iCol];
                                        if (dVal != 0)
                                        {
                                            dMax = Math.Max(dMax, dVal);
                                            dMin = Math.Min(dMin, dVal);
                                            CData.m_dPbVal[m_iWy].m_AFVal.Add(dVal); //191120 ksg :
                                            dTotal += dVal;

                                            //191118 ksg :
                                            if (CData.GemForm != null)
                                            {
                                                if (m_eWy == EWay.L)	{ CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Data[4, iCnt] = dVal; }
                                                else 					{ CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Data[6, iCnt] = dVal; }
                                            }
                                            iCnt++;
                                        }
                                    }
                                }
                            }
                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)	{ CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].nMeasure_Count[4] = iCnt; }
                                else 					{ CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].nMeasure_Count[6] = iCnt; }
                            }
                            if (m_eWy == EWay.L)
                            {
                                CData.SpcData.sTtvLim = CData.Dev.aData[(int)EWay.L].dTTV.ToString();

                                if (CData.Dev.aData[(int)EWay.L].dTTV != 0)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dTTV < (dMax - dMin))
                                    {
                                        CErr.Show(eErr.LEFT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);

                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                            }
                            else
                            {
                                if (CData.Dev.bDual == eDual.Dual)
                                {
                                    CData.SpcData.sTtvLim = CData.Dev.aData[m_iWy].dTTV.ToString();

                                    if (CData.Dev.aData[m_iWy].dTTV != 0)
                                    {
                                        if (CData.Dev.aData[m_iWy].dTTV < (dMax - dMin))
                                        {
                                            CErr.Show(eErr.RIGHT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);

                                            m_iStep = 0;
                                            return true;
                                        }
                                    }
                                }
                                else
                                {
                                    CData.SpcData.sTtvLim = CData.Dev.aData[(int)EWay.L].dTTV.ToString();

                                    if (CData.Dev.aData[(int)EWay.L].dTTV != 0)
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dTTV < (dMax - dMin))
                                        {
                                            CErr.Show(eErr.RIGHT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);

                                            m_iStep = 0;
                                            return true;
                                        }
                                    }
                                }
                            }

                            //190319 ksg :
                            if (iCnt != 0) dMean = Math.Round((dTotal / iCnt), 4);
                            else dMean = 0;
                            CData.PbResultVal[m_iWy].dAMax = dMax;
                            CData.PbResultVal[m_iWy].dAMin = dMin;
                            CData.PbResultVal[m_iWy].dAAvg = dMean;

                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)
                                {   // SECSGEM Host에 Data Upload 진행  20200301 LCY 
                                    // Top Side : Mold_높이 + DF 측정 Data
                                    // Bottom Side : Mold 높이
                                    if (CData.Dev.eMoldSide == ESide.Top)   { dTemp = CData.Parts[(int)EPart.GRDL].dPcbMean; }
                                    else                                    { dTemp = 0.0; }

                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Min_Data[4] = dMin + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Max_Data[4] = dMax + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Avr_Data[4] = dMean + dTemp;
                                    
                                    _SetLog("Func Call : CData.GemForm.OnCarrierGrindFinished(1)");

                                    // 2021.10.19 SungTae Start : [수정] (ASE-KR VOC) SECS/GEM Issue 관련 조건 추가
                                    //CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N1);
                                    if (!CData.bChkGrdM)
                                    {
                                        CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N1);
                                    }
                                    // 2021.10.19 SungTae End
                                }
                                else
                                {   // SECSGEM Host에 Data Upload 진행  20200301 LCY
                                    // Top Side : Mold_높이 + DF 측정 Data
                                    // Bottom Side : Mold 높이
                                    if (CData.Dev.eMoldSide == ESide.Top)   { dTemp = CData.Parts[(int)EPart.GRDR].dPcbMean; }
                                    else                                    { dTemp = 0.0; }

                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Min_Data[6] = dMin + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Max_Data[6] = dMax + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Avr_Data[6] = dMean + dTemp;
                                    
                                    _SetLog("Func Call : CData.GemForm.OnCarrierGrindFinished(2)");

                                    // 2021.10.19 SungTae Start : [수정] (ASE-KR VOC) SECS/GEM Issue 관련 조건 추가
                                    //CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N2);
                                    if (!CData.bChkGrdM)
                                    {
                                        CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N2);
                                    }
                                    // 2021.10.19 SungTae End
                                }
                            }

                            if (m_eWy == EWay.L)
                            {
                                if (CData.PbResultVal[m_iWy].dBMax <= 0 || CData.PbResultVal[m_iWy].dBMin >= 999)
                                {
                                    CErr.Show(eErr.LEFT_BEFORE_PROBE_DATA_LOST);
                                    _SetLog("Error : After data lost.");

                                    //201010 jhc : Before 측정 시에만 적용
                                    //m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (CData.PbResultVal[m_iWy].dBMax <= 0 || CData.PbResultVal[m_iWy].dBMin >= 999)
                                {
                                    CErr.Show(eErr.RIGHT_BEFORE_PROBE_DATA_LOST);
                                    _SetLog("Error : After data lost.");

                                    //201010 jhc : Before 측정 시에만 적용
                                    //m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }

                            if (CData.LotInfo.bLotOpen)
                            {
                                if (iCnt != 0)
                                { dMean = dTotal / iCnt; }
                                else
                                { dMean = 0; }

                                if (m_eWy == EWay.L)
                                {
                                    CData.SpcData.sMgzNo    = CData.Parts[(int)EPart.GRDL].iMGZ_No.ToString();
                                    CData.SpcData.sSlotNo   = CData.Parts[(int)EPart.GRDL].iSlot_No.ToString();
                                    CData.SpcData.sTable    = "L";
                                    CData.SpcData.sBcr      = CData.Parts[(int)EPart.GRDL].sBcr;
                                    //191128 ksg :
                                    if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown)	{ CData.SpcData.sMode = "TopDown"; }
                                    else 													{ CData.SpcData.sMode = "Target"; }

                                    //20190703 ghk_automeasure
                                    if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                    { CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_AfterMeaStrip; }
                                }
                                else
                                {
                                    CData.SpcData.sMgzNo    = CData.Parts[(int)EPart.GRDR].iMGZ_No.ToString();
                                    CData.SpcData.sSlotNo   = CData.Parts[(int)EPart.GRDR].iSlot_No.ToString();
                                    CData.SpcData.sTable    = "R";
                                    CData.SpcData.sBcr      = CData.Parts[(int)EPart.GRDR].sBcr;

                                    //191128 ksg :
                                    if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown)	{ CData.SpcData.sMode = "TopDown"; }
                                    else 													{ CData.SpcData.sMode = "Target"; }

                                    //20190703 ghk_automeasure
                                    if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                    { CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_AfterMeaStrip; }
                                }
                                CData.SpcData.sMax  = dMax.ToString();
                                CData.SpcData.sMin  = dMin.ToString();
                                CData.SpcData.sMean = dMean.ToString();
                                CData.SpcData.sTtv  = (dMax - dMin).ToString();
                                //190319 ksg :
                                CData.SpcData.sBMax = CData.PbResultVal[m_iWy].dBMax.ToString();
                                CData.SpcData.sBMin = CData.PbResultVal[m_iWy].dBMin.ToString();
                                CData.SpcData.sBAvg = CData.PbResultVal[m_iWy].dBAvg.ToString();

                                for (int i = m_iStepMaxCnt - 1; i >= 0; i--)
                                {
                                    if (CData.Dev.bDual == eDual.Dual)
                                    {
                                        if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                        {
                                            CData.SpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                            CData.SpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                            break;
                                        }
                                    }
                                    else
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].eGrdMod == eGrdMode.TopDown)
                                            {
                                                CData.SpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                CData.SpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                            }
                                            else
                                            {
                                                CData.SpcData.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                CData.SpcInfo.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                            }
                                            break;
                                        }
                                    }
                                }

                                if (CData.CurCompany == ECompany.ASE_KR)    { CSpc.It.SaveLotData_Add();    }
                                else                                        { CSpc.It.SaveLotData();        }

                                //190529 ksg :
                                if (m_eWy == EWay.L && CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown)
                                {
                                    if (CData.IsMultiLOT()) { double.TryParse(m_myLotInfo.rSpcInfo.sTarget, out CData.Parts[(int)EPart.GRDL].dShiftT); }
                                    else                    { double.TryParse(CData.SpcInfo.sTarget,        out CData.Parts[(int)EPart.GRDL].dShiftT); }
                                }
                            }
                        }

                        if (CData.LotInfo.bLotOpen)
                        {
                            string sTemp = (iIdx == 0) ? "BEFORE" : "AFTER";         

                            CSpc.It.SaveDataIniU(ref m_myLotInfo, m_eWy, sTemp);

                            //20190703 ghk_automeasure
                            if (m_eWy == EWay.L)
                            {
                                if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                { CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_AfterMeaStrip; }
                            }
                            else
                            {
                                if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                { CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_AfterMeaStrip; }
                            }
                        }

                        _SetLog("Finish.  Status : " + CData.Parts[m_iPart].iStat);
                        return true;
                    }

                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스
                case 200:  //Z축 대기 위치 이동
                    {
                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running)    { m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy]; }
                        else                                                { m_dPosZ = CData.SPos.dGRD_Z_Wait[m_iWy]; }
                        CMot.It.Stop(m_iZ);
                        CMot.It.Mv_N(m_iZ, m_dPosZ);

                        _SetLog("ERROR : Picker Vacuum : " + m_siZ + " UP : " + m_dPosZ.ToString());
                        
                        m_iStep++;
                        return false;
                    }

                case 201:
                    {//Z축 대기 위치 이동 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }

                        if (m_iPickerVacErr == 1)
                        { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else
                        { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        _SetLog("Picker Vacuum ERROR " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        m_bSubErr = true;

                        m_iStep = 0;
                        return true;
                    }
                ///////////////////////////////////////////////////////////////////////////////////////
            }
        }


        /// <summary>
        /// 2020-10-27, jhLee
        /// Unit Thickness Measure function by Z-Axis motion
        /// 유닛 두께 측정 함수 0:Before, 1:After
        /// Probe의 Down/Up이 아닌 Z축 모션을 통해 Probe 측정위치로 눌러 측정하도록 변경된 함수
        /// </summary>
        /// <param name="iIdx"></param>
        /// <returns></returns>
        public bool Cyl_MeaUnit_ZMotor(int iIdx)
        {
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                    if (iIdx == (int)EMeaStep.Before/*0*/)
                    {
                        if (m_eWy == EWay.L)
                        { CErr.Show(eErr.LEFT_GRIND_STRIP_INSPECTION_BEFORE_TIMEOUT); }
                        else
                        { CErr.Show(eErr.RIGHT_GRIND_STRIP_INSPECTION_BEFORE_TIMEOUT); }
                        _SetLog("Error : Before timeout.");
                    }
                    else
                    {
                        if (m_eWy == EWay.L)
                        { CErr.Show(eErr.LEFT_GRIND_STRIP_INSPECTION_AFTER_TIMEOUT); }
                        else
                        { CErr.Show(eErr.RIGHT_GRIND_STRIP_INSPECTION_AFTER_TIMEOUT); }
                        _SetLog("Error : After timeout.");
                    }

                    m_bSubErr = true;

                    m_iStep = 0;
                    return true;
                }
            }

            // 200316 mjy : Unit 버큠 항시 체크
            if (!Chk_Unit())
            {
                if (m_eWy == EWay.L)    { CErr.Show(eErr.LEFT_GRIND_VACUUM_ERROR); }
                else                    { CErr.Show(eErr.RIGHT_GRIND_VACUUM_ERROR); }

                _SetLog("Error : Check unit.");

                m_bSubErr = true;

                m_iStep = 0;
                return true;
            }

            m_iPreStep = m_iStep;

            if (m_eWy == EWay.L)    { m_LogVal.sStatus = "GRL_Cyl_MeaStrip"; }
            else                    { m_LogVal.sStatus = "GRR_Cyl_MeaStrip"; }

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if ((CData.CurCompany == ECompany.ASE_KR) &&
                ((m_iStep == 17) || (m_iStep == 18) || (m_iStep == 19) || (m_iStep == 32) || (m_iStep == 33) || (m_iStep == 34)
                    || (m_iStep == 42) || (m_iStep == 43)))
            {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                if (0 != m_iPickerVacErr)
                {
                    CMot.It.EStop(m_iY); //Table Y축 즉시 Stop

                    _SetLog("ERROR : Picker Vacuum : " + m_siY + " STOP : " + CMot.It.Get_FP(m_iY).ToString());

                    m_iStep = 200; //정리 스텝으로
                    return false;
                }
            }
            ///////////////////////////////////////////////////////////////////////////////////////

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10: // Axes check
                    {
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes(true))
                        {
                            m_iStep = 0;
                            return true;
                        }

                        _SetLog("===== Measure Unit Z-Motorize Start =====");

                        m_bSubErr = false;

                        _SetLog("Check axes.");

                        m_iStep++;
                        return false;
                    }

                case 11: // Variable initialize
                    {
                        m_iUnit = CData.Dev.iUnitCnt - 1;

                        m_bMeaErrBf_L = false;
                        m_bMeaErrAf_L = false;
                        m_bMeaErrBf_R = false;
                        m_bMeaErrAf_R = false;

                        _SetLog("Init variable.  Unit count : " + m_iUnit);

                        // jhLee, Multi-LOT의 경우에도 SPC 기록
                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        m_iStep++;
                        return false;
                    }

                case 12: // Probe array initialize
                    {
                        //190319 ksg :
                        ProbeClearVal(iIdx);

                        //190717 ksg : 데이터 클리어 요청
                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if(CData.CurCompany == ECompany.Qorvo || (CData.CurCompany == ECompany.Qorvo_DZ) || CData.CurCompany == ECompany.SST) && iIdx == 0)
                        if((CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ ||
                            CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC ||
                            CData.CurCompany == ECompany.SST) && iIdx == 0)
                        {
                            ProbeClearVal(iIdx + 1);
                        } //191202 ksg :

                        //191120 ksg :
                        InitPbValue(m_iWy, iIdx);
                        _SetLog("Init probe.");

                        m_iStep++;
                        return false;
                    }

                case 13: // IO initialize
                    {
                        _InitCycle();

                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_ProbeDn;
                            m_eOt2 = eY.GRDL_ProbeAir;
                            m_eIn1 = eX.GRDL_ProbeAMP;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_ProbeDn;
                            m_eOt2 = eY.GRDR_ProbeAir;
                            m_eIn1 = eX.GRDR_ProbeAMP;
                        }

                        _SetLog("Init cylce.");

                        m_iStep++;
                        return false;
                    }

                case 14: // Inspection data variable initialize
                    {
                        m_iRow = 0;
                        m_iCol = 0;
                        m_dPosX = CData.SPos.dGRD_X_Zero[m_iWy];
                        m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS;
                        m_dPosSafetyZ = CData.SPos.dGRD_Z_Able[m_iWy];          // 초기 안전위치
                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];

                        // 2022.04.04 SungTae : [수정] 코드 확인 용이하도록 변경
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            m_aInspBf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            m_abMeaBfErr = new bool[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];

                            CData.GrData[m_iWy].aMeaBf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            for (int iU = 0; iU < CData.Dev.iUnitCnt; iU++)
                            {
                                CData.GrData[m_iWy].aUnit[iU].aMeaBf = new double[CData.Dev.iRow, CData.Dev.iCol];
                                CData.GrData[m_iWy].aUnit[iU].aErrBf = new bool[CData.Dev.iRow, CData.Dev.iCol];
                            }

                            //190717 ksg : 새로운 자재 투입시 전후 데이터 클리어
                            // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                            //if(CData.CurCompany == ECompany.Qorvo || (CData.CurCompany == ECompany.Qorvo_DZ) || CData.CurCompany == ECompany.SST) //191202 ksg :
                            if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ ||
                                CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC ||
                                CData.CurCompany == ECompany.SST)
                            {
                                m_aInspAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                                m_abMeaAfErr = new bool[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];

                                CData.GrData[m_iWy].aMeaAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                                for (int iU = 0; iU < CData.Dev.iUnitCnt; iU++)
                                {
                                    CData.GrData[m_iWy].aUnit[iU].aMeaAf = new double[CData.Dev.iRow, CData.Dev.iCol];
                                    CData.GrData[m_iWy].aUnit[iU].aErrAf = new bool[CData.Dev.iRow, CData.Dev.iCol];
                                }
                            }

                        }
                        else
                        {
                            m_aInspAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            m_abMeaAfErr = new bool[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];

                            CData.GrData[m_iWy].aMeaAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            for (int iU = 0; iU < CData.Dev.iUnitCnt; iU++)
                            {
                                CData.GrData[m_iWy].aUnit[iU].aMeaAf = new double[CData.Dev.iRow, CData.Dev.iCol];
                                CData.GrData[m_iWy].aUnit[iU].aErrAf = new bool[CData.Dev.iRow, CData.Dev.iCol];
                            }

                            //190528 ksg :
                            if (m_eWy == EWay.L)
                            {
                                m_aInspShift = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            }
                        }

                        m_aInspTemp = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];

                        _SetLog("--- (End Prepare) Init array.");

                        //2021.08.06 syc : Up상태일때 Probe 값 정상 범위 인지 확인
                        //- Qorvo 프로브 앰프값 자동으로 바뀌는 이슈에 대한 방지책
                        //- Probe 값이 18.9xxx ~ 19.0xxx 범위 이탈시 알람
                        if (Chk_ProbeUpVal())
                        {
                            m_bSubErr = true;//211006 pjh : 측정 Error 시 Cycle Stop

                            m_iStep = 0;
                            return true;
                        }

                        m_iStep++;
                        return false;
                    }


                case 15: // Z 축 안전 위치로 이동
                    {
                        // 초기 안전위치는 Z_ABLE 위치이다.
                        // if (CMot.It.Mv_N(m_iZ, m_dPosSafetyZ) == 0)   //Z축 이동 안전 위치로 이동
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosSafetyZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 고속 안전 위치로 이동
                        {
                            _SetLog("Z axis move [Safety] position : ", m_dPosSafetyZ);
                            m_iStep++;
                        }
                        return false;
                    }

                case 16: // Z 축 안전 위치로 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosSafetyZ))
                        { return false; }

                        _SetLog("Z axis move [Safety] positin check.");

                        // Z축 안전위치로 이동하면 Probe를 Down시켜도 안전하므로 시간을 줄이기 위해 Probe를 Down 시킨다.

                        ActPrbDown(true);
                        _SetLog("Probe cylinder down");

                        m_iStep++;
                        return false;
                    }


                case 17: // Y axis move start to table inspection position
                    {
                        if (CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]) == 0)
                        {
                            _SetLog("Y axis move table base.", CData.SPos.dGRD_Y_TblInsp[m_iWy]);
                            m_iStep++;
                        }

                        return false;
                    }

                case 18: // X axis move start to zero position
                    {
                        if (CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]) == 0)
                        {
                            _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);
                            m_iStep++;
                        }
                        return false;
                    }

                case 19: // X, Y axis move finish table inspection position check
                    {
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]) || !CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }

                        // if (!ActPrbAir(true))
                        // { return false; }

                        ActPrbAir(true);        // Probe air on check 이물질을 제거하기위한 Air를 분출한다.
                        _SetLog("--- (Move done) X, Y axis move check, probe air on");

                        m_iStep++;
                        return false;
                    }

                case 20: // Probe down check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = !CIO.It.Get_X(eX.GRDL_ProbeAMP); }
                        else
                        { bRet = !CIO.It.Get_X(eX.GRDR_ProbeAMP); }

                        if (!bRet)
                        { return false; }
                        _SetLog("Probe down check.");

                        // Probe overdirve 지정값 만큼 더 내린다.
                        m_dPosZ = (CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS) + (CData.Opt.dProbeOD - 1.0);

                        m_iStep++;
                        return false;
                    }

                case 21: // Z 축 Table 측정 위치로 Down 이동
                    {
                        //                        if (CMot.It.Mv_N(m_iZ, m_dPosZ) == 0)   //Z축 측정 위치로 Down 이동
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 고속 안전 위치로 이동
                        {
                            _SetLog("Z axis move [Table Measure] position : " + m_dPosZ.ToString() + ", OD : " + CData.Opt.dProbeOD.ToString());
                            m_iStep++;
                        }
                        return false;
                    }

                case 22: // Z 축 측정 위치로 Down 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }
                        _SetLog("Z axis move [Table Measure] position  check.");

                        ActPrbAir(false);           // Probe air off
                        m_tmPrb.Set_Delay(CData.Opt.iProbeStableDelay);     // Probe 안정화 시간
                        _SetLog("Probe air off and Set Probe stable delay : " + CData.Opt.iProbeStableDelay + "ms");

                        m_iStep = 23;
                        return false;
                    }

                case 23: // Read probe value and calculate table thickness
                    {
                        if (!m_tmPrb.Chk_Delay() || ActPrbAir(false))      // 안정화 시간 지연이내 이거나 Air가 꺼지지 않았다면 return
                        {
                            return false;           // 반복
                        }

                        // 읽어들인 Probe값에서 적용해준 Probe overdrive만큼 빼서 실제값을 산출한다.
                        CData.Tbl_Af[m_iWy, 0] = (CPrb.It.Read_Val(m_eWy) + GV.EQP_TABLE_MIN_THICKNESS) - (CData.Opt.dProbeOD - 1.0);
                        _SetLog("--- (Measure Top) Table Top : " + CData.Tbl_Af[m_iWy, 0] + "mm");

                        // Manual zig 여부 판단
                        if (CData.Tbl_Af[m_iWy, 0] > (GV.EQP_TABLE_MIN_THICKNESS + 4))
                        {
                            if (m_iWy == (int)EWay.L)
                            { CErr.Show(eErr.LEFT_GRIND_MANUALZIG_ON_THE_TABLE); }
                            else
                            { CErr.Show(eErr.RIGHT_GRIND_MANUALZIG_ON_THE_TABLE); }
                            _SetLog("Error : Manual zig on table.  Table : " + CData.Tbl_Af[m_iWy, 0] + "mm");

                            m_bSubErr = true;
                            m_iGStep = 0;

                            //m_iStep = 0;
                            //return true;

                            m_iStep = 200;      // 종료 처리
                            return false;
                        }

                        // Z 축 대기위치는 Talble이 측정된 위치에서 안전 Offset으로 설정된 만큼 위로 올라간 위치이다.
                        //
                        // 측정 대기위치 = TableBase - (실측된 Table 높이 + 안전 위치 offset)
                        m_dPosSafetyZ = CData.MPos[m_iWy].dZ_TBL_BASE - (CData.Tbl_Af[m_iWy, 0] + CData.Opt.dSafetyTopOffset);

                        // Z축의 이동 안전 위치가 Table 상부 8mm 보다 낮다면 안전을 위해 최소 높이를 적용한다.
                        if (m_dPosSafetyZ > (CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS - 8))
                        {
                            _SetLog("Warning ! Z axis [Safety] position too low : ", m_dPosSafetyZ);

                            // Table 상부보다 8mm 높게 강제로 설정한다.
                            m_dPosSafetyZ = (CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS - 8);
                        }

                        m_iStep++;
                        return false;
                    }


                // Table 높이 측정을 마치고 안전위치로 이동 후 Table Zero 지점 위치까지 Z축을 Down시켜 값을 측정한다.
                // 이때 Probe는 Down 상태를 유지한다.

                case 24: // Z 축 안전 위치로 이동
                    {
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosSafetyZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 고속 안전 위치로 이동
                        {
                            _SetLog("After measuring, Z axis move [Measure Safety] position : ", m_dPosSafetyZ);
                            m_iStep++;
                        }
                        return false;
                    }

                case 25: // Z 축 안전 위치로 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosSafetyZ))
                        { return false; }
                        _SetLog("Z axis move [Measure Safety] positin check.");

                        ActPrbAir(true);                   // Probe air on

                        //프로브 테이블 측정시 0인 위치로 이동, 이때 Probe Overdrive 값을 적용시킨다.
                        m_dPosZ = (CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0]) + (CData.Opt.dProbeOD - 1.0);

                        m_iStep++;
                        return false;
                    }

                case 26: // Z axis move down to table zero position
                    {
                        //                        if (CMot.It.Mv_N(m_iZ, m_dPosZ) == 0)
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 위치로 이동
                        {
                            _SetLog("Z axis move [Table Zero] position : " + m_dPosZ.ToString() + ",  OD : " + CData.Opt.dProbeOD.ToString());
                            m_iStep++;
                        }

                        return false;
                    }

                case 27: // Z axis move table zero position check
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        ActPrbAir(false);                   // Probe air off
                        _SetLog("Check Z axis move.");

                        m_tmPrb.Set_Delay(CData.Opt.iProbeStableDelay);
                        _SetLog("Set Probe stable delay : " + CData.Opt.iProbeStableDelay + "ms");

                        m_iStep++;
                        return false;
                    }

                case 28: // Read probe value at Table-Zero position
                    {
                        if (!m_tmPrb.Chk_Delay() || ActPrbAir(false))       // 안정화 시간 이내이거나 Probe air가 off 상태가 아니라면 대기
                        {
                            return false;
                        }

                        // Table Top 위치에서 측정한 값 취득, Probe overdrive값 적용
                        m_InspZeroOffset = CPrb.It.Read_Val(m_eWy) - (CData.Opt.dProbeOD - 1.0);
                        _SetLog("--- (Measure Table Top) InspZeroOffset value : " + m_InspZeroOffset + "mm,  OD : " + CData.Opt.dProbeOD.ToString());

                        m_iStep++;
                        return false;
                    }


                // Table Zero 높이 측정을 마치고 안전위치로 이동
                // 이때 Probe는 Down 상태를 유지한다.

                case 29: // Z 축 안전 위치로 이동
                    {
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosSafetyZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 안전 위치로 고속 이동
                        {
                            _SetLog("Z axis move [Safety] position : ", m_dPosSafetyZ);
                            m_iStep++;
                        }
                        return false;
                    }

                case 30: // Z 축 안전 위치로 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosSafetyZ))
                        { return false; }
                        _SetLog("--- (Measure done) Z axis move [Safety] positin check.");

                        m_iStep++;
                        return false;
                    }


                // ======> 반복 시작

                case 31: // Column 반복 ( X 축 )
                    {
                        bool bTemp = false;
                        if (m_iCol < CData.Dev.iCol)
                        {
                            for (int i = 0; i < CData.Dev.iRow; i++)
                            {//해당 열의 모든행에 사용자가 설정한 측정 포인트가 있는지 검사
                                if (iIdx == 0)
                                { bTemp = CData.Dev.aData[m_iWy].aPosBf[i, m_iCol].bUse; }
                                else
                                { bTemp = CData.Dev.aData[m_iWy].aPosAf[i, m_iCol].bUse; }

                                // 측정 값 존재 시 for문 탈출
                                if (bTemp) { break; }
                            }

                            if (bTemp)
                            {   // 해당 열에 측정 포인트 존재 할 시 프로브축 포지션 획득
                                if (iIdx == 0)
                                { m_dPosX = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX; }
                                else
                                { m_dPosX = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX; }

                                _SetLog(string.Format("Column : {0}  Row : {1}", m_iCol, m_iRow));

                                m_iStep++;
                            }
                            else
                            {   // 측정 포인트 없어 다음 열로 이동
                                m_iCol++;
                                return false;
                            }
                        }
                        else
                        {
                            // 측정 종료
                            _SetLog("Loop end.");
                            m_iStep = 100;
                        }

                        return false;
                    }


                case 32: // Y axis move start to table inspection position
                    {
                        if (CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]) == 0)
                        {
                            _SetLog("Y axis move table base.", CData.SPos.dGRD_Y_TblInsp[m_iWy]);
                            m_iStep++;
                        }
                        return false;
                    }

                case 33: // X axis move start
                    {
                        if (CMot.It.Mv_N(m_iX, m_dPosX) == 0)
                        {
                            _SetLog("X axis move position : " + m_dPosX.ToString() + ",  Col : " + m_iCol.ToString());
                            m_iStep++;
                        }
                        return false;
                    }

                case 34: // X, Y axis move position check
                    {
                        if (!CMot.It.Get_Mv(m_iX, m_dPosX) || !CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]))
                        {
                            return false;
                        }

                        _SetLog("--- (Move Done) Check X, Y axis move done, Probe air ON");

                        ActPrbAir(true);                   // Probe air on

                        //프로브 테이블 측정시 0인 위치로 이동, 이때 Probe Overdrive 값을 적용시킨다.
                        m_dPosZ = (CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0]) + (CData.Opt.dProbeOD - 1.0);

                        m_iStep++;
                        return false;
                    }


                case 35: // Z axis move down to Measuring position
                    {
                        //                        if (CMot.It.Mv_N(m_iZ, m_dPosZ) == 0)
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 위치로 이동
                        {
                            _SetLog("Z axis move [Table Zero] position : " + m_dPosZ.ToString() + ",  OD : " + CData.Opt.dProbeOD.ToString());
                            m_iStep++;
                        }
                        return false;
                    }

                case 36: // Z axis move table base zero position check
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }
                        _SetLog("Check Z axis move done");

                        ActPrbAir(false);                   // Probe air off

                        m_tmPrb.Set_Delay(CData.Opt.iProbeStableDelay);
                        _SetLog("Probe air off and Set Probe stable delay : " + CData.Opt.iProbeStableDelay + "ms");

                        m_iStep++;
                        return false;
                    }


                case 37: // Read probe value at Table-Zero position
                    {
                        if (!m_tmPrb.Chk_Delay())   // Probe stable delay : Probe가 안정될 때까지 지정된 시간동안 지연 확인
                        { return false; }
                        _SetLog("Check delay.");

                        // Table Zero 위치에서 측정한 값 취득, Probe overdrive값 적용
                        m_InspOffset = CPrb.It.Read_Val(m_eWy) - (CData.Opt.dProbeOD - 1.0);
                        _SetLog("--- (Measure Table Zero) m_InspOffset value : " + m_InspOffset + "mm");

                        m_iStep++;
                        return false;
                    }


                case 38: // Z 축 측정시 안전 위치로 이동
                    {
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosSafetyZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 고속 안전 위치로 이동
                        {
                            _SetLog("Z axis move [Measure Safety] position : ", m_dPosSafetyZ);
                            m_iStep++;
                        }
                        return false;
                    }

                case 39: // Z 축 안전 위치로 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosSafetyZ))
                        { return false; }
                        _SetLog("Z axis move [Measure Safety] positin check.");

                        m_iStep++;
                        return false;
                    }


                // Unit 시작 위치
                case 40: // Find insepction unit index
                    {
                        // 200317 jhc : 배열 overflow 선 체크
                        if (m_iUnit < 0)
                        {
                            // 현재 Row, Column에서 Unit 검사 끝
                            m_iRow = 0;
                            m_iUnit = CData.Dev.iUnitCnt - 1;
                            m_iCol++;
                            _SetLog(string.Format("Loop1.  Col : {0}  Row : {1}  Unit : {2}", m_iCol, m_iRow, m_iUnit));

                            m_iStep = 31;
                            return false;
                        }
                        if (!CData.GrData[m_iWy].aUnitEx[m_iUnit])
                        {
                            m_iUnit -= 1;
                            return false;
                        }

                        _SetLog(string.Format("Loop2.  Col : {0}  Row : {1}  Unit : {2}", m_iCol, m_iRow, m_iUnit));
                        m_iStep++;
                        return false;
                    }

                // Row 반복 시작 

                case 41: // Row calculate
                    {
                        if (m_iRow >= CData.Dev.iRow)
                        {   // Row 갯수 만큼 검사 끝
                            m_iRow = 0;
                            // 200317 jhc : 다음 Unit 검사
                            m_iUnit--;
                            _SetLog(string.Format("Loop.  Col : {0}  Row : {1}  Unit : {2}", m_iCol, m_iRow, m_iUnit));

                            m_iStep = 40;
                            return false;
                        }

                        bool bTemp = false;
                        if (iIdx == 0)
                        { bTemp = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].bUse; }
                        else
                        { bTemp = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].bUse; }

                        if (bTemp)
                        {   // 현재 Row에 측정 값이 존재
                            if (iIdx == 0)
                            { m_dPosY = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].aY[m_iUnit]; }
                            else
                            { m_dPosY = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].aY[m_iUnit]; }
                            _SetLog(string.Format("Row find meausre point.  Col : {0}  Row : {1}", m_iCol, m_iRow));

                            m_iStep++;
                        }
                        else
                        {   // 현재 Row에 측정 값이 없어 다음 Row로 이동
                            m_iRow++;
                        }

                        return false;
                    }

                case 42: // Y axis move inspection position
                    {
                        if (CMot.It.Mv_N(m_iY, m_dPosY) == 0)
                        {
                            _SetLog("Y axis move position : " + m_dPosY.ToString() + ",  Row : " + m_iRow.ToString());
                            m_iStep++;
                        }
                        return false;
                    }

                case 43: // Y axis move inspection position check
                    {
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }
                        _SetLog("--- (Move Done) Check Y axis move.");

                        ActPrbAir(true);                   // Probe air on

                        //측정위치 : 프로브 테이블 측정시 0인 위치로 이동, 이때 Probe Overdrive 값을 적용시킨다.
                        m_dPosZ = (CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0]) + (CData.Opt.dProbeOD - 1.0);

                        m_iStep++;
                        return false;
                    }


                case 44: // Z axis move Measuring position
                    {
                        // if (CMot.It.Mv_N(m_iZ, m_dPosZ) == 0)
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 위치로 이동
                        {
                            _SetLog("Z axis move [Measuring] position : " + m_dPosZ.ToString() + ",  OD : " + CData.Opt.dProbeOD.ToString());
                            m_iStep++;
                        }
                        return false;
                    }

                case 45: // Z axis move table base zero position check
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        _SetLog("Check Z axis move done");

                        ActPrbAir(false);                   // Probe air off

                        m_tmPrb.Set_Delay(CData.Opt.iProbeStableDelay);
                        _SetLog("Probe air off and Set Probe stable delay : " + CData.Opt.iProbeStableDelay + "ms");

                        m_iStep++;
                        return false;
                    }

                case 46: // Read probe value
                    {
                        // Probe stable delay : Probe가 안정될 때까지 지정된 시간동안 지연 확인
                        if (!m_tmPrb.Chk_Delay() || ActPrbAir(false))
                        {
                            return false;
                        }

                        double dLimitMax = 0.0;
                        double dLimitMin = 0.0;
                        double dVal = 0.0;

                        m_PbOfset = CPrb.It.Read_Val(m_eWy) - (CData.Opt.dProbeOD - 1.0);       // 적용된 Probe Overdrive값 차감

                        if (iIdx == 0)
                        {
                            double NewGap = m_PbOfset - (m_InspOffset - m_InspZeroOffset);
                            if (CData.GrData[m_iWy].aOldOnPont[0] < NewGap)
                            { CData.GrData[m_iWy].aOldOnPont[0] = m_PbOfset - (m_InspOffset - m_InspZeroOffset); }
                        }
                        _SetLog("--- (Measure Offset) Original value : " + m_PbOfset + "mm");

                        m_PbOfset = m_PbOfset + CData.Dev.aData[m_iWy].dPrbOffset; //190502 ksg : 
                        _SetLog("RNR : " + CData.Dev.aData[m_iWy].dPrbOffset + "mm");

                        /// - SECSGEM 사용시 Top 의 AF 값을 BTM 진행 시 DF 대시 사용키 위함 20200301 LCY
                        /// 1. SECSGEM 사용 시 Btm Side 경우 Host에서 top Side 의 Af 값을 Down 
                        /// 2. Strip Top 측정 값 - Host에서 Down 값
                        dTemp = 0.0;
                        
						if ((CData.Opt.bSecsUse) && (CData.Dev.eMoldSide == ESide.Top) && (m_eWy == EWay.L))
                        {
                            if (CData.Dynamic.iHeightType == 0) { dTemp = CData.Parts[(int)EPart.GRDL].dPcbMax;     }
                            else                                { dTemp = CData.Parts[(int)EPart.GRDL].dPcbMean;    }
                        }
                        
						dVal = m_PbOfset + dTemp;

                        //190514 ksg : 센터도 옵셋 적용 가능
                        //CData.GrData[m_iWy].aUnit[m_iUnit].aMeaBf[m_iRow, m_iCol] -= (m_InspOffset - m_InspZeroOffset);
                        dVal -= (m_InspOffset - m_InspZeroOffset);

                        if (iIdx == 0)
                        {
                            dLimitMax = CData.Dev.aData[(int)EWay.L].dTotalTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                            dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dBfLimit;
                            CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dBfLimit.ToString();

                            if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                            {
                                dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dBfLimitLower;
                            }


                            if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                            {
                                dLimitMax = CData.Dev.aData[m_iWy].dTotalTh + CData.Dev.aData[m_iWy].dBfLimit;
                                dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dBfLimit;
                                CData.SpcData.sTargetLim = CData.Dev.aData[m_iWy].dBfLimit.ToString();

                                if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                                {
                                    dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dBfLimitLower;
                                }

                            }

                            if (m_eWy == EWay.L)
                            {
                                if (CData.Dev.aData[(int)EWay.L].dBfLimit != 0)
                                {
                                    if ((dVal > dLimitMax) || (dVal < dLimitMin))
                                    {   //범위 벗어 났을 경우 에러 발생
                                        CData.GrData[m_iWy].aUnit[m_iUnit].aErrBf[m_iRow, m_iCol] = true;
                                        m_bMeaErrBf_L = true;
                                    }
                                }
                            }
                            else
                            {
                                if (CData.Dev.bDual != eDual.Dual)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dBfLimit != 0)
                                    {
                                        if ((dVal > dLimitMax) || (dVal < dLimitMin))
                                        {   //범위 벗어 났을 경우 에러 발생
                                            CData.GrData[m_iWy].aUnit[m_iUnit].aErrBf[m_iRow, m_iCol] = true;
                                            m_bMeaErrBf_R = true;
                                        }
                                    }
                                }
                                else
                                {
                                    if (CData.Dev.aData[m_iWy].dBfLimit != 0)
                                    {
                                        if ((dVal > dLimitMax) || (dVal < dLimitMin))
                                        {   //범위 벗어 났을 경우 에러 발생
                                            CData.GrData[m_iWy].aUnit[m_iUnit].aErrBf[m_iRow, m_iCol] = true;
                                            m_bMeaErrBf_R = true;
                                        }
                                    }
                                }
                            }

                            CData.GrData[m_iWy].aUnit[m_iUnit].aMeaBf[m_iRow, m_iCol] = Math.Round(dVal, GV.MEA_POINT);
                            _SetLog("Final value : " + dVal + "mm");
                        }
                        else
                        {
                            // 200708 jym : After data에 옵셋 기능 추가
                            if (CDataOption.IsFakeAf)
                            {
                                dVal += CData.Dev.aFake[m_iWy];
                                _SetLog("Fake offset : " + CData.Dev.aFake[m_iWy] + "mm");
                            }

                            //자재 높이 범위 검사
                            double dTarget = 0.0;
                            //200414 ksg : 12 Step  기능 추가
                            //for (int i = 3; i >= 0; i--)
                            //for(int i = GV.StepMaxCnt - 1; i >= 0; i--)
                            for (int i = m_iStepMaxCnt - 1; i >= 0; i--)        // 2020.09.08 SungTae : modify
                            {
                                if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                {
                                    if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                    {
                                        //191206 ghk_cal_debug -> 20201017 ksg : 원복함
                                        dTarget = CData.GrData[m_iWy].aTar[i];
                                        _SetLog("1. Target : " + dTarget + "mm  Step : " + i);
                                        break;
                                    }
                                }
                                else
                                {
                                    if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                    {
                                        if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown && (m_eWy == EWay.R)) //190717 ksg :
                                        {
                                            //20191206 ghk_cal_debug -> 20201017 ksg : 원복함
                                            dTarget = CData.GrData[(int)EWay.R].aTar[i];
                                            _SetLog("2. Target : " + dTarget + "mm  Step : " + i);
                                            break;
                                        }
                                        else if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.Target)
                                        {
                                            //200414 jym : 수정
                                            dTarget = CData.Dev.aData[(int)EWay.L].aSteps[i].dTotalDep;
                                            _SetLog("3. Target : " + dTarget + "mm  Step : " + i);
                                            break;
                                        }
                                        else
                                        {
                                            //200414 jym : 수정
                                            dTarget = CData.GrData[(int)EWay.L].aTar[i];
                                            _SetLog("4. Target : " + dTarget + "mm  Step : " + i);
                                            break;
                                        }
                                    }
                                }
                            }

                            dLimitMax = dTarget + CData.Dev.aData[(int)EWay.L].dAfLimit;
                            dLimitMin = dTarget - CData.Dev.aData[(int)EWay.L].dAfLimit;

                            CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();
                            if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                            {
                                dLimitMax = dTarget + CData.Dev.aData[m_iWy].dAfLimit;
                                dLimitMin = dTarget - CData.Dev.aData[m_iWy].dAfLimit;

                                CData.SpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();
                            }

                            if (m_eWy == EWay.L)
                            {
                                if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                {
                                    if ((dVal > dLimitMax) || (dVal < dLimitMin))
                                    {//범위 벗어 났을 경우 에러 발생
                                        CData.GrData[m_iWy].aUnit[m_iUnit].aErrAf[m_iRow, m_iCol] = true;
                                        m_bMeaErrAf_L = true;
                                        _SetLog(string.Format("Limit fail.  Min : {0}mm  Max : {1}mm  Val : {2}mm", dLimitMin, dLimitMax, dVal));
                                    }
                                }
                            }
                            else
                            {
                                if (CData.Dev.bDual != eDual.Dual)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                    {
                                        if ((dVal > dLimitMax) || (dVal < dLimitMin))
                                        {//범위 벗어 났을 경우 에러 발생
                                            CData.GrData[m_iWy].aUnit[m_iUnit].aErrAf[m_iRow, m_iCol] = true;
                                            m_bMeaErrAf_R = true;
                                            _SetLog(string.Format("Limit fail(normal).  Min : {0}mm  Max : {1}mm  Val : {2}mm", dLimitMin, dLimitMax, dVal));
                                        }
                                    }
                                }
                                else
                                {
                                    if (CData.Dev.aData[m_iWy].dAfLimit != 0)
                                    {
                                        if ((dVal > dLimitMax) || (dVal < dLimitMin))
                                        {//범위 벗어 났을 경우 에러 발생
                                            CData.GrData[m_iWy].aUnit[m_iUnit].aErrAf[m_iRow, m_iCol] = true;
                                            m_bMeaErrAf_R = true;
                                            _SetLog(string.Format("Limit fail(dual).  Min : {0}mm  Max : {1}mm  Val : {2}mm", dLimitMin, dLimitMax, dVal));
                                        }
                                    }
                                }
                            }

                            CData.GrData[m_iWy].aUnit[m_iUnit].aMeaAf[m_iRow, m_iCol] = Math.Round(dVal, GV.MEA_POINT);
                            _SetLog("Final value : " + dVal + "mm");
                        }

                        m_iStep++;
                        return false;
                    }


                case 47: // Z 축을 측정 안전 위치로 고속 이동
                    {
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosSafetyZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 안전 위치로 고속 이동
                        {
                            _SetLog("Z axis move [Safety] position : ", m_dPosSafetyZ);
                            m_iStep++;
                        }
                        return false;
                    }

                case 48: // Z 축이 측정 안전 위치로 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosSafetyZ))
                        { return false; }
                        _SetLog("--- (Measure Done) Z axis move [Safety] positin check.");

                        // 현재 Row 측정 종료 다음 Row로 이동
                        m_iRow++;
                        _SetLog("Loop.  Row : " + m_iRow);

                        m_iStep = 41;
                        return false;
                    }


                // 측정 반복 종료 ==================================
                // Probe를 올리고 각종 축을 제자리로 이동시킨다.


                case 100:
                    {
                        Func_PrbAir(false);         // Probe Air off
                        Func_PrbDown(false);        // Probe를 Up 시켜준다.
                        //210907 pjh : Probe Up Log 추가
                        _SetLog("Probe up. Probe air off");
                        //

                        m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy];        // 이동 안전 위치

                        m_tmPrb.Set_Delay(GV.PRB_DELAY);                    // Probe Up 완료 대기 시간 측정 시작
                        _SetLog("Set Probe up delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 101:  // Z axis move Safety position
                    {
                        // if (CMot.It.Mv_N(m_iZ, m_dPosZ) == 0)
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 위치로 이동
                        {
                            _SetLog("Z axis move [Safety] position.", m_dPosZ);
                            m_iStep++;
                        }
                        return false;
                    }

                case 102: // Check csv file
                    {
                        if (CSpc.It.ChkOpenSaveDataCsv(m_eWy))
                        {
                            m_Delay.Set_Delay(1000);
                            _SetLog("Set OpenSaveDataCSV delay : 1000ms");
                        }
                        else
                        {
                            m_Delay.Set_Delay(0);
                            _SetLog("Set delay : 0ms");
                        }

                        m_iStep++;
                        return false;
                    }

                case 103: // SECSGEM
                    {
                        if ((CData.Opt.bSecsUse == true) && (CData.GemForm != null))
                        {
                            // 2021.07.19 SungTae Start : [수정] Data Shift 시 확인이 용이하도록 수정
                            if (iIdx == 0)
                            {// Before Measure
                                if (m_eWy == EWay.L)
                                {
                                    //CData.GemForm.Strip_Data_Shift(6, 7);// L Chuck Data -> Befor Data 로 이동
                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRL_TBL_CHUCK/*6*/, (int)EDataShift.GRL_BF_MEAS/*7*/);// L Chuck Data -> Befor Data 로 이동
                                }
                                else
                                {
                                    //CData.GemForm.Strip_Data_Shift(12, 13);// R Chuck Data -> R Befor Data 로 이동
                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_TBL_CHUCK/*12*/, (int)EDataShift.GRR_BF_MEAS/*13*/);// R Chuck Data -> R Befor Data 로 이동
                                }
                            }
                            else
                            {// After Measure
                                if (m_eWy == EWay.L)
                                {
                                    //CData.GemForm.Strip_Data_Shift(7, 10);// L Before Data -> L After Data 로 이동
                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRL_BF_MEAS/*7*/, (int)EDataShift.GRL_AF_MEAS/*10*/);// L Before Data -> L After Data 로 이동
                                }
                                else
                                {
                                    //if (CData.Dev.bDShiftPSkip) CData.GemForm.Strip_Data_Shift(12, 13);// R Chuck Data -> R Befor Data 로 이동
                                    //CData.GemForm.Strip_Data_Shift(13, 16);// R Befor Data -> R After Data 로 이동
                                    if (CData.Dev.bDShiftPSkip)
                                    {
                                        CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_TBL_CHUCK/*12*/, (int)EDataShift.GRR_BF_MEAS/*13*/);// R Chuck Data -> R Befor Data 로 이동
                                    }

                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_BF_MEAS/*13*/, (int)EDataShift.GRR_AF_MEAS/*16*/);// R Befor Data -> R After Data 로 이동
                                }
                            }
                            // 2021.07.19 SungTae End
                        }

                        _SetLog("SECS/GEM");

                        m_iStep++;
                        return false;
                    }


                case 104: // Check Z axis move done
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }
                        _SetLog("Check Z axis move done.");

                        m_iStep++;
                        return false;
                    }

                case 105: // X axis move zero position
                    {
                        // X축 대기 위치로 이동
                        if (CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]) == 0)
                        {
                            _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                            m_iStep++;
                        }

                        return false;
                    }

                case 106: // X axis move zero position check
                    {
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }
                        _SetLog("Check X axis move.");

                        m_iStep++;
                        return false;
                    }


                case 107: // Check delay
                    {
                        if (!m_Delay.Chk_Delay())
                        { return false; }
                        _SetLog("Check delay.");

                        m_iStep++;
                        return false;
                    }


                case 108: // Probe up check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Get_X(eX.GRDL_ProbeAMP); }
                        else
                        { bRet = CIO.It.Get_X(eX.GRDR_ProbeAMP); }

                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if(CData.CurCompany != ECompany.Qorvo && (CData.CurCompany != ECompany.Qorvo_DZ) && CData.CurCompany != ECompany.SST)
                        if (CData.CurCompany != ECompany.Qorvo && CData.CurCompany != ECompany.Qorvo_DZ &&
                            CData.CurCompany != ECompany.Qorvo_RT && CData.CurCompany != ECompany.Qorvo_NC &&
                            CData.CurCompany != ECompany.SST)
                        {
                            //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                            //if (!CIO.It.Get_X(m_eIn1) && m_tmPrb.Chk_Delay())
                            dtmp = CPrb.It.Read_Val(m_eWy);
                            if ((!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)) && m_tmPrb.Chk_Delay())
                            {
                                if (m_eWy == EWay.L)
                                {
                                    CErr.Show(eErr.LEFT_PROBE_UP_NOT_COMPLET);
                                    _SetLog("Probe up not complete.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                                else
                                {
                                    CErr.Show(eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                                    _SetLog("Probe up not complete.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }

                        if (!bRet) return false;

                        m_iStep++;
                        return false;
                    }


                case 109:
                    {//Temp 측정 값 Before or After에 복사, m_iCol = 0, m_iRow = 0, m_iStep = 0;

                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {   // Before
                            CSpc.It.SaveDataCsvU(m_eWy, "BEFORE");
							
                            if (CData.LotInfo.bLotOpen && CSQ_Main.It.m_iStat != EStatus.Manual) //191115 ksg :
                            {
								CSpc.It.SaveLotDataCsvU(ref m_myLotInfo, m_eWy, "BEFORE");
							}

                            //190714 ksg : 저장 후 Error 발생
                            if (m_eWy == EWay.L)
                            {
                                if (m_bMeaErrBf_L)
                                {
                                    CErr.Show(eErr.LEFT_GRIND_RANGEOVER_WHEN_BEFORE_MEASURE_STRIP);
                                    _SetLog("Error : Before measure rangeover.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (m_bMeaErrBf_R)
                                {
                                    CErr.Show(eErr.RIGHT_GRIND_RANGEOVER_WHEN_BEFORE_MEASURE_STRIP);
                                    _SetLog("Error : Before measure rangeover.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }
                        else
                        {   // After
                            //190528 ksg :
                            if (m_eWy == EWay.L)
                            { Array.Copy(m_aInspTemp, m_aInspShift, m_aInspTemp.Length); } //190528 ksg :                            

                            CSpc.It.SaveDataCsvU(m_eWy, "AFTER");
							
                            if (CData.LotInfo.bLotOpen && CSQ_Main.It.m_iStat != EStatus.Manual) //191115 ksg :
                            { CSpc.It.SaveLotDataCsvU(ref m_myLotInfo, m_eWy, "AFTER"); }

                            //190714 ksg : 저장 후 알람 발생
                            if (m_eWy == EWay.L)
                            {
                                if (m_bMeaErrAf_L)
                                {
                                    CErr.Show(eErr.LEFT_GRIND_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                    _SetLog("Error : Left Table After measure rangeover.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (m_bMeaErrAf_R)
                                {
                                    CErr.Show(eErr.RIGHT_GRIND_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                    _SetLog("Error : Right Table After measure rangeover.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }

                        _SetLog("Data save.");

                        m_iStep++;
                        return false;
                    }

                case 110:
                    {
                        m_iCol = 0;
                        m_iRow = 0;
                        m_iStep = 0;
                        double dMax = 0.0;
                        double dMin = 999.999;
                        double dMean = 0.0;
                        double dTotal = 0.0;
                        int iCnt = 0;
                        int iRowCnt = CData.Dev.iRow;
                        int iColCnt = CData.Dev.iCol;
                        
						SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        //190319 ksg : Bf / Af Max, Min, Ttv 표시 해야 됨
                        if (iIdx == 0)
                        {// Before 측정 Data   

                            for (int iRow = 0; iRow < iRowCnt; iRow++)
                            {
                                for (int iCol = 0; iCol < iColCnt; iCol++)
                                {
                                    for (int iU = 0; iU < CData.Dev.iUnitCnt; iU++)
                                    {
                                        double dVal = CData.GrData[m_iWy].aUnit[iU].aMeaBf[iRow, iCol];
                                        if (dVal != 0)
                                        {
                                            dMax = Math.Max(dMax, dVal);
                                            dMin = Math.Min(dMin, dVal);
                                            dTotal += dVal;
                                            CData.m_dPbVal[m_iWy].m_BFVal.Add(dVal); //191120 ksg :
                                                                                     //191118 ksg :
                                            if (CData.GemForm != null)
                                            {//Before 측정 Data 
                                                if (m_eWy == EWay.L)	{ CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Data[1, iCnt] = dVal; }// Left 측정 Data
                                                else 					{ CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Data[5, iCnt] = dVal; }// Right 측정 Data
                                            }
                                            iCnt++;
                                        }
                                    }
                                }
                            }
                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)	{ CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].nMeasure_Count[1] = iCnt; }
                                else 					{ CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].nMeasure_Count[5] = iCnt; }
                            }

                            if (iCnt != 0)	{ dMean = Math.Round((dTotal / iCnt), 4); }
                            else 			{ dMean = 0; }

                            CData.PbResultVal[m_iWy].dBMax = dMax;
                            CData.PbResultVal[m_iWy].dBMin = dMin;
                            CData.PbResultVal[m_iWy].dBAvg = dMean;

                            //191118 ksg :
                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)
                                {// Left Befor
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Min_Data[1] = dMin;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Max_Data[1] = dMax;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Avr_Data[1] = dMean;
                                }
                                else
                                {// Right Befor
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Min_Data[5] = dMin;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Max_Data[5] = dMax;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Avr_Data[5] = dMean;
                                }
                            }

                            //20190531 ghk
                            CData.PbResultVal[m_iWy].dBMean = Math.Round(((dMax + dMin) / 2), 4); //190502 ksg :
                            if (m_eWy == EWay.L)
                            {
                                if (CData.PbResultVal[m_iWy].dBMax <= CData.MPos[0].dPCBThickness || CData.PbResultVal[m_iWy].dBMin >= 999)
                                {
                                    CErr.Show(eErr.LEFT_BEFORE_PROBE_DATA_LOST);
                                    _SetLog("Error : Before data lost.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (CData.PbResultVal[m_iWy].dBMax <= CData.MPos[0].dPCBThickness || CData.PbResultVal[m_iWy].dBMin >= 999)
                                {
                                    CErr.Show(eErr.RIGHT_BEFORE_PROBE_DATA_LOST);
                                    _SetLog("Error : Before data lost.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }

                        if (iIdx == 1)
                        {//After 측정 Data

                            // 2021-05-17, jhLee, Multi-LOT, 현재 가공중인 Strip의 LOT Name을 사용하도록 한다.
                            if (CData.IsMultiLOT()) {   CData.SpcData.sLotName = CData.Parts[m_iPart].sLotName; } // Multi-LOT일 경우 가공중인 Strip의 Lot 이름을 사용한다.
                            else                    {   CData.SpcData.sLotName = CData.LotInfo.sLotName;        }

                            for (int iRow = 0; iRow < iRowCnt; iRow++)
                            {
                                for (int iCol = 0; iCol < iColCnt; iCol++)
                                {
                                    for (int iU = 0; iU < CData.Dev.iUnitCnt; iU++)
                                    {
                                        double dVal = CData.GrData[m_iWy].aUnit[iU].aMeaAf[iRow, iCol];
                                        if (dVal != 0)
                                        {
                                            dMax = Math.Max(dMax, dVal);
                                            dMin = Math.Min(dMin, dVal);
                                            CData.m_dPbVal[m_iWy].m_AFVal.Add(dVal); //191120 ksg :
                                            dTotal += dVal;

                                            //191118 ksg :
                                            if (CData.GemForm != null)
                                            {
                                                if (m_eWy == EWay.L)	{ CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Data[4, iCnt] = dVal; }
                                                else 					{ CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Data[6, iCnt] = dVal; }
                                            }
                                            iCnt++;
                                        }
                                    }
                                }
                            }
                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)	{ CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].nMeasure_Count[4] = iCnt; }
                                else 					{ CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].nMeasure_Count[6] = iCnt; }
                            }
                            if (m_eWy == EWay.L)
                            {
                                CData.SpcData.sTtvLim = CData.Dev.aData[(int)EWay.L].dTTV.ToString();

                                if (CData.Dev.aData[(int)EWay.L].dTTV != 0)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dTTV < (dMax - dMin))
                                    {
                                        CErr.Show(eErr.LEFT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);

                                        m_iStep = 0;
                                        return true;
                                    }
                                }
                            }
                            else
                            {
                                if (CData.Dev.bDual == eDual.Dual)
                                {
                                    CData.SpcData.sTtvLim = CData.Dev.aData[m_iWy].dTTV.ToString();

                                    if (CData.Dev.aData[m_iWy].dTTV != 0)
                                    {
                                        if (CData.Dev.aData[m_iWy].dTTV < (dMax - dMin))
                                        {
                                            CErr.Show(eErr.RIGHT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);

                                            m_iStep = 0;
                                            return true;
                                        }
                                    }
                                }
                                else
                                {
                                    CData.SpcData.sTtvLim = CData.Dev.aData[(int)EWay.L].dTTV.ToString();

                                    if (CData.Dev.aData[(int)EWay.L].dTTV != 0)
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dTTV < (dMax - dMin))
                                        {
                                            CErr.Show(eErr.RIGHT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);

                                            m_iStep = 0;
                                            return true;
                                        }
                                    }
                                }
                            }

                            //190319 ksg :
                            if (iCnt != 0) dMean = Math.Round((dTotal / iCnt), 4);
                            else dMean = 0;
                            CData.PbResultVal[m_iWy].dAMax = dMax;
                            CData.PbResultVal[m_iWy].dAMin = dMin;
                            CData.PbResultVal[m_iWy].dAAvg = dMean;

                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)
                                {   // SECSGEM Host에 Data Upload 진행  20200301 LCY 
                                    // Top Side : Mold_높이 + DF 측정 Data
                                    // Bottom Side : Mold 높이
                                    if (CData.Dev.eMoldSide == ESide.Top)
                                    { dTemp = CData.Parts[(int)EPart.GRDL].dPcbMean; }
                                    else dTemp = 0.0;

                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Min_Data[4] = dMin + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Max_Data[4] = dMax + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Avr_Data[4] = dMean + dTemp;
                                }
                                else
                                {   // SECSGEM Host에 Data Upload 진행  20200301 LCY
                                    // Top Side : Mold_높이 + DF 측정 Data
                                    // Bottom Side : Mold 높이
                                    if (CData.Dev.eMoldSide == ESide.Top)
                                    { dTemp = CData.Parts[(int)EPart.GRDR].dPcbMean; }
                                    else dTemp = 0.0;

                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Min_Data[6] = dMin + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Max_Data[6] = dMax + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Avr_Data[6] = dMean + dTemp;
                                }
                            }

                            if (m_eWy == EWay.L)
                            {
                                if (CData.PbResultVal[m_iWy].dBMax <= 0 || CData.PbResultVal[m_iWy].dBMin >= 999)
                                {
                                    CErr.Show(eErr.LEFT_BEFORE_PROBE_DATA_LOST);
                                    _SetLog("Error : After data lost.");

                                    //201010 jhc : Before 측정 시에만 적용
                                    //m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (CData.PbResultVal[m_iWy].dBMax <= 0 || CData.PbResultVal[m_iWy].dBMin >= 999)
                                {
                                    CErr.Show(eErr.RIGHT_BEFORE_PROBE_DATA_LOST);
                                    _SetLog("Error : After data lost.");

                                    //201010 jhc : Before 측정 시에만 적용
                                    //m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }

                            if (CData.LotInfo.bLotOpen)
                            {
                                if (iCnt != 0)
                                { dMean = dTotal / iCnt; }
                                else
                                { dMean = 0; }

                                if (m_eWy == EWay.L)
                                {
                                    CData.SpcData.sMgzNo    = CData.Parts[(int)EPart.GRDL].iMGZ_No.ToString();
                                    CData.SpcData.sSlotNo   = CData.Parts[(int)EPart.GRDL].iSlot_No.ToString();
                                    CData.SpcData.sTable    = "L";
                                    CData.SpcData.sBcr      = CData.Parts[(int)EPart.GRDL].sBcr;
                                    //191128 ksg :
                                    if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown)	{ CData.SpcData.sMode = "TopDown"; }
                                    else 													{ CData.SpcData.sMode = "Target"; }

                                    //20190703 ghk_automeasure
                                    if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                    {
										CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_AfterMeaStrip;
									}
                                }
                                else
                                {
                                    CData.SpcData.sMgzNo    = CData.Parts[(int)EPart.GRDR].iMGZ_No.ToString();
                                    CData.SpcData.sSlotNo   = CData.Parts[(int)EPart.GRDR].iSlot_No.ToString();
                                    CData.SpcData.sTable    = "R";
                                    CData.SpcData.sBcr      = CData.Parts[(int)EPart.GRDR].sBcr;

                                    //191128 ksg :
                                    if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown)	{ CData.SpcData.sMode = "TopDown"; }
                                    else 													{ CData.SpcData.sMode = "Target"; }

                                    //20190703 ghk_automeasure
                                    if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                    {
										CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_AfterMeaStrip;
									}
                                }
								
                                CData.SpcData.sMax = dMax.ToString();
                                CData.SpcData.sMin = dMin.ToString();
                                CData.SpcData.sMean = dMean.ToString();
                                CData.SpcData.sTtv = (dMax - dMin).ToString();
                                //190319 ksg :
                                CData.SpcData.sBMax = CData.PbResultVal[m_iWy].dBMax.ToString();
                                CData.SpcData.sBMin = CData.PbResultVal[m_iWy].dBMin.ToString();
                                CData.SpcData.sBAvg = CData.PbResultVal[m_iWy].dBAvg.ToString();

                                for (int i = m_iStepMaxCnt - 1; i >= 0; i--)
                                {
                                    if (CData.Dev.bDual == eDual.Dual)
                                    {
                                        if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                        {
                                            CData.SpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                            CData.SpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                            break;
                                        }
                                    }
                                    else
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].eGrdMod == eGrdMode.TopDown)
                                            {
                                                CData.SpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                CData.SpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                            }
                                            else
                                            {
                                                CData.SpcData.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                CData.SpcInfo.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                            }
                                            break;
                                        }
                                    }
                                }

                                if (CData.CurCompany == ECompany.ASE_KR)    { CSpc.It.SaveLotData_Add();    }
                                else                                        { CSpc.It.SaveLotData();        }

                                //190529 ksg :
                                if (m_eWy == EWay.L && CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown)
                                {
                                    if (CData.IsMultiLOT())
                                    {
                                        double.TryParse(m_myLotInfo.rSpcInfo.sTarget, out CData.Parts[(int)EPart.GRDL].dShiftT);
                                    }
                                    else
                                    {
									    double.TryParse(CData.SpcInfo.sTarget, out CData.Parts[(int)EPart.GRDL].dShiftT);
									}
                                    // CData.Parts[(int)EPart.GRDL].dShiftT = Convert.ToDouble(CData.SpcInfo.sTarget);
                                }
                            }
                        }

                        if (CData.LotInfo.bLotOpen)
                        {
                            string sTemp = (iIdx == 0) ? "BEFORE" : "AFTER";

                            CSpc.It.SaveDataIniU(ref m_myLotInfo, m_eWy, sTemp);

                            //20190703 ghk_automeasure
                            if (m_eWy == EWay.L)
                            {
                                if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                { CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_AfterMeaStrip; }
                            }
                            else
                            {
                                if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                { CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_AfterMeaStrip; }
                            }
                        }

                        _SetLog("===== Measure Unit Z Motorize Finish.  Status : " + CData.Parts[m_iPart].iStat);

                        m_iStep = 0;
                        return true;
                    }



                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스

                case 200:
                    {  // Probe up
                        bool bRet = false;
                        CMot.It.Stop(m_iZ);                                 // Z축 이동 중지

                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Set_Y(eY.GRDL_ProbeDn, false); }
                        else
                        { bRet = CIO.It.Set_Y(eY.GRDR_ProbeDn, false); }

                        if (!bRet) return false;
                        _SetLog("Probe up.");

                        m_tmPrb.Set_Delay(GV.PRB_DELAY);                    // Probe Up 완료 대기 시간 측정 시작
                        _SetLog("Set Probe up delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 201:
                    {//Z축 대기 위치 이동
                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        { m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy]; }
                        else
                        { m_dPosZ = CData.SPos.dGRD_Z_Wait[m_iWy]; }

                        CMot.It.Mv_N(m_iZ, m_dPosZ);

                        _SetLog("ERROR : Picker Vacuum : " + m_siZ + " UP : " + m_dPosZ.ToString());

                        m_iStep++;
                        return false;
                    }


                case 202: // Probe up check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = CIO.It.Get_X(eX.GRDL_ProbeAMP); }
                        else
                        { bRet = CIO.It.Get_X(eX.GRDR_ProbeAMP); }

                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if(CData.CurCompany != ECompany.Qorvo && (CData.CurCompany != ECompany.Qorvo_DZ) && CData.CurCompany != ECompany.SST)
                        if (CData.CurCompany != ECompany.Qorvo && CData.CurCompany != ECompany.Qorvo_DZ &&
                            CData.CurCompany != ECompany.Qorvo_RT && CData.CurCompany != ECompany.Qorvo_NC &&
                            CData.CurCompany != ECompany.SST)
                        {
                            //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                            //if (!CIO.It.Get_X(m_eIn1) && m_tmPrb.Chk_Delay())
                            dtmp = CPrb.It.Read_Val(m_eWy);
                            if ((!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight)) && m_tmPrb.Chk_Delay())
                            {
                                if (m_eWy == EWay.L)
                                {
                                    CErr.Show(eErr.LEFT_PROBE_UP_NOT_COMPLET);
                                    _SetLog("Probe up not complete.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                                else
                                {
                                    CErr.Show(eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                                    _SetLog("Probe up not complete.");

                                    m_bSubErr = true;

                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }

                        if (!bRet) return false;

                        m_iStep++;
                        return false;
                    }

                case 203:
                    {//Z축 대기 위치 이동 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            //d CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }

                        if (m_iPickerVacErr == 1)
                        { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else
                        { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        _SetLog("Picker Vacuum ERROR " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        m_bSubErr = true;

                        m_iStep = 0;
                        return true;
                    }



                // 수행을 종료 할 경우 (정상적인 Case) Down 되었던 Probe를 Up 하고 Z축을 안전 위치로 이동 시킨다.
                case 300:
                    {
                        Func_PrbAir(false);         // Probe Air off
                        Func_PrbDown(false);        // Probe를 Up 시켜준다.
                        //210907 pjh : Probe Up Log 추가
                        _SetLog("Probe up. Probe air off");
                        //

                        m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy];        // 이동 안전 위치
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move [Safety] position.", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 301:   //Z축 대기 위치 이동 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            //d CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }

                        m_iStep++;
                        return false;
                    }

                case 302:   // Probe Up 확인
                    {
                        //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        bool bProbeUp = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy);             //프로브 값
                        if (bProbeUp && (dProbeVal >= GV.dProbeUpHeight))
                        {
                            _SetLog("===== Measure Unit Z-Motorize End =====");

                            m_iStep = 0;
                            return true;            // 수행 종료 처리
                        }

                        return false;
                    }


                    ///////////////////////////////////////////////////////////////////////////////////////
            }//of switch
        }//of public bool Cyl_MeaUnit_ZAxis(int iIdx)



        /// <summary>
        /// 2020-11-04, jhLee, 기존 T1과 T2 계열로 나뉜것을 하나로 통합
        /// Strip Thickness Measure function by Z-Axis motion
        /// 스트립 두께 측정 함수 0:Before, 1:After
        /// Probe의 Down/Up이 아닌 Z축 모션을 통해 Probe 측정위치로 눌러 측정하도록 변경된 함수
        /// </summary>
        /// <param name="iIdx"></param>
        /// <returns></returns>
        public bool Cyl_MeaStrip_ZMotor(int iIdx)
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            {
                m_mTimeout.Set_Delay(TIMEOUT);
            }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (iIdx == (int)EMeaStep.Before/*0*/)     // 2022.05.25 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                    {
                        CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_STRIP_INSPECTION_BEFORE_TIMEOUT :
                                                           eErr.RIGHT_GRIND_STRIP_INSPECTION_BEFORE_TIMEOUT);
                        _SetLog("Error : Before timeout.");
                        // 201009 jym : Before 측정 시에만 적용
                        m_bSubErr = true;
                    }
                    else
                    {
                        CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_STRIP_INSPECTION_AFTER_TIMEOUT :
                                                           eErr.RIGHT_GRIND_STRIP_INSPECTION_AFTER_TIMEOUT);
                        _SetLog("Error : After timeout.");
                    }

                    //! 최소 Probe up 명령 필요
                    Func_PrbAir(false);         // Probe Air off
                    Func_PrbDown(false);        // Probe를 Up 시켜준다.

                    //210907 pjh : Probe Up Log 추가
                    _SetLog("Probe up. Probe air off");
                    //

                    m_iStep = 0;
                    return true;
                }
            }

            if (!Chk_Strip())
            {
                CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_VACUUM_ERROR :
                                                   eErr.RIGHT_GRIND_VACUUM_ERROR);
                _SetLog("Error : Vacuum fail.");

                // 201009 jym : Before 측정 시에만 적용
                if (iIdx == (int)EMeaStep.Before/*0*/)     // 2022.05.25 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                {
                    m_bSubErr = true;
                }

                //! 최소 Probe up 명령 필요
                Func_PrbAir(false);         // Probe Air off
                Func_PrbDown(false);        // Probe를 Up 시켜준다.

                //210907 pjh : Probe Up Log 추가
                _SetLog("Probe up. Probe air off");
                //
                m_iStep = 0;

                return true;
            }

            m_iPreStep = m_iStep;

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if (CData.CurCompany == ECompany.ASE_KR)
            {
                if ((m_iStep == 16) || (m_iStep == 17) || (m_iStep == 18) || (m_iStep == 26) || (m_iStep == 27) || (m_iStep == 28)
                     || (m_iStep == 35) || (m_iStep == 36) || (m_iStep == 40) || (m_iStep == 41))
                {   //Table Y축 대기 위치로 Moving 전 또는 Moving 중
                    m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                    if (0 != m_iPickerVacErr)
                    {
                        CMot.It.EStop(m_iY); //Table Y축 즉시 Stop
                        _SetLog("Error : Picker vacuum fail.", CMot.It.Get_FP(m_iY));

                        m_iStep = 100; //정리 스텝으로
                        return false;
                    }
                }
            }
            ///////////////////////////////////////////////////////////////////////////////////////

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10:
                    {// 축 상태 체크
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);
                            
                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }

                        _SetLog("===== Measure Strip Z-Motorize Start =====");

                        m_bMeaErrBf_L = false;
                        m_bMeaErrAf_L = false;
                        m_bMeaErrBf_R = false;
                        m_bMeaErrAf_R = false;

                        // 2022.08.05 SungTae Start : [추가] (ASE-KR 개발건)
                        if (CData.CurCompany == ECompany.ASE_KR)
                        {
                            m_bMeaErr_FinalTarget_L = false;
                            m_bMeaErr_FinalTarget_R = false;
                        }
                        // 2022.08.05 SungTae End

                        // jhLee, Multi-LOT의 경우에도 SPC 기록
                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        //190319 ksg :
                        ProbeClearVal(iIdx);

                        //190717 ksg : 데이터 클리어 요청
                        if((CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ ||
                            CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC ||
                            CData.CurCompany == ECompany.SST) && iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            ProbeClearVal(iIdx + 1);
                        }

                        //191120 ksg :
                        InitPbValue(m_iWy, iIdx);

                        // 200920 jym : 프로브 업 체크 카운트 초기화
                        m_iPrbUpCnt = 0;

                        m_bSubErr = false;

                        _SetLog("Check axes.");

                        m_iStep++;
                        return false;
                    }

                case 11:
                    {// IO 초기화
                        _InitCycle();
                        _SetLog("Init cycle.");

                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            if (!CData.dfInfo.bBusy)
                            {
                                if (m_eWy == EWay.L)
                                {
                                    if (iIdx == (int)EMeaStep.Before/*0*/)
                                    {
                                        CData.GRLDfData.sBcr = CData.Parts[(int)EPart.GRDL].sBcr;
                                        CDf.It.SendBfStart("LGD");
                                    }
                                    else
                                    {
                                        if (CData.Dev.bDual == eDual.Normal)
                                        {
                                            CData.GRLDfData.sBcr = CData.Parts[(int)EPart.GRDL].sBcr;
                                            CDf.It.SendAfStart("LGD");
                                        }
                                    }
                                }
                                else
                                {
                                    if (iIdx == (int)EMeaStep.Before/*0*/ && CData.Dev.bDual == eDual.Normal)
                                    {
                                        CData.GRRDfData.sBcr = CData.Parts[(int)EPart.GRDR].sBcr;
                                        CDf.It.SendBfStart("RGD");
                                    }
                                    else if (iIdx == (int)EMeaStep.After/*1*/)
                                    {
                                        CData.GRRDfData.sBcr = CData.Parts[(int)EPart.GRDR].sBcr;
                                        CDf.It.SendAfStart("RGD");
                                    }
                                }
                            }
                            else
                            {
                                return false;
                            }
                        }

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {// 데이터 저장 변수 초기화                       
                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            if (m_eWy == EWay.L)
                            {
                                if (iIdx == (int)EMeaStep.Before/*0*/)
                                {
                                    if (!CDf.It.ReciveAckGRL((int)ECMD.scBfStartL))
                                    { return false; }
                                }
                                else
                                {
                                    if (CData.Dev.bDual == eDual.Normal)
                                    {
                                        if (!CDf.It.ReciveAckGRL((int)ECMD.scAfStartL))
                                        { return false; }
                                    }
                                }

                                if (CData.dfInfo.sGl == "GL1" && iIdx == (int)EMeaStep.Before/*0*/ && CDataOption.MeasureDf == eDfServerType.MeasureDf)
                                {//GL1이고, Before측정이고, DF서버 사용시 DF 측정 할때
                                    if (!CData.dfInfo.bBusy)
                                    {
                                        CData.GRLDfData.dPcb1 = CData.Parts[(int)EPart.GRDL].dPcb[0];
                                        CData.GRLDfData.dPcb2 = CData.Parts[(int)EPart.GRDL].dPcb[1];
                                        CData.GRLDfData.dPcb3 = CData.Parts[(int)EPart.GRDL].dPcb[2];

                                        if (CData.Dynamic.iHeightType == 0)         { CData.GRLDfData.sPcbUse = "Max"; }
                                        else if (CData.Dynamic.iHeightType == 1)    { CData.GRLDfData.sPcbUse = "Avg"; }

                                        CDf.It.SendPcbData("LGD");
                                    }
                                    else
                                    {
                                        return false;
                                    }
                                }
                            }
                            else
                            {
                                if (iIdx == (int)EMeaStep.Before/*0*/ && CData.Dev.bDual == eDual.Normal)
                                {
                                    if (!CDf.It.ReciveAckGRR((int)ECMD.scBfStartR))
                                    { return false; }
                                }
                                else if (iIdx == (int)EMeaStep.After/*1*/)
                                {
                                    if (!CDf.It.ReciveAckGRR((int)ECMD.scAfStartR))
                                    { return false; }
                                }

                                //20191029 ghk_dfserver_notuse_df
                                //if (CData.dfInfo.sGl == "GL1" && iIdx == 0 && CData.Dev.bDual == eDual.Normal)
                                if (CData.dfInfo.sGl == "GL1" && iIdx == (int)EMeaStep.Before/*0*/ && CData.Dev.bDual == eDual.Normal && CDataOption.MeasureDf == eDfServerType.MeasureDf)
                                {//GL1이고, Before측정이고, Step모드 아니고, DF서버 사용시 DF 측정 할때
                                    if (!CData.dfInfo.bBusy)
                                    {
                                        CData.GRRDfData.dPcb1 = CData.Parts[(int)EPart.GRDR].dPcb[0];
                                        CData.GRRDfData.dPcb2 = CData.Parts[(int)EPart.GRDR].dPcb[1];
                                        CData.GRRDfData.dPcb3 = CData.Parts[(int)EPart.GRDR].dPcb[2];

                                        if (CData.Dynamic.iHeightType == 0)         { CData.GRRDfData.sPcbUse = "Max"; }
                                        else if (CData.Dynamic.iHeightType == 1)    { CData.GRRDfData.sPcbUse = "Avg"; }

                                        CDf.It.SendPcbData("RGD");
                                    }
                                    else
                                    {
                                        return false;
                                    }
                                }
                            }
                        }
                        //

                        m_iRow = 0;
                        m_iCol = 0;
                        m_dPosX = CData.SPos.dGRD_X_Zero[m_iWy];
                        m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS;
                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];

                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_ProbeDn;
                            m_eOt2 = eY.GRDL_ProbeAir;
                            m_eIn1 = eX.GRDL_ProbeAMP;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_ProbeDn;
                            m_eOt2 = eY.GRDR_ProbeAir;
                            m_eIn1 = eX.GRDR_ProbeAMP;
                        }

                        if (iIdx == (int)EMeaStep.Before/*0*/)     // 2022.05.25 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                        {
                            m_aInspBf       = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            m_aInspTotalBf  = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];    // 2020.09.14 JSKim Add
                            m_abMeaBfErr    = new bool[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            
                            CData.GrData[m_iWy].aMeaBf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            
                            // 새로운 자재 투입 시 전후 데이터 클리어
                            if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ ||
                                CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC ||
                                CData.CurCompany == ECompany.SST)
                            {
                                m_aInspAf       = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                                m_aInspTotalAf  = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];    // 2020.09.14 JSKim Add
                                m_abMeaAfErr    = new bool[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                                
                                CData.GrData[m_iWy].aMeaAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            }
                        }
                        else
                        {
                            m_aInspAf       = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            m_aInspTotalAf  = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];     // 2020.09.14 JSKim Add
                            m_abMeaAfErr    = new bool[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];

                            CData.GrData[m_iWy].aMeaAf = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];

                            if (m_eWy == EWay.L)
                            {
                                m_aInspShift = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                            }
                        }

                        m_aInspTemp      = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];
                        m_aInspTotalTemp = new double[CData.Dev.iRow * CData.Dev.iWinCnt, CData.Dev.iCol];  // 2020.09.14 JSKim Add

                        _SetLog("Init data.");

                        //2021.08.06 syc : Up상태일때 Probe 값 정상 범위 인지 확인
                        //- Qorvo 프로브 앰프값 자동으로 바뀌는 이슈에 대한 방지책
                        //- Probe 값이 18.9xxx ~ 19.0xxx 범위 이탈시 알람
                        if (Chk_ProbeUpVal())
                        {
                            m_bSubErr = true;//211006 pjh : 측정 Error 시 Cycle Stop

                            m_iStep = 0;
                            return true;
                        }

                        m_iStep++;
                        return false;
                    }

                case 13: // DF server 응답 대기
                    {
                        // 2022.05.25 SungTae : [수정] 코드 확인이 용이하도록 변경 (0 -> (int)EMeaStep.Before)
                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl == "GL1" && iIdx == (int)EMeaStep.Before/*0*/ &&
                            CSQ_Main.It.m_iStat == EStatus.Auto_Running && CDataOption.MeasureDf == eDfServerType.MeasureDf)
                        {
                            if (m_eWy == EWay.L)
                            {
                                if (!CDf.It.ReciveAckGRL((int)ECMD.scPcbL))
                                {
                                    return false;
                                }
                            }
                            else
                            {
                                if (CData.Dev.bDual == eDual.Normal)
                                {
                                    if (!CDf.It.ReciveAckGRR((int)ECMD.scPcbR))
                                    {
                                        return false;
                                    }
                                }
                            }
                        }

                        m_iStep++;
                        return false;
                    }


                case 14: // Z 축 안전 위치로 이동
                    {
                        m_dPosSafetyZ = CData.SPos.dGRD_Z_Able[m_iWy];          // 초기 안전위치
                        
                        //old if (CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]) == 0)   //Z축 이동 안전 위치로 이동
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosSafetyZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 안전 위치로 고속 이동
                        {
                            _SetLog("--- (Move start) Z axis move [Safety] position : ", m_dPosSafetyZ);
                            m_iStep++;
                        }
                        return false;
                    }

                case 15: // Z 축 안전 위치로 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosSafetyZ))   { return false; }

                        _SetLog("Z axis move [Safety] positin check. Probe Down.");

                        ActPrbDown(true);       // Probe Down 명령

                        m_iStep++;
                        return false;
                    }

                case 16: // Y axis move start to table inspection position
                    {
                        // 2022.07.05 SungTae Start : [수정] (ASE-KR VOC) Motorizing 사용 시 Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가
                        //if (CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]) == 0)
                        //{
                        //    _SetLog("Y axis move to table base", CData.SPos.dGRD_Y_TblInsp[m_iWy]);
                        //    m_iStep++;
                        //}

                        string sTblBase = (m_iTblMeasCnt == 0) ? "TOP" : "BTM";
                        double dPosY = 0.0;

                        if(m_iTblMeasCnt == 0)
                        {
                            // Table Y-Axis Top Position
                            dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                        }
                        else
                        {
                            // Table Y-Axis Btm Position
                            dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy] + Math.Abs((CData.SPos.dGRD_Y_TblInsp[m_iWy] - CData.MPos[m_iWy].dY_PRB_TBL_CENTER)) * 2;
                        }

                        if (CMot.It.Mv_N(m_iY, dPosY) == 0)
                        {
                            _SetLog($"--- [{sTblBase}] Y axis move to measure table base", dPosY);
                            m_iStep++;
                        }
                        // 2022.07.05 SungTae End

                        return false;
                    }

                case 17: // X axis move start to zero position
                    {
                        
                        if (CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]) == 0)
                        {
                            _SetLog("--- X axis move to zero.", CData.SPos.dGRD_X_Zero[m_iWy]);
                            m_iStep++;
                        }

                        return false;
                    }

                case 18: // X, Y axis move finish table inspection position check
                    {
                        // 2022.07.05 SungTae Start : [수정] (ASE-KR VOC) Motorizing 사용 시 Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가
                        //if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]) || !CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        //{
                        //    return false;
                        //}

                        double dPosY = 0.0;

                        if (m_iTblMeasCnt == 0)
                            dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                        else
                            dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy] + Math.Abs((CData.SPos.dGRD_Y_TblInsp[m_iWy] - CData.MPos[m_iWy].dY_PRB_TBL_CENTER)) * 2;
                        
                        if (!CMot.It.Get_Mv(m_iY, dPosY) || !CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        {
                            return false;
                        }
                        // 2022.07.05 SungTae End

                        Func_PrbDown(true);     // 이전에 Down 하였지만 확인차 다시 수행
                        ActPrbAir(true);        // Probe air on check 이물질을 제거하기위한 Air를 분출한다.

                        _SetLog("--- (Move done) X/Y axis move [Table Measure] check & probe air on");

                        m_iStep++;
                        return false;
                    }

                case 19: // Probe down check
                    {
                        bool bRet = false;

                        if (m_eWy == EWay.L)    { bRet = !CIO.It.Get_X(eX.GRDL_ProbeAMP); }
                        else                    { bRet = !CIO.It.Get_X(eX.GRDR_ProbeAMP); }

                        if (!bRet)              { return false; }

                        _SetLog("Probe down & check.");

                        // Probe overdirve 지정값 만큼 더 내린다.
                        m_dPosZ = (CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS) + (CData.Opt.dProbeOD - 1.0);
                        
                        _SetLog("Set Measure Z axis down position : " + m_dPosZ.ToString() + " & OD : " + CData.Opt.dProbeOD.ToString());

                        m_iStep++;
                        return false;
                    }


                case 20: // Z 축 Table 측정 위치로 Down 이동
                    {
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 측정 위치로 Down 이동
                        {
                            _SetLog("--- (Z Move down start) Z axis move [Table Measure] position : " + m_dPosZ.ToString());
                            m_iStep++;
                        }

                        return false;
                    }

                case 21: // Z 축 측정 위치로 Down 이동 완료 확인, Probe air off
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ)) { return false; }

                        ActPrbAir(false);               // Probe air off

                        _SetLog("--- (Z Move down done) Z axis move [Table Measure] position done check, probe air off.");

                        // Probe stable delay : Z축 Down 이동 후 Probe가 안정될 때까지 지정된 시간동안 지연한다.
                        m_tmPrb.Set_Delay(CData.Opt.iProbeStableDelay);
                        _SetLog("Set Probe stable delay : " + CData.Opt.iProbeStableDelay + "ms");

                        m_iStep++;           // 안정화 지연 후 값 측정 step으로 이동
                        return false;
                    }

                case 22:    //프로브 에어 오프 확인, 프로브 값 획득 후 테이블 높이 계산
                    {
                        // 안정화 시간 지연 이내 이거나 Air가 꺼지지 않았다면 return
                        if (!m_tmPrb.Chk_Delay() || ActPrbAir(false))
                        {
                            return false;
                        }
                        
                        // Probe값 Read    
                        double dProbeValue = CPrb.It.Read_Val(m_eWy);

                        m_InspZeroOffset = dProbeValue - (CData.Opt.dProbeOD - 1.0);                // 더 눌러준 값 만큼 복원

                        // 2022.07.05 SungTae Start : [수정] (ASE-KR VOC) Motorizing 사용 시 Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가
                        //CData.Tbl_Af[m_iWy, 0] = m_InspZeroOffset + GV.EQP_TABLE_MIN_THICKNESS;     // 실제 Table 높이

                        CData.Tbl_Af[m_iWy, m_iTblMeasCnt] = m_InspZeroOffset + GV.EQP_TABLE_MIN_THICKNESS;     // 실제 Table 높이

                        // 2022.05.25 SungTae Start : [수정] Log 수정
                        string sWay = (m_iWy == (int)EWay.L) ? "LEFT" : "RIGHT";

                        //_SetLog("--- (Probe Read) Probe=" + dProbeValue.ToString() + "  InspZeroOffset=" + m_InspZeroOffset.ToString() +
                        //        "  Table Height=" + CData.Tbl_Af[m_iWy, 0].ToString());
                        _SetLog($"--- [{sWay}] (Probe Read) Probe = {dProbeValue},  InspZeroOffset = {m_InspZeroOffset},  Table Height : {CData.Tbl_Af[m_iWy, m_iTblMeasCnt/*0*/]}");
                        // 2022.05.25 SungTae End

                        //if (CData.Tbl_Af[m_iWy, 0] > (GV.EQP_TABLE_MIN_THICKNESS + 4))
                        if (CData.Tbl_Af[m_iWy, 0] > (GV.EQP_TABLE_MIN_THICKNESS + 4) || CData.Tbl_Af[m_iWy, 1] > (GV.EQP_TABLE_MIN_THICKNESS + 4))
                        {
                            CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_MANUALZIG_ON_THE_TABLE :
                                                                eErr.RIGHT_GRIND_MANUALZIG_ON_THE_TABLE);

                            _SetLog("Error : Manual zig on table.");

                            m_bSubErr = true;

                            //d m_iStep = 0;
                            m_iGStep = 0;       // Grinding sequece initial
                            m_iStep = 100;      // 비정상 종료처리로 간다.
                            return false;
                        }
                        // 2022.07.05 SungTae End

                        m_InspZeroOffset = 0; //20200506 jym : DEBUG

                        // 축 대기위치는 Talble이 측정된 위치에서 안전 Offset으로 설정된 만큼 위로 올라간 위치이다.
                        //
                        // 측정 대기위치 = TableBase - (실측된 Table 높이 + 안전 위치 offset)
                        m_dPosSafetyZ = CData.MPos[m_iWy].dZ_TBL_BASE - (CData.Tbl_Af[m_iWy, 0] + CData.Opt.dSafetyTopOffset);

                        // Z축의 이동 안전 위치가 Table 상부 8mm 보다 낮다면 안전을 위해 최소 높이를 적용한다.
                        if (m_dPosSafetyZ > (CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS - 8))
                        {
                            _SetLog("(Warning !) Z axis [Safety] position too low : ", m_dPosSafetyZ);

                            // Table 상부보다 10mm 높게 강제로 설정한다.
                            m_dPosSafetyZ = (CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS - 8);

                            _SetLog("(Warning !) Z axis [Safety] position set : ", m_dPosSafetyZ);
                        }

                        m_iStep++;
                        return false;
                    }

                case 23: // Z 축 측정 대기 위치로 이동, Probe는 Down 상태를 유지한다.
                    {
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosSafetyZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 고속 안전 위치로 이동
                        {
                            _SetLog("--- (Z Move up start) Z axis move [Safety] position : ", m_dPosSafetyZ);
                            m_iStep++;
                        }
                        return false;
                    }

                case 24: // Z 축 안전 위치로 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosSafetyZ))
                        {
                            return false;
                        }
                        
                        _SetLog("--- (Z Move up done) Z axis move [Safety] positin check.");

                        // Data Shift 처리
                        //200325 ksg : Data Shift Probe Skip
                        if (CData.Dev.bDShiftPSkip && m_eWy == EWay.R && iIdx == 0 && CSQ_Main.It.m_bRun && CData.Dev.bDual == eDual.Dual) //200428 ksg : Data Shift Probe Skip 조건 추가
                        {
                            //200513 myk : Dats Shift 시 One Point 강제 셋팅
                            CData.GrData[(int)EWay.R].aOldOnPont[0] = CData.Parts[(int)EPart.GRDR].dShiftT;
                            _SetLog("Data shift Mode, Use One Point value :", CData.Parts[(int)EPart.GRDR].dShiftT);

                            //! 현재는 Probe가 Down되어있는상태이므로 반드시 Up 시켜주는 처리를 마친다음에 끝내도록 한다.
                            m_iStep = 200;      // 종료 처리
                            return false;
                        }

                        //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                        //여기에서 스트립 측정 포인트 18 포인트(Leading Strip)인지? 일반(Main Strip)인지? 결정
                        if (CDataOption.Use18PointMeasure)
                        {
                            if (iIdx == (int)EMeaStep.Before/*0*/) //200713 jhc : Before인 경우에만 18 포인트 스트립 여부 검사
                            {
                                this._checkIf18PStrip(ref CData.Parts[m_iPart].b18PMeasure, true);
                            }
                            else
                            {//After인 경우에는 현재 설정된 18 포인트 스트립 여부값을 참조
                             //Nothing to do
                            }

                            _SetLog("18 point measure : " + CData.Parts[m_iPart].b18PMeasure);
                        }
                        else
                        {
                            CData.Parts[m_iPart].b18PMeasure = false;
                        }

                        // 2022.07.05 SungTae Start : [수정] (ASE-KR VOC) Motorizing 사용 시 Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가
                        //m_iStep++;

                        if(m_iTblMeasCnt == 0)
                        {
                            m_iTblMeasCnt++;
                            m_iStep = 14;
                        }
                        else
                        {
                            m_iTblMeasCnt = 0;
                            m_iStep++;
                        }
                        // 2022.07.05 SungTae End

                        return false;
                    }


                //1. m_iCol < CData.Dev.iCol 인지 확인
                //2. [m_iRow, m_iCol].bUse = true 인지 확인 for(int i = 0; i < CData.Dev.iRow)
                //3. [m_iRow, m_iCol].dX = Probe X축 Zero 위치와 같은지 확인
                //4. X축 [m_iRow, m_iCol].dX 위치로 이동
                //5. 테이블 상단 측정 후 프로브 X축 Zero일때 테이블 위치와 차이값 계산(m_InspOffset)
                //6. m_iRow < CData.Dev.iRow일때 m_iRow++ 하면서 bUse = true 일경우 프로브값 - m_InspOffset = 해당 위치 자재 높이
                //7. m_iCol++ 후 1번부터 반복
                //8. 처리를 마치면 case 47로 간다.

                case 25:
                    {  //== 반복 시작 지점 == 테이블 Y축 자재 측정 위치 이동 확인, m_iCol < CData.Dev.iCol 인지 확인, 
                       // m_iCol열에서 사용자 설정 위치 있는지 확인, 있을 경우 프로브 X축 테이블 측정 위치와 같은지 확인, 같지 않을 경우 프로브 X축 해당 열위치로 이동                       
                        bool bTemp = false;

                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            //Before 자재 측정
                            if (m_iCol < CData.Dev.iCol)
                            {
                                //측정 열이 사용자가 설정한 열보다 작은지 확인
                                for (int i = 0; i < CData.Dev.iRow * CData.Dev.iWinCnt; i++)
                                {
                                    //해당 열의 모든행에 사용자가 설정한 측정 포인트가 있는지 검사

                                    //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                                    if (CData.Parts[m_iPart].b18PMeasure)   { bTemp = CData.Dev.aData[m_iWy].aPosBf[i, m_iCol].bUse18P; }
                                    else                                    { bTemp = CData.Dev.aData[m_iWy].aPosBf[i, m_iCol].bUse; }

                                    if (bTemp) { break; }
                                }

                                if (bTemp)
                                {
                                    //해당 열 사용자 설정 측정 위치 있을 경우 해당 열이 센터와 같은지 확인 후 다를 경우 프로브 X축 해당 열 측정 위치로 이동
                                    if (m_dPosX != CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX)
                                    {
                                        // 2022.07.05 SungTae Start : [수정] (ASE-KR VOC) Motorizing 사용 시 Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가
                                        //프로브 X축 [m_iCol] 열 테이블 측정 위치로 이동
                                        //m_dPosX = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX;
                                        //_SetLog("set X axis position : ", m_dPosX);

                                        string sMeas = (iIdx == (int)EMeaStep.Before/*0*/) ? "BEFORE" : "AFTER";
                                        string sWay = (m_iWy == (int)EWay.L) ? "LEFT" : "RIGHT";

                                        if (m_iWy == (int)EWay.L)
                                        {
                                            m_dPosX = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX + CData.Dev.dMeasOffsetX;

                                            _SetLog($"[{sMeas}][{sWay}] Set X axis position({m_dPosX}) = {CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX} + {CData.Dev.dMeasOffsetX}(Offset X)");
                                        }
                                        else
                                        {
                                            m_dPosX = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX - CData.Dev.dMeasOffsetX;

                                            _SetLog($"[{sMeas}][{sWay}] Set X axis position({m_dPosX}) = {CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dX} - {CData.Dev.dMeasOffsetX}(Offset X)");
                                        }
                                        // 2022.07.05 SungTae End

                                        // m_iRow 자재 측정 위치로 이동
                                        // CMot.It.Mv_N(m_iX, m_dPosX);
                                        // CMot.It.Mv_N(m_iY, m_dPosY);
                                        // _SetLog("Y axis move position.", m_dPosY);
                                    }

                                    _SetLog(string.Format("Use point(before).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                    m_iStep++;
                                }
                                else
                                {//해당 열에 사용자설정 측정 위치 없을 경우 m_iCol++ 후 반복
                                    m_iCol++;
                                    return false;
                                }
                            }
                            else
                            {
                                _SetLog(string.Format("Column end(before).  Col : {0}  Row : {1}", m_iCol, m_iRow));

                                // 반복 측정을 마치는 곳으로 간다.
                                m_iStep = 47;
                            }
                        }
                        else
                        {
                            //After 자재 측정
                            if (m_iCol < CData.Dev.iCol)
                            {
                                //측정 열이 사용자가 설정한 열보다 작은지 확인
                                for (int i = 0; i < CData.Dev.iRow * CData.Dev.iWinCnt; i++)
                                {
                                    //해당 열의 모든행에 사용자가 설정한 측정 포인트가 있는지 검사

                                    //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                                    if (CData.Parts[m_iPart].b18PMeasure)   { bTemp = CData.Dev.aData[m_iWy].aPosAf[i, m_iCol].bUse18P; }
                                    else                                    { bTemp = CData.Dev.aData[m_iWy].aPosAf[i, m_iCol].bUse; }

                                    if (bTemp) { break; }
                                }

                                if (bTemp)
                                {
                                    //해당 열 사용자 설정 측정 위치 있을 경우 해당 열이 센터와 같은지 확인 후 다를 경우 프로브 X축 해당 열 측정 위치로 이동
                                    if (m_dPosX != CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX)
                                    {
                                        // 2022.07.05 SungTae Start : [수정] (ASE-KR VOC) Motorizing 사용 시 Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가
                                        //프로브 X축 [m_iCol] 열 테이블 측정 위치로 이동
                                        //m_dPosX = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX;
                                        //_SetLog("set X axis position : ", m_dPosX);

                                        string sMeas = (iIdx == (int)EMeaStep.Before/*0*/) ? "BEFORE" : "AFTER";
                                        string sWay = (m_iWy == (int)EWay.L) ? "LEFT" : "RIGHT";

                                        if (m_iWy == (int)EWay.L)
                                        {
                                            m_dPosX = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX + CData.Dev.dMeasOffsetX;

                                            _SetLog($"[{sMeas}][{sWay}] Set X axis position({m_dPosX}) = {CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX} + {CData.Dev.dMeasOffsetX}(Offset X)");
                                        }
                                        else
                                        {
                                            m_dPosX = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX - CData.Dev.dMeasOffsetX;

                                            _SetLog($"[{sMeas}][{sWay}] Set X axis position({m_dPosX}) = {CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dX} - {CData.Dev.dMeasOffsetX}(Offset X)");
                                        }
                                        // 2022.07.05 SungTae End

                                        //CMot.It.Mv_N(m_iX, m_dPosX);
                                        //_SetLog("X axis move position.", m_dPosX);
                                        //CMot.It.Mv_N(m_iY, m_dPosY);
                                        //_SetLog("Y axis move position.", m_dPosY);
                                    }

                                    // m_iRow 자재 측정 위치로 이동

                                    _SetLog(string.Format("Use point(after).  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                    m_iStep++;
                                }
                                else
                                {//해당 열에 사용자설정 측정 위치 없을 경우 m_iCol++ 후 반복
                                    m_iCol++;
                                    return false;
                                }
                            }
                            else
                            {
                                _SetLog(string.Format("Column end(after).  Col : {0}  Row : {1}", m_iCol, m_iRow));

                                // 반복 측정을 마치는 곳으로 간다.
                                m_iStep = 47;
                            }
                        }

                        return false;
                    } //of case 25

                case 26: // Y axis move start 
                    {
                        // 현재 위치가 지정한 Y축 위치와 다르다면 Y축을 이동시켜준다.
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        {
                            if (CMot.It.Mv_N(m_iY, m_dPosY) != 0)
                            {
                                return false;
                            }
                        }

                        _SetLog("--- (X/Y Move start) Y axis move table base : ", m_dPosY);

                        m_iStep++;
                        return false;
                    }

                case 27: // X axis move start
                    {
                        // 현재 위치가 지정한 X축 위치와 다르다면 X축을 이동시켜준다.
                        if (!CMot.It.Get_Mv(m_iX, m_dPosX))
                        {
                            if (CMot.It.Mv_N(m_iX, m_dPosX) != 0)
                            {
                                return false;
                            }

                            _SetLog("X axis move position : " + m_dPosX.ToString() + "  Col : " + m_iCol.ToString());
                        }

                        m_iStep++;
                        return false;
                    }

                case 28: // X, Y axis move position check
                    {
                        if (!CMot.It.Get_Mv(m_iX, m_dPosX) || !CMot.It.Get_Mv(m_iY, m_dPosY))
                        {
                            return false;
                        }

                        _SetLog("--- (X/Y Move Done) Check X, Y axis move done, Probe air ON");

                        ActPrbAir(true);                   // Probe air on

                        m_iStep++;
                        return false;
                    }


                case 29:
                    {// 프로브 에어 온 확인, Z축 제품 높이 측정 위치로 Down 이동
                        if (!ActPrbAir(true))   { return false; }

                        // case 19 에서 설정된 값을 이후에 그대로 사용한다.
                        // Probe overdirve 지정값 만큼 더 내린다.
                        // m_dPosZ = (CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS) + (CData.Opt.dProbeOD - 1.0);

                        if (CMot.It.Mv_Speed(m_iZ, m_dPosZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 위치로 이동
                        {
                            _SetLog("--- (Z Move down start) Z axis move [Strip Measure] position : " + m_dPosZ.ToString());
                            m_iStep++;
                        }

                        return false;
                    }

                case 30: // Z 축 측정 위치로 Down 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ)) { return false; }

                        _SetLog("--- (Z Move done) Z axis move [Table Measure] position  check. Set Probe stable delay : " + CData.Opt.iProbeStableDelay + "ms");

                        ActPrbAir(false);       // Probe air off 지령
                        m_tmPrb.Set_Delay(CData.Opt.iProbeStableDelay);         // 안정화 시간 지정

                        m_iStep++;
                        return false;
                    }

                case 31: // Probe stable delay : Probe가 안정될 때까지 지정된 시간동안 지연 확인
                    {
                        if (!m_tmPrb.Chk_Delay() || ActPrbAir(false))      // 아직 안정화 시간 이전이거나 Probe air가 off가 아니라면 대기
                        {
                            return false;
                        }

                        // 테이블 높이 측정, 테이블 센터와의 옵셋 값 계산

                        // Probe값 Read    
                        double dProbeValue = CPrb.It.Read_Val(m_eWy);
                        
                        m_InspOffset = dProbeValue - (CData.Opt.dProbeOD - 1.0);                // 더 눌러준 값 만큼 복원

                        _SetLog("--- (Probe Read) Probe=" + dProbeValue.ToString() + "  InspOffset=" + m_InspOffset.ToString());

                        m_iStep++;
                        return false;
                    }


                // == 반복 동작 시작지점 Z 축을 안전 위치로 올리고 다음 측정 위치로 이동을 계산한다. 
                // case 45: 에서 이곳으로 Jump

                case 32: // Z 축 안전 위치로 이동, Probe는 Down 상태를 유지한다.
                    {
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosSafetyZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 안전 위치로 고속 이동
                        {
                            _SetLog("--- (Z Move up start) Zaxis move [Safety] position : ", m_dPosSafetyZ);
                            m_iStep++;
                        }

                        return false;
                    }

                case 33: // Z 축 안전 위치로 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosSafetyZ))
                        {
                            return false;
                        }
                        
                        _SetLog("Z axis move [Safety] positin check.");

                        m_iStep++;
                        return false;
                    }


                case 34:
                    {// == 자재 행(m_iRow) 측정 반복 시점 == 테이블 Y축 자재 측정 위치로 이동
                        bool bMeasure = false; //200712 jhc : 18 포인트 측정 (ASE-KR VOC)

                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            if (m_iRow >= CData.Dev.iRow * CData.Dev.iWinCnt)
                            {
                                m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                m_iCol++;
                                m_iRow = 0;

                                //old CMot.It.Mv_N(m_iY, m_dPosY);
                                _SetLog("Set Y axis move position(before)." + m_dPosY);

                                m_iStep++;      // Y축 이동 한 뒤 다시 case 25로 되돌아가는 공통 루틴으로 간다.
                                return false;
                            }

                            //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                            if (CData.Parts[m_iPart].b18PMeasure)   { bMeasure = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].bUse18P; }
                            else                                    { bMeasure = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].bUse; }

                            if (bMeasure)  // 측정 동작이 남아있다.
                            {
                                // 2022.07.05 SungTae Start : [수정] (ASE-KR VOC) Motorizing 사용 시 Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가
                                //m_dPosY = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dY;
                                //_SetLog("Set Measure point(before).  Y axis position : " + m_dPosY + "mm");

                                string sMeas = (iIdx == (int)EMeaStep.Before/*0*/) ? "BEFORE" : "AFTER";
                                string sWay = (m_iWy == (int)EWay.L) ? "LEFT" : "RIGHT";

                                m_dPosY = CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dY + CData.Dev.dMeasOffsetY;

                                _SetLog($"[{sMeas}][{sWay}] Set Y axis position({m_dPosY}) = {CData.Dev.aData[m_iWy].aPosBf[m_iRow, m_iCol].dY} + {CData.Dev.dMeasOffsetY}(Offset Y)");
                                // 2022.07.05 SungTae End

                                m_iStep = 40;   // 측정 동작 하는 다음 순번으로 간다.
                            }
                            else
                            {
                                m_iRow++;

                                if (m_iRow < CData.Dev.iRow * CData.Dev.iWinCnt)
                                {
                                    return false;
                                }
                                else
                                {
                                    m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                    
                                    m_iCol++;
                                    m_iRow = 0;

                                    _SetLog("Row end(before).  Col : " + m_iCol);

                                    m_iStep++;      // Y축 이동 한 뒤 다시 case 25로 되돌아가는 공통 루틴으로 간다.
                                    return false;
                                }
                            }
                        }
                        else
                        {
                            if (m_iRow >= CData.Dev.iRow * CData.Dev.iWinCnt)
                            {
                                m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                m_iCol++;
                                m_iRow = 0;

                                //old CMot.It.Mv_N(m_iY, m_dPosY);
                                _SetLog("Y axis move position(after)." + m_dPosY);

                                m_iStep++;      // Y축 이동 한 뒤 다시 case 25로 되돌아가는 공통 루틴으로 간다.
                                return false;
                            }

                            //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                            if (CData.Parts[m_iPart].b18PMeasure)   { bMeasure = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].bUse18P; }
                            else                                    { bMeasure = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].bUse; }

                            if (bMeasure)   // 측정 동작이 남아있다.
                            {
                                // 2022.07.05 SungTae Start : [수정] (ASE-KR VOC) Motorizing 사용 시 Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가
                                //m_dPosY = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dY;
                                //_SetLog("Measure point(after).  Y axis position : " + m_dPosY + "mm");

                                string sMeas = (iIdx == (int)EMeaStep.Before/*0*/) ? "BEFORE" : "AFTER";
                                string sWay = (m_iWy == (int)EWay.L) ? "LEFT" : "RIGHT";

                                m_dPosY = CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dY + CData.Dev.dMeasOffsetY;

                                _SetLog($"[{sMeas}][{sWay}] Set Y axis position({m_dPosY}) = {CData.Dev.aData[m_iWy].aPosAf[m_iRow, m_iCol].dY} + {CData.Dev.dMeasOffsetY}(Offset Y)");
                                // 2022.07.05 SungTae End

                                m_iStep = 40;   // 측정 동작 하는 다음 순번으로 간다.
                            }
                            else
                            {
                                m_iRow++;

                                if (m_iRow < CData.Dev.iRow * CData.Dev.iWinCnt)
                                {
                                    return false;
                                }
                                else
                                {
                                    m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                    m_iCol++;
                                    m_iRow = 0;
                                    
                                    _SetLog("Row end(after).  Col : " + m_iCol);

                                    m_iStep++;      // Y축 이동 한 뒤 다시 case 25로 되돌아가는 공통 루틴으로 간다.
                                    return false;
                                }
                            }
                        }

                        // 측정을 해야한다면
                        // Y축 이동 명령을 내리고 다음 Step으로 간다.
                        // Y축 이동 한 후 측정을 반복하는 case 40으로 jump 한다.
                        return false;
                    }

                // Strip의 측정 위치로 Y축 이동을 마치고 다시 case 25로 되돌아가기위한 공통 루틴,  이때는 Probe가 Down 상태로 동작한다.
                case 35: // Y축 위치 이동
                    {
                        CMot.It.Mv_N(m_iY, m_dPosY);
                        _SetLog("--- (Y Move Start) Y Axis move : ", m_dPosY);

                        m_iStep++;
                        return false;
                    }

                case 36: // Y축 이동 확인
                    {
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        {
                            return false;
                        }

                        _SetLog("--- (Y Move done) Y Axis move check, return loop step ");

                        m_iStep = 25;           // -----> 25 다시 반복을 하는 루틴으로 되돌아간다.
                        return false;
                    } // -------------------------


                // from case 34
                // 제품 측정을 위해 Y축 위치를 이동시킨다.
                case 40: // Y축 위치 이동
                    {
                        CMot.It.Mv_N(m_iY, m_dPosY);
                        _SetLog("--- (Y Move Start) Y Axis move : ", m_dPosY);

                        m_iStep++;
                        return false;
                    }

                case 41: // Y축 자재 측정 위치 이동 확인, 프로브 에어 온
                    {
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        {
                            return false;
                        }

                        ActPrbAir(true);                   // Probe air on
                        
                        _SetLog("--- (Y Move done) Y Axis move check and Probe air on");

                        // case 19에서 설정한 값을 사용한다.
                        // m_dPosZ = (CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS) + (CData.Opt.dProbeOD - 1.0);

                        m_iStep++;           // 다시 반복을 하는 루틴으로 되돌아간다.
                        return false;
                    }

                case 42:
                    {// 프로브 에어 온 확인, Z축 제품 높이 측정 위치로 Down 이동
                        if (!ActPrbAir(true))
                        {
                            return false;
                        }

                        if (CMot.It.Mv_Speed(m_iZ, m_dPosZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 측정 위치로 고속 이동
                        {
                            _SetLog("--- (Z Move Start) Z axis move [Strip Measure] position : " + m_dPosZ.ToString() + "  OD : " + CData.Opt.dProbeOD.ToString());
                            m_iStep++;
                        }

                        return false;
                    }

                case 43: // Z 축 측정 위치로 Down 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            return false;
                        }

                        _SetLog("--- (Z Move Done) Z axis move [Strip Measure] position check. Probe air off");

                        ActPrbAir(false);       // Probe air off 지령

                        // Probe stable delay : Probe가 안정될 때까지 지정된 시간동안 지연한다.
                        m_tmPrb.Set_Delay(CData.Opt.iProbeStableDelay);
                        _SetLog("Set Probe stable delay : " + CData.Opt.iProbeStableDelay + "ms");

                        m_iStep++;
                        return false;
                    }

                case 44: // Probe stable delay : Probe가 안정될 때까지 지정된 시간동안 지연 확인
                    {
                        if (!m_tmPrb.Chk_Delay())
                        { return false; }

                        _SetLog("Check delay.");

                        m_iStep++;
                        return false;
                    }

                case 45:
                    {//== 32 ~ 45 Y축 측정 반복 종료 시점 == 프로브 에어 오프 확인, 자재 높이 측정, 다음 행 설정(m_iRow++), m_iStep = 32로 이동

                        // 참고
                        // 
                        // from case 27 :
                        // m_dPosZ = (CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS)
                        // m_InspZeroOffset = CPrb.It.Read_Val(m_eWy)
                        // CData.Tbl_Af[m_iWy, 0] = m_InspZeroOffset + GV.EQP_TABLE_MIN_THICKNESS;     // 실제 Table 높이
                        // m_InspZeroOffset = 0; //20200506 jym : DEBUG
                        //
                        // from case 37 : Table의 높이
                        // m_dPosZ = (CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS);
                        // m_InspOffset = CPrb.It.Read_Val(m_eWy)
                        //

                        double dProbeValue = CPrb.It.Read_Val(m_eWy);

                        m_PbOfset = dProbeValue - (CData.Opt.dProbeOD - 1.0);                // 제품 높이 측정, 더 눌러준 값 만큼 복원

                        _SetLog("--- (Probe Read) Probe=" + dProbeValue.ToString() + "  PbOffset=" + m_PbOfset.ToString());

                        if (iIdx == (int)EMeaStep.Before/*0*/)      // Before Measure
                        {
                            double dGap = m_PbOfset - (m_InspOffset - m_InspZeroOffset);    // 제품 두께 = 제품 높이 측정값 - Table 상부 높이 측정값

                            if (CData.GrData[m_iWy].aOldOnPont[0] < dGap)                   // 이전 측정값과 이번에 측정한 것중 두꺼운 쪽을 One point 측정값으로 사용 
                            {
                                CData.GrData[m_iWy].aOldOnPont[0] = m_PbOfset - (m_InspOffset - m_InspZeroOffset);  // == dGap
                            }

                            // 2022.07.05 SungTae Start : [수정] (ASE-KR VOC) Motorizing 사용 시 Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가
                            //_SetLog(string.Format("Ori : {0}mm  Gap : {1}mm", m_PbOfset, dGap), true);
                            _SetLog($"Ori(Read Value) : {dProbeValue}mm, Gap[m_PbOfset - (m_InspOffset - m_InspZeroOffset)] = {m_PbOfset} - ({m_InspOffset} - {m_InspZeroOffset}) = {dGap}mm", true);
                            // 2022.07.05 SungTae End
                        }

                        // Probe RnR Offset 반영, Gauge의 일정한 offset값을 보정해준다.
                        m_PbOfset = m_PbOfset + CData.Dev.aData[m_iWy].dPrbOffset;  //CData.MPos[0].dPRB_OFFSET;

                        // 2022.07.05 SungTae Start : [추가] (ASE-KR VOC) Log 추가
                        _SetLog(string.Format($">> Probe Value = Read Value ({m_PbOfset}mm) + RNR ({CData.Dev.aData[m_iWy].dPrbOffset}mm) = {m_PbOfset + CData.Dev.aData[m_iWy].dPrbOffset}mm"), true);
                        // 2022.07.05 SungTae End

                        m_aInspTotalTemp[m_iRow, m_iCol] = m_PbOfset;               // 2020.09.14 JSKim Add

                        // 2020.09.14 JSKim St
                        if (CData.Parts[m_iPart].bExistStrip == false || CSQ_Main.It.m_iStat == EStatus.Manual) //201014 jhc : Manual 모드
                        {
                            CData.Parts[m_iPart].dDfMin     = 0.0;
                            CData.Parts[m_iPart].dDfMax     = 0.0;
                            CData.Parts[m_iPart].dDfAvg     = 0.0;

                            CData.Parts[m_iPart].dPcbMin    = 0.0;
                            CData.Parts[m_iPart].dPcbMax    = 0.0;
                            CData.Parts[m_iPart].dPcbMean   = 0.0;

                        }
                        // 2020.09.14 JSKim Ed

                        if (CData.Dev.bDynamicSkip)
                        {//다이나믹 펑션 스킵
                            /// - SECSGEM 사용시 Top 의 AF 값을 BTM 진행 시 DF 대신 사용하기 위함 20200301 LCY
                            /// 1. SECSGEM 사용 시 Btm Side 경우 Host에서 top Side 의 Af 값을 Down 
                            /// 2. Strip Top 측정 값 - Host에서 Down 값
                            dTemp = 0.0;

                            if (CData.Opt.bSecsUse)
                            {
                                if (CData.Dynamic.iHeightType == 0)
                                {
                                    dTemp = CData.Parts[m_iPart].dPcbMax;
                                    _SetLog("SECS/GEM use.  PCB Max : " + dTemp + "mm");
                                }
                                else
                                {
                                    dTemp = CData.Parts[m_iPart].dPcbMean;
                                    _SetLog("SECS/GEM use.  PCB Mean : " + dTemp + "mm");
                                }
                            }

                            m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - dTemp;            // Mold 두께 = 측정값 - 테이블높이 - PCB 두께

                            // 2022.07.05 SungTae Start : [수정] (ASE-KR VOC) Motorizing 사용 시 Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가
                            _SetLog($"Point-[{m_iRow}, {m_iCol}] Measure value = Probe Value ({m_PbOfset}mm) - PCB Thickness ({dTemp}mm) = {m_aInspTemp[m_iRow, m_iCol]}mm", true);
                            // 2022.07.05 SungTae End
                        }
                        else
                        {//다이나믹 펑션 사용 
                            if (CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                            {//DF 서버 사용시 DF측정 안할 경우 Max값으로 고정
                                CData.Dynamic.iHeightType = 0;
                            }

                            if (CData.Dynamic.iHeightType == 0)
                            {//측정한 PCB 값중 MAX 사용
                                if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                                {//[GL2, GL3]
                                    m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - CData.Parts[m_iPart].dDfMax;
                                    _SetLog("DF Max : " + CData.Parts[m_iPart].dDfMax + "mm");
                                }
                                else
                                {//[GL1]
                                    if (CDataOption.MeasureDf == eDfServerType.MeasureDf)
                                    {//DF 사용시 측정 사용 할경우[GL1]
                                        m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - CData.Parts[m_iPart].dPcbMax;
                                        _SetLog("PCB Max : " + CData.Parts[m_iPart].dPcbMax + "mm");
                                    }
                                    else
                                    {//DF 사용시 측정 사용 안할 경우
                                        m_aInspTemp[m_iRow, m_iCol] = m_PbOfset;
                                    }
                                }
                            }
                            else
                            {
                                if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                                {
                                    m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - CData.Parts[m_iPart].dDfAvg;
                                    _SetLog("DF Avg : " + CData.Parts[m_iPart].dDfAvg + "mm");
                                }
                                else
                                {
                                    m_aInspTemp[m_iRow, m_iCol] = m_PbOfset - CData.Parts[m_iPart].dPcbMean;
                                    _SetLog("PCB Mean : " + CData.Parts[m_iPart].dPcbMean + "mm");
                                }
                            }
                        }
                        //190514 ksg : 센터도 옵셋 적용 가능
                        m_aInspTemp[m_iRow, m_iCol] -= (m_InspOffset - m_InspZeroOffset);               // Mold두께 = (측정값 - PCB 두께) - Table 높이위치측정값
                        _SetLog("Measure value : " + m_aInspTemp[m_iRow, m_iCol] + "mm", true);

                        m_aInspTotalTemp[m_iRow, m_iCol] -= (m_InspOffset - m_InspZeroOffset);   // 2020.09.14 JSKim Add
                        _SetLog("Measure Total value : " + m_aInspTotalTemp[m_iRow, m_iCol] + "mm", true);   // 2020.09.14 JSKim Add

                        double dLimitMax = 0.0;
                        double dLimitMin = 0.0;

                        // 2022.08.15 SungTae Start : [추가] (ASE-KR 개조건)
                        // 최종 Target 두께 별도 입력하여 Grinding 최종 Target과 일치하지 않을 경우 Alarm 발생 기능 추가 개발 요청건
                        double dFinalLimitMax = 0.0;
                        double dFinalLimitMin = 0.0;
                        // 2022.08.15 SungTae End

                        // 2022.07.05 SungTae Start : [추가] (ASE-KR VOC)
                        string sMeas = (iIdx == (int)EMeaStep.Before) ? "BEFORE" : "AFTER";
                        string sDual = (CData.Dev.bDual == eDual.Dual) ? "DUAL" : "NORMAL";
                        // 2022.07.05 SungTae End

                        if (iIdx == (int)EMeaStep.Before/*0*/)      // 2022.05.25 SungTae : [수정]
                        #region Measure State : Before
                        {//Before
                            //자재 높이 범위 검사
                            if (CData.Dev.bDynamicSkip || CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                            #region Dynamic Function : 미사용 시
                            {//다이나믹 펑션 스킵, DF사용시 DF 측정 안할 경우
                                dLimitMax = CData.Dev.aData[(int)EWay.L].dTotalTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                                dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dBfLimit;

                                // 2022.07.05 SungTae Start : [수정] (ASE-KR VOC) Motorizing 사용 시 Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가
                                if (CData.Dev.eMoldSide == ESide.Top)
                                {
                                    _SetLog($"[{sMeas}][TOP][NORMAL] Max Limit (Total Thickness + Bf Limit) = {CData.Dev.aData[(int)EWay.L].dTotalTh} + {CData.Dev.aData[(int)EWay.L].dBfLimit} = {dLimitMax} mm", true);
                                    _SetLog($"[{sMeas}][TOP][NORMAL] Min Limit (Total Thickness - Bf Limit) = {CData.Dev.aData[(int)EWay.L].dTotalTh} - {CData.Dev.aData[(int)EWay.L].dBfLimit} = {dLimitMin} mm", true);
                                }
                                // 2022.07.05 SungTae End

                                if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                                {
                                    dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dBfLimitLower;
                                }

#if true //201014 jhc : ASE-Kr TOP 그라인딩 결과 두께 > SECS/GEM > BTM 그라인딩
                                //ASE-Kr Bottom Mold 기준 그라인딩 시 옵션
                                if ((CData.CurCompany == ECompany.ASE_KR) &&                            //ASE-Kr
                                    (CData.Dev.bDynamicSkip) &&                                         //DF기능 비활성(ASE-Kr)
                                    ((CDataOption.SecsUse == eSecsGem.Use) && CData.Opt.bSecsUse) &&    //SECS/GEM 사용(TOP 두께 수신)
                                    (CData.Dev.eMoldSide == ESide.Btm) &&                         //BTM 그라인딩
                                    (CSQ_Main.It.m_iStat != EStatus.Manual))                            //AUTO-RUNNING
                                {
                                    dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                                    dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dBfLimit;

                                    // 2022.07.05 SungTae Start : [수정] (ASE-KR VOC) Motorizing 사용 시 Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가
                                    _SetLog($"[{sMeas}][BTM][NORMAL] Max Limit (Mold Thickness + Bf Limit) = {CData.Dev.aData[(int)EWay.L].dMoldTh} + {CData.Dev.aData[(int)EWay.L].dBfLimit} = {dLimitMax} mm", true);
                                    _SetLog($"[{sMeas}][BTM][NORMAL] Min Limit (Mold Thickness - Bf Limit) = {CData.Dev.aData[(int)EWay.L].dMoldTh} - {CData.Dev.aData[(int)EWay.L].dBfLimit} = {dLimitMin} mm", true);
                                    // 2022.07.05 SungTae End
                                }
#endif
                            }
                            #endregion
                            else
                            #region Dynamic Function : 사용 시
                            {//다이나믹 펑션 사용
                                dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dBfLimit;
                                dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dBfLimit;

                                if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-09, jhLee : 상/하한 값을 별도로 관리
                                {
                                    dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dBfLimitLower;
                                }

                                // 2022.07.05 SungTae Start : [수정] (ASE-KR VOC) Motorizing 사용 시 Before/After Measure 시 Table 상단만 측정하던 것을 Bottom도 측정 위해 조건 추가
                                _SetLog($"[{sMeas}][DF Use][NORMAL] Max Limit (Mold Thickness + Bf Limit) = {CData.Dev.aData[(int)EWay.L].dMoldTh} + {CData.Dev.aData[(int)EWay.L].dBfLimit} = {dLimitMax} mm", true);
                                _SetLog($"[{sMeas}][DF Use][NORMAL] Min Limit (Mold Thickness - Bf Limit) = {CData.Dev.aData[(int)EWay.L].dMoldTh} - {CData.Dev.aData[(int)EWay.L].dBfLimit} = {dLimitMin} mm", true);
                                // 2022.07.05 SungTae End
                            }
                            #endregion

                            // jhLee, Multi-LOT의 경우 SPC 기록
                            if (CData.IsMultiLOT())
                            {
                                m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dBfLimit.ToString();
                            }
                            else
                            {
                                CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dBfLimit.ToString();
                            }

                            if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                            {
                                if (CData.Dev.bDynamicSkip || CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                {//다이나믹 펑션 스킵, DF 사용시 DF 측정 안할 경우
                                    dLimitMax = CData.Dev.aData[m_iWy].dTotalTh + CData.Dev.aData[m_iWy].dBfLimit;
                                    dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dBfLimit;

                                    // 2022.07.05 SungTae Start : [추가]
                                    if (CData.Dev.eMoldSide == ESide.Top)
                                    {
                                        _SetLog($"[{sMeas}][TOP][DUAL] Max Limit (Total Thickness + Bf Limit) = {CData.Dev.aData[m_iWy].dTotalTh} + {CData.Dev.aData[m_iWy].dBfLimit} = {dLimitMax} mm", true);
                                        _SetLog($"[{sMeas}][TOP][DUAL] Min Limit (Total Thickness - Bf Limit) = {CData.Dev.aData[m_iWy].dTotalTh} - {CData.Dev.aData[m_iWy].dBfLimit} = {dLimitMin} mm", true);
                                    }
                                    // 2022.07.05 SungTae End

                                    if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-10, jhLee : 상/하한 값을 별도로 관리
                                    {
                                        dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dBfLimitLower;
                                    }

#if true //201014 jhc : ASE-Kr TOP 그라인딩 결과 두께 > SECS/GEM > BTM 그라인딩
                                    //ASE-Kr Bottom Mold 기준 그라인딩 시 옵션
                                    if ((CData.CurCompany == ECompany.ASE_KR) &&                            //ASE-Kr
                                        (CData.Dev.bDynamicSkip) &&                                         //DF기능 비활성(ASE-Kr)
                                        ((CDataOption.SecsUse == eSecsGem.Use) && CData.Opt.bSecsUse) &&    //SECS/GEM 사용(TOP 두께 수신)
                                        (CData.Dev.eMoldSide == ESide.Btm) &&                         //BTM 그라인딩
                                        (CSQ_Main.It.m_iStat != EStatus.Manual))                            //AUTO-RUNNING
                                    {
                                        dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dBfLimit;
                                        dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dBfLimit;

                                        // 2022.07.05 SungTae Start : [추가]
                                        _SetLog($"[{sMeas}][BTM][DUAL] Max Limit (Mold Thickness + Limit) = {CData.Dev.aData[m_iWy].dMoldTh} + {CData.Dev.aData[m_iWy].dBfLimit} = {dLimitMax} mm", true);
                                        _SetLog($"[{sMeas}][BTM][DUAL] Min Limit (Mold Thickness - Limit) = {CData.Dev.aData[m_iWy].dMoldTh} - {CData.Dev.aData[m_iWy].dBfLimit} = {dLimitMin} mm", true);
                                        // 2022.07.05 SungTae End   
                                    }
#endif
                                }
                                else
                                {//다이나믹 펑션 사용
                                    dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dBfLimit;
                                    dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dBfLimit;

                                    if (CData.CurCompany == ECompany.SkyWorks) // 2021-03-10, jhLee : 상/하한 값을 별도로 관리
                                    {
                                        dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData .Dev.aData[m_iWy].dBfLimitLower;
                                    }

                                    // 2022.07.05 SungTae Start : [추가]
                                    _SetLog($"[{sMeas}][DF Use] Max Limit (Mold Thickness + Limit) = {CData.Dev.aData[m_iWy].dMoldTh} + {CData.Dev.aData[m_iWy].dBfLimit} = {dLimitMax} mm", true);
                                    _SetLog($"[{sMeas}][DF Use] Min Limit (Mold Thickness - Limit) = {CData.Dev.aData[m_iWy].dMoldTh} - {CData.Dev.aData[m_iWy].dBfLimit} = {dLimitMin} mm", true);
                                    // 2022.07.05 SungTae End
                                }

                                // jhLee, Multi-LOT의 경우 SPC 기록
                                if (CData.IsMultiLOT())
                                {
                                    m_myLotInfo.rSpcData.sTargetLim = CData.Dev.aData[m_iWy].dBfLimit.ToString();
                                }
                                else
                                {
                                    CData.SpcData.sTargetLim = CData.Dev.aData[m_iWy].dBfLimit.ToString();
                                }
                            }

                            _SetLog(string.Format("Before.  Limit min : {0}mm  Limit max : {1}mm", dLimitMin, dLimitMax));

                            if (m_eWy == EWay.L)
                            {
                                if (CData.Dev.aData[(int)EWay.L].dBfLimit != 0)
                                {
                                    if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                    {//범위 벗어 났을 경우 에러 발생
                                        m_abMeaBfErr[m_iRow, m_iCol] = true;
                                        m_bMeaErrBf_L = true;

                                        _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                    }
                                }
                            }
                            else
                            {
                                if (CData.Dev.bDual != eDual.Dual)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dBfLimit != 0)
                                    {
                                        if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                        {//범위 벗어 났을 경우 에러 발생
                                            m_abMeaBfErr[m_iRow, m_iCol] = true;
                                            m_bMeaErrBf_R = true;

                                            _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                        }
                                    }
                                }
                                else
                                {
                                    if (CData.Dev.aData[m_iWy].dBfLimit != 0)
                                    {
                                        if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                        {//범위 벗어 났을 경우 에러 발생
                                            m_abMeaBfErr[m_iRow, m_iCol] = true;
                                            m_bMeaErrBf_R = true;

                                            _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                        }
                                    }
                                }
                            }

                            CData.GrData[m_iWy].aMeaBf[m_iRow, m_iCol] = m_aInspTemp[m_iRow, m_iCol];
                        }
                        #endregion
                        else
                        #region Measure Step : After
                        {//After
                         //자재 높이 범위 검사
                         // 2020.09.14 JSKim St - MeasureMode인 경우에는 Bf 랑 동일하게 검사해야 한다. 아니면 AfLimit 설정을 0으로 하던지
                            if (CData.Dev.bMeasureMode)
                            {
                                //자재 높이 범위 검사
                                if (CData.Dev.bDynamicSkip || CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                {//다이나믹 펑션 스킵, DF사용시 DF 측정 안할 경우
                                    dLimitMax = CData.Dev.aData[(int)EWay.L].dTotalTh + CData.Dev.aData[(int)EWay.L].dAfLimit;
                                    dLimitMin = CData.Dev.aData[(int)EWay.L].dTotalTh - CData.Dev.aData[(int)EWay.L].dAfLimit;
                                }
                                else
                                {//다이나믹 펑션 사용
                                    dLimitMax = CData.Dev.aData[(int)EWay.L].dMoldTh + CData.Dev.aData[(int)EWay.L].dAfLimit;
                                    dLimitMin = CData.Dev.aData[(int)EWay.L].dMoldTh - CData.Dev.aData[(int)EWay.L].dAfLimit;
                                }

                                CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();

                                if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                {
                                    if (CData.Dev.bDynamicSkip || CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                    {//다이나믹 펑션 스킵, DF 사용시 DF 측정 안할 경우
                                        dLimitMax = CData.Dev.aData[m_iWy].dTotalTh + CData.Dev.aData[m_iWy].dAfLimit;
                                        dLimitMin = CData.Dev.aData[m_iWy].dTotalTh - CData.Dev.aData[m_iWy].dAfLimit;
                                    }
                                    else
                                    {//다이나믹 펑션 사용
                                        dLimitMax = CData.Dev.aData[m_iWy].dMoldTh + CData.Dev.aData[m_iWy].dAfLimit;
                                        dLimitMin = CData.Dev.aData[m_iWy].dMoldTh - CData.Dev.aData[m_iWy].dAfLimit;
                                    }

                                    CData.SpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();
                                }

                                _SetLog(string.Format("After MeasureMode.  Limit min : {0}mm  Limit max : {1}mm", dLimitMin, dLimitMax));

                                if (m_eWy == EWay.L)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                    {
                                        if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                        {//범위 벗어 났을 경우 에러 발생
                                            m_abMeaAfErr[m_iRow, m_iCol] = true;
                                            m_bMeaErrAf_L = true;
                                            _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                        }
                                    }
                                }
                                else
                                {
                                    if (CData.Dev.bDual != eDual.Dual)
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                        {
                                            // 2022.08.15 SungTae Start : [수정] (ASE-KR 개조건)
                                            if (CData.CurCompany == ECompany.ASE_KR)
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dFinalLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dFinalLimitMin))
                                                {
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErr_FinalTarget_R = true;

                                                    _SetLog($"[{sMeas}][{sDual}] Final Target Mismatch Error.  Col : {m_iCol}  Row : {m_iRow}");
                                                }
                                            }
                                            else
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                                {//범위 벗어 났을 경우 에러 발생
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErrAf_R = true;
                                                    _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                                }
                                            }
                                            // 2022.08.15 SungTae End
                                        }
                                    }
                                    else
                                    {
                                        if (CData.Dev.aData[m_iWy].dAfLimit != 0)
                                        {
                                            // 2022.08.15 SungTae Start : [수정] (ASE-KR 개조건)
                                            if (CData.CurCompany == ECompany.ASE_KR)
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dFinalLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dFinalLimitMin))
                                                {
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErr_FinalTarget_R = true;

                                                    _SetLog($"[{sMeas}][{sDual}] Final Target Mismatch Error.  Col : {m_iCol}  Row : {m_iRow}");
                                                }
                                            }
                                            else
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                                {//범위 벗어 났을 경우 에러 발생
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErrAf_R = true;
                                                    _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                                }
                                            }
                                            // 2022.08.15 SungTae End
                                        }
                                    }
                                }
                            }
                            else
                            {       // 2020.09.14 JSKim Ed
                                double dTarget = 0.0;

                                for (int i = m_iStepMaxCnt - 1; i >= 0; i--)        // 2020.09.08 SungTae : modify
                                {
                                    if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                    {
                                        if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                        {
                                            //20191206 ghk_cal_debug -> 20201017 ksg : 원복함
                                            dTarget = CData.GrData[m_iWy].aTar[i];
                                            _SetLog(string.Format("Dual.  Target : {0}mm  Col : {1}  Row : {2}", dTarget, m_iCol, m_iRow));
                                            break;
                                        }
                                    }
                                    else
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                        {
                                            //if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.Top && (m_eWy == EWay.R))
                                            if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown && (m_eWy == EWay.R)) //190717 ksg :
                                            {
                                                //20191206 ghk_cal_debug -> 20201017 ksg : 원복함
                                                dTarget = CData.GrData[(int)EWay.R].aTar[i];
                                                _SetLog(string.Format("Topdown.  Target : {0}mm  Col : {1}  Row : {2}", dTarget, m_iCol, m_iRow));
                                                break;
                                            }
                                            else
                                            {
                                                dTarget = CData.GrData[m_iWy].aTar[i];
                                                _SetLog(string.Format("Target : {0}mm  Col : {1}  Row : {2}", dTarget, m_iCol, m_iRow));
                                                break;
                                            }
                                        }
                                    }
                                }

                                dLimitMax = dTarget + CData.Dev.aData[(int)EWay.L].dAfLimit;
                                dLimitMin = dTarget - CData.Dev.aData[(int)EWay.L].dAfLimit;

                                // 2022.08.15 SungTae Start : [수정] (ASE-KR 개조건)
                                // 최종 Target 두께 별도 입력하여 Grinding 최종 Target과 일치하지 않을 경우 Alarm 발생 기능 추가 개발 요청건
                                dFinalLimitMax = CData.Dev.aData[(int)EWay.L].dFinalTarget + CData.Dev.aData[(int)EWay.L].dAfLimit;
                                dFinalLimitMin = CData.Dev.aData[(int)EWay.L].dFinalTarget - CData.Dev.aData[(int)EWay.L].dAfLimit;

                                //string sMeas = (iIdx == (int)EMeaStep.Before) ? "BEFORE" : "AFTER";
                                //string sDual = (CData.Dev.bDual == eDual.Dual) ? "DUAL" : "NORMAL";

                                if (CData.Dev.bDual != eDual.Dual)
                                {
                                    _SetLog($"[{sMeas}][{sDual}][{m_eWy}] Max Limit = Target( {dTarget}mm ) + Limit( {CData.Dev.aData[m_iWy].dAfLimit}mm ) = {dLimitMax}mm", true);
                                    _SetLog($"[{sMeas}][{sDual}][{m_eWy}] Min Limit = Target( {dTarget}mm ) - Limit( {CData.Dev.aData[m_iWy].dAfLimit}mm ) = {dLimitMin}mm", true);

                                    _SetLog($"[{sMeas}][{sDual}][{m_eWy}] Final Max Limit = Final Target( {CData.Dev.aData[(int)EWay.L].dFinalTarget}mm ) + Limit( {CData.Dev.aData[(int)EWay.L].dAfLimit}mm ) = {dFinalLimitMax}mm", true);
                                    _SetLog($"[{sMeas}][{sDual}][{m_eWy}] Final Min Limit = Final Target( {CData.Dev.aData[(int)EWay.L].dFinalTarget}mm ) - Limit( {CData.Dev.aData[(int)EWay.L].dAfLimit}mm ) = {dFinalLimitMin}mm", true);
                                }

                                CData.SpcData.sTargetLim = CData.Dev.aData[(int)EWay.L].dAfLimit.ToString();

                                if ((CData.Dev.bDual == eDual.Dual) && (m_eWy == EWay.R))
                                {
                                    dLimitMax = dTarget + CData.Dev.aData[m_iWy].dAfLimit;
                                    dLimitMin = dTarget - CData.Dev.aData[m_iWy].dAfLimit;

                                    // 2022.08.15 SungTae Start : [수정] (ASE-KR 개조건)
                                    // 최종 Target 두께 별도 입력하여 Grinding 최종 Target과 일치하지 않을 경우 Alarm 발생 기능 추가 개발 요청건
                                    dFinalLimitMax = CData.Dev.aData[m_iWy].dFinalTarget + CData.Dev.aData[m_iWy].dAfLimit;
                                    dFinalLimitMin = CData.Dev.aData[m_iWy].dFinalTarget - CData.Dev.aData[m_iWy].dAfLimit;

                                    _SetLog($"[{sMeas}][{sDual}][{m_eWy}] Max Limit = Target( {dTarget}mm ) + Limit( {CData.Dev.aData[m_iWy].dAfLimit}mm ) = {dLimitMax}mm", true);
                                    _SetLog($"[{sMeas}][{sDual}][{m_eWy}] Min Limit = Target( {dTarget}mm ) - Limit( {CData.Dev.aData[m_iWy].dAfLimit}mm ) = {dLimitMin}mm", true);

                                    _SetLog($"[{sMeas}][{sDual}][{m_eWy}] Final Max Limit = Final Target( {CData.Dev.aData[m_iWy].dFinalTarget}mm ) + Limit( {CData.Dev.aData[m_iWy].dAfLimit}mm ) = {dFinalLimitMax}mm", true);
                                    _SetLog($"[{sMeas}][{sDual}][{m_eWy}] Final Min Limit = Final Target( {CData.Dev.aData[m_iWy].dFinalTarget}mm ) - Limit( {CData.Dev.aData[m_iWy].dAfLimit}mm ) = {dFinalLimitMin}mm", true);
                                    // 2022.08.15 SungTae End

                                    CData.SpcData.sTargetLim = CData.Dev.aData[m_iWy].dAfLimit.ToString();
                                }

                                _SetLog(string.Format("After.  Limit min : {0}mm  Limit max : {1}mm", dLimitMin, dLimitMax));

                                if (m_eWy == EWay.L)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                    {
                                        if (CData.CurCompany == ECompany.ASE_KR)
                                        {
                                            if ((m_aInspTemp[m_iRow, m_iCol] > dFinalLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dFinalLimitMin))
                                            {//범위 벗어 났을 경우 에러 발생
                                                m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                m_bMeaErr_FinalTarget_L = true;

                                                _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                            }
                                        }
                                        else
                                        {
                                            if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                            {//범위 벗어 났을 경우 에러 발생
                                                m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                m_bMeaErrAf_L = true;

                                                _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    if (CData.Dev.bDual != eDual.Dual)
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dAfLimit != 0)
                                        {
                                            // 2022.08.15 SungTae Start : [수정] (ASE-KR 개조건)
                                            if (CData.CurCompany == ECompany.ASE_KR)
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dFinalLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dFinalLimitMin))
                                                {
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErr_FinalTarget_R = true;

                                                    _SetLog($"[{sMeas}][{sDual}] Final Target Mismatch Error.  Col : {m_iCol}  Row : {m_iRow}");
                                                }
                                            }
                                            else
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                                {//범위 벗어 났을 경우 에러 발생
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErrAf_R = true;
                                                    _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                                }
                                            }
                                            // 2022.08.15 SungTae End
                                        }
                                    }
                                    else
                                    {
                                        if (CData.Dev.aData[m_iWy].dAfLimit != 0)
                                        {
                                            // 2022.08.15 SungTae Start : [수정] (ASE-KR 개조건)
                                            if (CData.CurCompany == ECompany.ASE_KR)
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dFinalLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dFinalLimitMin))
                                                {
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErr_FinalTarget_R = true;

                                                    _SetLog($"[{sMeas}][{sDual}] Final Target Mismatch Error.  Col : {m_iCol}  Row : {m_iRow}");
                                                }
                                            }
                                            else
                                            {
                                                if ((m_aInspTemp[m_iRow, m_iCol] > dLimitMax) || (m_aInspTemp[m_iRow, m_iCol] < dLimitMin))
                                                {//범위 벗어 났을 경우 에러 발생
                                                    m_abMeaAfErr[m_iRow, m_iCol] = true;
                                                    m_bMeaErrAf_R = true;
                                                    _SetLog(string.Format("Limit error.  Col : {0}  Row : {1}", m_iCol, m_iRow));
                                                }
                                            }
                                            // 2022.08.15 SungTae End
                                        }
                                    }
                                }

                            } // 2020.09.14 JSKim Ed

                            CData.GrData[m_iWy].aMeaAf[m_iRow, m_iCol] = m_aInspTemp[m_iRow, m_iCol];

                            _SetLog("Measure value : " + m_aInspTemp[m_iRow, m_iCol] + "mm", true);
                        }
                        #endregion

                        // 임시 데이터를 실제 기억장소에 복사한다.
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            Array.Copy(m_aInspTemp, m_aInspBf, m_aInspTemp.Length);
                            Array.Copy(m_aInspTotalTemp, m_aInspTotalBf, m_aInspTemp.Length);     // 2020.09.14 JSKim Add
                        }
                        else
                        {
                            Array.Copy(m_aInspTemp, m_aInspAf, m_aInspTemp.Length);
                            Array.Copy(m_aInspTotalTemp, m_aInspTotalAf, m_aInspTemp.Length);     // 2020.09.14 JSKim Add
                        }

                        m_iRow++;

                        // Z축을 안전 위치로 올린 뒤 다음 측정을 반복하는 위치로 Jump 한다.
                        m_iStep = 32;
                        return false;
                    }


                // case 25에서 Jump되어 왔다.
                //
                // 측정 동작을 끝내고 Z축과 Probe를  Up시켜준다.
                //
                case 47: // Z 축 안전 위치로 이동, Probe는 Down 유지
                    {
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosSafetyZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 안전 위치로 고속 이동
                        {
                            _SetLog("--- (Z Move up start) Z axis move [Safety] position : ", m_dPosSafetyZ);
                            m_iStep++;
                        }
                        return false;
                    }

                case 48: // Z 축 안전 위치로 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosSafetyZ))
                        {
                            return false;
                        }

                        _SetLog("--- (Z Move done) Z axis move [Safety] positin check.");

                        m_iStep++;
                        return false;
                    }

                case 49:
                    {//프로브 x축 포지션 0으로 이동
                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);

                        _SetLog("--- (X Move Start) X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                        if (CSpc.It.ChkOpenSaveDataCsv(m_eWy))
                        {
                            m_Delay.Set_Delay(1000);
                            _SetLog("Set delay : 1000ms");
                        }
                        else
                        {
                            m_Delay.Set_Delay(0);
                            _SetLog("Set delay : 0ms");
                        }

                        if ((CData.Opt.bSecsUse == true) && (CData.GemForm != null))
                        {
                            // 2021.07.19 SungTae Start : [수정] Data Shift 시 확인이 용이하도록 수정
                            if (iIdx == (int)EMeaStep.Before/*0*/)
                            {// Before Measure
                                if (m_eWy == EWay.L)
                                {
                                    //CData.GemForm.Strip_Data_Shift(6, 7);// L Chuck Data -> Befor Data 로 이동
                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRL_TBL_CHUCK/*6*/, (int)EDataShift.GRL_BF_MEAS/*7*/);// L Chuck Data -> Befor Data 로 이동
                                }
                                else
                                {
                                    //CData.GemForm.Strip_Data_Shift(12, 13);// R Chuck Data -> R Befor Data 로 이동
                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_TBL_CHUCK/*12*/, (int)EDataShift.GRR_BF_MEAS/*13*/);// R Chuck Data -> R Befor Data 로 이동
                                }
                            }
                            else
                            {// After Measure
                                if (m_eWy == EWay.L)
                                {
                                    //CData.GemForm.Strip_Data_Shift(7, 10);// L Before Data -> L After Data 로 이동
                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRL_BF_MEAS/*7*/, (int)EDataShift.GRL_AF_MEAS/*10*/);// L Before Data -> L After Data 로 이동
                                }
                                else
                                {
                                    //if (CData.Dev.bDShiftPSkip) CData.GemForm.Strip_Data_Shift(12, 13);// R Chuck Data -> R Befor Data 로 이동
                                    //CData.GemForm.Strip_Data_Shift(13, 16);// R Befor Data -> R After Data 로 이동
                                    if (CData.Dev.bDShiftPSkip)
                                    {
                                        CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_TBL_CHUCK/*12*/, (int)EDataShift.GRR_BF_MEAS/*13*/);// R Chuck Data -> R Befor Data 로 이동
                                    }

                                    CData.GemForm.Strip_Data_Shift((int)EDataShift.GRR_BF_MEAS/*13*/, (int)EDataShift.GRR_AF_MEAS/*16*/);// R Befor Data -> R After Data 로 이동
                                }
                            }
                            // 2021.07.19 SungTae End
                        }

                        m_iStep++;
                        return false;
                    }

                case 50: // Save 처리시간 지연 
                    {
                        if (!m_Delay.Chk_Delay())   { return false; }

                        _SetLog("Data save check delay.");

                        m_iStep++;
                        return false;
                    }


                case 51:
                    {//Temp 측정 값 Before or After에 복사, m_iCol = 0, m_iRow = 0, m_iStep = 0;
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }

                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))     // 이동 명령을 내리지 않은 Y축 완료는 왜 조사할까 ??
                        { return false; }

                        _SetLog("--- (X Move done) Zero position");

                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        if (iIdx == (int)EMeaStep.Before/*0*/) // Before
                        {
                            Array.Copy(m_aInspTemp, m_aInspBf, m_aInspTemp.Length);
                            Array.Copy(m_aInspTotalTemp, m_aInspTotalBf, m_aInspTemp.Length);     // 2020.09.14 JSKim Add
                            
                            CSpc.It.SaveDataCsv(m_eWy, "BEFORE", m_aInspBf, CData.Parts[m_iPart].dPcb);
                            
                            if (CData.LotInfo.bLotOpen && CSQ_Main.It.m_iStat != EStatus.Manual) //191115 ksg :
                            {
                                if (CData.CurCompany == ECompany.SCK || CData.CurCompany == ECompany.JSCK)
                                {
                                    CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "BEFORE", m_aInspBf, CData.Parts[m_iPart].dPcb, m_aInspTotalBf);
                                }
                                else
                                {
                                    CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "BEFORE", m_aInspBf, CData.Parts[m_iPart].dPcb);
                                }
                            }

                            // 200722 jym : min max avg 계산
                            double dMax = 0;
                            double dMin = 0;
                            double dAvg = 0;

                            _Cal_MMA(m_aInspBf, out dMin, out dMax, out dAvg);

                            CData.PbResultVal[m_iWy].dBMax = dMax;
                            CData.PbResultVal[m_iWy].dBMin = dMin;
                            CData.PbResultVal[m_iWy].dBAvg = dAvg;

                            if (m_eWy == EWay.L)
                            {
                                if (m_bMeaErrBf_L)
                                {
                                    CErr.Show(eErr.LEFT_GRIND_RANGEOVER_WHEN_BEFORE_MEASURE_STRIP);
                                    _SetLog("Error : Range over when before measure strip.");

                                    m_bSubErr = true;

                                    m_iStep = 200;      // 종료처리로 간다.
                                    return false;
                                }
                            }
                            else
                            {
                                if (m_bMeaErrBf_R)
                                {
                                    CErr.Show(eErr.RIGHT_GRIND_RANGEOVER_WHEN_BEFORE_MEASURE_STRIP);
                                    _SetLog("Error : Range over when before measure strip.");

                                    m_bSubErr = true;

                                    m_iStep = 200;      // 종료처리로 간다.
                                    return false;
                                }
                            }
                        }
                        else // After
                        {
                            Array.Copy(m_aInspTemp, m_aInspAf, m_aInspTemp.Length);
                            Array.Copy(m_aInspTotalTemp, m_aInspTotalAf, m_aInspTemp.Length);   // 2020.09.14 JSKim Add

                            //190528 ksg :
                            if (m_eWy == EWay.L)
                            {
                                Array.Copy(m_aInspTemp, m_aInspShift, m_aInspTemp.Length);
                            }

                            CSpc.It.SaveDataCsv(m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb);
                            
                            if (CData.LotInfo.bLotOpen && CSQ_Main.It.m_iStat != EStatus.Manual) //191115 ksg :
                            {
                                if (CData.CurCompany == ECompany.SCK || CData.CurCompany == ECompany.JSCK)
                                {
                                    CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb, m_aInspTotalAf);
                                }
                                else
                                {
                                    CSpc.It.SaveLotDataCsv(ref m_myLotInfo, m_eWy, "AFTER", m_aInspAf, CData.Parts[m_iPart].dPcb);
                                }
                            }

                            // 200722 jym : min max avg 계산
                            double dMax = 0;
                            double dMin = 0;
                            double dAvg = 0;

                            _Cal_MMA(m_aInspAf, out dMin, out dMax, out dAvg);

                            CData.PbResultVal[m_iWy].dAMax = dMax;
                            CData.PbResultVal[m_iWy].dAMin = dMin;
                            CData.PbResultVal[m_iWy].dAAvg = dAvg;

                            //============================================================================//
                            // 2022.08.15 SungTae Start : [수정] (ASE-KR 개발건)
                            if (m_eWy == EWay.L)
                            {
                                // if (m_bMeaErrAf_L)
                                if (m_bMeaErrAf_L || m_bMeaErr_FinalTarget_L)
                                {
                                    // SECSGEM Host에 Data Upload 진행  20200301 LCY
                                    // Top Side : Mold_높이 + DF 측정 Data
                                    // Bottom Side : Mold 높이
                                    if (CData.Dev.eMoldSide == ESide.Top)
                                        dTemp = CData.Parts[(int)EPart.GRDR].dPcbMean;
                                    else
                                        dTemp = 0.0;

                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Min_Data[4] = dMax + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Max_Data[4] = dMin + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Avr_Data[4] = dAvg + dTemp;

                                    _SetLog("[MOTORIZING] Func Call : CData.GemForm.OnCarrierGrindFinished(1) - Happen Alarm");

                                    if (!CData.bChkGrdM)
                                    {
                                        CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N1);
                                    }

                                    if (CData.CurCompany == ECompany.ASE_KR)
                                    {
                                        CErr.Show(eErr.L_TOP_GRIND_DATA_FINAL_TARGET_COMPARE_ERROR);
                                        _SetLog("Error : L_TOP_GRIND_DATA_FINAL_TARGET_COMPARE_ERROR");
                                    }
                                    else
                                    {
                                        CErr.Show(eErr.LEFT_GRIND_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                        _SetLog("Error : Range over when after measure strip.");
                                    }

                                    // 201008 jym : After range over 에러 시 이어서 동작하기 위해 에러 처리 안함
                                    // 201009 jym : Before 측정 시에만 적용
                                    //m_bSubErr = true;

                                    m_iStep = 200;      // 종료처리로 간다.
                                    return false;
                                }
                            }
                            else
                            {
                                //if (m_bMeaErrAf_R)
                                if (m_bMeaErrAf_R || m_bMeaErr_FinalTarget_R)
                                {
                                    // SECSGEM Host에 Data Upload 진행  20200301 LCY
                                    // Top Side : Mold_높이 + DF 측정 Data
                                    // Bottom Side : Mold 높이
                                    if (CData.Dev.eMoldSide == ESide.Top)   dTemp = CData.Parts[(int)EPart.GRDR].dPcbMean;
                                    else                                    dTemp = 0.0;

                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Min_Data[6] = dMax + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Max_Data[6] = dMin + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Avr_Data[6] = dAvg + dTemp;

                                    _SetLog("[MOTORIZING] Func Call : CData.GemForm.OnCarrierGrindFinished(2) - Happen Alarm");

                                    if (!CData.bChkGrdM)
                                    {
                                        CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N2);
                                    }

                                    if (CData.CurCompany == ECompany.ASE_KR && m_bMeaErr_FinalTarget_R)
                                    {
                                        if(CData.Dev.bDual == eDual.Normal)
                                        {
                                            CErr.Show(eErr.R_TOP_GRIND_DATA_FINAL_TARGET_COMPARE_ERROR);
                                            _SetLog("Error : R_TOP_GRIND_DATA_FINAL_TARGET_COMPARE_ERROR");
                                        }
                                        else
                                        {
                                            CErr.Show(eErr.BTM_GRIND_DATA_FINAL_TARGET_COMPARE_ERROR);
                                            _SetLog("Error : BTM_GRIND_DATA_FINAL_TARGET_COMPARE_ERROR");
                                        }
                                    }
                                    else
                                    {
                                        CErr.Show(eErr.RIGHT_GRIND_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                        _SetLog("Error : Range over when after measure strip.");
                                    }

                                    m_iStep = 200;      // 종료처리로 간다.
                                    return false;
                                }
                            }
                        }
                        // 2022.08.15 SungTae End
                        //============================================================================//

                        //20190618 ghk_dfserver
                        if (m_eWy == EWay.L && CData.Dev.bDual == eDual.Dual && iIdx == (int)EMeaStep.After/*1*/)
                        {
                            m_iStep = 56;           // DF Skip
                            return false;
                        }

                        if (m_eWy == EWay.R && CData.Dev.bDual == eDual.Dual && iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            m_iStep = 56;           // DF Skip
                            return false;
                        }

                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            m_iCol = 0;
                            m_iRow = 0;
                            m_sRowData = "";
                            _SetLog("DF Server.");

                            m_iStep++;
                        }
                        else
                        {
                            _SetLog("DF Server not use.");
                            m_iStep = 56;           // DF Skip
                        }

                        return false;
                    }

                case 52: // for DF Server, from case 54 까지 반복 수행한다.
                    {
                        if (m_eWy == EWay.L)    { CData.GRLDfData.sRow = "L" + m_iRow.ToString("D2"); }
                        else                    { CData.GRRDfData.sRow = "R" + m_iRow.ToString("D2"); }

                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            if (m_iRow < m_aInspBf.GetLength(0))
                            {
                                if (m_iCol < m_aInspBf.GetLength(1))
                                {
                                    if (m_aInspBf[m_iRow, m_iCol] == 0)
                                    {
                                        m_sRowData += ".";
                                    }
                                    else
                                    {
                                        m_sRowData += m_aInspBf[m_iRow, m_iCol];
                                    }

                                    if (m_iCol < (m_aInspBf.GetLength(1) - 1))
                                    {
                                        m_sRowData += ",";
                                    }
                                
                                    m_iCol++;
                                }
                                else
                                {
                                    m_iStep++;
                                }

                                return false;
                            }
                            else
                            {
                                if (!CData.dfInfo.bBusy)
                                {
                                    if (m_eWy == EWay.L)
                                    {
                                        CDf.It.SendBfEnd("LGD");
                                        m_iStep = 55;       // DF Finish
                                    }
                                    else
                                    {
                                        CDf.It.SendBfEnd("RGD");
                                        m_iStep = 55;       // DF Finish
                                    }
                                }
                                else
                                {
                                    return false;
                                }
                            }
                        }
                        else
                        {
                            if (m_iRow < m_aInspAf.GetLength(0))
                            {
                                if (m_iCol < m_aInspAf.GetLength(1))
                                {
                                    if (m_aInspAf[m_iRow, m_iCol] == 0)
                                    {
                                        m_sRowData += ".";
                                    }
                                    else
                                    {
                                        m_sRowData += m_aInspAf[m_iRow, m_iCol];
                                    }

                                    if (m_iCol < (m_aInspAf.GetLength(1) - 1))
                                    {
                                        m_sRowData += ",";
                                    }

                                    m_iCol++;
                                }
                                else
                                {
                                    m_iStep++;
                                }

                                return false;
                            }
                            else
                            {
                                if (!CData.dfInfo.bBusy)
                                {
                                    if (m_eWy == EWay.L)
                                    {
                                        CDf.It.SendAfEnd("LGD");
                                        m_iStep = 55;       // DF Finish
                                    }
                                    else
                                    {
                                        CDf.It.SendAfEnd("RGD");
                                        m_iStep = 55;       // DF Finish
                                    }
                                }
                                else
                                {
                                    return false;
                                }
                            }
                        }

                        return false;
                    }

                case 53:
                    {
                        if (CData.dfInfo.bBusy)
                        {
                            return false;
                        }

                        CDf.It.SendGrdRowData((m_eWy == EWay.L) ? "LGD" : "RGD", m_sRowData);
                        m_iStep++;

                        return false;
                    }

                case 54:
                    {
                        if (m_eWy == EWay.L)
                        {
                            if (CDf.It.ReciveAckGRL((int)ECMD.scRowL))
                            {
                                m_sRowData = "";
                                m_iRow++;
                                m_iCol = 0;
                                m_iStep = 52;       // DF 반복 수행
                            }
                        }
                        else
                        {
                            if (CDf.It.ReciveAckGRR((int)ECMD.scRowR))
                            {
                                m_sRowData = "";
                                m_iRow++;
                                m_iCol = 0;
                                m_iStep = 52;       // DF 반복 수행
                            }
                        }
                        return false;
                    }


                case 55:    // DF Sever 처리 마무리, From case 51
                    {
                        if (iIdx == (int)EMeaStep.Before/*0*/)
                        {
                            if (m_eWy == EWay.L)
                            {
                                if (!CDf.It.ReciveAckGRL((int)ECMD.scBfEndL))
                                { return false; }
                            }
                            else
                            {
                                if (!CDf.It.ReciveAckGRR((int)ECMD.scBfEndR))
                                { return false; }
                            }
                        }
                        else
                        {
                            if (m_eWy == EWay.L)
                            {
                                if (!CDf.It.ReciveAckGRL((int)ECMD.scAfEndL))
                                { return false; }
                            }
                            else
                            {
                                if (!CDf.It.ReciveAckGRR((int)ECMD.scAfEndR))
                                { return false; }
                            }
                        }

                        m_iStep++;
                        return false;
                    }

                case 56:        // SECS/GEM 전송
                    {
                        m_iCol = 0;
                        m_iRow = 0;
                        
						SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        //190319 ksg : Bf / Af Max, Min, Ttv 표시 해야 됨
                        if (iIdx == (int)EMeaStep.Before/*0*/) // Before 측정 Data
                        {
                            double dMax = CData.PbResultVal[m_iWy].dBMax;
                            double dMin = CData.PbResultVal[m_iWy].dBMin;
                            double dMean = CData.PbResultVal[m_iWy].dBAvg;
                            int iCnt = 0;

                            for (int iRow = 0; iRow < m_aInspBf.GetLength(0); iRow++)
                            {
                                for (int iCol = 0; iCol < m_aInspBf.GetLength(1); iCol++)
                                {
                                    if (m_aInspBf[iRow, iCol] != 0)
                                    {
                                        CData.m_dPbVal[m_iWy].m_BFVal.Add(m_aInspBf[iRow, iCol]); //191120 ksg :
                                                                                                  //191118 ksg :
                                        if (CData.GemForm != null)
                                        {//Before 측정 Data 
                                            if (m_eWy == EWay.L)
                                            {
                                                CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Data[1, iCnt] = m_aInspBf[iRow, iCol];// Left 측정 Data
                                                CData.GemForm.Log_wt(string.Format("Left before Data = {0},{1}", iCnt, float.Parse(CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Data[1, iCnt].ToString())));
                                            }
                                            else
                                            {
                                                CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Data[5, iCnt] = m_aInspBf[iRow, iCol];// Right 측정 Data
                                                CData.GemForm.Log_wt(string.Format("Right before Data = {0},{1}", iCnt, float.Parse(CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Data[5, iCnt].ToString())));
                                            }
                                        }

                                        iCnt++;
                                    }
                                }
                            }

                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)
                                {
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].nMeasure_Count[1] = iCnt;
                                    CData.GemForm.Log_wt(string.Format("Left before Cnt = {0},{1}", iCnt, CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].nMeasure_Count[1]));
                                }
                                else
                                {
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].nMeasure_Count[5] = iCnt;
                                    CData.GemForm.Log_wt(string.Format("Right before Cnt = {0},{1}", iCnt, CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].nMeasure_Count[5]));
                                }
                            }

                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)
                                {// Left Befor
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Min_Data[1] = dMin;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Max_Data[1] = dMax;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].fMeasure_Avr_Data[1] = dMean;
                                }
                                else
                                {// Right Befor
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Min_Data[5] = dMin;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Max_Data[5] = dMax;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].fMeasure_Avr_Data[5] = dMean;
                                }
                            }

                            //20190531 ghk
                            CData.PbResultVal[m_iWy].dBMean = Math.Round(((dMax + dMin) / 2), 4); //190502 ksg :

                            if (m_eWy == EWay.L)
                            {
                                if (CData.Dev.bDynamicSkip)
                                {
                                    if (CData.PbResultVal[m_iWy].dBMax <= CData.MPos[0].dPCBThickness || CData.PbResultVal[m_iWy].dBMin >= 999)
                                    {
                                        CErr.Show(eErr.LEFT_BEFORE_PROBE_DATA_LOST);

                                        m_bSubErr = true;

                                        m_iStep = 200;      // 종료처리로 간다.
                                        return false;
                                    }
                                }
                                else
                                {
                                    if ((CData.PbResultVal[m_iWy].dBMax + CData.Parts[(int)EPart.GRDL].dPcbMax) <= CData.MPos[0].dPCBThickness || (CData.PbResultVal[m_iWy].dBMin + CData.Parts[(int)EPart.GRDL].dPcbMax) >= 999)
                                    {
                                        CErr.Show(eErr.LEFT_BEFORE_PROBE_DATA_LOST);

                                        m_bSubErr = true;

                                        m_iStep = 200;      // 종료처리로 간다.
                                        return false;
                                    }
                                }
                            }
                            else
                            {
                                if (CData.Dev.bDynamicSkip)
                                {
                                    if (CData.PbResultVal[m_iWy].dBMax <= CData.MPos[0].dPCBThickness || CData.PbResultVal[m_iWy].dBMin >= 999)
                                    {
                                        CErr.Show(eErr.RIGHT_BEFORE_PROBE_DATA_LOST);

                                        m_bSubErr = true;

                                        m_iStep = 200;      // 종료처리로 간다.
                                        return false;
                                    }
                                }
                                else
                                {
                                    if ((CData.PbResultVal[m_iWy].dBMax + CData.Parts[(int)EPart.GRDR].dPcbMax) <= CData.MPos[0].dPCBThickness || (CData.PbResultVal[m_iWy].dBMin + CData.Parts[(int)EPart.GRDL].dPcbMax) >= 999)
                                    {
                                        CErr.Show(eErr.RIGHT_BEFORE_PROBE_DATA_LOST);

                                        m_bSubErr = true;

                                        m_iStep = 200;      // 종료처리로 간다.
                                        return false;
                                    }
                                }
                            }
                        }
                        else  //After 측정 Data
                        {
                            double dMax = CData.PbResultVal[m_iWy].dAMax;
                            double dMin = CData.PbResultVal[m_iWy].dAMin;
                            double dMean = CData.PbResultVal[m_iWy].dAAvg;
                            int iCnt = 0;

                            // 2021-05-17, jhLee, Multi-LOT, 현재 가공중인 Strip의 LOT Name을 사용하도록 한다.
                            if (CData.IsMultiLOT()) { CData.SpcData.sLotName = CData.Parts[m_iPart].sLotName;   } // Multi-LOT일 경우 가공중인 Strip의 Lot 이름을 사용한다.
                            else                    { CData.SpcData.sLotName = CData.LotInfo.sLotName;          }

                            for (int iRow = 0; iRow < m_aInspAf.GetLength(0); iRow++)
                            {
                                for (int iCol = 0; iCol < m_aInspAf.GetLength(1); iCol++)
                                {
                                    if (m_aInspAf[iRow, iCol] != 0)
                                    {
                                        CData.m_dPbVal[m_iWy].m_AFVal.Add(m_aInspAf[iRow, iCol]); //191120 ksg :

                                        if (CData.GemForm != null)
                                        {
                                            if (m_eWy == EWay.L)
                                            {
                                                CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Data[4, iCnt] = m_aInspAf[iRow, iCol];
                                                CData.GemForm.Log_wt(string.Format("Left After Data = {0},{1}", iCnt, float.Parse(CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Data[4, iCnt].ToString())));
                                            }
                                            else
                                            {
                                                CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Data[6, iCnt] = m_aInspAf[iRow, iCol];
                                                CData.GemForm.Log_wt(string.Format("Right After Data = {0},{1}", iCnt, float.Parse(CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Data[6, iCnt].ToString())));
                                            }
                                        }

                                        iCnt++;
                                    }
                                }
                            }
                            
                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)
                                {
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].nMeasure_Count[4] = iCnt;
                                    CData.GemForm.Log_wt(string.Format("Left After Cnt = {0},{1}", iCnt, CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].nMeasure_Count[4]));
                                }
                                else
                                {
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].nMeasure_Count[6] = iCnt;
                                    CData.GemForm.Log_wt(string.Format("Right After Cnt = {0},{1}", iCnt, CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].nMeasure_Count[6]));
                                }
                            }

                            if (m_eWy == EWay.L)
                            {
                                // 2022.05.26 SungTae Start : [수정] Multi-LOT 관련
                                //CData.SpcData.sTtvLim = CData.Dev.aData[(int)EWay.L].dTTV.ToString();
                                if (CData.IsMultiLOT()) { m_myLotInfo.rSpcData.sTtvLim  = CData.Dev.aData[(int)EWay.L].dTTV.ToString(); }
                                else                    { CData.SpcData.sTtvLim         = CData.Dev.aData[(int)EWay.L].dTTV.ToString(); }
                                // 2022.05.26 SungTae End

                                if (CData.Dev.aData[(int)EWay.L].dTTV != 0)
                                {
                                    if (CData.Dev.aData[(int)EWay.L].dTTV < (dMax - dMin))
                                    {
                                        CErr.Show(eErr.LEFT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                        _SetLog("Error : TTV Range over when after measure strip.");

                                        // 201009 jym : Before 측정 시에만 적용
                                        //m_bSubErr = true;

                                        m_iStep = 200;      // 종료처리로 간다.
                                        return false;
                                    }
                                }
                            }
                            else
                            {
                                if (CData.Dev.bDual == eDual.Dual)
                                {
                                    // 2022.05.26 SungTae Start : [수정] Multi-LOT 관련
                                    //CData.SpcData.sTtvLim = CData.Dev.aData[m_iWy].dTTV.ToString();
                                    if (CData.IsMultiLOT()) { m_myLotInfo.rSpcData.sTtvLim  = CData.Dev.aData[m_iWy].dTTV.ToString(); }
                                    else                    { CData.SpcData.sTtvLim         = CData.Dev.aData[m_iWy].dTTV.ToString(); }
                                    // 2022.05.26 SungTae End

                                    if (CData.Dev.aData[m_iWy].dTTV != 0)
                                    {
                                        if (CData.Dev.aData[m_iWy].dTTV < (dMax - dMin))
                                        {
                                            CErr.Show(eErr.RIGHT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                            _SetLog("Error : TTV Range over when after measure strip.");

                                            // 201009 jym : Before 측정 시에만 적용
                                            //m_bSubErr = true;

                                            m_iStep = 200;      // 종료처리로 간다.
                                            return false;
                                        }
                                    }
                                }
                                else
                                {
                                    // 2022.05.26 SungTae Start : [수정] Multi-LOT 관련
                                    //CData.SpcData.sTtvLim = CData.Dev.aData[(int)EWay.L].dTTV.ToString();
                                    if (CData.IsMultiLOT()) { m_myLotInfo.rSpcData.sTtvLim  = CData.Dev.aData[(int)EWay.L].dTTV.ToString(); }
                                    else                    { CData.SpcData.sTtvLim         = CData.Dev.aData[(int)EWay.L].dTTV.ToString(); }
                                    // 2022.05.26 SungTae End

                                    if (CData.Dev.aData[(int)EWay.L].dTTV != 0)
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].dTTV < (dMax - dMin))
                                        {
                                            CErr.Show(eErr.RIGHT_GRIND_TTV_RANGEOVER_WHEN_AFTER_MEASURE_STRIP);
                                            _SetLog("Error : TTV Range over when after measure strip.");

                                            // 201009 jym : Before 측정 시에만 적용
                                            //m_bSubErr = true;

                                            m_iStep = 200;      // 종료처리로 간다.
                                            return false;
                                        }
                                    }
                                }
                            }

                            if (CData.GemForm != null)
                            {
                                if (m_eWy == EWay.L)
                                {   // SECSGEM Host에 Data Upload 진행  20200301 LCY 
                                    // Top Side : Mold_높이 + DF 측정 Data
                                    // Bottom Side : Mold 높이
                                    if      (CData.Dev.eMoldSide == ESide.Top)    dTemp = CData.Parts[(int)EPart.GRDL].dPcbMean;
                                    else                                          dTemp = 0.0;

                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Min_Data[4] = dMin + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Max_Data[4] = dMax + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].fMeasure_Avr_Data[4] = dMean + dTemp;

                                    // 2022.05.26 SungTae Start : [추가] (ASE-KR VOC) SECS/GEM Issue 관련 조건 추가
                                    _SetLog($"[{m_eWy}][SEND](H<-E) S6F11 CEID={(int)SECSGEM.JSCK.eCEID.Carrier_Grind_Finished}({SECSGEM.JSCK.eCEID.Carrier_Grind_Finished}). Table Loc : {(int)SECSGEM.JSCK.eTableLoc.N1}");

                                    if (!CData.bChkGrdM)
                                    {
                                        CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N1);
                                    }
                                    // 2022.05.26 SungTae End
                                }
                                else
                                {   // SECSGEM Host에 Data Upload 진행  20200301 LCY
                                    // Top Side : Mold_높이 + DF 측정 Data
                                    // Bottom Side : Mold 높이
                                    if      (CData.Dev.eMoldSide == ESide.Top)    dTemp = CData.Parts[(int)EPart.GRDR].dPcbMean;
                                    else                                          dTemp = 0.0;

                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Min_Data[6] = dMin + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Max_Data[6] = dMax + dTemp;
                                    CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].fMeasure_Avr_Data[6] = dMean + dTemp;

                                    // 2022.05.26 SungTae Start : [추가] (ASE-KR VOC) SECS/GEM Issue 관련 조건 추가
                                    _SetLog($"[{m_eWy}][SEND](H<-E) S6F11 CEID={(int)SECSGEM.JSCK.eCEID.Carrier_Grind_Finished}({SECSGEM.JSCK.eCEID.Carrier_Grind_Finished}). Table Loc : {(int)SECSGEM.JSCK.eTableLoc.N2}");

                                    if (!CData.bChkGrdM)
                                    {
                                        CData.GemForm.OnCarrierGrindFinished((int)SECSGEM.JSCK.eTableLoc.N2);
                                    }
                                    // 2022.05.26 SungTae End
                                }
                            }

                            if (CData.PbResultVal[m_iWy].dBMax <= 0 || CData.PbResultVal[m_iWy].dBMin >= 999)
                            {
                                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_BEFORE_PROBE_DATA_LOST :
                                                              eErr.RIGHT_BEFORE_PROBE_DATA_LOST);

                                _SetLog("Error : Before Probe data lost.");

                                //201010 jhc : Before 측정 시에만 적용
                                //m_bSubErr = true;

                                m_iStep = 200;      // 종료처리로 간다.
                                return false;
                            }

                            // 2022.05.26 SungTae Start : [수정] (ASE-KR VOC) Multi-LOT 관련 조건 추가
                            if (CData.IsMultiLOT())
                            {
                                SetMyLotInfo();     // 내부 사용 LotInfo  대입

                                m_myLotInfo.rSpcData.sMgzNo  = CData.Parts[m_iPart].iMGZ_No.ToString();
                                m_myLotInfo.rSpcData.sSlotNo = CData.Parts[m_iPart].iSlot_No.ToString();
                                m_myLotInfo.rSpcData.sTable  = (m_eWy == EWay.L) ? "L" : "R";
                                m_myLotInfo.rSpcData.sBcr    = CData.Parts[m_iPart].sBcr;
                                m_myLotInfo.rSpcData.sMode   = (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown) ? "TopDown" : "Target";

                                if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                {
                                    CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_AfterMeaStrip : ESeq.GRR_AfterMeaStrip;
                                }

                                m_myLotInfo.rSpcData.sMax   = dMax.ToString();
                                m_myLotInfo.rSpcData.sMin   = dMin.ToString();
                                m_myLotInfo.rSpcData.sMean  = dMean.ToString();
                                m_myLotInfo.rSpcData.sTtv   = (dMax - dMin).ToString();
                                m_myLotInfo.rSpcData.sBMax  = CData.PbResultVal[m_iWy].dBMax.ToString();
                                m_myLotInfo.rSpcData.sBMin  = CData.PbResultVal[m_iWy].dBMin.ToString();
                                m_myLotInfo.rSpcData.sBAvg  = CData.PbResultVal[m_iWy].dBAvg.ToString();

                                for (int i = m_iStepMaxCnt - 1; i >= 0; i--)
                                {
                                    if (CData.Dev.bDual == eDual.Dual)
                                    {
                                        if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                        {
                                            m_myLotInfo.rSpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                            m_myLotInfo.rSpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                            break;
                                        }
                                    }
                                    else
                                    {
                                        if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].eGrdMod == eGrdMode.TopDown)
                                            {
                                                m_myLotInfo.rSpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                m_myLotInfo.rSpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                            }
                                            else
                                            {
                                                m_myLotInfo.rSpcData.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                m_myLotInfo.rSpcInfo.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                            }
                                            break;
                                        }
                                    }
                                }

                                if (CData.CurCompany == ECompany.ASE_KR)    { CSpc.It.SaveLotData_Add(ref m_myLotInfo); }
                                else                                        { CSpc.It.SaveLotData(m_myLotInfo); }

                                if (m_eWy == EWay.L && CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown)
                                {
                                    if (CData.IsMultiLOT()) { double.TryParse(m_myLotInfo.rSpcInfo.sTarget  , out CData.Parts[(int)EPart.GRDL].dShiftT); }
                                    else                    { double.TryParse(CData.SpcInfo.sTarget         , out CData.Parts[(int)EPart.GRDL].dShiftT); }
                                }

                                if (m_eWy == EWay.L && CData.Dev.bDShiftPSkip && CData.Dev.bDual == eDual.Dual)
                                {
                                    CData.Parts[(int)EPart.GRDL].dShiftT = dMax;
                                }
                            }  // end : if (CData.IsMultiLOT())
                            else   // if (CData.IsMultiLOT())의 else 
                            {
                                if (CData.LotInfo.bLotOpen)
                                {
                                    CData.SpcData.sMgzNo    = CData.Parts[m_iPart].iMGZ_No.ToString();
                                    CData.SpcData.sSlotNo   = CData.Parts[m_iPart].iSlot_No.ToString();
                                    CData.SpcData.sTable    = (m_eWy == EWay.L) ? "L" : "R";
                                    CData.SpcData.sBcr      = CData.Parts[m_iPart].sBcr;
                                    CData.SpcData.sMode     = (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown) ? "TopDown" : "Target";

                                    if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                                    {
                                        CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_AfterMeaStrip : ESeq.GRR_AfterMeaStrip;
                                    }

                                    CData.SpcData.sMax = dMax.ToString();
                                    CData.SpcData.sMin = dMin.ToString();
                                    CData.SpcData.sMean = dMean.ToString();
                                    CData.SpcData.sTtv = (dMax - dMin).ToString();
                                    CData.SpcData.sBMax = CData.PbResultVal[m_iWy].dBMax.ToString();
                                    CData.SpcData.sBMin = CData.PbResultVal[m_iWy].dBMin.ToString();
                                    CData.SpcData.sBAvg = CData.PbResultVal[m_iWy].dBAvg.ToString();

                                    for (int i = m_iStepMaxCnt - 1; i >= 0; i--)
                                    {
                                        if (CData.Dev.bDual == eDual.Dual)
                                        {
                                            if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                                            {
                                                CData.SpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                CData.SpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)
                                            {
                                                if (CData.Dev.aData[(int)EWay.L].eGrdMod == eGrdMode.TopDown)
                                                {
                                                    CData.SpcData.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                    CData.SpcInfo.sTarget = CData.GrData[m_iWy].aTar[i].ToString();
                                                }
                                                else
                                                {
                                                    CData.SpcData.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                    CData.SpcInfo.sTarget = CData.GrData[(int)EWay.L].aTar[i].ToString();
                                                }
                                                break;
                                            }
                                        }
                                    }

                                    if (CData.CurCompany == ECompany.ASE_KR) { CSpc.It.SaveLotData_Add(); }
                                    else { CSpc.It.SaveLotData(); }

                                    if (m_eWy == EWay.L && CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown)
                                    {
                                        if (CData.IsMultiLOT())
                                        {
                                            double.TryParse(m_myLotInfo.rSpcInfo.sTarget, out CData.Parts[(int)EPart.GRDL].dShiftT);
                                        }
                                        else
                                        {
                                            double.TryParse(CData.SpcInfo.sTarget, out CData.Parts[(int)EPart.GRDL].dShiftT);
                                        }
                                        // CData.Parts[(int)EPart.GRDL].dShiftT = Convert.ToDouble(CData.SpcInfo.sTarget);
                                    }

                                    //200325 ksg : Data Shift Probe Skip
                                    if (m_eWy == EWay.L && CData.Dev.bDShiftPSkip && CData.Dev.bDual == eDual.Dual)
                                    {
                                        CData.Parts[(int)EPart.GRDL].dShiftT = dMax;
                                    }
                                }
                            }
                        } // end : After 측정 Data
                        // 2022.05.26 SungTae End

                        if (CData.LotInfo.bLotOpen)
                        {
                            SetMyLotInfo();     // 내부 사용 LotInfo  대입

                            string sTemp = (iIdx == (int)EMeaStep.Before/*0*/) ? "BEFORE" : "AFTER";

                            CSpc.It.SaveDataIni(ref m_myLotInfo, m_eWy, sTemp, m_aInspTemp);

                            if (CData.Opt.bDryAuto && !CData.Opt.bDryAutoMeaStripSkip)
                            {
                                CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_AfterMeaStrip : ESeq.GRR_AfterMeaStrip;
                            }
                        }

                        _SetLog("Finish.  Status : " + CData.Parts[m_iPart].iStat);

                        // 정상 종료 처리한다.
                        m_iStep = 200;      // 종료처리로 간다.
                        return false;
                    }


                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스
                case 100:
                    {//Z축 대기 위치 이동, 프로브 에어 오프
                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running)    { m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy]; }
                        else                                                { m_dPosZ = CData.SPos.dGRD_Z_Wait[m_iWy]; }

                        CMot.It.Stop(m_iZ);

                        Func_PrbAir(false);         // Probe Air off
                        Func_PrbDown(false);        // Probe를 Up 시켜준다.
                        //210907 pjh : Probe Up Log 추가
                        _SetLog("Probe up. Probe air off");
                        //

                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move position.", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 101:
                    {//Z축 대기 위치 이동 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            //d CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }

                        if (m_iPickerVacErr == 1)   { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else                        { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        _SetLog("ERROR : Picker Vacuum : " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        // 201009 jym : Before 측정 시에만 적용
                        if (iIdx == (int)EMeaStep.Before/*0*/) { m_bSubErr = true; }

                        m_iStep = 0;
                        return true;
                    }


                // 정상적인 종료처리, Down 되었던 Probe를 Up 하고 Z축을 안전 위치로 이동 시킨다.
                case 200:
                    {
                        Func_PrbAir(false);         // Probe Air off
                        Func_PrbDown(false);        // Probe를 Up 시켜준다.
                        //210907 pjh : Probe Up Log 추가
                        _SetLog("Probe up. Probe air off");
                        //

                        m_dPosSafetyZ = CData.SPos.dGRD_Z_Able[m_iWy];        // 이동 안전 위치

                        m_iStep++;
                        return false;
                    }

                case 201: // Z 축 안전 위치로 이동
                    {
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosSafetyZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 안전 위치로 고속 이동
                        {
                            _SetLog("--- (Z Move up start) Z axis move [Safety] position : ", m_dPosSafetyZ);
                            m_iStep++;
                        }

                        return false;
                    }

                case 202: // Z 축 안전 위치로 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosSafetyZ))
                        {
                            return false;
                        }

                        _SetLog("--- (Z Move up done) Z axis move [Safety] positin check.");

                        m_iStep++;
                        return false;
                    }

                case 203:   // Probe Up 확인
                    {
                        //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        bool    bProbeUp    = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double  dProbeVal   = CPrb.It.Read_Val(m_eWy);             //프로브 값

                        if (bProbeUp && (dProbeVal >= GV.dProbeUpHeight))
                        {
                            _SetLog("===== Measure Strip Z-Motorize End =====");

                            m_iStep = 0;
                            return true;            // 수행 종료 처리
                        }

                        return false;
                    }

            }//of switch
        }
        //of public bool Cyl_MeaStrip_ZMotor(int iIdx)


        /// <summary>
        /// Strip 1 Point  Thickness Measure
        /// 스트립 1 포인트 측정 함수 (자재 그라인딩 중 사용)
        /// </summary>
        /// <returns></returns>
        public bool Cyl_MeaStripOne()
        {//m_dInspGrd 결과 값 들어감 
            // Timeout check
            if (m_iPreStep != m_iStep)
            {
                m_mTimeout.Set_Delay(TIMEOUT);
            }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_STRIP_INSPECTION_ONE_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_STRIP_INSPECTION_ONE_TIMEOUT); }
                    _SetLog("Error : Timeout.");

                    m_iStep = 0;
                    return true;
                }
            }

            if ((CDataOption.Package == ePkg.Strip) ? !Chk_Strip() : !Chk_Unit())
            {
                if (m_eWy == EWay.L)
                { CErr.Show(eErr.LEFT_GRIND_VACUUM_ERROR); }
                else
                { CErr.Show(eErr.RIGHT_GRIND_VACUUM_ERROR); }
                _SetLog("Error : Vacuum fail.");

                m_iStep = 0;
                return true;
            }

            m_iPreStep = m_iStep;

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if ((CData.CurCompany == ECompany.ASE_KR) && 
                (m_iStep == 14 || m_iStep == 15 || m_iStep == 22 || m_iStep == 23))
            {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                if (0 != m_iPickerVacErr)
                {
                    CMot.It.EStop(m_iY); //Table Y축 즉시 Stop
                    _SetLog("Error : Picker vacuum fail.  Y axis stop.");

                    m_iStep = 100; //정리 스텝으로
                    return false;
                }
            }
            ///////////////////////////////////////////////////////////////////////////////////////

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10:
                    {// 축 상태 체크

                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            if (CData.Opt.bWheelStopWaitSkip == false)   // 2021.02.20 lhs : true = 기다리지 않음, false = 기다림 (JCET VOC)
                            {
                                return false;
                            }
                        }


                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }
                        _SetLog("Check axes.");

                        m_iStep++;
                        return false;
                    }

                case 11:
                    {// IO 초기화
                        _InitCycle();
                        _SetLog("Init cycle."); 

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {//데이터 저장 변수 초기화
                        m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS;

                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_ProbeDn;
                            m_eOt2 = eY.GRDL_ProbeAir;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_ProbeDn;
                            m_eOt2 = eY.GRDR_ProbeAir;
                        }
                        _SetLog("Init data.", m_dPosZ);

                        //2021.08.06 syc : Up상태일때 Probe 값 정상 범위 인지 확인
                        //- Qorvo 프로브 앰프값 자동으로 바뀌는 이슈에 대한 방지책
                        //- Probe 값이 18.9xxx ~ 19.0xxx 범위 이탈시 알람
                        if (Chk_ProbeUpVal())
                        {
                            m_bProbeAbnormalCheck = true;//211006 pjh : Error 발생 Check 변수

                            m_iStep = 0;
                            return true;
                        }

                        m_iStep++;
                        return false;
                    }

                case 13:
                    {//Z축 테이블 측정 위치로 이동
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move position.", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 14:
                    {//Z축 테이블 측정 위치 이동 확인, Y축 테이블 상단 측정 위치 이동
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]);
                        _SetLog("Y axis move measure table.", CData.SPos.dGRD_Y_TblInsp[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 15:
                    {//Y축 테이블 상단 측정 위치 이동 확인, X축 0으로 이동
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]))
                        { return false; }

                        // 2020.10.23 JSKim St
                        //CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                        //_SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);
                        int iSelectCol = CData.Dev.aData[m_iWy].iOnePointCol;

                        if (iSelectCol == 0 || CDataOption.Is1Point == false)
                        {
                            m_dPosX = CData.SPos.dGRD_X_Zero[m_iWy];
                        }
                        else
                        {
                            m_dPosX = CData.Dev.aData[m_iWy].aPosBf[0, (iSelectCol - 1)].dX;
                        }

                        CMot.It.Mv_N(m_iX, m_dPosX);
                        _SetLog("X axis move measure table.", m_dPosX);
                        // 2020.10.23 JSKim Ed

                        m_iStep++;
                        return false;
                    }

                case 16:
                    {//X축 0으로 이동, 프로브 에어 온
                        // 2020.10.23 JSKim St
                        //if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        //{ return false; }
                        if (!CMot.It.Get_Mv(m_iX, m_dPosX))
                        { return false; }
                        // 2020.10.23 JSKim Ed

                        Func_PrbAir(true);
                        _SetLog("Probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 17:
                    {//프로브 에어 온 확인, 프로브 다운
                        if (CIO.It.Get_Y(m_eOt2))
                        {
                            CIO.It.Set_Y(m_eOt1, true);
                            _SetLog("Probe down.");
                            
                            m_iStep++;
                        }

                        return false;
                    }

                case 18:
                    {//프로브 다운 확인, 프로브 에어 오프
                        if (CIO.It.Get_Y(m_eOt1))
                        {
                            Func_PrbAir(false);
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }

                        return false;
                    }

                case 19:
                    {//프로브 에어 오프 확인, 프로브 값 획득 후 테이블 높이 계산
                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            CData.Tbl_Af[m_iWy, 0] = CPrb.It.Read_Val(m_eWy) + GV.EQP_TABLE_MIN_THICKNESS;
                            m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0];
                            _SetLog(string.Format("Table thickness : {0}mm  Calc Z position : {1}mm", CData.Tbl_Af[m_iWy, 0], m_dPosZ));

                            m_iStep++;
                        }

                        return false;
                    }

                case 20:
                    {//프로브 업  == 테이블 측정 ==
                        //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(true);
                        }
                        CIO.It.Set_Y(m_eOt1, false);
                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

                        //211028 syc : Qorvo Probe Up Time Check
                        if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ)
                        {
                            sStopwatch.Restart(); //211028 syc : Qorvo Probe Up Time Check
                        }
                        // syc end

                        m_iStep++;
                        return false;
                    }

                case 21:
                    {//프로브 업 확인, Z축 자재 측정 위치로 이동

                        //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        //if (!CIO.It.Get_Y(m_eOt1) && m_tmPrb.Chk_Delay())
                        bool   bProbeUp  = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값
                        if (bProbeUp && (dProbeVal >= GV.dProbeUpHeight) && m_tmPrb.Chk_Delay())
                        {
                            //211227 pjh : Ejector off
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(false);
                            }
                            //
                            CMot.It.Mv_N(m_iZ, m_dPosZ);
                            _SetLog("Z axis move position.", m_dPosZ);
                            //210907 pjh : Probe Up Log 추가
                            _SetLog("Probe Height: " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                            //

                            //211028 syc : Qorvo Probe Up Time Check
                            if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ)
                            {
                                sStopwatch.Stop();
                                _SetLog("Probe Up Time : " + sStopwatch.ElapsedMilliseconds, true);
                            }
                            // syc end

                            m_iStep++;
                        }

                        return false;
                    }

                case 22:
                    {//Z축 자재 측정 위치로 이동 확인, Y축 자재 측정 포지션으로 이동
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        if (CDataOption.Package == ePkg.Strip)
                        {
                            // 2020.08.31 JSKim St
                            //m_dPosY = CData.Dev.aData[m_iWy].aPosBf[(CData.Dev.iRow / 2), 0].dY;
                            int iSelectRow = CData.Dev.aData[m_iWy].iOnePointRow + CData.Dev.iRow * (CData.Dev.aData[m_iWy].iOnePointWin - 1);

                            
                            if (iSelectRow <= 0 || CDataOption.Is1Point == false)
                            {
                                // 2021.08.02 SungTae Start : [추가] Measure(Before/After/One-point) 시 측정 위치에 대한 Offset 설정 추가(ASE-KR VOC)
                                //m_dPosY = CData.Dev.aData[m_iWy].aPosBf[(CData.Dev.iRow / 2), 0].dY;
                                if (CData.CurCompany != ECompany.ASE_KR)
                                {
                                    m_dPosY = CData.Dev.aData[m_iWy].aPosBf[(CData.Dev.iRow / 2), 0].dY;
                                }
                                else
                                {
                                    m_dPosY = CData.Dev.aData[m_iWy].aPosBf[(CData.Dev.iRow / 2), 0].dY + CData.Dev.dMeasOffsetY;

                                    _SetLog("One Point Select Row : " + iSelectRow + ".  Pos Y = " + CData.Dev.aData[m_iWy].aPosBf[(CData.Dev.iRow / 2), 0].dY + "mm  Offset Y = " + CData.Dev.dMeasOffsetY);
                                }
                                // 2021.08.02 SungTae End
                            }
                            else
                            {
                                // 2021.08.02 SungTae Start : [추가] Measure(Before/After/One-point) 시 측정 위치에 대한 Offset 설정 추가(ASE-KR VOC)
                                //m_dPosY = CData.Dev.aData[m_iWy].aPosBf[(iSelectRow - 1), 0].dY;

                                if (CData.CurCompany != ECompany.ASE_KR)
                                {
                                    m_dPosY = CData.Dev.aData[m_iWy].aPosBf[(iSelectRow - 1), 0].dY;
                                }
                                else
                                {
                                    m_dPosY = CData.Dev.aData[m_iWy].aPosBf[(iSelectRow - 1), 0].dY + CData.Dev.dMeasOffsetY;

                                    _SetLog("One Point Select Row : " + iSelectRow + ".  Pos Y = " + CData.Dev.aData[m_iWy].aPosBf[(iSelectRow - 1), 0].dY + "mm  Offset Y = " + CData.Dev.dMeasOffsetY);
                                }
                                // 2021.08.02 SungTae End
                            }

                            _SetLog("One Point Select Row : " + iSelectRow);
                            // 2020.08.31 JSKim Ed
                        }
                        else   // Unit
                        {   // 200317 mjy : Unit 일때 마지막 Unit 번호 찾아 측정
                            int iUnit = Cal_LastU();
                            // 2020.08.31 JSKim St
                            //m_dPosY = Math.Round(CData.MPos[m_iWy].dY_PRB_TBL_CENTER + CData.Dev.aUnitCen[iUnit], 6);
                            int iSelectRow = CData.Dev.aData[m_iWy].iOnePointRow;

                            if (iSelectRow == 0 || CDataOption.Is1Point == false)
                            {
                                m_dPosY = Math.Round(CData.MPos[m_iWy].dY_PRB_TBL_CENTER + CData.Dev.aUnitCen[iUnit], 6);
                            }
                            else
                            {
                                m_dPosY = CData.Dev.aData[m_iWy].aPosBf[(iSelectRow - 1), 0].aY[iUnit];
                            }
                            _SetLog("One Point Select Row : " + iSelectRow);
                            // 2020.08.31 JSKim Ed
                            _SetLog("Last unit index : " + iUnit);
                        }

                        CMot.It.Mv_N(m_iY, m_dPosY);
                        _SetLog("Y axis move position.", m_dPosY);

                        m_iStep++;
                        return false;
                    }

                case 23:
                    {//Y축 자재 측정 포지션 이동 확인, 프로브 에어 온
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        // 2020.08.31 JSKim St
                        //CIO.It.Set_Y(m_eOt2, true);
                        //_SetLog("Probe air on.");

                        //m_iStep++;
                        int iSelectCol = CData.Dev.aData[m_iWy].iOnePointCol;

                        if (iSelectCol == 0 || CDataOption.Is1Point == false)
                        {
                            CIO.It.Set_Y(m_eOt2, true);
                            _SetLog("Probe air on.");
                            m_iStep = 25;
                        }
                        else
                        {
                            // 2021.08.02 SungTae Start : [추가] Measure(Before/After/One-point) 시 측정 위치에 대한 Offset 설정 추가(ASE-KR VOC)
                            //m_dPosX = CData.Dev.aData[m_iWy].aPosBf[0, (iSelectCol - 1)].dX;
                            if (CData.CurCompany != ECompany.ASE_KR)
                            {
                                m_dPosX = CData.Dev.aData[m_iWy].aPosBf[0, (iSelectCol - 1)].dX;
                            }
                            else
                            {
                                if(m_iWy == (int)EWay.L)
                                    m_dPosX = CData.Dev.aData[m_iWy].aPosBf[0, (iSelectCol - 1)].dX + CData.Dev.dMeasOffsetX;
                                else
                                    m_dPosX = CData.Dev.aData[m_iWy].aPosBf[0, (iSelectCol - 1)].dX - CData.Dev.dMeasOffsetX;

                                _SetLog("Pos X = " + CData.Dev.aData[m_iWy].aPosBf[0, (iSelectCol - 1)].dX + "mm  Offset X = " + CData.Dev.dMeasOffsetX + "mm");
                            }
                            // 2021.08.02 SungTae End

                            CMot.It.Mv_N(m_iX, m_dPosX);
                            _SetLog("One Point Select Col : " + iSelectCol);
                            _SetLog("X axis move position.", m_dPosX);
                            m_iStep++;
                        }
                        // 2020.08.31 JSKim Ed
                        return false;
                    }

                // 2020.08.31 JSKim St
                case 24:
                    {
                        if (!CMot.It.Get_Mv(m_iX, m_dPosX))
                        { return false; }

                        Func_PrbAir(true);
                        _SetLog("Probe air on.");

                        m_iStep++;
                        return false;
                    }
                // 2020.08.31 JSKim Ed

                case 25:    // 2020.08.31 JSKim +1
                    {//프로브 에어 온 확인, 프로브 다운
                        if (CIO.It.Get_Y(m_eOt2))
                        {
                            CIO.It.Set_Y(m_eOt1, true);
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            _SetLog("Probe down.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }

                        return false;
                    }

                case 26:    // 2020.08.31 JSKim +1
                    {//프로브 다운 확인, 프로브 에어 오프
                        if (CIO.It.Get_Y(m_eOt1) && m_tmPrb.Chk_Delay())
                        {
                            Func_PrbAir(false);
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                            m_iStep++;
                        }

                        return false;
                    }

                case 27:    // 2020.08.31 JSKim +1
                    {//프로브 에어 오프 확인, 프로브 값 읽어서 자재 측정값 저장, 프로브 업
                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            m_PbOfset = CPrb.It.Read_Val(m_eWy);
                           
                            double dLimit = CData.Dev.aData[(CData.Dev.bDual == eDual.Normal) ? (int)EWay.L : m_iWy].dOneLimit;
                            if (dLimit > 0)
                            {
                                double dGap = CData.GrData[m_iWy].aOldOnPont[0] - m_PbOfset;
                                _SetLog(string.Format("Old 1 point : {0}mm  Gap : {1}mm  Limit : {2}mm", CData.GrData[m_iWy].aOldOnPont[0], dGap, dLimit));

                                if (CData.GrData[m_iWy].aOldOnPont[0] < (m_PbOfset - dLimit))
                                {
                                    m_WrongCalFlag = true;
                                    _SetLog("Wrong measure data.");
                                }
                                else
                                {
                                    CData.GrData[m_iWy].aOldOnPont[0] = m_PbOfset;
                                }

                                _SetLog(string.Format("1 point : {0}mm", m_PbOfset));
                            }

                            // 2021.08.05 lhs Start : New Sck Grind Process 적용 (SCK전용)
                            if (CDataOption.UseNewSckGrindProc)
                            {
                                m_PbOfset = m_PbOfset + CData.Dev.aData[m_iWy].dPrbOffset;

                                string sLogMsg  = "";
                                double dPcbTemp = 0.0;    // Pcb 값

                                // Pcb값은 초기값 = 0.0, 
                                // DF 측정시나 SecsGem 사용시 Pcb값이 존재 
                                if (CData.Dev.bDynamicSkip) { sLogMsg += "DF Not Measured, ";   }   else { sLogMsg += "DF Measured, ";       }
                                if (CData.Opt.bSecsUse)     { sLogMsg += "SECS/GEM Use, ";      }   else { sLogMsg += "SECS/GEM Not Use, ";  }

                                if (CData.Dynamic.iHeightType == 0) { dPcbTemp = CData.Parts[m_iPart].dPcbMax;      sLogMsg += string.Format("PCB Max = {0}, ",  dPcbTemp); }
                                else                                { dPcbTemp = CData.Parts[m_iPart].dPcbMean;     sLogMsg += string.Format("PCB Mean = {0}, ", dPcbTemp); }
                                // 일단 계산시 TopMold와 BtmMold는 Avg 값을 사용하자
                                double dTopMoldTemp = CData.Parts[m_iPart].dTopMoldAvg;     sLogMsg += string.Format("TopMold Avg = {0}. ", dTopMoldTemp);
                                double dBtmMoldTemp = CData.Parts[m_iPart].dBtmMoldAvg;     sLogMsg += string.Format("BtmMold Avg = {0}. ", dBtmMoldTemp);

                                _SetLog(sLogMsg);

                                if(dPcbTemp     < 0) _SetLog("Pcb thickness Error");
                                if(dTopMoldTemp < 0) _SetLog("TopMold thickness Error");
                                if(dBtmMoldTemp < 0) _SetLog("BtmMold thickness Error");

                                if (CData.Dev.aData[m_iWy].eBaseOnThick == EBaseOnThick.Total)
								{
                                    // m_PbOfset 그대로. (Top/BtmS/TopD/BtmD)
                                    m_dInspGrd = m_PbOfset;
                                }
								else  // Mold 기준
								{
                                    if      (CData.Dev.eMoldSide == ESide.Top)  { m_dInspGrd = m_PbOfset - dPcbTemp;                    }   // Single
                                    else if (CData.Dev.eMoldSide == ESide.BtmS) { m_dInspGrd = m_PbOfset - dPcbTemp;                    }   // Single  
                                    else if (CData.Dev.eMoldSide == ESide.TopD) { m_dInspGrd = m_PbOfset - (dPcbTemp + dBtmMoldTemp);   }   // Double
                                    else if (CData.Dev.eMoldSide == ESide.Btm)  { m_dInspGrd = m_PbOfset - (dPcbTemp + dTopMoldTemp);   }   // Double
                                    else    { }
                                } // end : Mold
                            }// end : if (CDataOption.UseNewSckGrindProc)
                            
                            else  // 기존 로직
                            // 2021.08.05 lhs End
                            {
                                // 다이나믹 펑션 스킵
                                if (CData.Dev.bDynamicSkip)
                                {
                                    dTemp = 0.0;
                                    if (CData.Opt.bSecsUse)
                                    {// One Point SECSGEM 으로 Data 사용 시 DF 및 Host Down Data 값 적용 20200401 LCY
                                        if (CData.Dynamic.iHeightType == 0)
                                        {//PCB 측정 값 중 Max 값 사용
                                            dTemp = CData.Parts[m_iPart].dPcbMax;
                                            _SetLog("SECS/GEM use.  PCB Max : " + dTemp + "mm");
                                        }
                                        else
                                        {//PCB 측정 값 중 펑균 값 사용
                                            dTemp = CData.Parts[m_iPart].dPcbMean;
                                            _SetLog("SECS/GEM use.  PCB Mean : " + dTemp + "mm");
                                        }
                                    }
        	                        //else if (CData.CurCompany == ECompany.Qorvo_NC && CData.Dev.eMoldSide != ESide.Top)                                
    	                            else if(CDataOption.UseDFDataServer && CData.Dev.eMoldSide != ESide.Top && !CData.Opt.bSecsUse)//210818 pjh : D/F Data server 기능 License로 구분
	                                {                                        
                                        //220111 pjh : DF Server 사용 시 Top Mold Thickness 저장 변수 변경
                                        if (CData.Dynamic.iHeightType == 0) { dTemp = CData.Parts[m_iPart].dPcbMax + CData.Parts[m_iPart].dTopMoldMax; _SetLog("D/F Data Server use.  PCB Max : " + dTemp + "mm"); }
                                        else { dTemp = CData.Parts[m_iPart].dPcbMean + CData.Parts[m_iPart].dTopMoldAvg; _SetLog("D/F Data Server use.  PCB Mean : " + dTemp + "mm"); }
                                    }

                                    m_dInspGrd = (m_PbOfset + CData.Dev.aData[m_iWy].dPrbOffset) - dTemp;
                                }
                                else
                                {//다이나믹 펑션 사용
                                 //DF 사용시 DF측정 안할경우 Max만 사용
                                    if (CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                                    { CData.Dynamic.iHeightType = 0; }

                                    m_PbOfset = m_PbOfset + CData.Dev.aData[m_iWy].dPrbOffset;

                                    if (CData.Dynamic.iHeightType == 0)
                                    {//PCB 측정 값 중 Max 값 사용
                                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                                        {//[GL2, GL3]
                                            m_dInspGrd = m_PbOfset - CData.Parts[m_iPart].dDfMax;
                                            _SetLog("GL2/3.  DF Max : " + CData.Parts[m_iPart].dDfMax + "mm");
                                        }
                                        else
                                        {//[GL1]
                                            if (CDataOption.MeasureDf == eDfServerType.MeasureDf)
                                            {//DF 사용시 DF 측정 할경우
                                                m_dInspGrd = m_PbOfset - CData.Parts[m_iPart].dPcbMax;
                                                _SetLog("GL1.  PCB Max : " + CData.Parts[m_iPart].dPcbMax + "mm");
                                            }
                                            else
                                            {//DF 사용시 DF 측정 안할경우
                                                m_dInspGrd = m_PbOfset;
                                            }
                                        }
                                    }
                                    else
                                    {//PCB 측정 값 중 Mean 값 사용
                                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                                        {
                                            m_dInspGrd = m_PbOfset - CData.Parts[m_iPart].dDfAvg;
                                            _SetLog("GL2/3.  DF Avg : " + CData.Parts[m_iPart].dDfAvg + "mm");
                                        }
                                        else
                                        {
                                            m_dInspGrd = m_PbOfset - CData.Parts[m_iPart].dPcbMean;
                                            _SetLog("GL1.  PCB Mean : " + CData.Parts[m_iPart].dPcbMean + "mm");
                                        }
                                    }
                                }
                            } // end : else (기존 로직)

                            CData.GrData[m_iWy].a1Pt[m_iIndex] = m_dInspGrd;
                            //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(true);
                            }
                            CIO.It.Set_Y(m_eOt1, false);
                            m_tmPrb.Set_Delay(GV.PRB_DELAY);
                            _SetLog("One point : " + m_dInspGrd + "mm,  Probe up.");

                            //211028 syc : Qorvo Probe Up Time Check
                            if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ)
                            {
                                sStopwatch.Restart(); //211028 syc : Qorvo Probe Up Time Check
                            }
                            // syc end

                            m_iStep++;
                        }

                        return false;
                    }

                case 28:    // 2020.08.31 JSKim +1
                    {//프로브 업 확인, 프로브 X축 포지션 0으로 이동
                        //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        bool   bProbeUp  = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값
                        
                        if (bProbeUp && (dProbeVal >= GV.dProbeUpHeight) && m_tmPrb.Chk_Delay())
                        {
                            //211227 pjh : Ejector off
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(false);
                            }
                            //
                            CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                            _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);
							//210907 pjh : Probe Up Log 추가
	                        _SetLog("Probe Height: " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                        	//

                            m_iStep++;
                        }

                        return false;
                    }

                case 29:    // 2020.08.31 JSKim +1
                    {//프로브 X축 대기위치로 이동 확인
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }

                        //211028 syc : Qorvo Probe Up Time Check
                        if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ)
                        {
                            sStopwatch.Stop();
                            _SetLog("Probe Up Time : " + sStopwatch.ElapsedMilliseconds, true);
                        }
                        // syc end

                        _SetLog("Finish.");

                        m_iStep = 0;
                        return true;
                    }

                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스
                case 100:
                    {//Z축 대기 위치 이동, 프로브 에어 오프
                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        { m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy]; }
                        else
                        { m_dPosZ = CData.SPos.dGRD_Z_Wait[m_iWy]; }
                        CMot.It.Stop(m_iZ);
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move position.", m_dPosZ);

                        // 프로브 에어 오프 (Case 23: ON)
                        Func_PrbAir(false);

                        m_iStep++;
                        return false;
                    }

                case 101:
                    {//Z축 대기 위치 이동 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }

                        if (m_iPickerVacErr == 1)
                        {
                            CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR);
                            _SetLog("Error : ONP Vacuum fail.");
                        }
                        else
                        {
                            CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR);
                            _SetLog("Error : OFP Vacuum fail.");
                        }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        m_iStep = 0;
                        return true;
                    }
                ///////////////////////////////////////////////////////////////////////////////////////
            }
        }


        /// <summary>
        /// Strip 1 point Thickness Measure function by Z-Axis motion
        /// 스트립 1 포인트 측정 함수 (자재 그라인딩 중 사용)
        /// 2020-10-28, jhLee
        /// 유닛 두께 측정 함수 0:Before, 1:After
        /// Probe의 Down/Up이 아닌 Z축 모션을 통해 Probe 측정위치로 눌러 측정하도록 변경된 함수
        /// </summary>
        /// <returns></returns>
        public bool Cyl_MeaStripOne_ZMotor()
        {//m_dInspGrd 결과 값 들어감 
            // Timeout check
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_STRIP_INSPECTION_ONE_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_STRIP_INSPECTION_ONE_TIMEOUT); }
                    _SetLog("Error : Timeout.");

                    m_iStep = 0;
                    return true;
                }
            }

            if ((CDataOption.Package == ePkg.Strip) ? !Chk_Strip() : !Chk_Unit())
            {
                if (m_eWy == EWay.L)
                { CErr.Show(eErr.LEFT_GRIND_VACUUM_ERROR); }
                else
                { CErr.Show(eErr.RIGHT_GRIND_VACUUM_ERROR); }
                _SetLog("Error : Vacuum fail.");

                m_iStep = 0;
                return true;
            }

            m_iPreStep = m_iStep;

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if (CData.CurCompany == ECompany.ASE_KR)
            {
                if ((m_iStep == 15) || (m_iStep == 16) || (m_iStep == 17) || (m_iStep == 24) || (m_iStep == 25) || (m_iStep == 26))
                {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                    m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                    if (0 != m_iPickerVacErr)
                    {
                        CMot.It.EStop(m_iY); //Table Y축 즉시 Stop
                        _SetLog("Error : Picker vacuum fail.  Y axis stop.");

                        m_iStep = 100; //정리 스텝으로
                        return false;
                    }
                }
            }
            ///////////////////////////////////////////////////////////////////////////////////////

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10:
                    {// 축 상태 체크

                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);
                            
                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            if (CData.Opt.bWheelStopWaitSkip == false)   // 2021.02.20 lhs : true = 기다리지 않음, false = 기다림 (JCET VOC)
                            {
                                return false;
                            }
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }
                        _SetLog("Check axes.");

                        m_iStep++;
                        return false;
                    }

                case 11:
                    {// IO 초기화
                        _InitCycle();
                        _SetLog("Init cycle.");

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {//데이터 저장 변수 초기화
                        m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS;

                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_ProbeDn;
                            m_eOt2 = eY.GRDL_ProbeAir;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_ProbeDn;
                            m_eOt2 = eY.GRDR_ProbeAir;
                        }
                        _SetLog("Init data.", m_dPosZ);

                        //2021.08.06 syc : Up상태일때 Probe 값 정상 범위 인지 확인
                        //- Qorvo 프로브 앰프값 자동으로 바뀌는 이슈에 대한 방지책
                        //- Probe 값이 18.9xxx ~ 19.0xxx 범위 이탈시 알람
                        if (Chk_ProbeUpVal())
                        {
                            m_bProbeAbnormalCheck = true;//211006 pjh : Error 발생 Check 변수

                            m_iStep = 0;
                            return true;
                        }

                        m_dPosSafetyZ = CData.SPos.dGRD_Z_Able[m_iWy];      // 초기 안전위치
                        m_iStep++;
                        return false;
                    }


                case 13: // Z 축 이동 안전 위치로 이동
                    {
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosSafetyZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 고속 안전 위치로 이동
                        {
                            _SetLog("--- (Z Move start) Z axis move [Safety] position : ", m_dPosSafetyZ);
                            m_iStep++;
                        }
                        return false;
                    }


                case 14: // Z 축 안전 위치로 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosSafetyZ))
                        { return false; }
                        _SetLog("--- (Z Move done) Z axis move [Safety] positin check.");

                        // Z축 안전위치로 이동하면 Probe를 Down시켜도 안전하므로 시간을 줄이기 위해 Probe를 Down 시킨다.
                        ActPrbDown(true);           // Probe Down action


                        // One point 측정을 위한 위치를 지정한다.
                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];

                        int iSelectCol = CData.Dev.aData[m_iWy].iOnePointCol;

                        if (iSelectCol == 0 || CDataOption.Is1Point == false)
                        {
                            m_dPosX = CData.SPos.dGRD_X_Zero[m_iWy];
                        }
                        else
                        {
                            m_dPosX = CData.Dev.aData[m_iWy].aPosBf[0, (iSelectCol - 1)].dX;
                        }

                        m_iStep++;
                        return false;
                    }

                case 15:
                    {   // Y축 테이블 상단 측정 위치 이동

                        if (CMot.It.Mv_N(m_iY, m_dPosY) == 0)
                        {
                            _SetLog("Y axis move measure table.", m_dPosY);
                            m_iStep++;
                        }
                        return false;
                    }

                case 16:
                    {   // X축 테이블 상단 측정 위치 이동

                        if (CMot.It.Mv_N(m_iX, m_dPosX) == 0)
                        {
                            _SetLog("X axis move measure table.", m_dPosX);
                            m_iStep++;
                        }
                        return false;
                    }

                case 17:
                    {  // Y, X축 테이블 상단 측정 위치 이동 완료 확인
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY) || !CMot.It.Get_Mv(m_iX, m_dPosX))
                        { return false; }

                        _SetLog("X/Y axis move done [measure table] and Probe air on");

                        Func_PrbAir(true);

                        m_iStep++;
                        return false;
                    }

                case 18: // Probe down check
                    {
                        bool bRet = false;
                        if (m_eWy == EWay.L)
                        { bRet = !CIO.It.Get_X(eX.GRDL_ProbeAMP); }
                        else
                        { bRet = !CIO.It.Get_X(eX.GRDR_ProbeAMP); }

                        if (!bRet)  { return false; }

                        _SetLog("Probe down check.");

                        // Probe overdirve 지정값 만큼 더 내린다.
                        m_dPosZ = (CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS) + (CData.Opt.dProbeOD - 1.0);

                        m_iStep++;
                        return false;
                    }

                case 19: // Z 축 Table 측정 위치로 Down 이동
                    {
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 위치로 이동
                        {
                            _SetLog("--- (Z Move down start) Z axis move [Strip Measure] position : " + m_dPosZ.ToString());
                            m_iStep++;
                        }
                        return false;
                    }


                case 20: // Z 축 측정 위치로 Down 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ)) { return false; }

                        _SetLog("Z axis move [Table Measure] position check & Probe Air Off.");

                        ActPrbAir(false);                   // Probe air off

                        m_tmPrb.Set_Delay(CData.Opt.iProbeStableDelay);
                        _SetLog("Set Probe stable delay : " + CData.Opt.iProbeStableDelay + "ms");

                        m_iStep++;
                        return false;
                    }

                case 21: // Read probe value at Table-Zero position
                    {
                        if (!m_tmPrb.Chk_Delay() || ActPrbAir(false))       // 안정화 시간 이내이거나 Probe air가 off 상태가 아니라면 대기
                        {
                            return false;
                        }

                        // Probe값 Read    
                        double dProbeValue = CPrb.It.Read_Val(m_eWy);

                        // 읽어들인 Probe값에서 적용해준 Probe overdrive만큼 빼서 실제값을 산출한다.
                        CData.Tbl_Af[m_iWy, 0] = (dProbeValue + GV.EQP_TABLE_MIN_THICKNESS) - (CData.Opt.dProbeOD - 1.0);

                        _SetLog("--- [MOTORIZE](Probe Read) Probe = " + dProbeValue.ToString() + "mm  Table Height = " + CData.Tbl_Af[m_iWy, 0].ToString() + "mm");

                        // Strip 측정시 Down 시킬 위치
                        m_dPosZ = (CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0]) + (CData.Opt.dProbeOD - 1.0);

                        // 축 대기위치는 Talble이 측정된 위치에서 안전 Offset으로 설정된 만큼 위로 올라간 위치이다.
                        // 측정 대기위치 = TableBase - (실측된 Table 높이 + 안전 위치 offset)
                        m_dPosSafetyZ = CData.MPos[m_iWy].dZ_TBL_BASE - (CData.Tbl_Af[m_iWy, 0] + CData.Opt.dSafetyTopOffset);

                        // Z축의 이동 안전 위치가 Table 상부 8mm 보다 낮다면 안전을 위해 최소 높이를 적용한다.
                        if (m_dPosSafetyZ > (CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS - 8))
                        {
                            _SetLog("(Warning !) Z axis [Safety] position too low : ", m_dPosSafetyZ);

                            // Table 상부보다 8mm 높게 강제로 설정한다.
                            m_dPosSafetyZ = (CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS - 8);
                            _SetLog("(Warning !) Z axis [Safety] position set : ", m_dPosSafetyZ);
                        }

                        _SetLog(string.Format("Table thickness : {0}  Calc Z position : {1}  Safety Position : {2}", CData.Tbl_Af[m_iWy, 0], m_dPosZ, m_dPosSafetyZ));

                        m_iStep++;
                        return false;
                    }

                case 22: // Z 축 안전 위치로 이동
                    {
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosSafetyZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 안전 위치로 이동
                        {
                            _SetLog("--- [MOTORIZE](Z Move safety start) Z axis move [Safety] position : " + m_dPosSafetyZ.ToString());
                            m_iStep++;
                        }
                        return false;
                    }

                case 23: // Z 축 안전 위치로 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosSafetyZ))
                        { return false; }
                        _SetLog("--- [MOTORIZE](Z Move Done) Z axis move [Safety] positin check.");


                        // Y축 자재 측정 포지션 계산

                        if (CDataOption.Package == ePkg.Strip)
                        {
                            // 2020.08.31 JSKim St
                            //m_dPosY = CData.Dev.aData[m_iWy].aPosBf[(CData.Dev.iRow / 2), 0].dY;
                            int iSelectRow = CData.Dev.aData[m_iWy].iOnePointRow + CData.Dev.iRow * (CData.Dev.aData[m_iWy].iOnePointWin - 1);

                            if (iSelectRow <= 0 || CDataOption.Is1Point == false)
                            {
                                m_dPosY = CData.Dev.aData[m_iWy].aPosBf[(CData.Dev.iRow / 2), 0].dY;
                            }
                            else
                            {
                                m_dPosY = CData.Dev.aData[m_iWy].aPosBf[(iSelectRow - 1), 0].dY;
                            }

                            _SetLog("--- [MOTORIZE] One Point Select Row : " + iSelectRow.ToString() + "  Y Pos : " + m_dPosY.ToString());
                            // 2020.08.31 JSKim Ed
                        }
                        else
                        {   // 200317 mjy : Unit 일때 마지막 Unit 번호 찾아 측정
                            int iUnit = Cal_LastU();
                            // 2020.08.31 JSKim St
                            //m_dPosY = Math.Round(CData.MPos[m_iWy].dY_PRB_TBL_CENTER + CData.Dev.aUnitCen[iUnit], 6);
                            int iSelectRow = CData.Dev.aData[m_iWy].iOnePointRow;

                            if (iSelectRow == 0 || CDataOption.Is1Point == false)
                            {
                                m_dPosY = Math.Round(CData.MPos[m_iWy].dY_PRB_TBL_CENTER + CData.Dev.aUnitCen[iUnit], 6);
                            }
                            else
                            {
                                m_dPosY = CData.Dev.aData[m_iWy].aPosBf[(iSelectRow - 1), 0].aY[iUnit];
                            }

                            _SetLog("--- [MOTORIZE] One Point Select Row : " + iSelectRow.ToString() + "  Y Pos : " + m_dPosY.ToString());
                            // 2020.08.31 JSKim Ed
                            _SetLog("Last unit index : " + iUnit);
                        }

                        // 이동 할 X축 산출
                        int iSelectCol = CData.Dev.aData[m_iWy].iOnePointCol;

                        if (iSelectCol == 0 || CDataOption.Is1Point == false)               // 이미 이동한 X축 위치라면
                        {
                            _SetLog("--- [MOTORIZE] X Axis move skip able and current Select Col : " + iSelectCol);
                        }
                        else
                        {
                            m_dPosX = CData.Dev.aData[m_iWy].aPosBf[0, (iSelectCol - 1)].dX;
                            _SetLog("--- [MOTORIZE] One Point Select Col : " + iSelectCol.ToString() + "  X Pos : " + m_dPosX.ToString());
                        }

                        m_iStep++;
                        return false;
                    }

                // X / Y 축 이동을 지령한다.
                case 24: // Y축 자재 측정 포지션으로 이동
                    {
                        if (CMot.It.Mv_N(m_iY, m_dPosY) == 0)
                        {
                            _SetLog("--- [MOTORIZE](Y Move Start) Y axis move position : ", m_dPosY);
                            m_iStep++;
                        }
                        return false;
                    }

                case 25: // X축 자재 측정 포지션으로 이동
                    {
                        if (CMot.It.Mv_N(m_iX, m_dPosX) == 0)
                        {
                            _SetLog("--- [MOTORIZE](X Move Start) X axis move position : ", m_dPosX);
                            m_iStep++;
                        }
                        return false;
                    }


                case 26: // X/Y축 자재 측정 포지션 이동 확인
                    {
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY) || !CMot.It.Get_Mv(m_iX, m_dPosX))
                        { return false; }

                        _SetLog("--- [MOTORIZE](X/Y Move Done) X/Y axis move position check & Probe air on");

                        ActPrbAir(true);              // Probe Air On  이물질을 제거하기위한 Air를 분출한다.

                        m_iStep++;
                        return false;
                    }

                case 27:    // Z축 Down 이동
                    {
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 제품 측정 위치로 이동
                        {
                            _SetLog("--- [MOTORIZE](Z Move down start) Z axis move [Strip Measure] position");
                            m_iStep++;
                        }
                        return false;
                    }

                case 28: // Z 축 측정 위치로 Down 이동 완료 확인, Probe air off
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ)) { return false; }

                        ActPrbAir(false);               // Probe air off

                        _SetLog("--- [MOTORIZE](Z Move down done) Z axis move [Table Measure] position done check, probe air off.");

                        // Probe stable delay : Z축 Down 이동 후 Probe가 안정될 때까지 지정된 시간동안 지연한다.
                        m_tmPrb.Set_Delay(CData.Opt.iProbeStableDelay);
                        _SetLog("--- [MOTORIZE] Set Probe stable delay : " + CData.Opt.iProbeStableDelay + "ms");

                        m_iStep++;           // 안정화 지연 후 값 측정 step으로 이동
                        return false;
                    }

                case 29:    // 프로브 값 읽어서 자재 측정값 저장
                    {
                        // Probe값 Read    
                        double dProbeValue = CPrb.It.Read_Val(m_eWy);

                        m_PbOfset = dProbeValue - (CData.Opt.dProbeOD - 1.0);       // 읽어온 값에서 Overdrvie 값을 차감한다.

                        double dLimit = CData.Dev.aData[(CData.Dev.bDual == eDual.Normal) ? (int)EWay.L : m_iWy].dOneLimit;

                        _SetLog($"--- [MOTORIZE](Probe Read) Probe : {dProbeValue}mm, Offset : {m_PbOfset}mm, Limit : {dLimit}mm");

                        if (dLimit > 0)
                        {
                            double dGap = CData.GrData[m_iWy].aOldOnPont[0] - m_PbOfset;
                            
                            //_SetLog(string.Format("Old 1 point : {0}mm  Gap : {1}mm  Limit : {2}mm", CData.GrData[m_iWy].aOldOnPont[0], dGap, dLimit));
                            _SetLog($"--- [MOTORIZE](Probe Read) Gap = Old One-Point({CData.GrData[m_iWy].aOldOnPont[0]}mm) - Offset({m_PbOfset}mm) = {dGap}mm, Limit : {dLimit}mm");

                            if (CData.GrData[m_iWy].aOldOnPont[0] < (m_PbOfset - dLimit))
                            {
                                m_WrongCalFlag = true;
                                _SetLog("Wrong measure data.");
                            }
                            else
                            {
                                CData.GrData[m_iWy].aOldOnPont[0] = m_PbOfset;
                            }

                            //_SetLog(string.Format("1 Point : {0}mm", m_PbOfset));
                        }//of if (dLimit > 0)

                        // 다이나믹 펑션 스킵
                        if (CData.Dev.bDynamicSkip)
                        {
                            dTemp = 0.0;

                            if (CData.Opt.bSecsUse)
                            {// One Point SECSGEM 으로 Data 사용 시 DF 및 Host Down Data 값 적용 20200401 LCY
                                if (CData.Dynamic.iHeightType == 0)
                                {//PCB 측정 값 중 Max 값 사용
                                    dTemp = CData.Parts[m_iPart].dPcbMax;
                                    _SetLog("--- [MOTORIZE] SECS/GEM use.  PCB Max : " + dTemp + "mm");
                                }
                                else
                                {//PCB 측정 값 중 펑균 값 사용
                                    dTemp = CData.Parts[m_iPart].dPcbMean;
                                    _SetLog("--- [MOTORIZE] SECS/GEM use.  PCB Mean : " + dTemp + "mm");
                                }
                            }

                            m_dInspGrd = (m_PbOfset + CData.Dev.aData[m_iWy].dPrbOffset) - dTemp;

                            // 2022.07.18 SungTae : [추가] Log 추가
                            _SetLog($"--- [MOTORIZE][D/F SKIP] One-Point : ({m_PbOfset}mm + {CData.Dev.aData[m_iWy].dPrbOffset}mm) - Top PCB({dTemp}mm) = {m_dInspGrd}mm");
                        }
                        else
                        {//다이나믹 펑션 사용
                            //DF 사용시 DF측정 안할경우 Max만 사용
                            if (CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
                            { CData.Dynamic.iHeightType = 0; }

                            m_PbOfset = m_PbOfset + CData.Dev.aData[m_iWy].dPrbOffset;

                            if (CData.Dynamic.iHeightType == 0)
                            {//PCB 측정 값 중 Max 값 사용
                                if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                                {//[GL2, GL3]
                                    m_dInspGrd = m_PbOfset - CData.Parts[m_iPart].dDfMax;
                                    _SetLog("--- [MOTORIZE] GL2/3.  DF Max : " + CData.Parts[m_iPart].dDfMax + "mm");
                                }
                                else
                                {//[GL1]
                                    if (CDataOption.MeasureDf == eDfServerType.MeasureDf)
                                    {//DF 사용시 DF 측정 할경우
                                        m_dInspGrd = m_PbOfset - CData.Parts[m_iPart].dPcbMax;
                                        _SetLog("--- [MOTORIZE] GL1.  PCB Max : " + CData.Parts[m_iPart].dPcbMax + "mm");
                                    }
                                    else
                                    {//DF 사용시 DF 측정 안할경우
                                        m_dInspGrd = m_PbOfset;
                                    }
                                }
                            }
                            else
                            {//PCB 측정 값 중 Mean 값 사용
                                if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                                {
                                    m_dInspGrd = m_PbOfset - CData.Parts[m_iPart].dDfAvg;
                                    _SetLog("--- [MOTORIZE] GL2/3.  DF Avg : " + CData.Parts[m_iPart].dDfAvg + "mm");
                                }
                                else
                                {
                                    m_dInspGrd = m_PbOfset - CData.Parts[m_iPart].dPcbMean;
                                    _SetLog("--- [MOTORIZE] GL1.  PCB Mean : " + CData.Parts[m_iPart].dPcbMean + "mm");
                                }
                            }

                            // 2022.07.18 SungTae : [추가] Log 추가
                            _SetLog($"--- [MOTORIZE][D/F USE] One-Point : {m_dInspGrd}mm");
                        }//of  if (CData.Dev.bDynamicSkip) else

                        CData.GrData[m_iWy].a1Pt[m_iIndex] = m_dInspGrd;

                        _SetLog($"--- (Probe Read) Old One-point : {CData.GrData[m_iWy].aOldOnPont[0]}mm,  One-point : {m_dInspGrd}mm");

                        //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(true);
                        }

                        ActPrbDown(false);       // Probe Up 명령

                        m_dPosSafetyZ   = CData.SPos.dGRD_Z_Able[m_iWy];          // 측정을 마치고 이동이 가능한 위치로 안전 위치를 지정한다.
                        m_dPosX         = CData.SPos.dGRD_X_Zero[m_iWy];          // 0 위치

                        m_iStep++;
                        return false;
                    }

                case 30: // Z 축 안전 위치로 이동
                    {
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosSafetyZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 안전 위치로 이동
                        {
                            _SetLog("--- [MOTORIZE](Z Move safety start) Z axis move [Safety] position : " + m_dPosSafetyZ.ToString());
                            m_iStep++;
                        }
                        return false;
                    }

                case 31: // 프로브 X축 포지션 0으로 이동   
                    {
                        if (CMot.It.Mv_N(m_iX, m_dPosX) == 0)
                        {
                            _SetLog("--- [MOTORIZE](X Move zero start) X axis move [Zero] position : ", m_dPosX);
                            m_iStep++;
                        }
                        return false;
                    }


                case 32: // Z / X 축 안전 위치로 이동 완료 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosSafetyZ) || !CMot.It.Get_Mv(m_iX, m_dPosX))
                        { return false; }

                        _SetLog("--- [MOTORIZE](Z/X Move done) Z/X axis move [Safety & Zero] position check.");

                        m_iStep++;
                        return false;
                    }


                case 33: //프로브 업 확인
                    {
                        //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        bool    bProbeUp = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double  dProbeVal = CPrb.It.Read_Val(m_eWy);             //프로브 값

                        if (bProbeUp && (dProbeVal >= GV.dProbeUpHeight))
                        {
                            //211227 pjh : Ejector off
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(false);
                            }
                            //

                            _SetLog("=== Finish Measure strip one point Z-Motorize ===");

                            m_iStep = 0;
                            return true;
                        }

                        return false;
                    }



                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스
                case 100:
                    {
                        // Probe up
                        bool bRet = false;

                        if (m_eWy == EWay.L)    { bRet = CIO.It.Set_Y(eY.GRDL_ProbeDn, false); }
                        else                    { bRet = CIO.It.Set_Y(eY.GRDR_ProbeDn, false); }

                        //210907 pjh : Probe Up Log 추가
                        _SetLog("--- [MOTORIZE] Probe up.");
                        //

                        if (!bRet) return false;

                        //Z축 대기 위치 이동, 프로브 에어 오프
                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running)    { m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy]; }
                        else                                                { m_dPosZ = CData.SPos.dGRD_Z_Wait[m_iWy]; }

                        CMot.It.Stop(m_iZ);         // 이동 중지

                        // 프로브 에어 오프 (Case 23: ON)
                        Func_PrbAir(false);

                        m_iStep++;
                        return false;
                    }

                case 101:
                    {
                        if (CMot.It.Mv_Speed(m_iZ, m_dPosZ, CData.Opt.dZAxisMoveUpSpeed) == 0)   //Z축 안전 위치로 이동
                        {
                            _SetLog("--- [MOTORIZE](Z Move start)  Z axis move position.", m_dPosZ);
                            m_iStep++;
                        }
                        return false;

                    }

                case 102:
                    {//Z축 대기 위치 이동 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }

                        _SetLog("--- [MOTORIZE](Z Move done)  Z axis move position check.");

                        if (m_iPickerVacErr == 1)
                        {
                            CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR);
                            _SetLog("--- [MOTORIZE] Error : ONP Vacuum fail.");
                        }
                        else
                        {
                            CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR);
                            _SetLog("--- [MOTORIZE] Error : OFP Vacuum fail.");
                        }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        m_iStep = 0;
                        return true;
                    }
                    ///////////////////////////////////////////////////////////////////////////////////////
            }
        } //of public bool Cyl_MeaStripOne_ZMotor()


        /// <summary>
        /// Wheel Height Measure
        /// 휠 높이 측정 함수
        /// </summary>
        /// <returns></returns>
        public bool Cyl_MeaWhl(bool bChkTTV = true)
        {
            double dVel;

            // Timeout check
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_WHEEL_INSPECTION_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_WHEEL_INSPECTION_TIMEOUT); }

                    //20190909 ghk_grd_drs_err
                    m_bSubErr = true;
                    //

                    m_iStep = 0;

                    return true;
                }
            }

            //if (CDataOption.SplType == eSpindleType.EtherCat)
            //{
            //    CData.Spls[0].iRpm = Convert.ToInt32(CSpl.It.GetFrpm(true));
            //    CData.Spls[1].iRpm = Convert.ToInt32(CSpl.It.GetFrpm(false));                
            //}            
            // 2023.03.15 Max
            CData.Spls[(int)EWay.L].iRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.L));
            CData.Spls[(int)EWay.R].iRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.R));


            m_iPreStep = m_iStep;

            if (m_eWy == EWay.L) m_LogVal.sStatus = "GRL_Cyl_MeaWhl";
            else                 m_LogVal.sStatus = "GRR_Cyl_MeaWhl";

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if ((CData.CurCompany == ECompany.ASE_KR) && 
                (m_iStep == 19 || m_iStep == 20))
            {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                if (0 != m_iPickerVacErr)
                {
                    CMot.It.EStop(m_iY); //Table Y축 즉시 Stop

                    _SetLog("ERROR : Picker Vacuum : " + m_siY + " STOP : " + CMot.It.Get_FP(m_iY).ToString());

                    m_iStep = 100; //정리 스텝으로
                    return false;
                }
            }
            ///////////////////////////////////////////////////////////////////////////////////////

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10:
                    {
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }
                        
                        // 축 상태 체크
                        if (Chk_Axes())
                        {
                            m_iStep = 0;

                            return true;
                        }

                        m_LogVal.iStep  = m_iStep;
                            SaveLog();
                            m_iStep++; 

                        //20190909 ghk_grd_drs_err
                        m_bSubErr = false;
                        //

                        m_iWhlCnt = 0;
                        m_aTip = new double[3];

                        //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                        m_aWheelTipZPos[0] = m_aWheelTipZPos[1] = m_aWheelTipZPos[2] = 0.0; //휠측정 시작 시 변수 초기화
                        //

                        return false;
                    }

                case 11:
                    {// Wheel file check
                        if (m_eWy == EWay.L)
                        {
                            if (CData.Whls[0].sWhlName == "")
                            {
                                CErr.Show(eErr.SYSTEM_LEFT_WHEEL_FILE_NOT_LOAD);
                                //20190909 ghk_grd_drs_err
                                m_bSubErr = true;
                                //
                                m_iStep = 0;
                                return true;
                            }
                        }
                        else
                        {
                            if (CData.Whls[1].sWhlName == "")
                            {
                                CErr.Show(eErr.SYSTEM_RIGHT_WHEEL_FILE_NOT_LOAD);
                                //20190909 ghk_grd_drs_err
                                m_bSubErr = true;
                                //
                                m_iStep = 0;
                                return true;
                            }
                        }
                        if (CData.GemForm != null)
                        {// Measure Wheel Before Data
                           // CData.GemForm.Measure_Wheel_Dress_Data_Set(m_iWy, 0, 0);// Left ,0-Wheel(1-Dress), 0-Before Data(1-Aftere)
                        }

                        m_LogVal.iStep  = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {// IO 초기화
                        _InitCycle();

                        m_LogVal.iStep  = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 13:
                    {// 프로브 대기 위치 이동
                        if (m_eWy == EWay.L)
                        { m_eOt1 = eY.GRDL_ProbeDn; }
                        else
                        { m_eOt1 = eY.GRDR_ProbeDn; }

                        CIO.It.Set_Y(m_eOt1, false);

                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Wait[m_iWy]);
                        if (CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Wait[m_iWy]) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sAsix1 = m_iX.ToString();
                        m_LogVal.dPos1  = CData.SPos.dGRD_X_Wait[m_iWy];
                        m_LogVal.sMsg   = m_eOt1.ToString() + " : false";
                        SaveLog();

                        m_iStep++;

                        return false;
                    }
                   
                case 14:
                    {// 프로브 이동 응답 확인
                        if (!(CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Wait[m_iWy])) || !(CIO.It.Set_Y(m_eOt1, false)))
                        { return false; }

                        m_LogVal.iStep  = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 15:
                    {// 테이블 안전상태 체크
                        SafeTbl(true, true, false);

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sMsg = "SafeTbl check";
                        SaveLog();

                        m_iStep++;
                        return false;
                    }
                //190128 : 중국에서 Dressing 중 처 박는 것 때문에 확인 결과 Z축 높이 Check 안 하고 Y축 이동 하기에 추가 함.(Case 16, 17)
                case 16:
                    {
                        m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy];

                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, m_dPosZ);
                        if (CMot.It.Mv_N(m_iZ, m_dPosZ) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sAsix1 = m_iZ.ToString();
                        m_LogVal.dPos1  = m_dPosZ;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 17:
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        m_LogVal.iStep  = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 18:
                    {// 탑클리너 업 체크
                        if (m_eWy == EWay.L)
                        { m_eIn1 = eX.GRDL_TopClnDn; m_eOt1 = eY.GRDL_TopClnDn; } //syc : new cleaner : 삭제예정
                        else
                        { m_eIn1 = eX.GRDR_TopClnDn; m_eOt1 = eY.GRDR_TopClnDn; }

                        //syc : new cleaner
                        //CIO.It.Set_Y(m_eOt1, false);
                        ActTcDown(false);

                        //syc : new cleaner
                        //if (!CIO.It.Get_X(m_eIn1))
                        if (!Chk_CleanerDn(false))
                        { 
                            m_LogVal.iStep  = m_iStep;
                            SaveLog();

                            m_iStep++; 
                        }

                        return false;
                    }

                case 19:
                    {// 테이블 측정위치 이동
                        m_dPosY = CData.MPos[m_iWy].dY_WHL_TOOL_SETTER - (CData.Whls[m_iWy].dWhlO / 2.0) + (GV.WHEEL_DEF_TIP_W / 2.0);

                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iY, m_dPosY);
                        if (CMot.It.Mv_N(m_iY, m_dPosY) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sAsix1 = m_iY.ToString();
                        m_LogVal.dPos1  = m_dPosY;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 20:
                    {// 테이블 이동 응답 확인
                        if (!(CMot.It.Get_Mv(m_iY, m_dPosY)))
                        { return false; }

                        m_LogVal.iStep  = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 21:
                    {// Z축 측정 시작위치 이동 (휠 베이스로 툴세터 측정위치 -12mm) 
                        m_dPosZ = CData.MPos[m_iWy].dZ_WHL_BASE - GV.WHEEL_DEF_TIP_T;

                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, m_dPosZ);
                        if (CMot.It.Mv_N(m_iZ, m_dPosZ) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sAsix1 = m_iZ.ToString();
                        m_LogVal.dPos1  = m_dPosZ;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 22:
                    {// Z축 이동 응답 확인
                        if (!(CMot.It.Get_Mv(m_iZ, m_dPosZ)))
                        { return false; }

                        //191002 ksg :
                        if(m_eWy == EWay.L)
                        {
                            bool xTSServoL = Convert.ToBoolean(CIO.It.Get_TS(EWay.L));
                            if (!xTSServoL)
                            {
                                CErr.Show(eErr.LEFT_TOOL_SETTER_SIGNAL_NOT_NOMAL);
                                m_bSubErr = true;
                                m_iStep = 0;
                                return true;
                            }
                        }
                        else
                        {
                            bool xTSServoR = Convert.ToBoolean(CIO.It.Get_TS(EWay.R));
                            if (!xTSServoR)
                            {
                                CErr.Show(eErr.RIGHT_TOOL_SETTER_SIGNAL_NOT_NOMAL);
                                m_bSubErr = true;
                                m_iStep = 0;
                                return true;
                            }
                        }

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sAsix1 = m_iZ.ToString();
                        m_LogVal.dPos1  = m_dPosZ;
                        SaveLog();


                        /// <summary>
                        /// Wheel Tip & Toolsetter 3point 측정 : Spindle Drv position Setting 방식
                        /// m_iWhlCnt 값 = 0 으로 원점 잡아서 첫번째 휠 측정
                        /// </summary>

                        // 2023.03.15 Max 회전 하기전 I/O를 설정
                        // Spindle Drv I/O 단자 Mi7에 접점 ON 시킴.
                        if (m_eWy == EWay.L) CIO.It.Set_Y(eY.GRL_WheelMeasureControlTerminal, true);
                        if (m_eWy == EWay.R) CIO.It.Set_Y(eY.GRR_WheelMeasureControlTerminal, true);



                        bool bExit = false;
                        bool bTimeOutFlag = false;

                        // Wheel 회전 위치 값  Setting
                        int nWheelPnt = ((int)(4096 / 3)) * m_iWhlCnt; // 4096 = 1회전 Pluse Count, 3 = Wheel 측정 갯수
                        CSpl_485.It.Write_WheelChkPosition(m_eWy, nWheelPnt);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptWheelChkSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptWheelChkSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                            return false;
                        }


                        // Spindle RUN
                        bExit = false;
                        bTimeOutFlag = false;
                        CSpl_485.It.Write_Run(m_eWy);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRunSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRunSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            return false;
                        }

                        // Wheel Stop 정지 TimeOut Check
                        m_Timout_485.Set_Delay(300);

                        // 2023.03.15 Max
                        //m_iStep++;
                        m_iStep = 222;
                        return false;
                    }

                case 222:
                    {
                        /// <summary>
                        /// Wheel Tip & Toolsetter 3point 측정 : 변경 코드
                        ///  23번 스텝에서 RPM 회전 값 Check함으로 아래 코드 없어도 되나 222번 스텝 일단 추가.
                        /// </summary>
                        /// 
                        int nSplLRpm = 0;
                        if (m_eWy == EWay.L)
                        {
                            nSplLRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.L));
                        }
                        else
                        {
                            nSplLRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.R));
                        }

                        if (nSplLRpm != 0)
                        {
                            if (m_Timout_485.Chk_Delay())
                            {
                                if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                                if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                                m_Timout_485.Set_Delay(300);
                            }
                            return false;
                        }

                        m_iStep = 23;
                        return false;
                    }

                case 23:
                    {// 툴세터 이벤트 활성화
                        //20190705 ghk_whlmea
                        //CMot.It.Set_Evt(m_eWy, true);
                        if (CMot.It.Set_Log(3, m_iZ, 10, 7) == 1)
                        { return false; }
                        if (CMot.It.Start_Log(3) == 1)
                        { return false; }
                        if (CMot.It.Set_Evt(m_eWy, true) == 1)
                        { return false; }

                        if (m_eWy == EWay.L)
                        {
                            bool xTSServoL = Convert.ToBoolean(CIO.It.Get_TS(EWay.L));
                            m_LogVal.sMsg = "xTSServoL = " + xTSServoL.ToString();
                        }
                        else
                        {
                            bool xTSServoR = Convert.ToBoolean(CIO.It.Get_TS(EWay.R));
                            m_LogVal.sMsg = "xTSServoR = " + xTSServoR.ToString();
                        }
                        // 휠 3번 측정 값 초기화
                        CData.WhlMea[m_iWy, 0] = 0.0;
                        CData.WhlMea[m_iWy, 1] = 0.0;
                        CData.WhlMea[m_iWy, 2] = 0.0;

                        m_LogVal.iStep  = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 24:
                    {// 빠른속도 하강 측정 (1mm/s)
                        if (m_eWy == EWay.L)
                        {
                            bool xTSServoL = Convert.ToBoolean(CIO.It.Get_TS(EWay.L));
                            m_LogVal.sMsg = "xTSServoL = " + xTSServoL.ToString();
                        }
                        else
                        {
                            bool xTSServoR = Convert.ToBoolean(CIO.It.Get_TS(EWay.R));
                            m_LogVal.sMsg = "xTSServoR = " + xTSServoR.ToString();
                        }

                        dVel = 1;
                        
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_J(m_iZ, true, dVel, dVel * 5.0);
                        if (CMot.It.Mv_J(m_iZ, true, dVel, dVel * 5.0) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sAsix1 = m_iZ.ToString();
                        m_LogVal.sMsg   += "dVel = " +dVel.ToString(); 
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 25:
                    {// Z축 이동 응답 대기
                        if (CMot.It.Chk_OP(m_iZ) == EAxOp.Idle)
                        {
                            m_Delay.Set_Delay(2000);
                            m_LogVal.iStep  = m_iStep;
                            SaveLog();
                            m_iStep++; 
                        }
                        //191002 ksg :
                        if(m_eWy == EWay.L)
                        {
                            bool xTSServoL = Convert.ToBoolean(CIO.It.Get_TS(EWay.L));
                            bool xTSIOL    = CIO.It.Get_X(eX.SYS_ToolsetterL);

                            if (!xTSServoL)
                            {
                                if (CMot.It.Chk_OP(m_iZ) == EAxOp.Jog)
                                {
                                    //CErr.Show(eErr.LEFT_TOOL_SETTER_IO_NOT_DETECT);
                                    m_Delay.Set_Delay(2000);
                                    CMot.It.EStop(m_iZ);
                                    m_LogVal.iStep  = m_iStep;
                                    m_LogVal.sMsg   = "Servo Pack I/O 감지";
                                    SaveLog();
                                    m_iStep++;
                                    //m_bSubErr = true;
                                    //m_iStep = 0;
                                    CMot.It.Stop_Log(3);
                                    //return true;
                                    return false;

                                }
                                
                            }
                            if(CDataOption.UseIO == eUseToolSetterIO.Use)
                            {
                                if(!xTSIOL)
                                {
                                    if (CMot.It.Chk_OP(m_iZ) == EAxOp.Jog)
                                    { 
                                        //CErr.Show(eErr.LEFT_TOOL_SETTER_IO_NOT_DETECT);
                                        CMot.It.EStop(m_iZ);
                                        m_Delay.Set_Delay(2000);
                                        m_LogVal.iStep  = m_iStep;
                                        m_LogVal.sMsg   = "외부 I/O 감지";
                                        SaveLog();
                                        m_iStep++;
                                        //m_bSubErr = true;
                                        //m_iStep = 0;
                                        CMot.It.Stop_Log(3);
                                        //return true;
                                        return false;
                                    }
                                }
                            }
                        }
                        else
                        {
                            bool xTSServoR = Convert.ToBoolean(CIO.It.Get_TS(EWay.R));
                            bool xTSIOR    = CIO.It.Get_X(eX.SYS_ToolsetterR);
                            if(!xTSServoR)
                            {
                                if (CMot.It.Chk_OP(m_iZ) == EAxOp.Jog)
                                {
                                    //CErr.Show(eErr.RIGHT_TOOL_SETTER_IO_NOT_DETECT);
                                    CMot.It.EStop(m_iZ);
                                    m_Delay.Set_Delay(2000);
                                    m_LogVal.iStep  = m_iStep;
                                    m_LogVal.sMsg   = "Servo Pack I/O 감지";
                                    SaveLog();
                                    m_iStep++;
                                    //m_bSubErr = true;
                                    //m_iStep = 0;
                                    //return true;
                                    return false;
                                }
                            }
                            if(CDataOption.UseIO == eUseToolSetterIO.Use)
                            {
                                if(!xTSIOR)
                                {
                                    if (CMot.It.Chk_OP(m_iZ) == EAxOp.Jog)
                                    { 
                                        //CErr.Show(eErr.RIGHT_TOOL_SETTER_IO_NOT_DETECT);
                                        CMot.It.EStop(m_iZ);
                                        m_Delay.Set_Delay(2000);
                                        m_LogVal.iStep  = m_iStep;
                                        m_LogVal.sMsg   = "외부 I/O 감지";
                                        SaveLog();
                                        m_iStep++;
                                        //m_bSubErr = true;
                                        //m_iStep = 0;
                                        //return true;
                                        return false;
                                    }
                                }
                            }
                        }
                            
                        return false;
                    }

                case 26:
                    {// 1mm 상승
                        if (!m_Delay.Chk_Delay()) return false;

                        // 200720 jym : 스핀들 스탑 후 확인 구문 추가
                        if (CData.Spls[m_iWy].iRpm != 0)
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max - Spildle Stop Check
                            CSpl_485.It.Write_Stop(m_eWy);

                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(300);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }                        

                        if (m_iWhlCnt == 0)
                        {
                            // 2021.04.06 SungTae Start
                            //CMot.It.Mv_I(m_iZ, -1.0);
                            if (CMot.It.Mv_I(m_iZ, -1.0) != 0)
                            {
                                return false;
                            }
                            // 2021.04.06 SungTae End
                        }
                        else
                        {
                            // 2021.04.06 SungTae Start
                            //CMot.It.Mv_I(m_iZ, 1.0);
                            if (CMot.It.Mv_I(m_iZ, 1.0) != 0)
                            {
                                return false;
                            }
                            // 2021.04.06 SungTae End
                        }

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sMsg += "Spindle stop check.";
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 27:
                    {// Z축 이동 응답 확인
                        if (!CMot.It.Get_Mv(m_iZ))
                        { return false; }

                        m_Delay.Set_Delay(2000);
                        //191002 ksg :
                        if(m_eWy == EWay.L)
                        {
                            bool xTSServoL = Convert.ToBoolean(CIO.It.Get_TS(EWay.L));
                            if (!xTSServoL)
                            {
                                CErr.Show(eErr.LEFT_TOOL_SETTER_SIGNAL_NOT_NOMAL);
                                m_bSubErr = true;
                                m_iStep = 0;
                                return true;
                            }
                        }
                        else
                        {
                            bool xTSServoR = Convert.ToBoolean(CIO.It.Get_TS(EWay.R));
                            if (!xTSServoR)
                            {
                                CErr.Show(eErr.RIGHT_TOOL_SETTER_SIGNAL_NOT_NOMAL);
                                m_bSubErr = true;
                                m_iStep = 0;
                                return true;
                            }
                        }

                        m_LogVal.iStep  = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 28:
                    {// 느린속도 하강 측정 (0.1mm/s)
                        if (!m_Delay.Chk_Delay()) return false;
                        dVel = 0.1;
                        if (m_eWy == EWay.L)
                        {
                            bool xTSServoL = Convert.ToBoolean(CIO.It.Get_TS(EWay.L));
                            m_LogVal.sMsg = "xTSServoL = " + xTSServoL.ToString();
                        }
                        else
                        {
                            bool xTSServoR = Convert.ToBoolean(CIO.It.Get_TS(EWay.R));
                            m_LogVal.sMsg = "xTSServoR = " + xTSServoR.ToString();
                        }
                        
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_J(m_iZ, true, dVel, dVel * 5.0);
                        if (CMot.It.Mv_J(m_iZ,true, dVel, dVel * 5.0) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sAsix1 = m_iZ.ToString();
                        m_LogVal.sMsg   += "dVel = " +dVel.ToString(); 
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 29:
                    {// Z축 이동 응답 대기
                        if (CMot.It.Chk_OP(m_iZ) == EAxOp.Idle)
                        {
                            m_Delay.Set_Delay(2000);

#if true //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                            m_aWheelTipZPos[m_iWhlCnt] = Math.Round(CMot.It.Get_FP(m_iZ),6); //Z축 위치 저장
                            m_aTip[m_iWhlCnt] = Math.Round((CData.MPos[m_iWy].dZ_WHL_BASE - m_aWheelTipZPos[m_iWhlCnt]), 6);
                            _SetLog("Wheel Tip[" + m_iWhlCnt.ToString() + "] Z Axis", m_aWheelTipZPos[m_iWhlCnt]);
#else
                            m_aTip[m_iWhlCnt] = Math.Round((CData.MPos[m_iWy].dZ_WHL_BASE - CMot.It.Get_FP(m_iZ)), 6);
#endif

                            // 휠 측정 값 순서대로 저장
                            CData.WhlMea[m_iWy, m_iWhlCnt] = m_aTip[m_iWhlCnt];
                            //200318 ksg : Wheel One Point Check
                            /*
                            if (m_iWhlCnt == 2)
                            {
                                m_LogVal.iStep  = m_iStep;
                                SaveLog();

                                m_iStep = 34; 
                            }
                            else
                            {
                                m_LogVal.iStep  = m_iStep;
                                SaveLog();
                                m_iStep++;
                                m_iWhlCnt++;
                            }
                            */
                            //if(CData.Opt.bWhlOneCheck && (CSQ_Main.It.m_iStat == EStatus.Auto_Running))
                            if(CData.Opt.bWhlOneCheck && CSQ_Main.It.m_bRun)//200406 ksg : 조건 변경
                            {
                                CData.WhlMea[m_iWy, 1] = m_aTip[m_iWhlCnt];
                                CData.WhlMea[m_iWy, 2] = m_aTip[m_iWhlCnt];
                                m_aTip[1] = m_aTip[m_iWhlCnt];
                                m_aTip[2] = m_aTip[m_iWhlCnt];
                                //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                m_aWheelTipZPos[1] = m_aWheelTipZPos[2] = m_aWheelTipZPos[m_iWhlCnt]; //1회 측정한 Z축 위치 복사
                                //
                                m_iStep = 34; 
                            }
                            else
                            {
                                if (m_iWhlCnt == 2)
                                {
                                    m_LogVal.iStep  = m_iStep;
                                    SaveLog();

                                    m_iStep = 34; 
                                }
                                else
                                {
                                    m_LogVal.iStep  = m_iStep;
                                    SaveLog();
                                    m_iStep++;
                                    m_iWhlCnt++;
                                }
                            }
                        }
                        //191002 ksg :
                        if(m_eWy == EWay.L)
                        {
                            bool xTSServoL = Convert.ToBoolean(CIO.It.Get_TS(EWay.L));
                            bool xTSIOL    = CIO.It.Get_X(eX.SYS_ToolsetterL);

                            if (!xTSServoL)
                            {
                                if (CMot.It.Chk_OP(m_iZ) == EAxOp.Jog)
                                {
                                    CMot.It.Stop_Log(3);
                                    //CErr.Show(eErr.LEFT_TOOL_SETTER_IO_NOT_DETECT);
                                    CMot.It.EStop(m_iZ);
                                    m_Delay.Set_Delay(2000);
#if true ////201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                    m_aWheelTipZPos[m_iWhlCnt] = Math.Round(CMot.It.Get_FP(m_iZ),6); //Z축 위치 저장
                                    m_aTip[m_iWhlCnt] = Math.Round((CData.MPos[m_iWy].dZ_WHL_BASE - m_aWheelTipZPos[m_iWhlCnt]), 6);
                                    _SetLog("Wheel Tip[" + m_iWhlCnt.ToString() + "] Z Axis", m_aWheelTipZPos[m_iWhlCnt]);
#else
                                    m_aTip[m_iWhlCnt] = Math.Round((CData.MPos[m_iWy].dZ_WHL_BASE - CMot.It.Get_FP(m_iZ)), 6);
#endif

                                    // 휠 측정 값 순서대로 저장
                                    CData.WhlMea[m_iWy, m_iWhlCnt] = m_aTip[m_iWhlCnt];

                                    //200318 ksg : Wheel One Point Check
                                    /*
                                    if (m_iWhlCnt == 2)
                                    {
                                        m_LogVal.iStep  = m_iStep;
                                        SaveLog();

                                        m_iStep = 34; 
                                    }
                                    else
                                    {
                                        m_LogVal.iStep  = m_iStep;
                                        SaveLog();
                                        m_iStep++;
                                        m_iWhlCnt++;
                                    }
                                    */
                                    //if(CData.Opt.bWhlOneCheck && (CSQ_Main.It.m_iStat == EStatus.Auto_Running))
                                    if(CData.Opt.bWhlOneCheck && CSQ_Main.It.m_bRun)//200406 ksg : 조건 변경
                                    {
                                        CData.WhlMea[m_iWy, 1] = m_aTip[m_iWhlCnt];
                                        CData.WhlMea[m_iWy, 2] = m_aTip[m_iWhlCnt];
                                        m_aTip[1] = m_aTip[m_iWhlCnt];
                                        m_aTip[2] = m_aTip[m_iWhlCnt];
                                        //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                        m_aWheelTipZPos[1] = m_aWheelTipZPos[2] = m_aWheelTipZPos[m_iWhlCnt]; //1회 측정한 Z축 위치 복사
                                        //
                                        m_iStep = 34; 
                                    }
                                    else
                                    {
                                        if (m_iWhlCnt == 2)
                                        {
                                            m_LogVal.iStep  = m_iStep;
                                            SaveLog();

                                            m_iStep = 34; 
                                        }
                                        else
                                        {
                                            m_LogVal.iStep  = m_iStep;
                                            SaveLog();
                                            m_iStep++;
                                            m_iWhlCnt++;
                                        }
                                    }
                                    m_LogVal.iStep  = m_iStep;
                                    m_LogVal.sMsg   = "Servo Pack I/O 감지";
                                    SaveLog();
                                    CMot.It.Stop_Log(3);
                                    return false;
                                    //m_bSubErr = true;
                                    //m_iStep = 0;
                                    //return true;

                                }
                                
                            }
                            if(CDataOption.UseIO == eUseToolSetterIO.Use)
                            {
                                if(!xTSIOL)
                                {
                                    if (CMot.It.Chk_OP(m_iZ) == EAxOp.Jog)
                                    { 
                                        //CErr.Show(eErr.LEFT_TOOL_SETTER_IO_NOT_DETECT);
                                        CMot.It.EStop(m_iZ);
                                        CMot.It.Stop_Log(3);
                                        m_Delay.Set_Delay(2000);
#if true //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                        m_aWheelTipZPos[m_iWhlCnt] = Math.Round(CMot.It.Get_FP(m_iZ),6); //Z축 위치 저장
                                        m_aTip[m_iWhlCnt] = Math.Round((CData.MPos[m_iWy].dZ_WHL_BASE - m_aWheelTipZPos[m_iWhlCnt]), 6);
                                        _SetLog("Wheel Tip[" + m_iWhlCnt.ToString() + "] Z Axis", m_aWheelTipZPos[m_iWhlCnt]);
#else
                                        m_aTip[m_iWhlCnt] = Math.Round((CData.MPos[m_iWy].dZ_WHL_BASE - CMot.It.Get_FP(m_iZ)), 6);
#endif

                                        // 휠 측정 값 순서대로 저장
                                        CData.WhlMea[m_iWy, m_iWhlCnt] = m_aTip[m_iWhlCnt];

                                        //200318 ksg : Wheel One Point Check
                                        /*
                                        if (m_iWhlCnt == 2)
                                        {
                                            m_LogVal.iStep  = m_iStep;
                                            SaveLog();

                                            m_iStep = 34; 
                                        }
                                        else
                                        {
                                            m_LogVal.iStep  = m_iStep;
                                            SaveLog();
                                            m_iStep++;
                                            m_iWhlCnt++;
                                        }
                                        */
                                        //if(CData.Opt.bWhlOneCheck && (CSQ_Main.It.m_iStat == EStatus.Auto_Running))
                                        if(CData.Opt.bWhlOneCheck && CSQ_Main.It.m_bRun)//200406 ksg : 조건 변경
                                        {
                                            CData.WhlMea[m_iWy, 1] = m_aTip[m_iWhlCnt];
                                            CData.WhlMea[m_iWy, 2] = m_aTip[m_iWhlCnt];
                                            m_aTip[1] = m_aTip[m_iWhlCnt];
                                            m_aTip[2] = m_aTip[m_iWhlCnt];
                                            //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                            m_aWheelTipZPos[1] = m_aWheelTipZPos[2] = m_aWheelTipZPos[m_iWhlCnt]; //1회 측정한 Z축 위치 복사
                                            //

                                            m_LogVal.iStep  = m_iStep;
                                            SaveLog();
                                            m_iStep = 34; 
                                        }
                                        else
                                        {
                                            if (m_iWhlCnt == 2)
                                            {
                                                m_LogVal.iStep  = m_iStep;
                                                SaveLog();

                                                m_iStep = 34; 
                                            }
                                            else
                                            {
                                                m_LogVal.iStep  = m_iStep;
                                                SaveLog();
                                                m_iStep++;
                                                m_iWhlCnt++;
                                            }
                                        }

                                        m_LogVal.iStep  = m_iStep;
                                        m_LogVal.sMsg   = "외부 I/O 감지";
                                        SaveLog();
                                        CMot.It.Stop_Log(3);
                                        return false;
                                        //m_bSubErr = true;
                                        //m_iStep = 0;
                                        //return true;
                                    }
                                }
                                
                            }
                        }
                        else
                        {
                            bool xTSServoR = Convert.ToBoolean(CIO.It.Get_TS(EWay.R));
                            bool xTSIOR    = CIO.It.Get_X(eX.SYS_ToolsetterR);
                            if(!xTSServoR)
                            {
                                if (CMot.It.Chk_OP(m_iZ) == EAxOp.Jog)
                                {
                                    //CErr.Show(eErr.RIGHT_TOOL_SETTER_IO_NOT_DETECT);
                                    CMot.It.EStop(m_iZ);
                                    m_Delay.Set_Delay(2000);

#if true //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                    m_aWheelTipZPos[m_iWhlCnt] = Math.Round(CMot.It.Get_FP(m_iZ),6); //Z축 위치 저장
                                    m_aTip[m_iWhlCnt] = Math.Round((CData.MPos[m_iWy].dZ_WHL_BASE - m_aWheelTipZPos[m_iWhlCnt]), 6);
                                    _SetLog("Wheel Tip[" + m_iWhlCnt.ToString() + "] Z Axis", m_aWheelTipZPos[m_iWhlCnt]);
#else
                                    m_aTip[m_iWhlCnt] = Math.Round((CData.MPos[m_iWy].dZ_WHL_BASE - CMot.It.Get_FP(m_iZ)), 6);
#endif

                                    // 휠 측정 값 순서대로 저장
                                    CData.WhlMea[m_iWy, m_iWhlCnt] = m_aTip[m_iWhlCnt];

                                    //200318 ksg : Wheel One Point Check
                                    /*
                                    if (m_iWhlCnt == 2)
                                    {
                                        m_LogVal.iStep  = m_iStep;
                                        SaveLog();

                                        m_iStep = 34; 
                                    }
                                    else
                                    {
                                        m_LogVal.iStep  = m_iStep;
                                        SaveLog();
                                        m_iStep++;
                                        m_iWhlCnt++;
                                    }
                                    */
                                    //if(CData.Opt.bWhlOneCheck && (CSQ_Main.It.m_iStat == EStatus.Auto_Running))
                                    if(CData.Opt.bWhlOneCheck && CSQ_Main.It.m_bRun)//200406 ksg : 조건 변경
                                    {
                                        CData.WhlMea[m_iWy, 1] = m_aTip[m_iWhlCnt];
                                        CData.WhlMea[m_iWy, 2] = m_aTip[m_iWhlCnt];
                                        m_aTip[1] = m_aTip[m_iWhlCnt];
                                        m_aTip[2] = m_aTip[m_iWhlCnt];

                                        //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                        m_aWheelTipZPos[1] = m_aWheelTipZPos[2] = m_aWheelTipZPos[m_iWhlCnt]; //1회 측정한 Z축 위치 복사
                                        //

                                        m_LogVal.iStep  = m_iStep;
                                        SaveLog();
                                        m_iStep = 34; 
                                    }
                                    else
                                    {
                                        if (m_iWhlCnt == 2)
                                        {
                                            m_LogVal.iStep  = m_iStep;
                                            SaveLog();

                                            m_iStep = 34; 
                                        }
                                        else
                                        {
                                            m_LogVal.iStep  = m_iStep;
                                            SaveLog();
                                            m_iStep++;
                                            m_iWhlCnt++;
                                        }
                                    }
                                    m_LogVal.iStep  = m_iStep;
                                    m_LogVal.sMsg   = "Servo Pack I/O 감지";
                                    SaveLog();
                                    return false;
                                    //m_bSubErr = true;
                                    //m_iStep = 0;
                                    //return true;
                                }
                            }
                            if(CDataOption.UseIO == eUseToolSetterIO.Use)
                            {
                                if(!xTSIOR)
                                {
                                    if (CMot.It.Chk_OP(m_iZ) == EAxOp.Jog)
                                    { 
                                        //CErr.Show(eErr.RIGHT_TOOL_SETTER_IO_NOT_DETECT);
                                        CMot.It.EStop(m_iZ);
                                        m_Delay.Set_Delay(2000);

#if true //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                        m_aWheelTipZPos[m_iWhlCnt] = Math.Round(CMot.It.Get_FP(m_iZ),6); //Z축 위치 저장
                                        m_aTip[m_iWhlCnt] = Math.Round((CData.MPos[m_iWy].dZ_WHL_BASE - m_aWheelTipZPos[m_iWhlCnt]), 6);
                                        _SetLog("Wheel Tip[" + m_iWhlCnt.ToString() + "] Z Axis", m_aWheelTipZPos[m_iWhlCnt]);
#else
                                        m_aTip[m_iWhlCnt] = Math.Round((CData.MPos[m_iWy].dZ_WHL_BASE - CMot.It.Get_FP(m_iZ)), 6);
#endif

                                        // 휠 측정 값 순서대로 저장
                                        CData.WhlMea[m_iWy, m_iWhlCnt] = m_aTip[m_iWhlCnt];

                                        //200318 ksg : Wheel One Point Check
                                        /*
                                        if (m_iWhlCnt == 2)
                                        {
                                            m_LogVal.iStep  = m_iStep;
                                            SaveLog();

                                            m_iStep = 34; 
                                        }
                                        else
                                        {
                                            m_LogVal.iStep  = m_iStep;
                                            SaveLog();
                                            m_iStep++;
                                            m_iWhlCnt++;
                                        }
                                        */
                                        //if(CData.Opt.bWhlOneCheck && (CSQ_Main.It.m_iStat == EStatus.Auto_Running))
                                        if(CData.Opt.bWhlOneCheck && CSQ_Main.It.m_bRun)//200406 ksg : 조건 변경
                                        {
                                            CData.WhlMea[m_iWy, 1] = m_aTip[m_iWhlCnt];
                                            CData.WhlMea[m_iWy, 2] = m_aTip[m_iWhlCnt];
                                            m_aTip[1] = m_aTip[m_iWhlCnt];
                                            m_aTip[2] = m_aTip[m_iWhlCnt];

                                            //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                            m_aWheelTipZPos[1] = m_aWheelTipZPos[2] = m_aWheelTipZPos[m_iWhlCnt]; //1회 측정한 Z축 위치 복사
                                            //

                                            m_LogVal.iStep  = m_iStep;
                                            SaveLog();
                                            m_iStep = 34; 
                                        }
                                        else
                                        {
                                            if (m_iWhlCnt == 2)
                                            {
                                                m_LogVal.iStep  = m_iStep;
                                                SaveLog();

                                                m_iStep = 34; 
                                            }
                                            else
                                            {
                                                m_LogVal.iStep  = m_iStep;
                                                SaveLog();
                                                m_iStep++;
                                                m_iWhlCnt++;
                                            }
                                        }
                                        m_LogVal.iStep  = m_iStep;
                                        m_LogVal.sMsg   = "외부 I/O 감지";
                                        SaveLog();
                                        return false;
                                        //m_iStep++; 
                                        //m_bSubErr = true;
                                        //m_iStep = 0;
                                        //return true;
                                    }
                                }
                            }
                        }

                        return false;
                    }

                case 30:
                    {// 3mm 상승
                        if (!m_Delay.Chk_Delay()) return false;
                        
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_I(m_iZ, -3.0);
                        if (CMot.It.Mv_I(m_iZ, -3.0) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sAsix1 = m_iZ.ToString();
                        m_LogVal.dPos1  = Convert.ToDouble("-3.0");
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 31:
                    {// Z축 이동 응답 확인
                        if (!CMot.It.Get_Mv(m_iZ))
                        { return false; }

                        m_LogVal.iStep  = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 32:
                    {// 휠 측정 위치 이동

                        /// <summary>
                        /// Wheel Tip & Toolsetter 3point 측정 : Spindle Drv position Setting 방식
                        /// m_iWhlCnt 값 = 1 또는 2 로 원점이후 휠 위치 변경
                        /// </summary>

                        bool bExit = false;
                        bool bTimeOutFlag = false;

                        // Wheel 회전 위치 값  Setting
                        int nWheelPnt = ((int)(4096 / 3)) * m_iWhlCnt; // 4096 = 1회전 Pluse Count, 3 = Wheel 측정 갯수
                        CSpl_485.It.Write_WheelChkPosition(m_eWy, nWheelPnt);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptWheelChkSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptWheelChkSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                            return false;
                        }


                        // Spindle RUN
                        bExit = false;
                        bTimeOutFlag = false;
                        CSpl_485.It.Write_Run(m_eWy);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRunSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRunSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            return false;
                        }

                        // Wheel Stop 정지 TimeOut Check
                        m_Timout_485.Set_Delay(300);

                        /*
                        //CSpl.It.Get_Position_Value(m_eWy, ref nSpindle_Degree); // spindle 현재 위치
                        // 2023.03.15 Max
                        CSpl_485.It.Get_Position_Value(m_eWy, ref nSpindle_Degree); // spindle 현재 위치

                        //CSpl.It.Write_Run(m_eWy, CData.Opt.iMeaS);
                        // 2023.03.15 Max
                        bool bExit = false;
                        bool bTimeOutFlag = false;

                        // RPM Setting
                        CSpl_485.It.Write_Rpm(m_eWy, CData.Opt.iMeaS);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRPMSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRPMSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                            return false;
                        }

                        // Spindle RUN
                        bExit = false;
                        bTimeOutFlag = false;
                        CSpl_485.It.Write_Run(m_eWy);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRunSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRunSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {                                                 
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_RUN_RPM_ERROR);

                            return false;
                        }

                        // 딜레이 설정
                        m_mSpl.Set_Delay(CData.Opt.iMeaT);
                        */

                        m_LogVal.iStep  = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 33:
                    {// 스핀들 응답 대기
                        /// <summary>
                        /// Wheel Tip & Toolsetter 3point 측정 : 변경 코드
                        /// </summary>
                        /// 
                        int nSplLRpm = 0;
                        if (m_eWy == EWay.L)
                        {
                            nSplLRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.L));
                        }
                        else
                        {
                            nSplLRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.R));
                        }

                        if (nSplLRpm != 0)
                        {
                            if (m_Timout_485.Chk_Delay())
                            {
                                if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                                if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                                m_Timout_485.Set_Delay(300);
                            }
                            return false;
                        }

                        m_iStep = 26;

                        /*
                        if (m_mSpl.Chk_Delay() == true)
                        {
                            // 스핀들 정지
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max - Spildle Stop Check
                            CSpl_485.It.Write_Stop(m_eWy);

                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(300);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            m_LogVal.iStep  = m_iStep;
                            m_LogVal.sMsg  = "Write_Stop("+m_eWy.ToString()+")";
                            SaveLog();

                            m_iStep = 26;

                            //m_mSpl_Chk.Set_Delay(300);
                            //m_iStep = 333;
                        }
                        */

                        return false;
                    }

                case 333: // 2023.03.15 Max - Spildle Stop Check - 추가전
                    {// 스핀들 응답 대기
                        if (m_mSpl_Chk.Chk_Delay()) 
                        {
                            m_LogVal.iStep = m_iStep;
                            m_LogVal.sMsg = "Write_Stop(" + m_eWy.ToString() + ")";
                            SaveLog();

                            m_iStep = 26;
                        }
                        return false;
                    }

                case 34:
                    {// 반복 측정 종료 데이터 관리
                        if (!m_Delay.Chk_Delay())
                        { return false; }

                        // 201006 jym : TTV 체크 여부 추가
                        if (bChkTTV && CData.Opt.aWhlTTV[m_iWy] != 0 && (m_aTip.Max() - m_aTip.Min()) > CData.Opt.aWhlTTV[m_iWy])
                        {
                            if (m_iWy == (int)EWay.L)
                            { CErr.Show(eErr.LEFT_GRIND_WHEEL_MEASURE_TTV_OVER); }
                            else
                            { CErr.Show(eErr.RIGHT_GRIND_WHEEL_MEASURE_TTV_OVER); }
                            
                            //20190909 ghk_grd_drs_err
                            m_bSubErr = true;
                            //

                            m_iStep = 0;
                            return true;
                        }
                        CMot.It.Stop_Log(3);

                        // 휠 높이 갱신
                        CData.WhlBf[m_iWy] = CData.WhlAf[m_iWy];
                        CData.WhlAf[m_iWy] = m_aTip.Max();

                        //210727 pjh : Wheel 변화량 Limit
                        if (CDataOption.UseWheelDresserMaxLimit && CData.Opt.bVarLimitUse)
                        {
                            if ((Math.Abs(CData.WhlBf[m_iWy] - CData.WhlAf[m_iWy]) > CData.Opt.aWheelMax[m_iWy]) || (m_aTip.Max() > GV.WHEEL_DEF_TIP_T))
                            {
                                //210812 pjh : 휠 지그 감지 시 에러 발생안됨(휠 교체에 있어서 조건 안보기 위함)
                                if (CData.DrData[m_iWy].bWheelChange)
                                {
                                    CData.DrData[m_iWy].bWheelChange = false;
                                }
                                else
                                {
                                    CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_OVER_WHEEL_THICKNESS : eErr.RIGHT_GRIND_OVER_WHEEL_THICKNESS);
                                    _SetLog("Error : Wheel measure limit over error");//210830 pjh : Log 추가

                                    m_iStep = 0;
                                    return true;
                                }
                                //        
                            }
                        }
                        //

                        //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                        CData.WheelTipBeforeZPos[m_iWy] = CData.WheelTipAfterZPos[m_iWy]; //휠팁 이전 값 저장
                        CData.WheelTipAfterZPos[m_iWy] = m_aWheelTipZPos.Min(); //휠팁 최고 두께 위치 = Z축 가장 높은 위치 = Z축 최소값
                        _SetLog("Wheel Tip Z Aixs  Before:" + CData.WheelTipBeforeZPos[m_iWy].ToString() + "  After: " + CData.WheelTipAfterZPos[m_iWy].ToString());
                        //

                        CData.Whls[m_iWy].dWhlBf = CData.Whls[m_iWy].dWhlAf;
                        CData.Whls[m_iWy].dWhlAf = m_aTip.Max();
                        CData.Whls[m_iWy].dWhltH = m_aTip.Max();

                        if (CData.GemForm != null)
                        {// Measure Wheel After Data
                           // CData.GemForm.Measure_Wheel_Dress_Data_Set(m_iWy, 0, 1);// Left ,0-Wheel(1-Dress), 0-Before Data(1-Aftere)
                        }
                        if (CData.Whls[m_iWy].iGtc == 0 && CData.Whls[m_iWy].iDrsC == 0)
                        {
                            CData.Whls[m_iWy].dWhlFtH = CData.Whls[m_iWy].dWhltH;
                        }

                        //휠 히스토리
                        if (CSQ_Main.It.m_iStat == EStatus.Manual)
                        {
                            CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.MeasureWheel.ToString();
                        }
                        //

                        m_iStep++;
                        return false;
                    }

               case 35:
                    {// 툴세터 이벤트 비활성화
                        //20190705 ghk_meawhl
                        //CMot.It.Set_Evt(m_eWy, false);
                        if (CMot.It.Set_Evt(m_eWy, false) == 1)
                        { return false; }

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sMsg  = "Set_Evt("+m_eWy.ToString()+", false)";
                        SaveLog();

                        m_iStep++;

                        return false;
                    }

                case 36:
                    {//Z축 Able 위치로 이동
                        
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                        if (CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sAsix1 = m_iZ.ToString();
                        m_LogVal.dPos1  = CData.SPos.dGRD_Z_Able[m_iWy];
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 37:
                    {//Z축 Able 위치로 응답 확인
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        m_LogVal.iStep  = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 38:
                    {//작업 종료
                        CLast.Save();
                        CWhl.It.Save(m_eWy, CData.Whls[m_iWy]);

                        // 2023.03.15 Max 회전후 I/O를 설정 Reset
                        // Spindle Drv I/O 단자 Mi7에 접점 OFF 시킴.
                        if (m_eWy == EWay.L) CIO.It.Set_Y(eY.GRL_WheelMeasureControlTerminal, false);
                        if (m_eWy == EWay.R) CIO.It.Set_Y(eY.GRR_WheelMeasureControlTerminal, false);

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sMsg = "CLast.Save(), CWhl.It.Save(" + m_eWy.ToString() +")";
                        SaveLog();

                        m_iStep = 0;

                        return true;
                    }

                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스
                case 100:
                    {//Z축 대기 위치 이동
                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        { m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy]; }
                        else
                        { m_dPosZ = CData.SPos.dGRD_Z_Wait[m_iWy]; }
                        CMot.It.Stop(m_iZ);
                        
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, m_dPosZ);
                        if (CMot.It.Mv_N(m_iZ, m_dPosZ) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("ERROR : Picker Vacuum : " + m_siZ + " UP : " + m_dPosZ.ToString());
                        
                        m_iStep++;
                        return false;
                    }

                case 101:
                    {//Z축 대기 위치 이동 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            //CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }

                        if (m_iPickerVacErr == 1)
                        { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else
                        { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        _SetLog("ERROR : Picker Vacuum : " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        m_bSubErr = true; ////////

                        m_iStep = 0;
                        return true;
                    }
                ///////////////////////////////////////////////////////////////////////////////////////
            }
        }

        //20190705 ghk_meawhl
        /// <summary>
        /// Wheel Height Measure
        /// 휠 높이 측정 함수
        /// </summary>
        /// <returns></returns>
        public bool Cyl_MeaWhl_Step(bool bChkTTV = true)
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_WHEEL_INSPECTION_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_WHEEL_INSPECTION_TIMEOUT); }
                    //20190909 ghk_grd_drs_err
                    m_bSubErr = true;
                    _SetLog("Error : Timeout.");

                    m_iStep = 0;
                    return true;
                }
            }

            //if (CDataOption.SplType == eSpindleType.EtherCat)
            //{
            //    CData.Spls[0].iRpm = Convert.ToInt32(CSpl.It.GetFrpm(true));
            //    CData.Spls[1].iRpm = Convert.ToInt32(CSpl.It.GetFrpm(false));
            //}
            
            // 2023.03.15 Max
            CData.Spls[(int)EWay.L].iRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.L));
            CData.Spls[(int)EWay.R].iRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.R));

            m_iPreStep = m_iStep;

            if (m_eWy == EWay.L) m_LogVal.sStatus = "GRL_Cyl_MeaWhl";
            else m_LogVal.sStatus = "GRR_Cyl_MeaWhl";

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if ((CData.CurCompany == ECompany.ASE_KR) && 
                (m_iStep == 19 || m_iStep == 20))
            {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                if (0 != m_iPickerVacErr)
                {
                    CMot.It.EStop(m_iY); //Table Y축 즉시 Stop

                    _SetLog("ERROR : Picker Vacuum : " + m_siY + " STOP : " + CMot.It.Get_FP(m_iY).ToString());

                    m_iStep = 100; //정리 스텝으로
                    return false;
                }
            }
            ///////////////////////////////////////////////////////////////////////////////////////

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10:
                    {// 축 상태 체크
                     // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }

                        //20190704 ghk_meawhl
                        // Tool Setter I/O이며, Motor Z축 I/O와 연결, 
                        // WMX 연결 순서상 왼쪽 이면 직접 I/O 번호 적용
                        if (m_eWy == EWay.L)
                        {   
                            m_iAddr = 10;
                            m_iBit = 7;
                        }
                        else
                        {
                            // WMX 연결 순서상 오른쪽이면 스핀들 인버터 가 추가 됨으로 
                            // I/O 자리수 변경됨 
                            // 하기 스핀들 인버터가 RS-232 CAN이면 I/O 변경됨.

                            //20191022 ghk_spindle_type
                            //if (CSpl.It.bUse232)
                            //if (CDataOption.SplType == eSpindleType.Rs232)
                            //{
                            //    if (CDataOption.CurEqu == eEquType.Nomal)
                            //    {
                            //        m_iAddr = 85;
                            //        m_iBit = 7;
                            //    }
                            //    else
                            //    {
                            //        m_iAddr = 89;
                            //        m_iBit = 7;
                            //    }
                            //}
                            //else
                            //{
                            //    if (CDataOption.CurEqu == eEquType.Nomal)
                            //    {
                            //        m_iAddr = 97;
                            //        m_iBit = 7;
                            //    }
                            //    else
                            //    {
                            //        m_iAddr = 101;
                            //        m_iBit = 7;
                            //    }
                            //}

                            // 2023.03.15 Max
                            if (CDataOption.CurEqu == eEquType.Nomal)
                            {
                                m_iAddr = 97;
                                m_iBit = 7;
                            }
                            else
                            {
                                m_iAddr = 101;
                                m_iBit = 7;
                            }
                        }

                        // 휠 3번 측정 값 초기화
                        CData.WhlMea[m_iWy, 0] = 0.0;
                        CData.WhlMea[m_iWy, 1] = 0.0;
                        CData.WhlMea[m_iWy, 2] = 0.0;

                        //20190909 ghk_grd_drs_err
                        m_bSubErr = false;
                        m_iWhlCnt = 0;
                        m_aTip = new double[3];

                        //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                        m_aWheelTipZPos[0] = m_aWheelTipZPos[1] = m_aWheelTipZPos[2] = 0.0; //휠측정 시작 시 변수 초기화
                        //

                        _SetLog("Check axes.  Addr : " + m_iAddr + "  Bit : " + m_iBit);

                        m_iStep++;
                        return false;
                    }

                case 11:
                    {// Wheel file check
                        if (m_eWy == EWay.L)
                        {
                            if (CData.Whls[0].sWhlName == "")
                            {
                                CErr.Show(eErr.SYSTEM_LEFT_WHEEL_FILE_NOT_LOAD);
                                _SetLog("Error : Wheel file not loading.");
                                //20190909 ghk_grd_drs_err
                                m_bSubErr = true;
                                //
                                m_iStep = 0;
                                return true;
                            }
                        }
                        else
                        {
                            if (CData.Whls[1].sWhlName == "")
                            {
                                CErr.Show(eErr.SYSTEM_RIGHT_WHEEL_FILE_NOT_LOAD);
                                _SetLog("Error : Wheel file not loading.");
                                //20190909 ghk_grd_drs_err
                                m_bSubErr = true;
                                //
                                m_iStep = 0;
                                return true;
                            }
                        }
                        if (CData.GemForm != null)
                        {// Measure Wheel Before Data
                            //CData.GemForm.Measure_Wheel_Dress_Data_Set(m_iWy, 0, 0);// Left ,0-Wheel(1-Dress), 0-Before Data(1-Aftere)
                        }
                        _SetLog("Check wheel file.");

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {// IO 초기화
                        _InitCycle();
                        _SetLog("Init cycle.");

                        m_iStep++;
                        return false;
                    }

                case 13:
                    {// 프로브 대기 위치 이동
                        if (m_eWy == EWay.L)
                        { m_eOt1 = eY.GRDL_ProbeDn; }
                        else
                        { m_eOt1 = eY.GRDR_ProbeDn; }

                        CIO.It.Set_Y(m_eOt1, false);
                        
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Wait[m_iWy]);
                        if (CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Wait[m_iWy]) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("X axis move wait.", CData.SPos.dGRD_X_Wait[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 14:
                    {// 프로브 이동 응답 확인
                        if (!(CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Wait[m_iWy])) || !(CIO.It.Set_Y(m_eOt1, false)))
                        { return false; }
                        _SetLog("Check X axis move.");

                        m_iStep++;
                        return false;
                    }

                case 15:
                    {// 테이블 안전상태 체크
                        SafeTbl(true, true, false);
                        _SetLog("Check table safe");

                        m_iStep++;
                        return false;
                    }
                //190128 : 중국에서 Dressing 중 처 박는 것 때문에 확인 결과 Z축 높이 Check 안 하고 Y축 이동 하기에 추가 함.(Case 16, 17)
                case 16:
                    {
                        m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy];
                        
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, m_dPosZ);
                        if (CMot.It.Mv_N(m_iZ, m_dPosZ) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("Z axis move position.", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 17:
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }
                        _SetLog("Check Z axis move.");

                        m_iStep++;
                        return false;
                    }

                case 18:
                    {// 탑클리너 업 체크
                        if (m_eWy == EWay.L)
                        { m_eIn1 = eX.GRDL_TopClnDn; m_eOt1 = eY.GRDL_TopClnDn; } //syc : new cleaner : 삭제 예정
                        else
                        { m_eIn1 = eX.GRDR_TopClnDn; m_eOt1 = eY.GRDR_TopClnDn; }

                        //syc : new cleaner
                        //CIO.It.Set_Y(m_eOt1, false);
                        ActTcDown(false);

                        //syc : new clean
                        //if (!CIO.It.Get_X(m_eIn1))
                        if (!Chk_CleanerDn(false))
                        {
                            _SetLog("Top cleaner up.");

                            m_iStep++;
                        }

                        return false;
                    }

                case 19:
                    {// 테이블 측정위치 이동
                        m_dPosY = CData.MPos[m_iWy].dY_WHL_TOOL_SETTER - (CData.Whls[m_iWy].dWhlO / 2.0) + (GV.WHEEL_DEF_TIP_W / 2.0);

                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iY, m_dPosY);
                        if (CMot.It.Mv_N(m_iY, m_dPosY) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("Y axis move measure position.", m_dPosY);

                        m_iStep++;
                        return false;
                    }

                case 20:
                    {// 테이블 이동 응답 확인
                        if (!(CMot.It.Get_Mv(m_iY, m_dPosY)))
                        { return false; }

                        // 휠 3번 측정 값 초기화
                        CData.WhlMea[m_iWy, 0] = 0.0;
                        CData.WhlMea[m_iWy, 1] = 0.0;
                        CData.WhlMea[m_iWy, 2] = 0.0;
                        _SetLog("Init array.");

                        m_iStep++;
                        return false;
                    }

                case 21:
                    {// Z축 측정 시작위치 이동 (휠 베이스로 툴세터 측정위치 -12mm) 
                        m_dPosZ = CData.MPos[m_iWy].dZ_WHL_BASE - GV.WHEEL_DEF_TIP_T;

                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, m_dPosZ);
                        if (CMot.It.Mv_N(m_iZ, m_dPosZ) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("Z axis move position.", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 22:
                    {// Z축 이동 응답 확인
                        if (!(CMot.It.Get_Mv(m_iZ, m_dPosZ, GV.INPOS_GRD_CYCLE)))
                        { return false; }
                        _SetLog("Check Z axis move.");

                        // 2023.03.15 Max
                        //m_iStep++;

                        /// <summary>
                        /// Wheel Tip & Toolsetter 3point 측정 : Spindle Drv position Setting 방식
                        /// m_iWhlCnt 값 = 0 으로 원점 잡아서 첫번째 휠 측정
                        /// </summary>

                        // 2023.03.15 Max 회전 하기전 I/O를 설정
                        // Spindle Drv I/O 단자 Mi7에 접점 ON 시킴.
                        if (m_eWy == EWay.L) CIO.It.Set_Y(eY.GRL_WheelMeasureControlTerminal, true);
                        if (m_eWy == EWay.R) CIO.It.Set_Y(eY.GRR_WheelMeasureControlTerminal, true);


                        bool bExit = false;
                        bool bTimeOutFlag = false;

                        // Wheel 회전 위치 값  Setting
                        int nWheelPnt = ((int)(4096 / 3)) * m_iWhlCnt; // 4096 = 1회전 Pluse Count, 3 = Wheel 측정 갯수
                        CSpl_485.It.Write_WheelChkPosition(m_eWy, nWheelPnt);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptWheelChkSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptWheelChkSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                            return false;
                        }


                        // Spindle RUN
                        bExit = false;
                        bTimeOutFlag = false;
                        CSpl_485.It.Write_Run(m_eWy);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRunSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRunSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            return false;
                        }

                        // Wheel Stop 정지 TimeOut Check
                        m_Timout_485.Set_Delay(300);

                        m_iStep = 222;
                        return false;
                    }


                case 222:
                    {
                        /// <summary>
                        /// Wheel Tip & Toolsetter 3point 측정 : 변경 코드
                        ///  23번 스텝에서 RPM 회전 값 Check함으로 아래 코드 없어도 되나 222번 스텝 일단 추가.
                        /// </summary>
                        /// 
                        int nSplLRpm = 0;
                        if (m_eWy == EWay.L)
                        {
                            nSplLRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.L));
                        }
                        else
                        {
                            nSplLRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.R));
                        }

                        if (nSplLRpm != 0)
                        {
                            if (m_Timout_485.Chk_Delay())
                            {
                                if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                                if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                                m_Timout_485.Set_Delay(300);
                            }
                            return false;
                        }

                        m_iStep = 23;
                        return false;
                    }

                case 23:
                    {//1mm 다운
                        // 200720 jym : 스핀들 스탑 후 확인 구문 추가
                        
                        if (CData.Spls[m_iWy].iRpm != 0)
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max - Spildle Stop Check
                            CSpl_485.It.Write_Stop(m_eWy);

                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(300);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if ((CData.MPos[m_iWy].dZ_WHL_BASE - CData.Whls[m_iWy].dWhlLimit) == m_dPosZ)
                        {//휠 감지 에러
                            if (m_eWy == EWay.L)
                            { CErr.Show(eErr.LEFT_GRIND_NOT_DETECTED_TOOLSENSOR); }
                            else
                            { CErr.Show(eErr.RIGHT_GRIND_NOT_DETECTED_TOOLSENSOR); }
                            _SetLog("Error : Not detect toolsetter.");
                            //20190909 ghk_grd_drs_err
                            m_bSubErr = true;
                            //
                            m_iStep = 0;
                            return true;
                        }

                        m_dPosZ += 1;
                        if((CData.MPos[m_iWy].dZ_WHL_BASE - CData.Whls[m_iWy].dWhlLimit) < m_dPosZ)
                        {
                            m_dPosZ = (CData.MPos[m_iWy].dZ_WHL_BASE - CData.Whls[m_iWy].dWhlLimit);
                        }
                        CMot.It.Mv_N(m_iZ, m_dPosZ);

                        _SetLog("Z axis move position.", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 24:
                    {//Z축 1mm 다운 확인, 툴세터 감지 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ, GV.INPOS_GRD_CYCLE))
                        { return false; }

                        if (CIO.It.Get_X(m_iAddr, m_iBit) == 1)
                        {//툴세터 IO (ON) 감지 안됨
                            m_iStep = 23;
                        }
                        else
                        {//툴세터 IO (OFF) 감지 됨
                            _SetLog("Toolsetter off.", m_dPosZ);
                            m_iStep++;
                        }
                        return false;
                    }

                case 25:
                    {//Z축 0.1mm 업
                        m_dPosZ -= 0.1;
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move position.", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 26:
                    {//Z축 0.1mm 업 확인, 툴세터 감지 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ, GV.INPOS_GRD_CYCLE))
                        { return false; }

                        if (CIO.It.Get_X(m_iAddr, m_iBit) == 0)
                        {//툴세터 IO (OFF) 감지 됨
                            m_iStep = 25;
                        }
                        else
                        {//툴세터 IO (ON) 감지 안됨
                            _SetLog("Toolsetter on.", m_dPosZ);
                            m_iStep++;
                        }
                        return false;
                    }

                case 27:
                    {//Z축 0.02mm 다운
                        if ((CData.MPos[m_iWy].dZ_WHL_BASE - CData.Whls[m_iWy].dWhlLimit) == m_dPosZ)
                        {//휠 감지 에러
                            if (m_eWy == EWay.L)
                            { CErr.Show(eErr.LEFT_GRIND_NOT_DETECTED_TOOLSENSOR); }
                            else
                            { CErr.Show(eErr.RIGHT_GRIND_NOT_DETECTED_TOOLSENSOR); }
                            _SetLog("Error : Not detect toolsetter.");
                            //20190909 ghk_grd_drs_err
                            m_bSubErr = true;
                            
                            m_iStep = 0;
                            return true;
                        }

                        m_dPosZ += 0.02;

                        if ((CData.MPos[m_iWy].dZ_WHL_BASE - CData.Whls[m_iWy].dWhlLimit) < m_dPosZ)
                        {
                            m_dPosZ = (CData.MPos[m_iWy].dZ_WHL_BASE - CData.Whls[m_iWy].dWhlLimit);
                        }

                        //CMot.It.Mv_N(m_iZ, m_dPosZ);
                        CMot.It.Mv_S(m_iZ, m_dPosZ);
                        _SetLog("Z axis move position(slow).", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 28:
                    {//Z축 0.02mm 다운 확인, 툴세터 감지 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ, GV.INPOS_GRD_CYCLE))
                        { return false; }

                        if (CIO.It.Get_X(m_iAddr, m_iBit) == 1)
                        {//툴세터 IO (ON) 감지 안됨
                            m_iStep = 27;
                        }
                        else
                        {//툴세터 IO (OFF) 감지 됨
                            _SetLog("Toolsetter off.", m_dPosZ);
                            m_iStep++;
                        }
                        return false;
                    }

                case 29:
                    {//Z축 0.001mm 업
                        m_dPosZ -= 0.001;
                        //CMot.It.Mv_N(m_iZ, m_dPosZ);
                        CMot.It.Mv_S(m_iZ, m_dPosZ);
                        _SetLog("Z axis move position(slow).", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 30:
                    {//Z축 0.001mm 업 확인, 툴세터 감지 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ, GV.INPOS_GRD_CYCLE))
                        { return false; }

                        if (CIO.It.Get_X(m_iAddr, m_iBit) == 0)
                        {//툴세터 IO (OFF) 감지 됨 
                            m_iStep = 29;
                        }
                        else
                        {//툴세터 IO (ON) 감지 안됨
                            _SetLog("Toolsetter on.", m_dPosZ);
                            m_iStep++;
                        }
                        return false;
                    }

                case 31:
                    {//Z축 0.001mm 다운
                        m_dPosZ += 0.001;
                        if ((CData.MPos[m_iWy].dZ_WHL_BASE - CData.Whls[m_iWy].dWhlLimit) < m_dPosZ)
                        {//휠 감지 에러
                            if (m_eWy == EWay.L)
                            { CErr.Show(eErr.LEFT_GRIND_NOT_DETECTED_TOOLSENSOR); }
                            else
                            { CErr.Show(eErr.RIGHT_GRIND_NOT_DETECTED_TOOLSENSOR); }
                            _SetLog("Error : Not detect toolsetter.");
                            //20190909 ghk_grd_drs_err
                            m_bSubErr = true;
                            
                            m_iStep = 0;
                            return true;
                        }
                        //CMot.It.Mv_N(m_iZ, m_dPosZ);
                        CMot.It.Mv_S(m_iZ, m_dPosZ);
                        _SetLog("Z axis move position(slow).", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 32:
                    {//Z축 0.001mm 다운 확인, 툴세터 감지 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ, GV.INPOS_GRD_CYCLE))
                        { return false; }

                        if (CIO.It.Get_X(m_iAddr, m_iBit) == 1)
                        {//툴세터 IO (ON) 감지 안됨
                            m_iStep = 31;
                        }
                        else
                        {//툴세터 IO (OFF) 감지 됨
                            _SetLog("Toolsetter off.", m_dPosZ);
                            m_iStep++;
                        }
                        return false;
                    }

                case 33:
                    {//휠 측정값 저장, 반복 여부 확인, 반복 해야 할경우 Z축 3mm업, 종료시 종료위치로 이동

                        //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                        m_aWheelTipZPos[m_iWhlCnt] = Math.Round(m_dPosZ,6); //Z축 위치 저장
                        //

                        m_aTip[m_iWhlCnt] = Math.Round((CData.MPos[m_iWy].dZ_WHL_BASE - m_dPosZ), 6);
                        _SetLog("Wheel detect.  Count : " + m_iWhlCnt, m_dPosZ, true);

                        // 휠 측정 값 순서대로 저장
                        CData.WhlMea[m_iWy, m_iWhlCnt] = m_aTip[m_iWhlCnt];
                        //200406 ksg : 
                        //if(CData.Opt.bWhlOneCheck && (CSQ_Main.It.m_iStat == EStatus.Auto_Running))
                        if(CData.Opt.bWhlOneCheck && CSQ_Main.It.m_bRun)//200406 ksg :
                        {
                            CData.WhlMea[m_iWy, 1] = m_aTip[m_iWhlCnt];
                            CData.WhlMea[m_iWy, 2] = m_aTip[m_iWhlCnt];
                            m_aTip[1] = m_aTip[m_iWhlCnt];
                            m_aTip[2] = m_aTip[m_iWhlCnt];

                            //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                            m_aWheelTipZPos[1] = m_aWheelTipZPos[2] = m_aWheelTipZPos[m_iWhlCnt]; //1회 측정한 Z축 위치 복사
                            //

                            _SetLog("Wheel one measure.");
                            m_iStep = 36; 
                        }
                        else
                        { 
                            if (m_iWhlCnt == 2)
                            {//종료위치 이동
                                _SetLog("Loop end.");
                                m_iStep = 36;
                            }
                            else
                            {//Z축 3mm 업
                                m_dPosZ -= 3;
                                CMot.It.Mv_N(m_iZ, m_dPosZ);
                                _SetLog("Loop.  Z axis move position.", m_dPosZ);

                                m_iWhlCnt++;
                                m_iStep++;
                            }
                        }
                        return false;
                    }

                case 34:
                    {//Z축 3mm 업 확인, 휠 측정 위치 이동
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ, GV.INPOS_GRD_CYCLE))
                        { return false; }

                        /// <summary>
                        /// Wheel Tip & Toolsetter 3point 측정 : Spindle Drv position Setting 방식
                        /// m_iWhlCnt 값 = 1 또는 2 로 원점이후 휠 위치 변경
                        /// </summary>
                                                

                        bool bExit = false;
                        bool bTimeOutFlag = false;

                        // Wheel 회전 위치 값  Setting
                        int nWheelPnt = ((int)(4096 / 3)) * m_iWhlCnt; // 4096 = 1회전 Pluse Count, 3 = Wheel 측정 갯수
                        CSpl_485.It.Write_WheelChkPosition(m_eWy, nWheelPnt);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptWheelChkSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptWheelChkSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                            return false;
                        }


                        // Spindle RUN
                        bExit = false;
                        bTimeOutFlag = false;
                        CSpl_485.It.Write_Run(m_eWy);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRunSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRunSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            return false;
                        }

                        // Wheel Stop 정지 TimeOut Check
                        m_Timout_485.Set_Delay(300);

                        /// <summary>
                        /// Wheel Tip & Toolsetter 3point 측정 : Delay Time으로 동작 (하기 주석코드)
                        /// </summary>
                        /*
                        //CSpl.It.Write_Run(m_eWy, CData.Opt.iMeaS);
                        // 2023.03.15 Max
                        bool bExit = false;
                        bool bTimeOutFlag = false;

                        // RPM Setting
                        CSpl_485.It.Write_Rpm(m_eWy, CData.Opt.iMeaS);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRPMSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRPMSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                            return false;
                        }

                        // Spindle RUN
                        bExit = false;
                        bTimeOutFlag = false;
                        CSpl_485.It.Write_Run(m_eWy);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRunSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRunSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            return false;
                        }


                        // 딜레이 설정
                        m_mSpl.Set_Delay(CData.Opt.iMeaT);
                        _SetLog("Set delay : " + CData.Opt.iMeaT + "ms");
                        */

                        m_iStep++;
                        return false;

                    }

                case 35:
                    {// 스핀들 응답 대기

                        /// <summary>
                        /// Wheel Tip & Toolsetter 3point 측정 : 변경 코드
                        /// </summary>
                        /// 
                        int nSplLRpm = 0;
                        if (m_eWy == EWay.L)
                        {
                            nSplLRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.L));                            
                        }
                        else
                        {
                            nSplLRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.R));
                        }
                        
                        if (nSplLRpm != 0)
                        {
                            if (m_Timout_485.Chk_Delay())
                            {
                                if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                                if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                                m_Timout_485.Set_Delay(300);
                            }
                            return false;
                        }

                        m_iStep = 23;


                        /// <summary>
                        /// Wheel Tip & Toolsetter 3point 측정 : Delay Time으로 동작 (하기 주석코드)
                        /// </summary>
                        /*
                        if (m_mSpl.Chk_Delay())
                        {
                            // 스핀들 정지
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max - Spildle Stop Check
                            CSpl_485.It.Write_Stop(m_eWy);

                            bool bExit = false; 
                            m_mSpl_Chk.Set_Delay(300);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            _SetLog("Spindle stop.");

                            m_iStep = 23;

                            
                            //m_iStep = 355;
                            //m_mSpl_Chk.Set_Delay(300);
                            
                        }
                        */
                        return false;
                    }
                case 355: // 2023.03.15 Max - Spildle Stop Check - 추가전
                    {// 스핀들 응답 대기
                        if (m_mSpl_Chk.Chk_Delay())
                        {
                            _SetLog("Spindle stop.");

                            m_iStep = 23;
                        }
                        return false;
                    }

                case 36:
                    {// 반복 측정 종료 데이터 관리
                        // 201006 jym : TTV 체크 여부 조건 추가
                        if (bChkTTV && CData.Opt.aWhlTTV[m_iWy] != 0 && (m_aTip.Max() - m_aTip.Min()) > CData.Opt.aWhlTTV[m_iWy])
                        {
                            if (m_iWy == (int)EWay.L)
                            { CErr.Show(eErr.LEFT_GRIND_WHEEL_MEASURE_TTV_OVER); }
                            else
                            { CErr.Show(eErr.RIGHT_GRIND_WHEEL_MEASURE_TTV_OVER); }
                            _SetLog("Error : Wheel measure TTV over.");
                            //20190909 ghk_grd_drs_err
                            m_bSubErr = true;

                            m_iStep = 0;
                            return true;
                        }

                        // 휠 높이 갱신
                        CData.WhlBf[m_iWy] = CData.WhlAf[m_iWy];
                        CData.WhlAf[m_iWy] = m_aTip.Max();

                        //210727 pjh : Wheel 변화량 Limit
                        if (CDataOption.UseWheelDresserMaxLimit && CData.Opt.bVarLimitUse)
                        {
                            if ((Math.Abs(CData.WhlBf[m_iWy] - CData.WhlAf[m_iWy]) > CData.Opt.aWheelMax[m_iWy]) || (m_aTip.Max() > GV.WHEEL_DEF_TIP_T))
                            {
                                //210812 pjh : 휠 지그 감지 시 에러 발생안됨(휠 교체에 있어서 조건 안보기 위함)
                                if (CData.DrData[m_iWy].bWheelChange)
                                {
                                    CData.DrData[m_iWy].bWheelChange = false;
                                }
                                else
                                {
                                    CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_OVER_WHEEL_THICKNESS : eErr.RIGHT_GRIND_OVER_WHEEL_THICKNESS);
                                    _SetLog("Error : Wheel measure limit over error");//210830 pjh : Log 추가

                                    m_iStep = 0;
                                    return true;
                                }
                                //           
                            }
                        }
                        //

                        //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                        CData.WheelTipBeforeZPos[m_iWy] = CData.WheelTipAfterZPos[m_iWy]; //휠팁 이전 값 저장
                        CData.WheelTipAfterZPos[m_iWy] = m_aWheelTipZPos.Min(); //휠팁 최고 두께 위치 = Z축 가장 높은 위치 = Z축 최소값
                        _SetLog("Wheel Tip Z Aixs  Before:" + CData.WheelTipBeforeZPos[m_iWy].ToString() + "  After: " + CData.WheelTipAfterZPos[m_iWy].ToString());
                        //

                        CData.Whls[m_iWy].dWhlBf = CData.Whls[m_iWy].dWhlAf;
                        CData.Whls[m_iWy].dWhlAf = m_aTip.Max();
                        CData.Whls[m_iWy].dWhltH = m_aTip.Max();
                        if (CData.GemForm != null)
                        {// Measure Wheel After Data
                            //CData.GemForm.Measure_Wheel_Dress_Data_Set(m_iWy, 0, 1);// Left ,0-Wheel(1-Dress), 0-Before Data(1-Aftere)
                        }
                        if (CData.Whls[m_iWy].iGtc == 0 && CData.Whls[m_iWy].iDrsC == 0)
                        {
                            CData.Whls[m_iWy].dWhlFtH = CData.Whls[m_iWy].dWhltH;
                        }

                        //휠 히스토리
                        if (CSQ_Main.It.m_iStat == EStatus.Manual)
                        {
                            CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.MeasureWheel.ToString();
                        }

                        _SetLog(string.Format("Wheel tip thickness.  Bf : {0}mm  Af : {1}mm", CData.WhlBf[m_iWy], CData.WhlAf[m_iWy]), true);

                        m_iStep++;
                        return false;
                    }

                case 37:
                    {//Z축 Able 위치로 이동
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                        if (CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("Z axis move able.", CData.SPos.dGRD_Z_Able[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 38:
                    {//Z축 Able 위치로 응답 확인
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        _SetLog("Check Z axis move.");

                        m_iStep++;
                        return false;
                    }

                case 39:
                    {//작업 종료

                        // 2023.03.15 Max 회전후 I/O를 설정 Reset
                        // Spindle Drv I/O 단자 Mi7에 접점 OFF 시킴.
                        if (m_eWy == EWay.L) CIO.It.Set_Y(eY.GRL_WheelMeasureControlTerminal, false);
                        if (m_eWy == EWay.R) CIO.It.Set_Y(eY.GRR_WheelMeasureControlTerminal, false);

                        
                        CLast.Save();
                        CWhl.It.Save(m_eWy, CData.Whls[m_iWy]);
                        _SetLog("Finish.");

                        m_iStep = 0;
                        return true;
                    }

                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스
                case 100:
                    {//Z축 대기 위치 이동
                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        { m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy]; }
                        else
                        { m_dPosZ = CData.SPos.dGRD_Z_Wait[m_iWy]; }

                        CMot.It.Stop(m_iZ);

                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, m_dPosZ);
                        if (CMot.It.Mv_N(m_iZ, m_dPosZ) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("ERROR : Picker Vacuum : " + m_siZ + " UP : " + m_dPosZ.ToString());
                        
                        m_iStep++;
                        return false;
                    }

                case 101:
                    {//Z축 대기 위치 이동 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            //CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }

                        if (m_iPickerVacErr == 1)
                        { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else
                        { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        _SetLog("Picker Vacuum ERROR " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        m_bSubErr = true; ////////

                        m_iStep = 0;
                        return true;
                    }
                ///////////////////////////////////////////////////////////////////////////////////////
            }
        }

        /// <summary>
        /// Dresser Thickness Measure
        /// 드레셔 두께 측정 함수
        /// </summary>
        /// <returns></returns>
        public bool Cyl_MeaDrs()
        {
            double dVal = 0;
            bAuto = false;

            // Timeout check
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay() == true)
                {
                    m_bSubErr = true;

                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_WHEEL_INSPECTION_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_WHEEL_INSPECTION_TIMEOUT); }
                    _SetLog("Error : Timeout.");

                    m_iStep = 0;
                    return true;
                }
            }

            m_iPreStep = m_iStep;

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if ((CData.CurCompany == ECompany.ASE_KR) && 
                (m_iStep == 15 || m_iStep == 16))
            {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                if (0 != m_iPickerVacErr)
                {
                    CMot.It.EStop(m_iY); //Table Y축 즉시 Stop
                    _SetLog("Error : Picker Vacuum : " + m_siY + " STOP : " + CMot.It.Get_FP(m_iY).ToString());

                    m_iStep = 100; //정리 스텝으로
                    return false;
                }
            }

            //210823 pjh : Auto run 플래그 추가
            if(CSQ_Main.It.m_iStat == EStatus.Auto_Running)
            {
                bAuto = true;
            }
            ///////////////////////////////////////////////////////////////////////////////////////

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10:
                    {// 1. 축 상태 체크
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max 
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }

                        _SetLog("Check axes.");

                        m_tStMeaTime = DateTime.Now;    // 2020.10.29 SungTae : Add

                        m_iStep++; 
                        return false;
                    }

                case 11:
                    {// 2. IO 초기화
                        _InitCycle();

                        //20190909 ghk_grd_drs_err
                        m_bSubErr = false;

                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                        if (CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("Z axis move able.", CData.SPos.dGRD_Z_Able[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {// 프로브 업, 프로브 축 대기 위치 이동
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }
                        //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(true);
                        }
                        Func_PrbDown(false);
                        //210907 pjh : Probe Up Log 추가
                        _SetLog("Probe up.");
                        //

                        //211028 syc : Qorvo Probe Up Time Check
                        if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ)
                        {
                            sStopwatch.Restart(); //211028 syc : Qorvo Probe Up Time Check
                        }
                        // syc end

                        // 2020.10.13 SungTae Start : Modify
                        // 0 - Center, 1 - Left, 2 - Right, 3 - Top, 4 - Bottom
                        //CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                        //_SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        if ((CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ ||
                            CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC) &&
                            CSQ_Main.It.m_iStat == EStatus.Manual &&
                            CData.Opt.bDrsFiveCheck)
                        {
                            if(m_iDrsMeaCnt == (int)EMeaPoint.LEFT)
                            {
                                // 2021.04.06 SungTae Start
                                //CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy] - 30.0D);
                                if (CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy] - 30.0D) != 0)
                                {
                                    return false;
                                }
                                // 2021.04.06 SungTae End

                                _SetLog("X axis move left zero. (-30 mm)", CData.SPos.dGRD_X_Zero[m_iWy] - 30.0D);
                            }
                            else if(m_iDrsMeaCnt == (int)EMeaPoint.RIGHT)
                            {
                                // 2021.04.06 SungTae Start
                                //CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy] + 30.0D);
                                if (CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy] + 30.0D) != 0)
                                {
                                    return false;
                                }
                                // 2021.04.06 SungTae End
                                
                                _SetLog("X axis move right zero. (+30 mm)", CData.SPos.dGRD_X_Zero[m_iWy] + 30.0D);
                            }
                            else
                            {
                                // 2021.04.06 SungTae Start
                                //CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                                if (CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]) != 0)
                                {
                                    return false;
                                }
                                // 2021.04.06 SungTae End

                                _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);
                            }
                        }
                        else
                        {
                            // 2021.04.06 SungTae Start
                            //CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                            if (CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]) != 0)
                            {
                                return false;
                            }
                            // 2021.04.06 SungTae End

                            _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);
                        }

                        if (CData.GemForm != null)
                        {// Measure Dress After Data
                           // CData.GemForm.Measure_Wheel_Dress_Data_Set(m_iWy, 1, 0);// Left ,0-Wheel(1-Dress), 0-Before Data(1-Aftere)
                        }

                        m_iStep++;
                        return false;
                    }

                case 13:
                    {// 프로브 업 확인, 프로브 축 대기 위치 이동 확인

                        //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        //if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]) || !(CIO.It.Set_Y(m_eOt1, false)))
                        bool   bProbeUp  = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값

                        // 2020.10.13 SungTae Start : Modify
                        // 0 - Center, 1 - Left, 2 - Right, 3 - Top, 4 - Bottom
                        //if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]) || (!bProbeUp) || (dProbeVal < GV.dProbeUpHeight))
                        //{ return false; }
                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if((CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ) &&
                        if((CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ ||
                            CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC) &&
                            CSQ_Main.It.m_iStat == EStatus.Manual &&
                            CData.Opt.bDrsFiveCheck)
                        {
                            if (m_iDrsMeaCnt == (int)EMeaPoint.LEFT)
                            {
                                if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy] - 30.0D) || (!bProbeUp) || (dProbeVal < GV.dProbeUpHeight))
                                { return false; }
                            }
                            else if (m_iDrsMeaCnt == (int)EMeaPoint.RIGHT)
                            {
                                if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy] + 30.0D) || (!bProbeUp) || (dProbeVal < GV.dProbeUpHeight))
                                { return false; }
                            }
                            else
                            {
                                if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]) || (!bProbeUp) || (dProbeVal < GV.dProbeUpHeight))
                                { return false; }
                            }
                        }
                        else
                        {
                            if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]) || (!bProbeUp) || (dProbeVal < GV.dProbeUpHeight))
                            { return false; }
                        }
                        // 2020.10.13 SungTae End

                        //2021.08.06 syc : Up상태일때 Probe 값 정상 범위 인지 확인
                        //- Qorvo 프로브 앰프값 자동으로 바뀌는 이슈에 대한 방지책
                        //- Probe 값이 18.9xxx ~ 19.0xxx 범위 이탈시 알람
                        if (Chk_ProbeUpVal())
                        {
                            m_iStep = 0;
                            return true;
                        }

                        //211227 pjh : Ejector off
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(false);
                        }
                        //

                        _SetLog("Check probe up.");

                        //211028 syc : Qorvo Probe Up Time Check
                        if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ)
                        {
                            sStopwatch.Stop();
                            _SetLog("Probe Up Time : " + sStopwatch.ElapsedMilliseconds, true);
                        }
                        // syc end

                        m_iStep++;
                        return false;
                    }

                case 14:
                    {// 탑클리너 업
                        Func_TcDown(false);
                        _SetLog("Top cleaner up.");

                        m_iStep++;
                        return false;
                    }

                case 15:
                    {//탑클리너 업 체크, 테이블 축 측정 위치 이동
                        if (!Func_TcDown(false))
                        { return false; }

                        // 2020.10.13 SungTae Start : Modify
                        // 0 - Center, 1 - Left, 2 - Right, 3 - Top, 4 - Bottom
                        //CMot.It.Mv_N(m_iY, CData.MPos[m_iWy].dY_PRB_DRS);
                        //_SetLog("Y axis move dresser.", CData.MPos[m_iWy].dY_PRB_DRS);
                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if((CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ) &&
                        if((CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ ||
                            CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC) &&
                            CSQ_Main.It.m_iStat == EStatus.Manual &&
                            CData.Opt.bDrsFiveCheck)
                        {
                            if (m_iDrsMeaCnt == (int)EMeaPoint.TOP)
                            {
                                // 2021.04.06 SungTae Start
                                //CMot.It.Mv_N(m_iY, CData.MPos[m_iWy].dY_PRB_DRS - 30.0D);
                                if (CMot.It.Mv_N(m_iY, CData.MPos[m_iWy].dY_PRB_DRS - 30.0D) != 0)
                                {
                                    return false;
                                }
                                // 2021.04.06 SungTae End

                                _SetLog("Y axis move dresser top. (-30 mm)", CData.MPos[m_iWy].dY_PRB_DRS - 30.0D);
                            }
                            else if (m_iDrsMeaCnt == (int)EMeaPoint.BOTTOM)
                            {
                                // 2021.04.06 SungTae Start
                                //CMot.It.Mv_N(m_iY, CData.MPos[m_iWy].dY_PRB_DRS + 10.0D);
                                if (CMot.It.Mv_N(m_iY, CData.MPos[m_iWy].dY_PRB_DRS + 10.0D) != 0)
                                {
                                    return false;
                                }
                                // 2021.04.06 SungTae End

                                _SetLog("Y axis move dresser bottom. (+10 mm)", CData.MPos[m_iWy].dY_PRB_DRS + 10.0D);
                            }
                            else
                            {
                                // 2021.04.06 SungTae Start
                                //CMot.It.Mv_N(m_iY, CData.MPos[m_iWy].dY_PRB_DRS);
                                if (CMot.It.Mv_N(m_iY, CData.MPos[m_iWy].dY_PRB_DRS) != 0)
                                {
                                    return false;
                                }
                                // 2021.04.06 SungTae End

                                _SetLog("Y axis move dresser.", CData.MPos[m_iWy].dY_PRB_DRS);
                            }
                        }
                        else
                        {
                            // 2021.04.06 SungTae Start
                            //CMot.It.Mv_N(m_iY, CData.MPos[m_iWy].dY_PRB_DRS);
                            if (CMot.It.Mv_N(m_iY, CData.MPos[m_iWy].dY_PRB_DRS) != 0)
                            {
                                return false;
                            }
                            // 2021.04.06 SungTae End

                            _SetLog("Y axis move dresser.", CData.MPos[m_iWy].dY_PRB_DRS);
                        }
                        // 2020.10.13 SungTae End

                        m_iStep++;
                        return false;
                    }

                case 16:
                    {// 8. 테이블 축 측정 위치 이동 확인
                        // 2020.10.13 SungTae Start : Modify
                        // 0 - Center, 1 - Left, 2 - Right, 3 - Top, 4 - Bottom
                        //if (!CMot.It.Get_Mv(m_iY, CData.MPos[m_iWy].dY_PRB_DRS))
                        //{ return false; }
                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if((CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ) &&
                        if((CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ ||
                            CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC) &&
                            CSQ_Main.It.m_iStat == EStatus.Manual &&
                            CData.Opt.bDrsFiveCheck)
                        {
                            if (m_iDrsMeaCnt == (int)EMeaPoint.TOP)
                            {
                                if (!CMot.It.Get_Mv(m_iY, CData.MPos[m_iWy].dY_PRB_DRS - 30.0D)) { return false; }
                            }
                            else if (m_iDrsMeaCnt == (int)EMeaPoint.BOTTOM)
                            {
                                if (!CMot.It.Get_Mv(m_iY, CData.MPos[m_iWy].dY_PRB_DRS + 10.0D)) { return false; }
                            }
                            else
                            {
                                if (!CMot.It.Get_Mv(m_iY, CData.MPos[m_iWy].dY_PRB_DRS)) { return false; }
                            }
                        }
                        else
                        {
                            if (!CMot.It.Get_Mv(m_iY, CData.MPos[m_iWy].dY_PRB_DRS)) { return false; }
                        }
                        // 2020.10.13 SungTae End

                        _SetLog("Check Y axis move.");

                        m_iStep++;
                        return false;
                    }

                case 17:
                    {// 9. 프로브 다운 및 프로브 에어 온
                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_ProbeDn;
                            m_eOt2 = eY.GRDL_ProbeAir;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_ProbeDn;
                            m_eOt2 = eY.GRDR_ProbeAir;
                        }

                        m_tStTime = DateTime.Now;   // 2020.10.29 SungTae : Add(Dresser Measure 시 Point 당 측정 시간 확인용)

                        Func_PrbDown(true);
                        Func_PrbAir(true);
                        _SetLog("Probe down.  Probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 18:
                    {// 10. 프로브 다운 체크, 프로브 에어 온 체크
                        if (!(CIO.It.Set_Y(m_eOt1, true)) && !(CIO.It.Set_Y(m_eOt2, true)))
                        { return false; }
                        _SetLog("Check probe down.");

                        m_iStep++;
                        return false;
                    }

                case 19:
                    {// 11. Z축 측정 시작위치 이동 (드레셔 베이스 - 7.5mm) 
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, CData.MPos[m_iWy].dZ_DRS_MEA_POS);
                        if (CMot.It.Mv_N(m_iZ, CData.MPos[m_iWy].dZ_DRS_MEA_POS) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("Z axis move dresser measure.", CData.MPos[m_iWy].dZ_DRS_MEA_POS);

                        m_iStep++;
                        return false;
                    }

                case 20:
                    {// 12. Z축 이동 응답 확인
                        if (!CMot.It.Get_Mv(m_iZ, CData.MPos[m_iWy].dZ_DRS_MEA_POS))
                        { return false; }

                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        _SetLog("Set delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 21:
                    {// 13. 프로브 값 획득
                        if (!m_tmPrb.Chk_Delay()) 
                        { return false; }

                        dVal = CPrb.It.Read_Val(m_eWy);

                        if ((dVal != 0) && (dVal != 19.0))
                        {
                            //210727 pjh : Dresser 변화량 Limit
                            if (CDataOption.UseWheelDresserMaxLimit && CData.Opt.bVarLimitUse)
                            {
                                //if ((Math.Abs(CData.DrsAf[m_iWy] - dVal) > CData.Opt.aDresserMax[m_iWy]) || (dVal > GV.EQP_DRESSER_BLOCK_HEIGHT))
                                if ((Math.Abs(CData.DrsAf[m_iWy] - dVal) > CData.Opt.aDresserMax[m_iWy]))//210823 pjh : 디폴트 두께 조건 제외
                                {
                                    if(bAuto)
                                    {//210823 pjh : Auto run 중 조건 벗어나면 즉시 에러 발생
                                        CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_OVER_DRESSER_THICKNESS : eErr.RIGHT_GRIND_OVER_DRESSER_THICKNESS);

                                        bAuto = false;
                                        m_iStep = 0;
                                        return true;
                                    }
                                    else
                                    {//210812 pjh : Dresser 변화량이 너무 많으면 Dresser를 교체한건지 확인 메세지 발생
                                        if (CMsg.Show(eMsg.Warning, "Warning", "Did you change Dresser?") == DialogResult.Cancel)
                                        {
                                            CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_OVER_DRESSER_THICKNESS : eErr.RIGHT_GRIND_OVER_DRESSER_THICKNESS);

                                            m_iStep = 0;
                                            return true;
                                        }
                                    }								    
									//
                                }
                            }
                            //

                            // 2020.10.26 SungTae Start : Modify
                            CData.DrsBf[m_iWy] = CData.DrsAf[m_iWy];
                            CData.DrsAf[m_iWy] = dVal;

                            CData.Whls[m_iWy].dDrsBf = CData.Whls[m_iWy].dDrsAf;
                            CData.Whls[m_iWy].dDrsAf = dVal;
                            CData.Whls[m_iWy].dDrsH = dVal;
                            
                            m_dOldMeaValue = CData.DrsBf[m_iWy];

                            _SetLog(string.Format("Point-{0} Dresser thickness.  Bf : {1}mm  Af : {2}mm", m_iDrsMeaCnt + 1, CData.DrsBf[m_iWy], CData.DrsAf[m_iWy]), true);

                            // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                            //if((CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ) &&
                            if((CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ ||
                                CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC) &&
                                CSQ_Main.It.m_iStat == EStatus.Manual &&
                                CData.Opt.bDrsFiveCheck)
                            {
                                m_dMaxMeaValue = Math.Max(m_dOldMeaValue, dVal);
                                m_dMinMeaValue = Math.Min(m_dOldMeaValue, dVal);
                            }
                            // 2020.10.26 SungTae End

                            if (CData.GemForm != null)
                            {// Measure Dress After Data
                                //CData.GemForm.Measure_Wheel_Dress_Data_Set(m_iWy, 1, 1);// Left ,0-Wheel(1-Dress), 0-Before Data(1-Aftere)
                            }

                            m_iStep++;
                        }

                        return false;
                    }

                case 22:
                    {// 프로브 업
                        if (m_eWy == EWay.L)    // 왼쪽
                        {
                            m_eOt1 = eY.GRDL_ProbeDn;
                            m_eIn2 = eX.GRDL_ProbeAMP;
                        }
                        else    // 오른쪽
                        {
                            m_eOt1 = eY.GRDR_ProbeDn;
                            m_eIn2 = eX.GRDR_ProbeAMP;
                        }

                        CIO.It.Set_Y(m_eOt1, false);
                        //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(true);
                        }
                        Func_PrbDown(false);
                        _SetLog("Probe up.");

                        //211028 syc : Qorvo Probe Up Time Check
                        if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ)
                        {
                            sStopwatch.Restart(); //211028 syc : Qorvo Probe Up Time Check
                        }
                        // syc end

                        m_iStep++;
                        return false;
                    }

                case 23:
                    {// 프로브 업 체크
                        //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                        dtmp = CPrb.It.Read_Val(m_eWy);
                        if (CIO.It.Get_X(m_eIn2) && (dtmp >= GV.dProbeUpHeight))
                        {
                            //211227 pjh : Ejector off
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(false);
                            }
                            //

                            // 2020.10.29 SungTae Start : Add
                            m_tTackTime = DateTime.Now - m_tStTime;
                            //_SetLog("[Point-{0}]" + (m_iDrsMeaCnt + 1) + " Measure Tact Time : " + m_tTackTime.ToString(@"ss") + " sec");
                            _SetLog($"[Point-{(m_iDrsMeaCnt + 1)}]  Measure Tact Time : {m_tTackTime:ss} sec");     // 2022.04.19 SungTae : [수정] Log 수정
                            // 2020.10.29 SungTae End

                            //210907 pjh : Probe Up Log 추가
                            _SetLog("Probe Height: " + (Math.Round(CPrb.It.Read_Val(m_eWy), 4)).ToString());
                            //
                            _SetLog("Check probe up.");

                            //211028 syc : Qorvo Probe Up Time Check
                            if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ)
                            {
                                sStopwatch.Stop();
                                _SetLog("Probe Up Time : " + sStopwatch.ElapsedMilliseconds, true);
                            }
                            // syc end

                            m_iStep++; 
                        }

                        return false;
                    }

                case 24:
                    {// Z축 Able 포지션 이동
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                        if (CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("Z axis move able.", CData.SPos.dGRD_Z_Able[m_iWy]);
                        
                        m_iStep++;
                        return false;
                    }

                case 25:
                    {// Z축 Able 포지션 체크
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        _SetLog("Check Z axis move.");

                        m_iStep++;
                        return false;
                    }

                case 26:
                    {// 프로브 대기 포지션 이동
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Wait[m_iWy]);
                        if (CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Wait[m_iWy]) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("X axis move wait.", CData.SPos.dGRD_X_Wait[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 27:
                    {// 프로브 대기 포지션 체크
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Wait[m_iWy]))
                        { return false; }

                        _SetLog("Check X axis move.");

                        // 2020.10.13 SungTae Start : Dresser 5-Point Check
                        // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                        //if((CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ) &&
                        if((CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ ||
                            CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC) &&
                            CSQ_Main.It.m_iStat == EStatus.Manual &&
                            CData.Opt.bDrsFiveCheck)
                        {
                            if (m_iDrsMeaCnt + 1 != (int)EDrsMea.MeaPoint5)
                            {
                                m_iDrsMeaCnt++;
                                m_iStep = 12;

                                return false;
                            }
                            else
                            {
                                _SetLog("\n[5-Point Measure Result]", true);
                                _SetLog(string.Format("Max : {0} mm, Min : {1} mm, Tilt(Max - Min) : {2} mm \n", m_dMaxMeaValue, m_dMinMeaValue, m_dMaxMeaValue - m_dMinMeaValue), true);
                            }
                        }
                        // 2020.10.13 SungTae End

                        m_iStep++;
                        return false;
                    }

                case 28:
                    {// 작업 종료
                        // 2020.10.26 SungTae Start : Alarm 조건 추가
                        if(m_dMaxMeaValue - m_dMinMeaValue > 0.1)
                        {
                            if (m_eWy == EWay.L)    { CErr.Show(eErr.RETRY_LEFT_DRESSER_CHANGE); }
                            else                    { CErr.Show(eErr.RETRY_RIGHT_DRESSER_CHANGE); }

                            _SetLog("Error : Retry dresser change.");

                            m_iStep = 0;
                            return false;
                        }
                        else
                        {
                            m_dOldMeaValue = 0.0D;
                            m_dMaxMeaValue = 0.0D;      
                            m_dMinMeaValue = 0.0D;
                        }
                        // 2020.10.26 SungTae End

                        CLast.Save();
                        CWhl.It.Save(m_eWy, CData.Whls[m_iWy]);
						//220106 pjh : Dresser History 저장
                        if(CDataOption.UseSeperateDresser)
                        {
                            if(CSQ_Main.It.m_iStat == EStatus.Manual) CData.DrsLog[m_iWy].sMeaType = eDrsMeasureType.MeasureDrs.ToString();
                            CData.Drs[m_iWy].dDrsH = CData.DrsLog[m_iWy].dDrsH = CData.Whls[m_iWy].dDrsAf;
                            CData.DrsLog[m_iWy].dDrsL = CData.Whls[m_iWy].dDrsAf - CData.Whls[m_iWy].dDrsBf;

                            CWhl.It.SaveDrs(m_eWy, CData.Drs[m_iWy]);
                        }
                        

                        // 2020.10.29 SungTae Start : Add
                        m_tMeaTackTime = DateTime.Now - m_tStMeaTime;
                        //_SetLog("[GR{0}]" + EWay.L.ToString() + "Dresser Measure Tact Time - " + m_tMeaTackTime.ToString(@"hh\:mm\:ss"));
                        _SetLog($"[GR{m_eWy}] Dresser Measure Tact Time - " + m_tMeaTackTime.ToString(@"hh\:mm\:ss"));
                        // 2020.10.29 SungTae End

                        _SetLog("Finish.  Wheel file save.");

                        m_iStep = 0;
                        return true;
                    }

                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스
                case 100:
                    {//Z축 대기 위치 이동
                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        { m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy]; }
                        else
                        { m_dPosZ = CData.SPos.dGRD_Z_Wait[m_iWy]; }

                        CMot.It.Stop(m_iZ);

                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, m_dPosZ);
                        if (CMot.It.Mv_N(m_iZ, m_dPosZ) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("Error : Picker Vacuum : " + m_siZ + " UP : " + m_dPosZ.ToString());
                        
                        m_iStep++;
                        return false;
                    }

                case 101:
                    {//Z축 대기 위치 이동 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }

                        if (m_iPickerVacErr == 1)
                        { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else
                        { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        _SetLog("Picker Vacuum ERROR " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        m_bSubErr = true; ////////

                        m_iStep = 0;
                        return true;
                    }
                ///////////////////////////////////////////////////////////////////////////////////////
            }
        }

        /// <summary>
        /// Table Thickness Measure
        /// 테이블 두께 측정 함수
        /// true : Only ASE-KR(4-Point Measure : Top + Bottom + Left + Right) , false : Etc. Site(2-Point Measure : Top + Bottom)
        /// </summary>
        /// <returns></returns>
        //public bool Cyl_MeaTbl()
        public bool Cyl_MeaTbl(int nBfAf = 0, bool bUseLRMeas = false)
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            {
                m_mTimeout.Set_Delay(TIMEOUT);
            }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (m_eWy == EWay.L)    { CErr.Show(eErr.LEFT_GRIND_TABLE_INSPECTION_TIMEOUT); }
                    else                    { CErr.Show(eErr.RIGHT_GRIND_TABLE_INSPECTION_TIMEOUT); }

                    _SetLog("Error : Timeout.");

                    m_iCnt = 0;
                    m_iStep = 0;

                    return true;
                }
            }

            m_iPreStep = m_iStep;

            switch (m_iStep)
            {
                default:
                    {
                        m_iCnt = 0;
                        m_iStep = 0;
                        return true;
                    }

                case 10:
                    {// 축 상태 체크 및 테이블 저장 배열 초기화(999)
                        if (CData.TblMea == EMeaStep.Before)
                        {
                            CData.Tbl_Bf[m_iWy, 0] = 999;
                            CData.Tbl_Bf[m_iWy, 1] = 999;

                            // 2021.09.23 SungTae Start : [추가]
                            if (bUseLRMeas && CData.CurCompany == ECompany.ASE_KR) // 211022 syc : ase kr 일때만
                            {
                                CData.Tbl_Bf[m_iWy, 2] = 999;
                                CData.Tbl_Bf[m_iWy, 3] = 999;
                            }
                            // 2021.09.23 SungTae End
                        }
                        else
                        {
                            CData.Tbl_Af[m_iWy, 0] = 999;
                            CData.Tbl_Af[m_iWy, 1] = 999;

                            // 2021.09.23 SungTae Start : [추가]
                            if (bUseLRMeas && CData.CurCompany == ECompany.ASE_KR) //211022 syc : ase kr 일때만
                            {
                                CData.Tbl_Af[m_iWy, 2] = 999;
                                CData.Tbl_Af[m_iWy, 3] = 999;
                            }
                            // 2021.09.23 SungTae End
                        }

                        m_iCnt = 0;

                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }
                        _SetLog("Check axes.");

                        m_iStep++;
                        return false;
                    }

                case 11:
                    {// IO 초기화
                        _InitCycle();
                        _SetLog("Inti cycle.");

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {// 테이블 안전상태 체크
                        SafeTbl(true, true, false);
                        _SetLog("Check saft table.");

                        m_iStep++;
                        return false;
                    }

                case 13:
                    {// Z축 ABLE 위치 이동
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                        if (CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("Z axis move able.", CData.SPos.dGRD_Z_Able[m_iWy]);

                        m_iStep++;
                        return false;
                    }
                case 14:
                    {//프로브 업
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_ProbeDn;
                            m_eOt2 = eY.GRDL_ProbeAir;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_ProbeDn;
                            m_eOt2 = eY.GRDR_ProbeAir;
                        }

                        //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(true);
                        }
                        Func_PrbDown(false);
                        _SetLog("Probe up.");

                        m_iStep++;
                        return false;
                    }

                case 15:
                    {//프로브 업 확인 후 프로브 X축 0으로 이동, Z축 측정 위치 계산
                        //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        bool   bProbeUp  = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값

                        if (bProbeUp && (dProbeVal >= GV.dProbeUpHeight))
                        {
                            //2021.08.06 syc : Up상태일때 Probe 값 정상 범위 인지 확인
                            //- Qorvo 프로브 앰프값 자동으로 바뀌는 이슈에 대한 방지책
                            //- Probe 값이 18.9xxx ~ 19.0xxx 범위 이탈시 알람
                            if (Chk_ProbeUpVal())
                            {
                                m_iStep = 0;
                                return true;
                            }

                            //211227 pjh : Ejector off
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(false);
                            }
                            //

                            // 2021.09.23 SungTae Start : [수정]
                            if (m_eWy == EWay.L)
                            {
                                //if (CData.Opt.LeftXPos != 0)
                                //    m_dPosX = CData.Opt.LeftXPos;
                                //else
                                //    m_dPosX = CData.SPos.dGRD_X_Zero[m_iWy];

                                if (bUseLRMeas && CData.CurCompany == ECompany.ASE_KR)         // ASE-KR인 경우
                                {
                                    if (m_iCnt == 2)        { m_dPosX = CData.Opt.LeftXPos; }                           // X-Axis Left Measure
                                    else if (m_iCnt == 3)   { m_dPosX = CData.Axes[(int)EAx.LeftGrindZone_X].dSWMax; }  // X-Axis Right Measure
                                    else                    { m_dPosX = CData.SPos.dGRD_X_Zero[m_iWy]; }                // X-Axis Top & Bottom Measure
                                }
                                else                    // 그 외 나머지 Site의 경우
                                {
                                    if (CData.Opt.LeftXPos != 0)
                                        m_dPosX = CData.Opt.LeftXPos;
                                    else
                                        m_dPosX = CData.SPos.dGRD_X_Zero[m_iWy];
                                }
                            }
                            else
                            {
                                if (bUseLRMeas && CData.CurCompany == ECompany.ASE_KR)         // ASE-KR인 경우
                                {
                                    if (m_iCnt == 2)        { m_dPosX = CData.Opt.RightXPos; }                          // X-Axis Left Measure
                                    else if (m_iCnt == 3)   { m_dPosX = CData.Axes[(int)EAx.RightGrindZone_X].dSWMin; } // X-Axis Right Measure
                                    else                    { m_dPosX = CData.SPos.dGRD_X_Zero[m_iWy]; }                // X-Axis Top & Bottpm Measure
                                }
                                else                    // 그 외 나머지 Site의 경우
                                {
                                    //if (CData.Opt.LeftXPos != 0)
                                    if (CData.Opt.RightXPos != 0)       // 2021.09.23 SungTae : [수정] 오타 수정 (LeftXPos -> RightXPos)
                                        m_dPosX = CData.Opt.RightXPos;
                                    else
                                        m_dPosX = CData.SPos.dGRD_X_Zero[m_iWy];
                                }
                            }
                            // 2021.09.23 SungTae End

                            // 2021.04.06 SungTae Start
                            //CMot.It.Mv_N(m_iX, m_dPosX);
                            if (CMot.It.Mv_N(m_iX, m_dPosX) != 0)
                            {
                                return false;
                            }
                            // 2021.04.06 SungTae End

                            _SetLog("X axis move position.", m_dPosX);

                            m_iStep++;
                        }

                        return false;
                    }

                case 16:
                    {//프로브 X축 0으로 이동 확인 후 테이블 측정 위치로 이동 == 반복 시작 점 ==
                        if (!CMot.It.Get_Mv(m_iX, m_dPosX)) { return false; }

                        // 2021.09.23 SungTae Start : [수정]
                        if (bUseLRMeas && CData.CurCompany == ECompany.ASE_KR)
                        {
                            if (m_iCnt == 0)        // Y-Axis 상단 측정 위치
                            {
                                m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                            }
                            else if (m_iCnt == 1)    // Y-Axis 하단 측정 위치
                            {
                                m_dPosY += Math.Abs((m_dPosY - CData.MPos[m_iWy].dY_PRB_TBL_CENTER)) * 2;
                            }
                            else                    // Y-Axis 좌측 & 우측 측정 위치
                            {
                                m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy] + Math.Abs((CData.SPos.dGRD_Y_TblInsp[m_iWy] - CData.MPos[m_iWy].dY_PRB_TBL_CENTER));
                            }
                        }
                        else
                        {
                            if (m_iCnt == 0)
                            {// 상단 측정 위치
                                if (m_eWy == EWay.L)
                                {
                                    if (CData.Opt.LeftTopPos != 0)
                                        m_dPosY = CData.Opt.LeftTopPos;
                                    else
                                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                }
                                else
                                {
                                    if (CData.Opt.RightTopPos != 0)
                                        m_dPosY = CData.Opt.RightTopPos;
                                    else
                                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                                }
                            }
                            else    // 하단 측정 위치
                            {
                                if (m_eWy == EWay.L)
                                {
                                    if (CData.Opt.LeftBtmPos != 0)
                                        m_dPosY = CData.Opt.LeftBtmPos;
                                    else
                                        m_dPosY += Math.Abs((m_dPosY - CData.MPos[m_iWy].dY_PRB_TBL_CENTER)) * 2;
                                }
                                else
                                {
                                    if (CData.Opt.RightBtmPos != 0)
                                        m_dPosY = CData.Opt.RightBtmPos;
                                    else
                                        m_dPosY += Math.Abs((m_dPosY - CData.MPos[m_iWy].dY_PRB_TBL_CENTER)) * 2;
                                }
                            }
                        }
                        // 2021.09.23 SungTae End

                        CMot.It.Mv_N(m_iY, m_dPosY);

                        _SetLog("Y axis move position.", m_dPosY);

                        m_iStep++;
                        return false;
                    }

                case 17:
                    {//테이블 측정 위치로 이동 확인 후 프로브 다운, 프로브 에어 온
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        {
                            CMot.It.Mv_N(m_iY, m_dPosY);
                            return false;
                        }

                        Func_PrbDown(true);
                        Func_PrbAir(true);

                        _SetLog("Probe down.  Probe air on.");

                        m_iStep++;
                        return false;
                    }

                case 18:
                    {//프로브 다운, 프로브 에어 온 확인, Z축 측정 위치로 이동
                        if (CIO.It.Get_Y(m_eOt1) && CIO.It.Get_Y(m_eOt2))
                        {
                            m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS;
                            
                            // 2021.04.06 SungTae Start
                            //CMot.It.Mv_N(m_iZ, m_dPosZ);
                            if (CMot.It.Mv_N(m_iZ, m_dPosZ) != 0)
                            {
                                return false;
                            }
                            // 2021.04.06 SungTae End

                            _SetLog("Z axis move position.", m_dPosZ);

                            m_iStep++;
                        }

                        return false;
                    }

                case 19:
                    {//Z축 측정 위치 이동 확인, 프로브 에어 오프
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        Func_PrbAir(false);
                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 20:
                    {//프로브 에어 오프 확인, 테이블 높이 측정
                        if (!m_tmPrb.Chk_Delay())
                        { return false; }

                        if (!CIO.It.Get_Y(m_eOt2))
                        {
                            //200406 jym : Before/After  구분
                            double dVal = CPrb.It.Read_Val(m_eWy) + GV.EQP_TABLE_MIN_THICKNESS;

                            if (CData.TblMea == EMeaStep.Before)
                            {
                                CData.Tbl_Bf[m_iWy, m_iCnt] = dVal;

                                // 2021.04.05 SungTae Start : Table Grinding 허용 가능 잔여량 표시 위해 추가(ASE-KR)
                                if (CData.CurCompany == ECompany.ASE_KR && m_iCnt < 2)
                                {
                                    if (m_eWy == EWay.L)
                                        CData.Opt.aLTblMeasPos[m_iCnt] = dVal;
                                    else
                                        CData.Opt.aRTblMeasPos[m_iCnt] = dVal;
                                }
                                // 2021.04.05 SungTae End
                                if (CDataOption.Use2004U)
                                {
                                    if (m_eWy == EWay.L)
                                        CData.Opt.aLTblMeasPos[m_iCnt] = dVal;
                                    else
                                        CData.Opt.aRTblMeasPos[m_iCnt] = dVal;
                                }
                            }
                            else
                            {
                                CData.Tbl_Af[m_iWy, m_iCnt] = dVal;
                            }

                            // 2021.09.17 SungTae Start : [수정]
                            //_SetLog("Table thickness : " + dVal + "mm");
                            string sPoint = "";
                            if (m_iCnt == 0) sPoint = "TOP";
                            if (m_iCnt == 1) sPoint = "BOTTOM";
                            if (m_iCnt == 2) sPoint = "LEFT";
                            if (m_iCnt == 3) sPoint = "RIGHT";

                            _SetLog(string.Format("Table : {0}, Meas. Point : {1}, Table Thickness : {2}mm, Count = {3}", (m_eWy == EWay.L) ? "Left" : "Right", sPoint, dVal, m_iCnt + 1));
                            // 2021.09.17 SungTae End

                            m_iStep++;
                        }

                        return false;
                    }

                case 21:
                    {//테이블 높이 값 확인(999 인지 아닌지 확인), Z축 Able 포지션 이동
                        //200406 jym : Before/After  구분
                        double dVal = 999;

                        if (CData.TblMea == EMeaStep.Before)    { dVal = CData.Tbl_Bf[m_iWy, m_iCnt]; }
                        else                                    { dVal = CData.Tbl_Af[m_iWy, m_iCnt]; }

                        if (dVal == 999)
                        {
                            if (m_eWy == EWay.L)    { CErr.Show(eErr.LEFT_INSPECTION_TABLE_FAIL); }
                            else                    { CErr.Show(eErr.RIGHT_INSPECTION_TABLE_FAIL); }

                            m_iCnt = 0;

                            _SetLog("Error : Table thickness measure fail.");

                            m_iStep = 0;
                            return true;
                        }
                        else
                        {
                            // 2021.11.17 SungTae Start : [추가] Manual Jig 감지 시 Alarm 발생되도록 Interlock 추가
                            if (CData.TblMea == EMeaStep.Before &&
                                CData.Tbl_Bf[m_iWy, 0] > (GV.EQP_TABLE_MIN_THICKNESS + 4))
                            {
                                CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_MANUALZIG_ON_THE_TABLE :
                                                                   eErr.RIGHT_GRIND_MANUALZIG_ON_THE_TABLE);
                                    
                                _SetLog("Error : Manual zig on table. Table : " + CData.Tbl_Bf[m_iWy, 0] + " mm");

                                CData.bAutoTblMeas = false;

                                m_iCnt = 0;
                                _SetLog("Table Measure Finish.");

                                m_iStep = 0;
                                m_iGStep = 0;

                                return true;
                            }
                            // 2021.11.17 SungTae End

                            // 2021.04.06 SungTae Start
                            //CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                            if (CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]) != 0)
                            {
                                return false;
                            }
                            // 2021.04.06 SungTae End

                            _SetLog("Z axis move abla.", CData.SPos.dGRD_Z_Able[m_iWy]);

                            m_iStep++;
                        }

                        return false;
                    }

                case 22:
                    {//Z축 Able 포지션 이동 확인    == 반복 종료 여부 확인 ==
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        // 2021.09.23 SungTae Start : [수정]
                        if (bUseLRMeas && CData.CurCompany == ECompany.ASE_KR)
                        {
                            if (m_iCnt >= 3)
                            {
                                _SetLog("Loop end.  Count : " + m_iCnt);

                                m_iStep++;
                            }
                            else
                            {
                                m_iCnt++;
                                _SetLog("Loop.  Count : " + m_iCnt);

                                m_iStep = 14;
                            }
                        }
                        else
                        {
                            if (m_iCnt >= 1)
                            {
                                _SetLog("Loop end.  Count : " + m_iCnt);

                                m_iStep++;
                            }
                            else
                            {
                                m_iCnt++;
                                _SetLog("Loop.  Count : " + m_iCnt);

                                m_iStep = 16;
                            }
                        }
                        // 2021.09.23 SungTae End

                        return false;
                    }

                case 23:
                    {//프로브 업
                     //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(true);
                        }
                        Func_PrbDown(false);
                        _SetLog("Probe up.");

                        m_iStep++;
                        return false;
                    }

                case 24:
                    {//측정 종료, 프로브 업 확인
                        //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        bool   bProbeUp  = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값
                        
                        if (!bProbeUp || (dProbeVal < GV.dProbeUpHeight))
                        {
                            return false;
                        }
                        //211227 pjh : Ejector off
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(false);
                        }
                        //

                        // 2021.09.24 SungTae Start : [추가]
                        if (CData.CurCompany == ECompany.ASE_KR)
                        {
                            double dTtoBOver = 0.0;
                            double dLtoROver = 0.0;

                            // 2021.10.08 SungTae Start : [추가] 5um로 Fix 해서 사용하는 것에서 Limit을 설정해서 사용할 수 있도록 변경 요청(ASE-KR VOC)
                            if (m_eWy == EWay.L)
                            {
                                if (nBfAf == (int)EMeaStep.Before)  // Before Measure
                                {
                                    dTtoBOver = Math.Abs(CData.Tbl_Bf[(int)EWay.L, 0] - CData.Tbl_Bf[(int)EWay.L, 1]);
                                    dLtoROver = Math.Abs(CData.Tbl_Bf[(int)EWay.L, 2] - CData.Tbl_Bf[(int)EWay.L, 3]);

                                    //if (dTtoBOver > CData.Opt.LeftLimitTtoB/*0.005*/)      // ASE-KR 담당자 요청으로 5um로 Fix
                                    //{
                                    //    CErr.Show(eErr.LEFT_TBL_TOP_TO_BTM_TILT_OVER_ERROR);
                                    //    _SetLog("Error : Left Table Top to Btm Tilt Over Error. (Before)");
                                    //}

                                    //if (dLtoROver > CData.Opt.LeftLimitLtoR/*0.005*/)      // ASE-KR 담당자 요청으로 5um로 Fix
                                    //{
                                    //    CErr.Show(eErr.LEFT_TBL_LFT_TO_RGT_TILT_OVER_ERROR);
                                    //    _SetLog("Error : Left Table Left to Right Tilt Over Error. (Before)");
                                    //}
                                }
                                else        // After Measure
                                {
                                    dTtoBOver = Math.Abs(CData.Tbl_Af[(int)EWay.L, 0] - CData.Tbl_Af[(int)EWay.L, 1]);
                                    dLtoROver = Math.Abs(CData.Tbl_Af[(int)EWay.L, 2] - CData.Tbl_Af[(int)EWay.L, 3]);

                                    if (dTtoBOver > CData.Opt.LeftLimitTtoB/*0.005*/)      // ASE-KR 담당자 요청으로 5um로 Fix
                                    {
                                        CErr.Show(eErr.LEFT_TBL_TOP_TO_BTM_TILT_OVER_ERROR);
                                        _SetLog("Error : Left Table Top to Btm Tilt Over Error. (After)");
                                    }

                                    if (dLtoROver > CData.Opt.LeftLimitLtoR/*0.005*/)      // ASE-KR 담당자 요청으로 5um로 Fix
                                    {
                                        CErr.Show(eErr.LEFT_TBL_LFT_TO_RGT_TILT_OVER_ERROR);
                                        _SetLog("Error : Left Table Left to Right Tilt Over Error. (After)");
                                    }
                                }

                                CData.dTblMeasDiff[(int)EWay.L, nBfAf, 0] = dTtoBOver;
                                CData.dTblMeasDiff[(int)EWay.L, nBfAf, 1] = dLtoROver;
                            }
                            else
                            {
                                if (nBfAf == (int)EMeaStep.Before)  // Before Measure
                                {
                                    dTtoBOver = Math.Abs(CData.Tbl_Bf[(int)EWay.R, 0] - CData.Tbl_Bf[(int)EWay.R, 1]);
                                    dLtoROver = Math.Abs(CData.Tbl_Bf[(int)EWay.R, 2] - CData.Tbl_Bf[(int)EWay.R, 3]);

                                    //if (dTtoBOver > CData.Opt.RightLimitTtoB/*0.005*/)      // ASE-KR 담당자 요청으로 5um로 Fix
                                    //{
                                    //    CErr.Show(eErr.RIGHT_TBL_TOP_TO_BTM_TILT_OVER_ERROR);
                                    //    _SetLog("Error : Right Table Top to Btm Tilt Over Error. (Before)");
                                    //}

                                    //if (dLtoROver > CData.Opt.RightLimitLtoR/*0.005*/)      // ASE-KR 담당자 요청으로 5um로 Fix
                                    //{
                                    //    CErr.Show(eErr.RIGHT_TBL_LFT_TO_RGT_TILT_OVER_ERROR);
                                    //    _SetLog("Error : Right Table Left to Right Tilt Over Error. (Before)");
                                    //}
                                }
                                else
                                {
                                    dTtoBOver = Math.Abs(CData.Tbl_Af[(int)EWay.R, 0] - CData.Tbl_Af[(int)EWay.R, 1]);
                                    dLtoROver = Math.Abs(CData.Tbl_Af[(int)EWay.R, 2] - CData.Tbl_Af[(int)EWay.R, 3]);

                                    if (dTtoBOver > CData.Opt.RightLimitTtoB/*0.005*/)      // ASE-KR 담당자 요청으로 5um로 Fix
                                    {
                                        CErr.Show(eErr.RIGHT_TBL_TOP_TO_BTM_TILT_OVER_ERROR);
                                        _SetLog("Error : Right Table Top to Btm Tilt Over Error. (After)");
                                    }

                                    if (dLtoROver > CData.Opt.RightLimitLtoR/*0.005*/)      // ASE-KR 담당자 요청으로 5um로 Fix
                                    {
                                        CErr.Show(eErr.RIGHT_TBL_LFT_TO_RGT_TILT_OVER_ERROR);
                                        _SetLog("Error : Right Table Left to Right Tilt Over Error. (After)");
                                    }
                                }

                                CData.dTblMeasDiff[(int)EWay.R, nBfAf, 0] = dTtoBOver;
                                CData.dTblMeasDiff[(int)EWay.R, nBfAf, 1] = dLtoROver;
                            }
                            // 2021.10.08 SungTae End
                        }
                        // 2021.09.24 SungTae End

                        // 2021.09.28 SungTae : [추가] 매 LOT의 첫번째 Strip일 경우 Auto로 Table Measuring 하기 위한 Flag OFF
                        CData.bAutoTblMeas = false;

                        m_iCnt = 0;
                        _SetLog("Finish.");


                        m_iStep = 0;
                        return true;
                    }
            }
        }

        /// <summary>
        /// Table Thickness Measure
        /// 테이블 두께 측정 함수(Six Point)
        /// </summary>
        /// <returns></returns>
        public bool Cyl_MeaTblSixPoint()
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay() == true)
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_TABLE_INSPECTION_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_TABLE_INSPECTION_TIMEOUT); }

                    m_iCnt = 0;
                    m_iStep = 0;

                    return true;
                }
            }

            m_iPreStep = m_iStep;

            if (m_eWy == EWay.L) m_LogVal.sStatus = "GRL_Cyl_MeaTblSixPoint";
            else                 m_LogVal.sStatus = "GRR_Cyl_MeaTblSixPoint";

            double dLTLx = CData.SPos.dGRD_X_Zero[0] + CData.Dev.aWinSt[0].X + 2;
            double dLTRx = CData.SPos.dGRD_X_Zero[0] - CData.Dev.aWinSt[0].X - 2;
            double dRTLx = CData.SPos.dGRD_X_Zero[1] - CData.Dev.aWinSt[0].X - 2;
            double dRTRx = CData.SPos.dGRD_X_Zero[1] + CData.Dev.aWinSt[0].X + 2;

            switch (m_iStep)
            {
                default:
                    {
                        m_iCnt = 0;
                        m_iStep = 0;

                        return true;
                    }

                case 10:
                    {// 축 상태 체크 및 테이블 저장 배열 초기화(999)
                        if (m_iWy == (int)EWay.L)
                        {
                            for (int i = 0; i < 1; i++)
                            {
                                for (int j = 0; j < 6; j++)
                                {
                                    CData.Tbl_BfSix[i, j] = 999;
                                }
                            }
                        }
                        else
                        {
                            for (int i = 1; i < 2; i++)
                            {
                                for (int j = 0; j < 6; j++)
                                {
                                    CData.Tbl_BfSix[i, j] = 999;
                                }
                            }
                        }

                        m_iCnt = 0;

                        if (Chk_Axes())
                        {
                            m_iStep = 0;

                            return true;
                        }

                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        m_LogVal.iStep = m_iStep;
                        SaveLog();
                        m_iStep++;
                        return false;
                    }

                case 11:
                    {// IO 초기화
                        _InitCycle();

                        m_LogVal.iStep  = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {// 테이블 안전상태 체크
                        SafeTbl(true, true, false);

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sMsg   = "SafeTbl(true, true, false)";
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 13:
                    {// Z축 ABLE 위치 이동
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                        if (CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sAsix1 = m_iZ.ToString();
                        m_LogVal.dPos1  = CData.SPos.dGRD_Z_Able[m_iWy];
                        SaveLog();

                        m_iStep++;
                        return false;
                    }
                    //시작
                case 14:
                    {//프로브 업
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_ProbeDn;
                            m_eOt2 = eY.GRDL_ProbeAir;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_ProbeDn;
                            m_eOt2 = eY.GRDR_ProbeAir;
                        }

                        CIO.It.Set_Y(m_eOt1, false);

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sMsg   = m_eOt1.ToString() + " = false";
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 15:
                    {//프로브 업 확인 후 프로브 X축 0으로 이동, Z축 측정 위치 계산

                        //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        //if (!CIO.It.Get_Y(m_eOt1))
                        bool   bProbeUp  = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값
                        if (bProbeUp && (dProbeVal >= GV.dProbeUpHeight))
                        {
                            // 2021.04.06 SungTae Start
                            //CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                            if (CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]) != 0)
                            {
                                return false;
                            }
                            // 2021.04.06 SungTae End

                            m_LogVal.iStep  = m_iStep;
                            m_LogVal.sAsix1 = m_iX.ToString();
                            m_LogVal.dPos1  = CData.SPos.dGRD_X_Zero[m_iWy];
                            SaveLog();

                            m_iStep++;
                        }

                        return false;
                    }

                case 16:
                    {//프로브 X축 0으로 이동 확인 후 테이블 측정 위치로 이동 == 반복 시작 점 ==

                        //2021.08.06 syc : Up상태일때 Probe 값 정상 범위 인지 확인
                        //- Qorvo 프로브 앰프값 자동으로 바뀌는 이슈에 대한 방지책
                        //- Probe 값이 18.9xxx ~ 19.0xxx 범위 이탈시 알람
                        if (Chk_ProbeUpVal())
                        {
                            m_iStep = 0;
                            return true;
                        }

                        if (m_iCnt <2)
                        {
                            if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                            { return false; }
                        }
                        else if(m_iCnt >=2 && m_iCnt < 4)
                        {
                            if(m_iWy == (int)EWay.L)
                            {
                                if(!CMot.It.Get_Mv(m_iX, dLTLx)) { return false; }
                            }
                            else
                            {
                                if(!CMot.It.Get_Mv(m_iX, dRTLx)) { return false; }
                            }
                        }
                        else
                        {
                            if(m_iWy == (int)EWay.L)
                            {
                                if(!CMot.It.Get_Mv(m_iX, dLTRx)) { return false; }
                            }
                            else
                            {
                                if(!CMot.It.Get_Mv(m_iX, dRTRx)) { return false; }
                            }
                        }

                        //if (m_iCnt == 0)
                        if (m_iCnt % 2 == 0)
                        {// 상단 측정 위치
                            m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                        }
                        else
                        {// 하단 측정 위치
                            m_dPosY += Math.Abs((m_dPosY - CData.MPos[m_iWy].dY_PRB_TBL_CENTER)) * 2;
                        }

                        CMot.It.Mv_N(m_iY, m_dPosY);

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sAsix1 = m_iY.ToString();
                        m_LogVal.dPos1  = m_dPosY;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 17:
                    {//테이블 측정 위치로 이동 확인 후 프로브 다운, 프로브 에어 온
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        CIO.It.Set_Y(m_eOt1, true);
                        CIO.It.Set_Y(m_eOt2, true);

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sMsg   = m_eOt1.ToString() + "true, " + m_eOt2.ToString() + "true";
                        SaveLog();

                        m_iStep++;

                        return false;
                    }

                case 18:
                    {//프로브 다운, 프로브 에어 온 확인, Z축 측정 위치로 이동
                        if (CIO.It.Get_Y(m_eOt1) && CIO.It.Get_Y(m_eOt2))
                        {
                            m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS;
                            
                            // 2021.04.06 SungTae Start
                            //CMot.It.Mv_N(m_iZ, m_dPosZ);
                            if (CMot.It.Mv_N(m_iZ, m_dPosZ) != 0)
                            {
                                return false;
                            }
                            // 2021.04.06 SungTae End

                            m_LogVal.iStep  = m_iStep;
                            m_LogVal.sAsix1 = m_iZ.ToString();
                            m_LogVal.dPos1  = m_dPosZ;
                            SaveLog();

                            m_iStep++;
                        }

                        return false;
                    }

                case 19:
                    {//Z축 측정 위치 이동 확인, 프로브 에어 오프
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        CIO.It.Set_Y(m_eOt2, false);

                        m_tmPrb.Set_Delay(GV.PRB_DELAY);

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sMsg   = m_eOt2.ToString() + "= false, m_tmPrb.Set_Delay(GV.PRB_DELAY)";
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 20:
                    {//프로브 에어 오프 확인, 테이블 높이 측정
                        if(!m_tmPrb.Chk_Delay()) return false;

                        if (!CIO.It.Get_Y(m_eOt2))
                        {
                            CData.Tbl_BfSix[m_iWy, m_iCnt] = CPrb.It.Read_Val(m_eWy) + GV.EQP_TABLE_MIN_THICKNESS;

                            m_LogVal.iStep  = m_iStep;
                            m_LogVal.sMsg   = "CData.Tbl_Bf[m_iWy, m_iCnt] = " + CData.Tbl_BfSix[m_iWy, m_iCnt].ToString();
                            SaveLog();

                            m_iStep++;
                        }

                        return false;
                    }

                case 21:
                    {//테이블 높이 값 확인(999 인지 아닌지 확인), Z축 Able 포지션 이동
                        if (CData.Tbl_BfSix[m_iWy, m_iCnt] == 999)
                        {
                            if (m_eWy == EWay.L)
                            { CErr.Show(eErr.LEFT_INSPECTION_TABLE_FAIL); }
                            else
                            { CErr.Show(eErr.RIGHT_INSPECTION_TABLE_FAIL); }
                            m_iCnt = 0;
                            m_iStep = 0;

                            return true;
                        }
                        else
                        {
                            // 2021.04.06 SungTae Start
                            //CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                            if (CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]) != 0)
                            {
                                return false;
                            }
                            // 2021.04.06 SungTae End

                            m_LogVal.iStep  = m_iStep;
                            m_LogVal.sAsix1 = m_iZ.ToString();
                            m_LogVal.dPos1  = CData.SPos.dGRD_Z_Able[m_iWy];
                            SaveLog();

                            m_iStep++;
                        }

                        return false;
                    }

                case 22:
                    {//Z축 Able 포지션 이동 확인    == 반복 종료 여부 확인 ==
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        if (m_iCnt >= 5)
                        { 
                            m_LogVal.iStep  = m_iStep;
                            m_LogVal.sMsg   = "m_iCnt = " +m_iCnt.ToString();
                            SaveLog();

                            m_iStep++; 
                        }
                        else
                        {
                            m_iCnt++;

                            m_LogVal.iStep  = m_iStep;
                            m_LogVal.sMsg   = "m_iCnt = " +m_iCnt.ToString();
                            SaveLog();
                            if(m_iCnt >= 2 && m_iCnt < 4)
                            {
                                if(m_iWy == (int)EWay.L) CMot.It.Mv_N(m_iX, dLTLx);
                                else                     CMot.It.Mv_N(m_iX, dRTLx);

                            }
                            else if(m_iCnt >= 4 && m_iCnt < 6)
                            {
                                if(m_iWy == (int)EWay.L) CMot.It.Mv_N(m_iX, dLTRx);
                                else                     CMot.It.Mv_N(m_iX, dRTRx);
                            }
                            m_iStep = 16;
                        }
                        return false;
                    }

                case 23:
                    {//프로브 업
                        CIO.It.Set_Y(m_eOt1, false);

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sMsg   = m_eOt1.ToString() + " = false";
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 24:
                    {//측정 종료, 프로브 업 확인

                        //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        //if (CIO.It.Get_Y(m_eOt1))
                        bool   bProbeUp  = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값
                        if (!bProbeUp || (dProbeVal < GV.dProbeUpHeight))
                        { return false; }

                        
                        m_LogVal.iStep  = m_iStep;
                        SaveLog();

                        m_iCnt = 0;
                        m_iStep = 0;

                        return true;
                    }
            }
        }

        /// <summary>
        /// Table Height Measure 8 Point
        /// 테이블 높이 8Point 반복 측정 (테이블 높이를 보정없이 측정된 값 그대로 표시)
        /// </summary>
        public bool Cyl_MeaTbl_8p()         // 201007  lhs
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            {
                m_mTimeout.Set_Delay(TIMEOUT);
            }
            else
            {
                if (m_mTimeout.Chk_Delay() == true)
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_TABLE_INSPECTION_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_TABLE_INSPECTION_TIMEOUT); }

                    m_nPtIdx = 0;
                    m_iStep = 0;

                    return true;
                }
            }

            m_iPreStep = m_iStep;

            if (m_eWy == EWay.L)    m_LogVal.sStatus = "GRL_Cyl_MeaTbl_8Point";
            else                    m_LogVal.sStatus = "GRR_Cyl_MeaTbl_8Point";

            switch (m_iStep)
            {
                default:
                    {
                        m_nPtIdx = 0;     // 측정 포인트 카운트
                        m_nReptIdx = 0;   // 반복 횟수 카운트
                        m_iStep = 0;

                        return true;
                    }

                case 10:
                    {// 축 상태 체크 및 테이블 저장 배열 초기화(999)

                        //--------------------
                        // 측정결과값 초기화 
                        for (int nR = 0; nR < CTm8.m_nMaxRept; nR++)
                        {
                            for (int nM = 0; nM < CTm8.m_nMaxPt; nM++)
                            {
                                if (m_iWy == (int)EWay.L)   CTm8.It.m_aLTbl_RltZ[nR, nM] = 999;
                                else                        CTm8.It.m_aRTbl_RltZ[nR, nM] = 999;
                            }
                        }
                        CTm8.It.m_nAcqReptCnt[m_iWy] = 0;   // 갯수
                        CTm8.It.m_nAcqPtCnt[m_iWy] = 0;     // 갯수
                        CTm8.It.m_bAcqed[m_iWy] = false;    // 갯수

                        //--------------------
                        m_nReptIdx = 0;
                        m_nPtIdx = 0;
                        //--------------------
                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }
                        //--------------------
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }
                        //--------------------
                        m_LogVal.iStep = m_iStep;
                        SaveLog();
                        m_iStep++;
                        return false;
                    }

                case 11:
                    {// IO 초기화
                        _InitCycle();

                        m_LogVal.iStep = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {// 테이블 안전상태 체크
                        SafeTbl(true, true, false);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sMsg = "SafeTbl(true, true, false)";
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 13:
                    {// Z축 ABLE 위치 이동
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                        if (CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sAsix1 = m_iZ.ToString();
                        m_LogVal.dPos1 = CData.SPos.dGRD_Z_Able[m_iWy];
                        SaveLog();

                        m_iStep++;
                        return false;
                    }
                //시작
                case 14:
                    {//프로브 업
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_ProbeDn;
                            m_eOt2 = eY.GRDL_ProbeAir;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_ProbeDn;
                            m_eOt2 = eY.GRDR_ProbeAir;
                        }

                        CIO.It.Set_Y(m_eOt1, false);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sMsg = m_eOt1.ToString() + " = false (Probe Up)";
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 15:
                    {//프로브 업 확인 

                        //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        bool bProbeUp = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값
                        if (bProbeUp && (dProbeVal >= GV.dProbeUpHeight))
                        {
                            m_LogVal.iStep = m_iStep;
                            m_LogVal.sMsg = "bProbeUp && (dProbeVal >= GV.dProbeUpHeight) => true";
                            SaveLog();

                            m_iStep++;
                        }
                        return false;
                    }

                case 16:
                    {//프로브 X축/Y축 측정위치 이동  == 반복 시작 점 ==

                        //2021.08.06 syc : Up상태일때 Probe 값 정상 범위 인지 확인
                        //- Qorvo 프로브 앰프값 자동으로 바뀌는 이슈에 대한 방지책
                        //- Probe 값이 18.9xxx ~ 19.0xxx 범위 이탈시 알람
                        if (Chk_ProbeUpVal())
                        {
                            m_iStep = 0;
                            return true;
                        }

                        double dX = 0.0;
                        double dY = 0.0;
                        if (m_eWy == EWay.L)
                        {
                            dX = (double)CTm8.It.mTable.alLTbl_X[m_nPtIdx];
                            dY = (double)CTm8.It.mTable.alLTbl_Y[m_nPtIdx];
                        }
                        else
                        {
                            dX = (double)CTm8.It.mTable.alRTbl_X[m_nPtIdx];
                            dY = (double)CTm8.It.mTable.alRTbl_Y[m_nPtIdx];
                        }

                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iX, dX);
                        //CMot.It.Mv_N(m_iY, dY);
                        if (CMot.It.Mv_N(m_iX, dX) != 0 || CMot.It.Mv_N(m_iY, dY) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sAsix1 = m_iX.ToString();
                        m_LogVal.dPos1 = dX;
                        m_LogVal.sAsix2 = m_iY.ToString();
                        m_LogVal.dPos2 = dY;
                        m_LogVal.sMsg = "m_nReptIdx = " + m_nReptIdx.ToString() + ", m_nPtIdx = " + m_nPtIdx.ToString();
                        SaveLog();

                        m_iStep++;

                        return false;
                    }

                case 17:
                    {//테이블 측정 위치로 이동 확인 후 프로브 다운, 프로브 에어 온
                        //-------------------------
                        // 측정위치 확인
                        double dX = 0.0;
                        double dY = 0.0;
                        if (m_eWy == EWay.L)
                        {
                            dX = (double)CTm8.It.mTable.alLTbl_X[m_nPtIdx];
                            dY = (double)CTm8.It.mTable.alLTbl_Y[m_nPtIdx];
                        }
                        else
                        {
                            dX = (double)CTm8.It.mTable.alRTbl_X[m_nPtIdx];
                            dY = (double)CTm8.It.mTable.alRTbl_Y[m_nPtIdx];
                        }
                        if (!CMot.It.Get_Mv(m_iX, dX))
                        {
                            return false;
                        }
                        if (!CMot.It.Get_Mv(m_iY, dY))
                        {
                            return false;
                        }
                        //-------------------------
                        // 프로브 다운
                        CIO.It.Set_Y(m_eOt1, true);
                        CIO.It.Set_Y(m_eOt2, true);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sMsg = m_eOt1.ToString() + "true, " + m_eOt2.ToString() + "true";
                        SaveLog();

                        m_iStep++;

                        return false;
                    }

                case 18:
                    {//프로브 다운, 프로브 에어 온 확인, Z축 측정 위치로 이동
                        if (CIO.It.Get_Y(m_eOt1) && CIO.It.Get_Y(m_eOt2))
                        {
                            m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS;
                            
                            // 2021.04.06 SungTae Start
                            //CMot.It.Mv_N(m_iZ, m_dPosZ);
                            if (CMot.It.Mv_N(m_iZ, m_dPosZ) != 0)
                            {
                                return false;
                            }
                            // 2021.04.06 SungTae End

                            m_LogVal.iStep = m_iStep;
                            m_LogVal.sAsix1 = m_iZ.ToString();
                            m_LogVal.dPos1 = m_dPosZ;
                            SaveLog();

                            m_iStep++;
                        }
                        return false;
                    }

                case 19:
                    {//Z축 측정 위치 이동 확인, 프로브 에어 오프
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        CIO.It.Set_Y(m_eOt2, false);

                        m_tmPrb.Set_Delay(GV.PRB_DELAY);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sMsg = m_eOt2.ToString() + "= false, m_tmPrb.Set_Delay(GV.PRB_DELAY)";
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 20:
                    {//프로브 에어 오프 확인, 테이블 높이 측정
                        if (!m_tmPrb.Chk_Delay()) return false;

                        if (!CIO.It.Get_Y(m_eOt2))
                        {
                            string sMsg = "";
                            if (m_eWy == EWay.L)
                            {
                                CTm8.It.m_aLTbl_RltZ[m_nReptIdx, m_nPtIdx] = CPrb.It.Read_Val(m_eWy) + GV.EQP_TABLE_MIN_THICKNESS;
                                sMsg = "CTm8.It.m_aLTbl_RltZ[m_nReptIdx, m_nPtIdx] = " + CTm8.It.m_aLTbl_RltZ[m_nReptIdx, m_nPtIdx].ToString();
                            }
                            else
                            {
                                CTm8.It.m_aRTbl_RltZ[m_nReptIdx, m_nPtIdx] = CPrb.It.Read_Val(m_eWy) + GV.EQP_TABLE_MIN_THICKNESS;
                                sMsg = "CTm8.It.m_aLTbl_RltZ[m_nReptIdx, m_nPtIdx] = " + CTm8.It.m_aLTbl_RltZ[m_nReptIdx, m_nPtIdx].ToString();
                            }
                            //-------------------------------
                            // 측정값을 UI에 표시하기 위해
                            //-------------------------------
                            CTm8.It.m_nAcqReptCnt[m_iWy] = m_nReptIdx + 1;    // 갯수
                            CTm8.It.m_nAcqPtCnt[m_iWy] = m_nPtIdx + 1;      // 갯수
                            CTm8.It.m_bAcqed[m_iWy] = true; // 갯수

                            //-------------------------------
                            m_LogVal.iStep = m_iStep;
                            m_LogVal.sMsg = sMsg;
                            SaveLog();

                            m_iStep++;
                        }
                        return false;
                    }

                case 21:
                    {//테이블 높이 값 확인(999 인지 아닌지 확인), Z축 Able 포지션 이동
                        if (m_eWy == EWay.L)
                        {
                            if (CTm8.It.m_aLTbl_RltZ[m_nReptIdx, m_nPtIdx] == 999)
                            {
                                CErr.Show(eErr.LEFT_INSPECTION_TABLE_FAIL);
                                m_nReptIdx = 0;
                                m_nPtIdx = 0;
                                m_iStep = 0;
                                return true;
                            }
                            else
                            {
                                // 2021.04.06 SungTae Start
                                //CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                                if (CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]) != 0)
                                {
                                    return false;
                                }
                                // 2021.04.06 SungTae End

                                m_LogVal.iStep = m_iStep;
                                m_LogVal.sAsix1 = m_iZ.ToString();
                                m_LogVal.dPos1 = CData.SPos.dGRD_Z_Able[m_iWy];
                                SaveLog();

                                m_iStep++;
                            }
                        }
                        else
                        {
                            if (CTm8.It.m_aRTbl_RltZ[m_nReptIdx, m_nPtIdx] == 999)
                            {
                                CErr.Show(eErr.RIGHT_INSPECTION_TABLE_FAIL);
                                m_nReptIdx = 0;
                                m_nPtIdx = 0;
                                m_iStep = 0;
                                return true;
                            }
                            else
                            {
                                // 2021.04.06 SungTae Start
                                //CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                                if (CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]) != 0)
                                {
                                    return false;
                                }
                                // 2021.04.06 SungTae End

                                m_LogVal.iStep = m_iStep;
                                m_LogVal.sAsix1 = m_iZ.ToString();
                                m_LogVal.dPos1 = CData.SPos.dGRD_Z_Able[m_iWy];
                                SaveLog();

                                m_iStep++;
                            }
                        }
                        return false;
                    }

                case 22:
                    {//Z축 Able 포지션 이동 확인    == 반복 종료 여부 확인 ==
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        // 측정 포인트를 다 측정했으면 반복횟수 증가 후 반복측정
                        // 반복횟수도 다 수행했으면 프로브업 후 측정 종료
                        if(m_nPtIdx >= CTm8.It.mTable.aTbl_MeasCnt[m_iWy] - 1)
                        {   // 측정포인트 갯수 이상이면
                            if (m_nReptIdx >= CTm8.It.mTable.aTbl_RepeatCnt[m_iWy] - 1)
                            {   // 반복횟수 이상이면 
                                m_LogVal.iStep = m_iStep;
                                m_LogVal.sMsg = "m_nReptIdx = " + m_nReptIdx.ToString() + ", m_nPtIdx = " + m_nPtIdx.ToString();
                                SaveLog();

                                m_iStep++;
                            }
                            else
                            {   // 반복횟수 증가
                                m_nReptIdx++;
                                m_nPtIdx = 0;
                                m_iStep = 16;
                            }
                        }
                        else
                        {
                            m_nPtIdx++;
                            m_iStep = 16;
                        }

                        return false;
                    }

                case 23:
                    {//프로브 업
                        CIO.It.Set_Y(m_eOt1, false);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sMsg = m_eOt1.ToString() + " = false";
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 24:
                    {//측정 종료, 프로브 업 확인

                        //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        //if (CIO.It.Get_Y(m_eOt1))
                        bool bProbeUp = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값
                        if (!bProbeUp || (dProbeVal < GV.dProbeUpHeight))
                        { return false; }


                        m_LogVal.iStep = m_iStep;
                        SaveLog();

                        m_nPtIdx = 0;
                        m_iStep = 0;

                        return true;
                    }
            }
        }


        /// <summary>
        /// Table Height Measure 8 Point
        /// 테이블 높이 8Point 반복 측정 (보정 적용)
        /// 테이블의 중앙상단과 Col별(X축)상단의 높이 차이를 측정값에 보정 (SCK+ 요구사항)
        /// </summary>
        public bool Cyl_MeaTbl_TM8()         // 2020.11.27 lhs
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            {
                m_mTimeout.Set_Delay(TIMEOUT);
            }
            else
            {
                if (m_mTimeout.Chk_Delay() == true)
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_TABLE_INSPECTION_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_TABLE_INSPECTION_TIMEOUT); }

                    m_nPtIdx = 0;
                    m_iStep = 0;

                    return true;
                }
            }

            m_iPreStep = m_iStep;

            if (m_eWy == EWay.L) m_LogVal.sStatus = "Cyl_MeaTbl_TM8";
            else m_LogVal.sStatus = "Cyl_MeaTbl_TM8";

            switch (m_iStep)
            {
                default:
                    {
                        m_nReptIdx = 0;   // 반복 횟수 카운트
                        m_nPtIdx = 0;     // 측정 포인트 카운트
                        m_iStep = 0;

                        return true;
                    }

                case 10:
                    {// 축 상태 체크 및 테이블 저장 배열 초기화(999)
                        //--------------------
                        // 측정결과값 초기화 
                        for (int nR = 0; nR < CTm8.m_nMaxRept; nR++)
                        {
                            for (int nM = 0; nM < CTm8.m_nMaxPt; nM++)
                            {
                                if (m_iWy == (int)EWay.L) CTm8.It.m_aLTbl_RltZ[nR, nM] = 999;
                                else CTm8.It.m_aRTbl_RltZ[nR, nM] = 999;
                            }
                        }
                        CTm8.It.m_nAcqReptCnt[m_iWy] = 0;   // 갯수
                        CTm8.It.m_nAcqPtCnt[m_iWy] = 0;   // 갯수
                        CTm8.It.m_bAcqed[m_iWy] = false;    // 갯수

                        //--------------------
                        // 변수 초기화
                        m_dPosX = 0.0;
                        m_dPosY = 0.0;
                        m_dPosZ = 0.0;

                        m_nReptIdx = 0;         // 반복측정 인덱스 초기화
                        m_nPtIdx = 0;           // 측정포인트 인덱스 초기화

                        m_dTableH_CT = 0.0;     // 테이블 중앙상단 높이
                        for (int i = 0; i < CTm8.m_nMaxPt; i++)
                        {
                            m_bMeased_Top[i] = false;    // col별 테이블 상단 측정 여부 
                            m_dTableH_Top[i] = 0.0;      // col별 테이블 상단 측정값
                        }


                        //--------------------
                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }
                        
                        //--------------------
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);
                            
                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }
                        //--------------------
                        m_LogVal.iStep = m_iStep;
                        SaveLog();
                        m_iStep++;
                        return false;
                    }

                case 11:
                    {// IO 초기화
                        _InitCycle();

                        m_LogVal.iStep = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {// 테이블 안전상태 체크
                        SafeTbl(true, true, false);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sMsg = "SafeTbl(true, true, false)";
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 13:
                    {// Z축 ABLE 위치 이동
                        m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy];
                        CMot.It.Mv_N(m_iZ, m_dPosZ);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sAsix1 = m_iZ.ToString();
                        m_LogVal.dPos1 = m_dPosZ;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }
                //시작
                case 14:
                    {//프로브 업
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_ProbeDn;
                            m_eOt2 = eY.GRDL_ProbeAir;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_ProbeDn;
                            m_eOt2 = eY.GRDR_ProbeAir;
                        }

                        CIO.It.Set_Y(m_eOt1, false);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sMsg = m_eOt1.ToString() + " = false (Probe Up)";
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 15:
                    {//프로브 업 확인 

                        //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        bool bProbeUp = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값
                        if (bProbeUp && (dProbeVal >= GV.dProbeUpHeight))
                        {
                            m_LogVal.iStep = m_iStep;
                            m_LogVal.sMsg = "bProbeUp && (dProbeVal >= GV.dProbeUpHeight) => true";
                            SaveLog();

                            m_iStep++;
                        }
                        return false;
                    }

                /////////////////////////////////////////////////////
                // 테이블 중앙 상단 측정
                /////////////////////////////////////////////////////

                case 16: // X축/Y축 중앙상단으로 이동
                    {
                        //2021.08.06 syc : Up상태일때 Probe 값 정상 범위 인지 확인
                        //- Qorvo 프로브 앰프값 자동으로 바뀌는 이슈에 대한 방지책
                        //- Probe 값이 18.9xxx ~ 19.0xxx 범위 이탈시 알람
                        if (Chk_ProbeUpVal())
                        {
                            m_iStep = 0;
                            return true;
                        }

                        m_dPosX = CData.SPos.dGRD_X_Zero[m_iWy];
                        m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];

                        CMot.It.Mv_N(m_iX, m_dPosX);
                        CMot.It.Mv_N(m_iY, m_dPosY);

                        m_LogVal.iStep  = m_iStep;
                        m_LogVal.sAsix1 = m_iX.ToString();
                        m_LogVal.dPos1  = m_dPosX;
                        m_LogVal.sAsix2 = m_iY.ToString();
                        m_LogVal.dPos2  = m_dPosY;
                        m_LogVal.sMsg = "X axis move dGRD_X_Zero, Y axis move dGRD_Y_TblInsp";
                        SaveLog();

                        m_iStep++;

                        return false;
                    }

                case 17: //중앙상단(X, Y)으로 이동 확인 후 프로브 다운, 프로브 에어 온
                    {
                        //-------------------------
                        // 측정위치 확인
                        if (!CMot.It.Get_Mv(m_iX, m_dPosX))
                        {
                            return false;
                        }
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        {
                            return false;
                        }

                        //-------------------------
                        // 프로브 다운
                        CIO.It.Set_Y(m_eOt1, true);
                        CIO.It.Set_Y(m_eOt2, true);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sMsg = "Probe Down : " + m_eOt1.ToString() + " = true, " + m_eOt2.ToString() + " = true";
                        SaveLog();

                        m_iStep++;

                        return false;
                    }

                case 18: //프로브 다운, 프로브 에어 온 확인, Z축 측정 위치로 이동
                    {
                        if (CIO.It.Get_Y(m_eOt1) && CIO.It.Get_Y(m_eOt2))
                        {
                            m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS;  // Table Base 보다 19mm 높은 위치
                            CMot.It.Mv_N(m_iZ, m_dPosZ);

                            m_LogVal.iStep = m_iStep;
                            m_LogVal.sAsix1 = m_iZ.ToString();
                            m_LogVal.dPos1 = m_dPosZ;
                            m_LogVal.sMsg = "Z axis move position = " + m_dPosZ.ToString();
 
                            SaveLog();

                            m_iStep++;
                        }
                        return false;
                    }

                case 19:  //Z축 측정 위치 이동 확인, 프로브 에어 오프
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        CIO.It.Set_Y(m_eOt2, false);
                        m_tmPrb.Set_Delay(GV.PRB_DELAY);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sMsg = m_eOt2.ToString() + "= false, m_tmPrb.Set_Delay(GV.PRB_DELAY)";
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 20: //프로브 에어 오프 확인, 테이블 중앙상단 높이 측정
                    {   
                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay())
                        {
                            string sMsg = "";

                            m_dTableH_CT = CPrb.It.Read_Val(m_eWy) + GV.EQP_TABLE_MIN_THICKNESS; // 테이블 중앙상단 높이 (이후 측정시 Z에 적용)

                            sMsg = "Table Height (Center Top) = : " + m_dTableH_CT + "mm";

                            if (m_dTableH_CT > (GV.EQP_TABLE_MIN_THICKNESS + 4))
                            {
                                CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_GRIND_MANUALZIG_ON_THE_TABLE :
                                                                   eErr.RIGHT_GRIND_MANUALZIG_ON_THE_TABLE);
                                _SetLog("Error : Manual zig on table.");

                                m_bSubErr = true;

                                m_iStep = 0;
                                return true;
                            }

                            m_LogVal.iStep = m_iStep;
                            m_LogVal.sMsg = sMsg;
                            SaveLog();

                            m_iStep++;
                        }
                        return false;
                    }

                case 21: // Z축 Able 포지션 이동
                    {
                        CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sAsix1 = m_iZ.ToString();
                        m_LogVal.dPos1 = CData.SPos.dGRD_Z_Able[m_iWy];
                        SaveLog();

                        m_iStep++;

                        return false;
                    }

                case 22: //Z축 Able 포지션 이동 확인, 
                    {
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        //---------------------------
                        // 테이블 상단 측정 전 변수 초기화
                        m_nReptIdx = 0;                     // 반복측정 인덱스 초기화
                        m_nPtIdx = 0;                       // 측정포인트 인덱스 초기화

                        m_bTopMode = false;
                        for (int i = 0; i < CTm8.m_nMaxPt; i++)
                        {
                            m_bMeased_Top[i] = false;       // col별 테이블 상단 측정 여부 
                            m_dTableH_Top[i] = 0.0;         // col별 테이블 상단 측정값
                        }
                        //---------------------------
                        string sMsg = "Z Axis dGRD_Z_Able Position OK, Init : m_nReptIdx = " + m_nReptIdx.ToString() + ", m_nPtIdx = " + m_nPtIdx.ToString(); ;
                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sAsix1 = m_iZ.ToString();
                        m_LogVal.dPos1 = CData.SPos.dGRD_Z_Able[m_iWy];
                        m_LogVal.sMsg = sMsg;

                        SaveLog();

                        m_iStep++;

                        return false;
                        
                    }

                /////////////////////////////////////////////////////
                // 1. 테이블 Col별 상단 측정 (Col별 1번만 측정)
                // 2. 측정포인트 측정 -> 반복횟수만큼 반복측정
                /////////////////////////////////////////////////////

                case 23: // 테이블 상단 or 측정포인트의 X축/Y축 측정위치 이동  == 반복 시작 점 ==
                    {
                        // 1. Col별 테이블 상단 측정을 하지 않았으면 -> 테이블 상단 측정모드
                        // 2. Col별 테이블 상단 측정을 했으면       -> 측정포인트 측정

                        string sMsg = "";
                        int nColIdx = -1;
                        if (m_eWy == EWay.L)    { nColIdx = (int)CTm8.It.mTable.alLTbl_Colidx[m_nPtIdx]; }
                        else                    { nColIdx = (int)CTm8.It.mTable.alRTbl_Colidx[m_nPtIdx]; }

                        // 테이블 상단 측정이 완료된 Col 인지 확인
                        if (m_bMeased_Top[nColIdx] == false) // Col별 테이블 상단 측정
                        {
                            m_bTopMode = true;          // 테이블 상단 측정모드

                            if (m_eWy == EWay.L)    { m_dPosX = (double)CTm8.It.mTable.alLTbl_X[m_nPtIdx]; }
                            else                    { m_dPosX = (double)CTm8.It.mTable.alRTbl_X[m_nPtIdx]; }
                            m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];

                            sMsg = "Move X, Y : Table Top, ColIdx = " + nColIdx.ToString();
                        }
                        else                                // 설정한 측정포인트 측정
                        {
                            m_bTopMode = false;  // 측정포인트 측정모드

                            if (m_eWy == EWay.L)
                            {
                                m_dPosX = (double)CTm8.It.mTable.alLTbl_X[m_nPtIdx];
                                m_dPosY = (double)CTm8.It.mTable.alLTbl_Y[m_nPtIdx];
                            }
                            else
                            {
                                m_dPosX = (double)CTm8.It.mTable.alRTbl_X[m_nPtIdx];
                                m_dPosY = (double)CTm8.It.mTable.alRTbl_Y[m_nPtIdx];
                            }
                            sMsg = "Move X, Y : m_nReptIdx = " + m_nReptIdx.ToString() + ", m_nPtIdx = " + m_nPtIdx.ToString();
                        }

                        CMot.It.Mv_N(m_iX, m_dPosX);
                        CMot.It.Mv_N(m_iY, m_dPosY);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sAsix1 = m_iX.ToString();
                        m_LogVal.dPos1 = m_dPosX;
                        m_LogVal.sAsix2 = m_iY.ToString();
                        m_LogVal.dPos2 = m_dPosY;

                        m_LogVal.sMsg = sMsg;
                        SaveLog();

                        m_iStep++;

                        return false;
                    }

                case 24: //테이블 상단 or 측정포인트 위치로 이동 확인 후 프로브 다운, 프로브 에어 온
                    {
                        //-------------------------
                        // 측정위치 확인
                        if (!CMot.It.Get_Mv(m_iX, m_dPosX))
                        {
                            return false;
                        }
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        {
                            return false;
                        }
                        //-------------------------
                        // 프로브 다운
                        CIO.It.Set_Y(m_eOt1, true);
                        CIO.It.Set_Y(m_eOt2, true);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sMsg = m_eOt1.ToString() + " = true, " + m_eOt2.ToString() + " = true";
                        SaveLog();

                        m_iStep++;

                        return false;
                    }

                case 25: //프로브 다운, 프로브 에어 온 확인, Z축 측정 위치로 이동
                    {
                        if (CIO.It.Get_Y(m_eOt1) && CIO.It.Get_Y(m_eOt2))
                        {
                            CMot.It.Mv_N(m_iZ, m_dPosZ);     // Z축은 같음 (Table Base 보다 19mm 높은 위치)

                            string sMsg = "Z axis move position = " + m_dPosZ.ToString();
                            m_LogVal.iStep = m_iStep;
                            m_LogVal.sAsix1 = m_iZ.ToString();
                            m_LogVal.dPos1 = m_dPosZ;
                            m_LogVal.sMsg = sMsg;
                            SaveLog();

                            m_iStep++;
                        }
                        return false;
                    }

                case 26:    //Z축 측정 위치 이동 확인, 프로브 에어 오프
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        CIO.It.Set_Y(m_eOt2, false);

                        m_tmPrb.Set_Delay(GV.PRB_DELAY);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sMsg = m_eOt2.ToString() + "= false, m_tmPrb.Set_Delay(GV.PRB_DELAY)";
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 27:    //프로브 에어 오프 확인, 테이블 높이 측정
                    {
                        if (!CIO.It.Get_Y(m_eOt2) && m_tmPrb.Chk_Delay()) 
                        {
                            string sMsg = "";

                            // Col Index
                            int nColIdx = -1;
                            if (m_eWy == EWay.L)    {   nColIdx = (int)CTm8.It.mTable.alLTbl_Colidx[m_nPtIdx]; }
                            else                    {   nColIdx = (int)CTm8.It.mTable.alRTbl_Colidx[m_nPtIdx]; }

                            // 테이블 상단 측정이 완료된 Col 인지 확인
                            if (m_bTopMode == true)  // 테이블 상단 측정 모드
                            {
                                m_bMeased_Top[nColIdx] = true;
                                m_dTableH_Top[nColIdx] = CPrb.It.Read_Val(m_eWy) + GV.EQP_TABLE_MIN_THICKNESS; // Col별 테이블 상단 높이

                                sMsg = string.Format("Table Height Top Measure : ColIdx = {0}, Table Height Top = {1}", nColIdx, m_dTableH_Top[nColIdx]);
                            }
                            else
                            {
                                double dTableH_Org  = CPrb.It.Read_Val(m_eWy) + GV.EQP_TABLE_MIN_THICKNESS;
                                double dOffset      = m_dTableH_Top[nColIdx] - m_dTableH_CT;     // Col별 Offset (테이블 상단 - 테이블 중앙상단)
                                double dTableH_Corr = dTableH_Org - dOffset;

                                if (m_eWy == EWay.L)
                                {
                                    CTm8.It.m_aLTbl_RltZ[m_nReptIdx, m_nPtIdx] = dTableH_Corr;
                                    sMsg = string.Format("RepeatIdx = {0}, MeasPointIdx = {1}, MeasResult = {2}", m_nReptIdx, m_nPtIdx, CTm8.It.m_aLTbl_RltZ[m_nReptIdx, m_nPtIdx]);
                                }
                                else
                                {
                                    CTm8.It.m_aRTbl_RltZ[m_nReptIdx, m_nPtIdx] = dTableH_Corr;
                                    sMsg = string.Format("RepeatIdx = {0}, MeasPointIdx = {1}, MeasResult = {2}", m_nReptIdx, m_nPtIdx, CTm8.It.m_aRTbl_RltZ[m_nReptIdx, m_nPtIdx]);
                                }
                                //-------------------------------
                                // 측정값을 UI에 표시하기 위해
                                //-------------------------------
                                CTm8.It.m_nAcqReptCnt[m_iWy] = m_nReptIdx + 1;  // 갯수
                                CTm8.It.m_nAcqPtCnt[m_iWy] = m_nPtIdx + 1;      // 갯수
                                CTm8.It.m_bAcqed[m_iWy] = true; // 갯수
                            }

                            //-------------------------------
                            m_LogVal.iStep = m_iStep;
                            m_LogVal.sMsg = sMsg;
                            SaveLog();

                            m_iStep++;
                        }
                        return false;
                    }

                case 28:    //테이블 높이 값 확인(999 인지 아닌지 확인), Z축 Able 포지션 이동
                    {
                        if (m_bTopMode == true)  // 테이블 상단 측정 모드
                        {   
                            // 냉무
                        }
                        else                             // 측정포인트 측정
                        {
                            if (m_eWy == EWay.L)
                            {
                                if (CTm8.It.m_aLTbl_RltZ[m_nReptIdx, m_nPtIdx] == 999)
                                {
                                    CErr.Show(eErr.LEFT_INSPECTION_TABLE_FAIL);
                                    m_nReptIdx = 0;
                                    m_nPtIdx = 0;
                                    m_iStep = 0;
                                    return true;
                                }
                            }
                            else
                            {
                                if (CTm8.It.m_aRTbl_RltZ[m_nReptIdx, m_nPtIdx] == 999)
                                {
                                    CErr.Show(eErr.RIGHT_INSPECTION_TABLE_FAIL);
                                    m_nReptIdx = 0;
                                    m_nPtIdx = 0;
                                    m_iStep = 0;
                                    return true;
                                }
                            }
                        }
                        //----------------
                        CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sAsix1 = m_iZ.ToString();
                        m_LogVal.dPos1 = CData.SPos.dGRD_Z_Able[m_iWy];
                        SaveLog();

                        m_iStep++;

                        return false;
                    }

                case 29:    //Z축 Able 포지션 이동 확인    == 반복 종료 여부 확인 ==
                    {
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        // 테이블 상단 측정 모드
                        if (m_bTopMode == true)  
                        {
                            m_iStep = 23; // m_iStep = 23 : 반복 시작점
                        }
                        // 측정포인트 측정
                        else
                        {
                            // 측정 포인트를 다 측정했으면 반복횟수 증가 후 반복측정
                            if (m_nPtIdx >= CTm8.It.mTable.aTbl_MeasCnt[m_iWy] - 1)
                            {
                                // 반복횟수도 다 수행했으면 프로브업 후 측정 종료
                                if (m_nReptIdx >= CTm8.It.mTable.aTbl_RepeatCnt[m_iWy] - 1)
                                {
                                    // 반복횟수 이상이면 
                                    m_LogVal.iStep = m_iStep;
                                    m_LogVal.sMsg = "Repeat End : m_nReptIdx = " + m_nReptIdx.ToString() + ", m_nPtIdx = " + m_nPtIdx.ToString();
                                    SaveLog();

                                    m_iStep++;
                                }
                                else
                                {   // 반복횟수 증가
                                    m_nReptIdx++;
                                    m_nPtIdx = 0;
                                    m_iStep = 23; // m_iStep = 23 : 반복 시작점
                                }
                            }
                            // 측정 포인트를 다 측정하지 않았으면
                            else
                            {
                                m_nPtIdx++;
                                m_iStep = 23; // m_iStep = 23 : 반복 시작점
                            }
                        }
                        return false;
                    }

                case 30:
                    {//프로브 업
                        CIO.It.Set_Y(m_eOt1, false);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sMsg = m_eOt1.ToString() + " = false";
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 31:
                    {//측정 종료, 프로브 업 확인

                        // 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        bool bProbeUp = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); // 프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy);                                                          // 프로브 값
                        if (!bProbeUp || (dProbeVal < GV.dProbeUpHeight))
                        {
                            return false;
                        }
                        m_LogVal.iStep = m_iStep;
                        SaveLog();

                        m_iStep = 0;

                        return true;
                    }
            }
        }

        /// <summary>
        /// Strip Grinding
        /// 스트립 그라인딩 함수
        /// </summary>
        /// <returns></returns>
        public bool Cyl_Grd()
        {
            //220801 pjh : Pump Error Check
            int iRet = ChkPumpErr();
            //
            // Probe down check & Probe up
            if (!m_bUsePrbFlag)
            {
                Func_PrbUp();

                if (!Chk_PrbUpAmp())
                {
                    m_iGStep = 0;
                    m_iStep = 0;

                    Func_SplWater(false);
                    Func_BtmWater(false);
                    if (CDataOption.IsWhlCleaner)   { Func_WhlClnWater(false); }
                    //CSpl.It.Write_Stop(m_eWy);
                    // 2023.03.15 Max
                    CSpl_485.It.Write_Stop(m_eWy);
                    CMot.It.Mv_N(m_iZ, 0);

                    CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET : eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                    _SetLog("Error : Probe down during grinding.");

                    return true;
                }
            }
            //220801 pjh : Pump Error 발생 시 Grinding Stop
            if (iRet != 0)
            {
                m_iGStep = 0;
                m_iStep = 0;
                Bf_Stop();

                Func_SplWater(false);
                Func_BtmWater(false);

                if (CDataOption.IsWhlCleaner) { Func_WhlClnWater(false); }

                //CSpl.It.Write_Stop(m_eWy);
                // 2023.03.15 Max
                CSpl_485.It.Write_Stop(m_eWy);
                CMot.It.Mv_N(m_iZ, 0);

                switch (iRet)
                {
                    default:
                        {
                            break;
                        }
                    case 1:
                        {
                            CErr.Show(eErr.LEFT_PUMP_FLOW_LOW_ERROR);
                            _SetLog("Error : Left Pump Flow Error");
                            break;
                        }
                    case 2:
                        {
                            CErr.Show(eErr.LEFT_PUMP_TEMP_HIGH_ERROR);
                            _SetLog("Error : Left Pump Temp High Error");
                            break;
                        }
                    case 3:
                        {
                            CErr.Show(eErr.LEFT_PUMP_OVERLOAD_ERROR);
                            _SetLog("Error : Left Pump Overload Error");
                            break;
                        }
                    case 4:
                        {
                            CErr.Show(eErr.RIGHT_PUMP_FLOW_LOW_ERROR);
                            _SetLog("Error : Right Pump Flow Error");
                            break;
                        }
                    case 5:
                        {
                            CErr.Show(eErr.RIGHT_PUMP_TEMP_HIGH_ERROR);
                            _SetLog("Error : Right Pump Temp High Error");
                            break;
                        }
                    case 6:
                        {
                            CErr.Show(eErr.RIGHT_PUMP_OVERLOAD_ERROR);
                            _SetLog("Error : Right Pump Overload Error");
                            break;
                        }
                }
                return true;
            }
            if (m_eWy == EWay.L)
            {
                if (CDataOption.Package == ePkg.Strip)
                {
                    //210901 syc : 2004U
                    if (CDataOption.Use2004U)
                    {
                        if (!CIO.It.Get_X(eX.GRDL_Unit_Vacuum_4U) || !CIO.It.Get_X(eX.GRDL_TbVaccum))
                        {
                            CIO.It.Set_Y(eY.GRDL_SplWater, false);
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            CMot.It.Mv_N((int)EAx.LeftGrindZone_Z, 0);

                            CErr.Show(eErr.LEFT_GRIND_VACUUM_ERROR);
                            _SetLog("Error : Vacuum fail.");

                            m_iGStep = 0;
                            m_iStep = 0;
                            return true;
                        }
                    }
                    //
                    else
                    {
                        if (!CIO.It.Get_X(eX.GRDL_TbVaccum))
                        {
                            CIO.It.Set_Y(eY.GRDL_SplWater, false);
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            CMot.It.Mv_N((int)EAx.LeftGrindZone_Z, 0);

                            CErr.Show(eErr.LEFT_GRIND_VACUUM_ERROR);
                            
                            _SetLog("Error : Vacuum fail.");

                            m_iGStep = 0;
                            m_iStep = 0;
                            return true;
                        }
                    }

                    //200310 ksg : Spindle 부하
                    if (CData.Dev.aData[m_iWy].dSpdError > 0 && CData.GrData[m_iWy].dSplMaxLoad > CData.Dev.aData[m_iWy].dSpdError)
                    {
                        m_NeedDrs = true;
                        CIO.It.Set_Y(eY.GRDL_SplWater, false);

                        //CSpl.It.Write_Stop(m_eWy);
                        // 2023.03.15 Max
                        CSpl_485.It.Write_Stop(m_eWy);

                        CMot.It.Mv_N((int)EAx.LeftGrindZone_Z, 0);

                        CErr.Show(eErr.LEFT_GRIND_SPINDLE_OVERLOAD);
                        _SetLog("Error : Spindle overload.  Load : " + CData.GrData[m_iWy].dSplMaxLoad + "%");

                        // 2020.11.20 SungTae : Alarm 발생 후 초기화
                        CData.GrData[m_iWy].dSplMaxLoad = 0;

                        m_iGStep = 0;
                        m_iStep = 0;
                        return true;
                    }
                }
                else // Unit 모드 시 버큠 체크
                {   
                    if (!Chk_Unit())
                    {
                        CIO.It.Set_Y(eY.GRDL_SplWater, false);
                        //CSpl.It.Write_Stop(m_eWy);
                        // 2023.03.15 Max
                        CSpl_485.It.Write_Stop(m_eWy);

                        CMot.It.Mv_N((int)EAx.LeftGrindZone_Z, 0);

                        CErr.Show(eErr.LEFT_GRIND_VACUUM_ERROR);
                        _SetLog("Error : Vacuum fail.");

                        m_iGStep = 0;
                        m_iStep = 0;
                        return true;
                    }
                }                    
            } // end : Left

            if(m_eWy == EWay.R)
            {
                if (CDataOption.Package == ePkg.Strip)
                {
                    //210901 syc : 2004U
                    if (CDataOption.Use2004U)
                    {
                        if (!CIO.It.Get_X(eX.GRDR_Unit_Vacuum_4U) || !CIO.It.Get_X(eX.GRDR_Carrier_Vacuum_4U))
                        {
                            CIO.It.Set_Y(eY.GRDR_SplWater, false);
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            CMot.It.Mv_N((int)EAx.RightGrindZone_Z, 0);

                            CErr.Show(eErr.RIGHT_GRIND_VACUUM_ERROR);
                            _SetLog("Error : Vacuum fail.");

                            m_iGStep = 0;
                            m_iStep = 0;
                            return true;
                        }
                    }
                    else
                    {
                        if (!CIO.It.Get_X(eX.GRDR_TbVaccum))
                        {
                            CIO.It.Set_Y(eY.GRDR_SplWater, false);
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            CMot.It.Mv_N((int)EAx.RightGrindZone_Z, 0);

                            CErr.Show(eErr.RIGHT_GRIND_VACUUM_ERROR);
                            
                            _SetLog("Error : Vacuum fail.");

                            m_iGStep = 0;
                            m_iStep = 0;
                            return true;
                        }
                    }
					//200310 ksg : Spindle 부하
	                if(CData.Dev.aData[m_iWy].dSpdError > 0 && CData.GrData[m_iWy].dSplMaxLoad > CData.Dev.aData[m_iWy].dSpdError)
	                {
	                    m_NeedDrs = true;
	                    CIO.It.Set_Y(eY.GRDR_SplWater, false);
                        //CSpl.It.Write_Stop(m_eWy);  
                        // 2023.03.15 Max
                        CSpl_485.It.Write_Stop(m_eWy);

                        CMot.It.Mv_N((int)EAx.RightGrindZone_Z, 0);
                    
	                    CErr.Show(eErr.RIGHT_GRIND_SPINDLE_OVERLOAD);
                        _SetLog("Error : Spindle overload.  Load : " + CData.GrData[m_iWy].dSplMaxLoad + "%");

                        // 2020.11.20 SungTae : Alarm 발생 후 초기화
                        CData.GrData[m_iWy].dSplMaxLoad = 0;

                        m_iGStep = 0;
                        m_iStep = 0;
                        return true;
	                }
                }
                else
                {   // Unit 모드 시 버큠 체크
                    if (!Chk_Unit())
                    {
                        CIO.It.Set_Y(eY.GRDR_SplWater, false);
                        //CSpl.It.Write_Stop(m_eWy);
                        // 2023.03.15 Max
                        CSpl_485.It.Write_Stop(m_eWy);

                        CMot.It.Mv_N((int)EAx.RightGrindZone_Z, 0);

                        CErr.Show(eErr.RIGHT_GRIND_VACUUM_ERROR);
                        _SetLog("Error : Vacuum fail.");

                        m_iGStep = 0;
                        m_iStep = 0;
                        return true;
                    }
                }
            } //end : Right

            //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
            //if (CDataOption.UseDeviceAdvancedOption && CDataOption.UseAdvancedGrindCondition && (CDataOption.SplType == eSpindleType.EtherCat)) //Advanced Grind Condition 체크 사용 조건 (라이선스)
            // 2023.03.15 Max
            if (CDataOption.UseDeviceAdvancedOption && CDataOption.UseAdvancedGrindCondition)
            {
                if (0 != CheckAdvancedGrindCondition(0)) //여기서 체크하지만 Step 10에서 체크 시작 => Step 10 이 후부터 체크하게 됨
                {
                    if (m_bErrTableVacuumLow || m_bErrSpindleCurrentHigh)
                    {
                        //스핀들 과부하 => 드레싱 필요
                        if (m_bErrSpindleCurrentHigh)
                        { m_NeedDrs = true; }

                        //버퍼 모드 아니지만 일단 대기 시간 적용 (버퍼 모드의 경우 버퍼 스탑 후 모터 레디 대기 시간 설정)
                        m_Delay.Set_Delay(500);
                        _SetLog("Set delay : 500ms");

                        ResetAdvancedGrindCondition(0, false); //Condition 체크 플래그 리셋

                        m_iGStep = 300; //종료 처리 및 Alarm
                        return false;
                    }
                }
            }
            //..

            // Timeout check
            // 2020.09.16 JSKim St - Fine Grinding 진행 시 Table Speed 설정이 낮은 경우 Timeout 가 발생하여 수정
            // 시퀀스가 변경되면 m_iGStep == 20 도 변경해줘야 함
            //if (m_iGPreStep != m_iGStep)
            //{ m_mGTimeout.Set_Delay(TIMEOUT); }
            int nTimeOut = 30000;

            if (m_iGPreStep != m_iGStep)
            {
                // 2021.05.23 SungTae Start : [추가] 추가한 SVID(Actual Parameter(Spindle & Grd Y-Axis Speed)) Update 설정 Delay
                if (CData.CurCompany == ECompany.SPIL)
                {
                    m_ActualDelay.Set_Delay(1000);
                }
                // 2021.05.23 SungTae End

                //if (m_iGStep == 20 && m_dVelY >= 5)       // Table Speed 가 5미만인 경우 Timeout 시간이 너무 길어짐..
                //if (m_iGStep == 20 && m_dVelY >= 1)         // 2021.04.20 lhs
                if ((m_iGStep == 20 || m_iGStep == 27) && m_dVelY >= 1) // 2022.09.05 lhs : 20=Grd, 27=ReGrd 
                {
                    nTimeOut = Convert.ToInt32(Math.Abs(CData.Dev.aGrd_Y_End[m_iWy] - CData.Dev.aGrd_Y_Start[m_iWy]) / m_dVelY) * 1000 + 10000;
                    m_mGTimeout.Set_Delay(nTimeOut);
                }
                else
                {
                    m_mGTimeout.Set_Delay(TIMEOUT);
                }
            }
            // 2020.09.16 JSKim Ed
            else
            {
                if (m_mGTimeout.Chk_Delay())
                {
                    if (m_eWy == EWay.L)    { CErr.Show(eErr.LEFT_GRIND_STRIP_GRINDING_TIMEOUT);    }
                    else                    { CErr.Show(eErr.RIGHT_GRIND_STRIP_GRINDING_TIMEOUT);   }
                    _SetLog("Error : Timeout.");

                    m_iCnt = 0;
                    m_iGStep = 0;
                    return true;
                }

                // 2021.05.23 SungTae Start: [추가] 추가한 SVID(Actual Parameter(Spindle & Grd Y-Axis Speed)) Update 설정 Delay
                if (CData.CurCompany == ECompany.SPIL && m_ActualDelay.Chk_Delay())
                {
                    if (CData.GemForm != null)
                    {
                        if (m_iGStep < 15 || m_iGStep > 30) { 
                            CData.GemForm.OnSetAddSVID_ActualCycleDepth(m_eWy);
                        }
                        else
                        {
                            // 2021.06.30 SungTae Start : [수정] SPIL에서 Grinding 후 SW Down Issue 관련
                            //CData.GemForm.OnSetAddSVID_ActualCycleDepth(m_eWy, CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].bUse, m_iIndex);

                            if (m_iIndex < m_iStepMaxCnt) {
                                CData.GemForm.OnSetAddSVID_ActualCycleDepth(m_eWy, CData.Dev.aData[(int)m_eWy].aSteps[m_iIndex].bUse, m_iIndex);
                            }
                            // 2021.06.30 SungTae End
                        }

                        CData.GemForm.OnSetAddSVID_ActualSpeed();
                    }
                }
                // 2021.05.23 SungTae End
            }

            m_iGPreStep = m_iGStep;

            //if(CDataOption.SplType == eSpindleType.EtherCat)
            //{
            //    CData.Spls[0].iRpm =  Convert.ToInt32(CSpl.It.GetFrpm(true));
            //    CData.Spls[1].iRpm =  Convert.ToInt32(CSpl.It.GetFrpm(false));
            //}

            // 2023.03.15 Max : CSpl_485.cs에서 CData.Spls[(int)EWay.L].iRpm, CData.Spls[(int)EWay.R].iRpm 값 Update 되어
            // 하기 주석 처리
            //CData.Spls[(int)EWay.L].iRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.L));
            //CData.Spls[(int)EWay.R].iRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.R));

            switch (m_iGStep)
            {
                default:
                    {
                        m_iGStep = 0;
                        return true;
                    }

                case 10:    // 축 상태 체크, ReGrd 초기화,  Z축 옵셋 강제, 휠리미트 검사    
                    {
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iGStep = 0;
                            return true;
                        }
                        _SetLog("Check axes.");

                        // 200919 jym : 프로브 체크 flag
                        m_bUsePrbFlag = false;

                        m_bSubErr = false;

                        //20190618 ghk_dfserver
                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            if (!CData.dfInfo.bBusy)    {   CDf.It.SendGrdReady((m_eWy == EWay.L) ? "LGD" : "RGD"); }
                            else                        {   return false;   }
                        }

                        //20191111 ghk_regrindinglog
                        InitReGrd(m_iWy);    //List 초기화

                        m_iIndex    = 0;
                        m_iCnt      = 0;
                        m_iReCnt    = 0;
                        //20190421 ghk_휠 리그라인딩 옵셋
                        m_dStartHeight  = 0;
                        m_bRoughtLast   = false;
                        m_bFineCheck    = false;

                        // jhLee, Multi-LOT의 경우에도 SPC 기록
                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        if (CDataOption.IsChkDI && (CSQ_Main.It.m_iStat == EStatus.Auto_Running || CSQ_Main.It.m_bRun == true))
                        {//200708 pjh : Auto Running 중 일때만 Check
                            if (CData.Parts[m_iPart].bChkGrd == true)
                            {
                                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_DETECT_REJECT_STRIP_ERROR :
                                                              eErr.RIGHT_GRIND_DETECT_REJECT_STRIP_ERROR);
                                _SetLog("Error : Check DI.");

                                m_iGStep = 0;
                                return true;
                            }
                        }

                        //190419 ksg : Z축 옵셋 강제 10um 띄우는 옵셋 정하는 곳
                        if (CDataOption.ZUpOffset == eZUpOffset.Use)
                        {
                            m_ZPosUpOffset = 0.010;

                            if (CData.CurCompany == ECompany.Qorvo      || CData.CurCompany == ECompany.Qorvo_DZ ||
                                CData.CurCompany == ECompany.Qorvo_RT   || CData.CurCompany == ECompany.Qorvo_NC || // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                                CData.CurCompany == ECompany.SST)
                            { m_ZPosUpOffset = 0.004; }
                        }
                        else
                        {
                            m_ZPosUpOffset = 0;
                        }
                        _SetLog("Z axis up offset : " + m_ZPosUpOffset + "mm", true);

                        if (CData.CurCompany == ECompany.SCK || CData.CurCompany == ECompany.JSCK || CData.CurCompany == ECompany.JCET) //200121 ksg : , 200625 lks
                        {
                            if (!CIO.It.Get_Y(eY.IOZT_Power)) CIO.It.Set_Y(eY.IOZT_Power, true);  // SCK, JSCK, JCET
                            CData.Opt.bIOZT_ManualClick = false;    // 2021.09.15 lhs 수동클릭 아님
                        }
                        //휠 리미터 검사
                        if (CData.Whls[m_iWy].dWhlLimit > CData.Whls[m_iWy].dWhlAf)
                        {
                            //200730 jhc : Wheel/Dresser Limit Alaram 보류용 (ASE-Kr VOC)
                            if((CData.CurCompany != ECompany.ASE_KR) || (CData.bWhlDrsLimitAlarmSkip == false))
                            {
                                CSQ_Main.It.m_bWhlLimitArm = true;
                                frmMain.bShowWhlView = true;
                                m_Delay.Set_Delay(1000);
                                _SetLog("Wheel limit.  Wheel thickness : " + CData.Whls[m_iWy].dWhlLimit + "mm");

                                m_iGStep = 50; // Over Wheel thickness error
                                return false;
                            }
                        }
                        //200310 ksg : Spindle 부하
                        CData.GrData[m_iWy].dSplMaxLoad = 0;
                        CData.GrData[m_iWy].bSplLoadFlag = true;

                        //// 2022.08.30 lhs Start : Spindle Current (전류)
                        //CData.GrData[m_iWy].bSplMaxCurrFlag = true;    // 여기서만 true  // 임시로 사용 안되도록
                        //CData.GrData[m_iWy].bSplMinCurrFlag = true;    // 여기서만 true  // 임시로 사용 안되도록
                        //CData.GrData[m_iWy].nSplMaxCurr = 0;
                        //CData.GrData[m_iWy].nSplMinCurr = 999999;
                        //// 2022.08.30 lhs End

                        //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
                        ResetAdvancedGrindCondition(0, true); //Condition 검사 플래그 리셋
                        //..

                        //20200427 lks 시작시 초기화
                        m_bManualStop = false;

                        m_bSubErr = false;

                        m_iGStep++;
                        return false;
                    }

                case 11:    //IO 초기화
                    {
                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            if (m_eWy == EWay.L)    {   if (!CDf.It.ReciveAckGRL((int)ECMD.scGrdReadyL))    { return false; }   }
                            else                    {   if (!CDf.It.ReciveAckGRR((int)ECMD.scGrdReadyR))    { return false; }   }
                        }

                        _InitCycle();
                        //200414 ksg : 12 Step  기능 추가
                        CData.GrData[m_iWy].iStep  = 0;

                        CData.GrData[m_iWy].aInx   = new int    [m_iStepMaxCnt];
                        CData.GrData[m_iWy].aCnt   = new int    [m_iStepMaxCnt];
                        CData.GrData[m_iWy].aTar   = new double [m_iStepMaxCnt];
                        CData.GrData[m_iWy].aReNum = new int    [m_iStepMaxCnt];
                        CData.GrData[m_iWy].aReInx = new int    [m_iStepMaxCnt];
                        CData.GrData[m_iWy].aReCnt = new int    [m_iStepMaxCnt];
                        CData.GrData[m_iWy].a1Pt   = new double [m_iStepMaxCnt];

                        //201023 JSKim : Over Grinding Correction - Grinding Count Correction 기능
                        m_dRoughOver = 0.0;
                        ////////

                        _SetLog("Init data.");

                        m_iGStep++;
                        return false;
                    }

                case 12:    //데이터 저장 변수 초기화, m_iStep = 10, iPreStep = 0 
                    {
                        m_tGrT = new tTempData();

                        // 200317 mjy : 그라인딩 Start, End position 계산 후 설정
                        if (CDataOption.Package == ePkg.Unit)
                        {
                            int iUnit = 0;
                            double dPos = 0;

                            // Start position
                            iUnit = Cal_LastU();
                            // ([휠센터 <-> 테이블 센터 포지션] - ([휠 외경] / 2)) + [테이블 센터에서 해당 유닛 센터까지 거리]
                            // 해당 계산으로 휠팁이 마지막 유닛(휠에서 가장 가까운 유닛) 센터에 오는 위치 계산
                            dPos = (CData.MPos[m_iWy].dY_WHL_TBL_CENTER - (CData.Whls[m_iWy].dWhlO / 2)) + CData.Dev.aUnitCen[iUnit];
                            // [휠팁 <-> 마지막 유닛 센터] - ([자재 사이즈(세로) / 2] + [옵셋값])
                            CData.Dev.aGrd_Y_Start[m_iWy] = dPos - ((CData.Dev.dChipH / 2) + GV.GRD_WHL_OFFSET);
                            _SetLog(string.Format("Last unit : {0}  Start pos : {1}mm", iUnit, CData.Dev.aGrd_Y_Start[m_iWy]), true);

                            // End position
                            iUnit = Cal_FirstU();
                            // ([휠센터 <-> 테이블 센터 포지션] - ([휠 외경] / 2)) + [테이블 센터에서 해당 유닛 센터까지 거리]
                            // 해당 계산으로 휠팁이 마지막 유닛(휠에서 가장 가까운 유닛) 센터에 오는 위치 계산
                            dPos = (CData.MPos[m_iWy].dY_WHL_TBL_CENTER - (CData.Whls[m_iWy].dWhlO / 2)) + CData.Dev.aUnitCen[iUnit];
                            // [휠팁 <-> 마지막 유닛 센터] + ([자재 사이즈(세로) / 2] + [옵셋값])
                            CData.Dev.aGrd_Y_End[m_iWy] = dPos + ((CData.Dev.dChipH / 2) + GV.GRD_WHL_OFFSET);
                            _SetLog(string.Format("First unit : {0}  End pos : {1}mm", iUnit, CData.Dev.aGrd_Y_End[m_iWy]), true);
                        }

                        if (m_eWy == EWay.L) //왼쪽 테이블
                        {
                            m_tGrT.eIn1  = eX.GRDL_SplWater   ;
                            m_tGrT.eIn2  = eX.GRDL_SplBtmWater;
                            m_tGrT.eOt1  = eY.GRDL_SplWater   ;
                            m_tGrT.eOt2  = eY.GRDL_SplBtmWater;
                            m_tGrT.dPosX = CData.SPos.dGRD_X_Wait[m_iWy];

                            if (CData.Dev.aData[m_iWy].aSteps[0].eDir == eStartDir.Forward) { m_tGrT.dPosY = CData.Dev.aGrd_Y_Start[m_iWy]; }
                            else                                                            { m_tGrT.dPosY = CData.Dev.aGrd_Y_End[m_iWy];   }
                            //191019 ksg :
                            CData.GrData[m_iWy].aOldOnPont[0] = 0;
                        }
                        else //오른쪽 테이블
                        {
                            m_tGrT.eIn1  = eX.GRDR_SplWater;
                            m_tGrT.eIn2  = eX.GRDR_SplBtmWater;
                            m_tGrT.eOt1  = eY.GRDR_SplWater;
                            m_tGrT.eOt2  = eY.GRDR_SplBtmWater;
                            m_tGrT.dPosX = CData.SPos.dGRD_X_Wait[m_iWy];

                            if (CData.Dev.bDual == eDual.Normal)
                            {//노멀 모드 일경우 왼쪽 파라미터 사용
                                if (CData.Dev.aData[(int)EWay.L].aSteps[0].eDir == eStartDir.Forward)   { m_tGrT.dPosY = CData.Dev.aGrd_Y_Start[m_iWy]; }
                                else                                                                    { m_tGrT.dPosY = CData.Dev.aGrd_Y_End[m_iWy];   }
                            }
                            else
                            {//듀얼 모드 일경우 오른쪽 파라미터 사용
                                if (CData.Dev.aData[m_iWy].aSteps[0].eDir == eStartDir.Forward)         { m_tGrT.dPosY = CData.Dev.aGrd_Y_Start[m_iWy]; }
                                else                                                                    { m_tGrT.dPosY = CData.Dev.aGrd_Y_End[m_iWy];   }
                            }
                            //191019 ksg :
                            CData.GrData[m_iWy].aOldOnPont[0] = 0;
                        }

                        _SetLog("Calculate position.");

                        m_iStep = 10;
                        m_iPreStep = 0;
                        m_iGStep++;
                        return false;
                    }

                case 13:  //자재 높이 측정(Before)
                    {
                        // 200919 jym : 프로브 체크 flag
                        m_bUsePrbFlag = true;

                        m_bSubErr = false;

                        // 200903 jym : Timeout 초기화
                        m_mGTimeout.Set_Delay(TIMEOUT);

                        // 2020-12-14, jhLee : Motorizing probe measure
                        if (CDataOption.Package == ePkg.Strip)
                        {
                            if (Cyl_MeaStrip((int)EMeaStep.Before))    // Before
                            {
                                // 200919 jym : 프로브 체크 flag
                                m_bUsePrbFlag = false;

                                // 200920 jym : 에러 상태 시 사이클 중단
                                if (m_bSubErr)
                                {
                                    _SetLog("Error : Before measure.");
                                    m_iGStep = 0;
                                    return true;
                                }

                                _SetLog("Measure strip end.");
                                m_iGStep++;
                            }
                        }
                        else // Unit
                        {
                            //d if (Cyl_MeaUnit(0))
                            if ((CData.Opt.bPbType) ? Cyl_MeaUnit_ZMotor(0) : Cyl_MeaUnit(0))
                            {
                                // 200919 jym : 프로브 체크 flag
                                m_bUsePrbFlag = false;

                                // 200920 jym : 에러 상태 시 사이클 중단
                                if (m_bSubErr)
                                {
                                    _SetLog("Error : Before measure.");
                                    m_iGStep = 0;
                                    return true;
                                }

                                _SetLog("Measure unit end.");
                                m_iGStep++;
                            }
                        }

                        return false;
                    }

                case 14: //그라인딩 시작 위치 계산, 각 스텝 별 타켓 계산(기본 횟수)
                    {
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max 
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        //20200723 lks : 메저모드이면 그라인딩 스킵     // 2020.09.11 JSKim St
                        if (CData.Dev.bMeasureMode)
                        {
                            m_LogVal.iStep = m_iGStep;
                            m_LogVal.sMsg = "Measure Mode : " + CData.Dev.bMeasureMode;
                            SaveLog();
                            m_iGStep = 30;  //그라인딩 종료
                            m_iStep = 10;
                            m_iPreStep = 0;
                            return false;
                        }
                        // 2020.09.11 JSKim Ed

                        CData.GrdElp[m_iWy].dtStr = DateTime.Now;
                        m_CntTimeFlag = true;
                        m_WrongCalFlag = false; //190813 ksg :
                        m_WrongPCBThicknessFlag = false;    // 2021.07.30 SungTae 

                        // 2021.07.31 lhs Start : 새로운 Grind Process 추가 (SCK 전용)
                        if (CDataOption.UseNewSckGrindProc)
                        {
                            m_tGrT.dPosZ = Cal_GrdStart_NewSck(); // 함수안에서 m_WrongCalFlag 변경
                        }
                        else  // 기존방식
                        // 2021.07.31 lhs End
                        {
                            m_tGrT.dPosZ = Cal_GrdStart(); // 함수안에서 m_WrongCalFlag 변경
                        }
                        _SetLog("Calculate start position.", m_tGrT.dPosZ, true);

                        // 2021.07.30 SungTae Start : [추가] ASE-KR VOC로 Grinding이 완료된 자재가 재투입 시 Over Grinding 되는 Issue 관련 조건 추가
                        if (m_WrongPCBThicknessFlag)
                        {
                            if (m_eWy == EWay.L)
                            {
                                CErr.Show(eErr.LEFT_WRONG_PCB_THICKNESS_DATA_ERROR);
                                _SetLog("[ERROR] : LEFT_WRONG_PCB_THICKNESS_DATA_ERROR", true);

                                m_WrongPCBThicknessFlag = false;
                                m_iGStep = 0;
                                return true;
                            }
                        }
                        // 2021.07.30 SungTae End

                        //200708 pjh : Grinding 중 Error Check 변수
                        if (CData.Parts[m_iPart].bChkGrd == false)
                        { CData.Parts[m_iPart].bChkGrd = true; }

                        //20190421 ghk_휠 리그라인딩 옵셋
                        if(m_WrongCalFlag)
                        {
                            eErr eEr = (m_eWy == EWay.L) ? eErr.LEFT_WRONG_CALCULATOR_GRIND_START_POSITION :
                                                           eErr.RIGHT_WRONG_CALCULATOR_GRIND_START_POSITION;
                            CErr.Show(eEr);
                            _SetLog("Error : Wrong calcualte grind start position.");

                            m_iGStep = 0;
                            return true;
                        }

                        //201203 jhc : 드레싱 후 N번째 그라인딩 시 휠 소모량 보정 기능
                        if (CDataOption.UseDeviceAdvancedOption && CDataOption.UseWheelLossCorrect) //(DEVICE > PARAM > ADVANCED 메뉴 표시) + (드레싱 후 N번째 그라인딩 시 휠 소모량 보정 기능 사용)
                        {
                            if (m_TotalWheelLossLimitOver) //누적 Wheel Loss 제한량 초과 (Z축 과도 DOWN 제한 ==> 해제하려면 드레싱 해야 함)
                            {
                                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_WHEEL_LOSS_CORRECT_LIMIT_OVER : eErr.RIGHT_WHEEL_LOSS_CORRECT_LIMIT_OVER);
                                _SetLog("Error : Total Wheel Loss Correction Limit Over.");

                                m_TotalWheelLossLimitOver = false;

                                m_iGStep = 0;
                                return true;
                            }
                        }
                        //

                        if (CData.Whls[m_iWy].dReGrdOffset > 0)
                        {
                            m_tGrT.dPosZ += CData.Whls[m_iWy].dReGrdOffset;
                            _SetLog("Wheel Regrinding Offset : " + CData.Whls[m_iWy].dReGrdOffset + "mm", true);
                        }

                        m_WrongCalFlag = false; //190813 ksg :

                        Cal_GrdTarget();    
                        _SetLog("Calculate target position.");

                        if (m_WrongCalFlag)
                        {
                            eErr eEr = (m_eWy == EWay.L) ? eErr.LEFT_WRONG_CALCULATOR_GRIND_TARGET_POSITION :
                                                           eErr.RIGHT_WRONG_CALCULATOR_GRIND_TARGET_POSITION;
                            CErr.Show(eEr);
                            _SetLog("Error : Wrong calcualte grind target position.");

                            m_iGStep = 0;
                            return true;
                        }

                        //191118 ksg :
                        if(CData.GemForm != null)
                        {
                            if(m_eWy == EWay.L) {   CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].nUnit_LEFT_Work_Start_Cnt++;     }
                            else                {   CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].nUnit_RIGHT_Work_Start_Cnt++;   }

                            CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].nUnit_TOTAL_Work_Start_Cnt = CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].nUnit_LEFT_Work_Start_Cnt +
                                                                                                                CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].nUnit_RIGHT_Work_Start_Cnt;
                        }
                        m_iGStep++;
                        return false;
                    }

                case 15:  //== 스텝 바뀌었을때 그라인딩 반복 시작 시점 == 스텝별 파라미터 선택, Y축 그라인딩 시작 위치 이동
                    {
                        if(CData.Dev.bDual == eDual.Normal) //스텝 모드 아닐 경우, 테이블 왼쪽 오른쪽 상관 없이 왼쪽 파라미터 사용
                        {
                            if (m_iIndex > m_iStepMaxCnt - 1)    //그라인딩 종료
                            {
                                //CSpl.It.Write_Stop(m_eWy);          //스핀들 정지
                                // 2023.03.15 Max
                                CSpl_485.It.Write_Stop(m_eWy);

                                CIO.It.Set_Y(m_tGrT.eOt1, false);   //그라인딩 워터 오프
                                CIO.It.Set_Y(m_tGrT.eOt2, false);   //그라인딩 바텀 워터 오프
                                //200515 myk : Wheel Cleaner Water 추가 -> 200728 jym : 휠 클린 노즐 Skip 기능 추가
                                if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                                { CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_WhlCleaner : eY.GRDR_WhlCleaner, false); }    //휠 클리너 워터 오프

                                _SetLog("Normal mode.  Grinding end.  Index : " + m_iIndex, true);

                                m_iStep     = 10;
                                m_iPreStep  = 0;
                                m_iGStep    = 30;  //그라인딩 종료
                                return false;
                            }

                            if (!CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].bUse)    //해당 스텝 사용 안할 경우, 다음 스텝으로 이동
                            {
                                m_iIndex++;

                                if (m_iIndex > m_iStepMaxCnt - 1)   //그라인딩 종료
                                {
                                    //CSpl.It.Write_Stop(m_eWy);          //스핀들 정지
                                    // 2023.03.15 Max
                                    CSpl_485.It.Write_Stop(m_eWy);

                                    CIO.It.Set_Y(m_tGrT.eOt1, false);   //그라인딩 워터 오프
                                    CIO.It.Set_Y(m_tGrT.eOt2, false);   //그라인딩 바텀 워터 오프
                                    //200515 myk : Wheel Cleaner Water 추가 -> 200728 jym : 휠 클린 노즐 Skip 기능 추가
                                    if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                                    { CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_WhlCleaner : eY.GRDR_WhlCleaner, false); }    //휠 클리너 워터 오프

                                    _SetLog("Normal mode.  Grinding end.  Index : " + m_iIndex, true);

                                    m_iStep     = 10;
                                    m_iPreStep  = 0;
                                    m_iGStep    = 30;  //그라인딩 종료
                                }
                                return false;
                            }
                            else
                            {//해당 스텝 사용 할 경우, 스텝 파라미터 및 테이블 시작위치 값 설정 *****Fine 그라인딩 경우 조건 추가 해야됨

                                //201023 JSKim : Over Grinding Correction - Grinding Count Correction 기능
                                if (CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].bOverGrdCorrectionUse)
                                {
                                    if (CData.Opt.bOverGrdCountCorrectionUse)
                                    {
                                        if (OverGrindingCountCorrection() == false)
                                        {
                                            m_iIndex++;

                                            if (m_iIndex > (m_iStepMaxCnt - 1))
                                            {
                                                //그라인딩 종료
                                                //CSpl.It.Write_Stop(m_eWy);          //스핀들 정지
                                                // 2023.03.15 Max
                                                CSpl_485.It.Write_Stop(m_eWy);

                                                CIO.It.Set_Y(m_tGrT.eOt1, false);   //그라인딩 워터 오프
                                                CIO.It.Set_Y(m_tGrT.eOt2, false);   //그라인딩 바텀 워터 오프
                                                //200515 myk : Wheel Cleaner Water 추가 -> 200728 jym : 휠 클린 노즐 Skip 기능 추가
                                                if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                                                { CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_WhlCleaner : eY.GRDR_WhlCleaner, false); } //휠 클리너 워터 오프

                                                _SetLog("NORMAL mode - OverGrinding Correction. Grinding end.  Index : " + m_iIndex);

                                                m_iStep = 10;
                                                m_iPreStep = 0;
                                                m_iGStep = 30;  //그라인딩 종료

                                                ///////////////////////////////////////////
                                                m_dRoughOver = 0.0; //오버그라인딩 값 초기화
                                                ///////////////////////////////////////////
                                            }
                                            return false;
                                        }
                                    }
                                }
                                ////////

                                if (m_iIndex == m_iStepMaxCnt - 1 && !m_bFineCheck)     //Fine Grinding 일 경우
                                {
                                    if(CData.Dev.aData[(int)EWay.L].eFine == eFineMode.WheelInsp)
                                    {//휠 인스펙션 스텝으로 이동
                                        m_bFineCheck = true;
                                        _SetLog("Normal mode.  Fine step.  Wheel inspection.", true);

                                        m_iStep     = 10;
                                        m_iPreStep  = 0;
                                        m_iGStep    = 28;
                                        return false;
                                    }
                                    else
                                    {//보정 값 적용
                                        m_tGrT.dPosZ -= CData.Dev.aData[m_iWy].dCpen;
                                        m_bFineCheck = true;
                                        _SetLog("Normal mode.  Fine step.  Compensation : " + CData.Dev.aData[m_iWy].dCpen + "mm", true);
                                    }
                                }

                                if (CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].eDir == eStartDir.Forward)
                                {
                                    m_tGrT.dPosY = CData.Dev.aGrd_Y_Start[m_iWy];
                                }
                                else
                                {
                                    m_tGrT.dPosY = CData.Dev.aGrd_Y_End[m_iWy];
                                }
                                m_dVelY = CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].dTblSpd;
                                m_iRpm  = CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].iSplSpd;
                                m_dCylZ = CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].dCycleDep;
                            }
                        }
                        else  //Dual //스텝 모드 일 경우, 테이블 왼쪽 오른쪽 각각 파라미터 사용
                        {
                            if (m_iIndex > m_iStepMaxCnt - 1)   //그라인딩 종료
                            {
                                //CSpl.It.Write_Stop(m_eWy);  //스핀들 정지
                                // 2023.03.15 Max
                                CSpl_485.It.Write_Stop(m_eWy);

                                Func_SplWater(false);       //그라인딩 워터 오프
                                Func_BtmWater(false);       //그라인딩 바텀 워터 오프   
                                //200515 myk : Wheel Cleaner Water 추가 -> 200728 jym : 휠 클린 노즐 Skip 기능 추가
                                if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                                { Func_WhlClnWater(false); }    //휠 클리너 워터 오프

                                _SetLog("Dual mode.  Grinding end.  Index : " + m_iIndex, true);

                                m_iStep     = 10;
                                m_iPreStep  = 0;
                                m_iGStep    = 30;  //그라인딩 종료
                                return false;
                            }

                            if (!CData.Dev.aData[m_iWy].aSteps[m_iIndex].bUse)
                            {//해당 스텝 사용 안할 경우, 다음 스텝으로 이동
                                m_iIndex++;

                                if (m_iIndex > m_iStepMaxCnt - 1)       //그라인딩 종료
                                {
                                    //CSpl.It.Write_Stop(m_eWy);  //스핀들 정지
                                    // 2023.03.15 Max
                                    CSpl_485.It.Write_Stop(m_eWy);

                                    Func_SplWater(false);       //그라인딩 워터 오프
                                    Func_BtmWater(false);       //그라인딩 바텀 워터 오프
                                    //200515 myk : Wheel Cleaner Water 추가 -> 200728 jym : 휠 클린 노즐 Skip 기능 추가
                                    if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                                    { Func_WhlClnWater(false); }    //휠 클리너 워터 오프

                                    _SetLog("Dual mode.  Grinding end.  Index : " + m_iIndex, true);

                                    m_iStep    = 10;
                                    m_iPreStep = 0;
                                    m_iGStep   = 30;  //그라인딩 종료
                                }
                                return false;
                            }
                            else
                            {//해당 스텝 사용 할 경우, 스텝 파라미터 및 테이블 시작위치 값 설정 *****Fine 그라인딩 경우 조건 추가 해야됨

                                //201023 JSKim : Over Grinding Correction - Grinding Count Correction 기능
                                if (CData.Dev.aData[m_iWy].aSteps[m_iIndex].bOverGrdCorrectionUse)
                                {
                                    if (CData.Opt.bOverGrdCountCorrectionUse)
                                    {
                                        if (OverGrindingCountCorrection() == false)
                                        {
                                            m_iIndex++;

                                            if (m_iIndex > (m_iStepMaxCnt - 1))
                                            {
                                                //그라인딩 종료
                                                //CSpl.It.Write_Stop(m_eWy);      //스핀들 정지
                                                // 2023.03.15 Max
                                                CSpl_485.It.Write_Stop(m_eWy);

                                                Func_SplWater(false);           //그라인딩 워터 오프
                                                Func_BtmWater(false);           //그라인딩 바텀 워터 오프
                                                //200515 myk : Wheel Cleaner Water 추가 -> 200728 jym : 휠 클린 노즐 Skip 기능 추가
                                                if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                                                { Func_WhlClnWater(false); }    //휠 클리너 워터 오프

                                                _SetLog("STEP mode - OverGrinding Correction. Grinding end.  Index : " + m_iIndex);

                                                m_iStep = 10;
                                                m_iPreStep = 0;
                                                m_iGStep = 30;  //그라인딩 종료

                                                ///////////////////////////////////////////
                                                m_dRoughOver = 0.0; //오버그라인딩 값 초기화
                                                ///////////////////////////////////////////
                                            }
                                            return false;
                                        }
                                    }
                                }
                                ////////

                                if (m_iIndex == m_iStepMaxCnt - 1 && !m_bFineCheck)     // 2020.09.08 SungTae : Modify
                                {//Fine Grinding 일 경우
                                    if (CData.Dev.aData[m_iWy].eFine == eFineMode.WheelInsp)
                                    {//휠 인스펙션 스텝으로 이동
                                        m_bFineCheck = true;
                                        _SetLog("Dual mode.  Fine step.  Wheel inspection.", true);  // 2022.01.04 lhs : 오타수정 Normal -> Dual

                                        m_iStep = 10;
                                        m_iPreStep = 0;
                                        m_iGStep = 28;
                                        return false;
                                    }
                                    else
                                    {//보정 값 적용
                                        m_tGrT.dPosZ -= CData.Dev.aData[m_iWy].dCpen;
                                        m_bFineCheck = true;
                                        _SetLog("Dual mode.  Fine step.  Compensation : " + CData.Dev.aData[m_iWy].dCpen + "mm", true);
                                    }
                                }

                                if (CData.Dev.aData[m_iWy].aSteps[m_iIndex].eDir == eStartDir.Forward)
                                {//해당 스텝 Forward 일경우 Y축 시작 위치                
                                    m_tGrT.dPosY = CData.Dev.aGrd_Y_Start[m_iWy];
                                }
                                else
                                {//해당 스텝 Backward 일경우 Y축 시작 위치
                                    m_tGrT.dPosY = CData.Dev.aGrd_Y_End[m_iWy];
                                }
                                m_dVelY = CData.Dev.aData[m_iWy].aSteps[m_iIndex].dTblSpd;
                                m_iRpm  = CData.Dev.aData[m_iWy].aSteps[m_iIndex].iSplSpd;
                                m_dCylZ = CData.Dev.aData[m_iWy].aSteps[m_iIndex].dCycleDep;
                            }
                        }

                        //200414 ksg : 12 Step  기능 추가
                        if (m_iCnt == 0 && m_iIndex != 0 && m_iIndex != m_iStepMaxCnt - 1)     
                        {
                            m_tGrT.dPosZ -= m_ZPosUpOffset; //Z축 옵셋 //190419 ksg :
                        }

                        CMot.It.Mv_N(m_iY, m_tGrT.dPosY);
                        _SetLog("Y axis move position.", m_tGrT.dPosY);

                        m_iGStep++;
                        return false;
                    }

                case 16: //==스텝 안에서 반복 시점 == Y축 그라인딩 시작 위치 이동 확인, Y축 그라인딩 종료 위치 설정, 스핀들 회전
                    {
                        if (!CMot.It.Get_Mv(m_iY, m_tGrT.dPosY))
                        {
                            CMot.It.Mv_N(m_iY, m_tGrT.dPosY);
                            return false;
                        }

                        if (CData.Dev.bDual == eDual.Normal)
                        {//노멀 모드 일 경우
                            if (CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].eDir == eStartDir.Forward)
                            {//해당 스텝 Forward 일경우 Y축 종료 위치
                                if ((m_iCnt % 2) == 0)  {   m_tGrT.dPosY = CData.Dev.aGrd_Y_End[m_iWy];     }
                                else                    {   m_tGrT.dPosY = CData.Dev.aGrd_Y_Start[m_iWy];   }
                            }
                            else
                            {//해당 스텝 Backward 일경우 Y축 종료 위치
                                if ((m_iCnt % 2) == 0)  {   m_tGrT.dPosY = CData.Dev.aGrd_Y_Start[m_iWy];   }
                                else                    {   m_tGrT.dPosY = CData.Dev.aGrd_Y_End[m_iWy];     }
                            }
                        }
                        else
                        {//듀얼 모드 일 경우
                            if (CData.Dev.aData[m_iWy].aSteps[m_iIndex].eDir == eStartDir.Forward)
                            {//해당 스텝 Forward 일경우 Y축 종료 위치
                                if ((m_iCnt % 2) == 0)  {   m_tGrT.dPosY = CData.Dev.aGrd_Y_End[m_iWy];     }
                                else                    {   m_tGrT.dPosY = CData.Dev.aGrd_Y_Start[m_iWy];   }
                            }
                            else
                            {//해당 스텝 Backward 일경우 Y축 종료 위치
                                if ((m_iCnt % 2) == 0)  {   m_tGrT.dPosY = CData.Dev.aGrd_Y_Start[m_iWy];   }
                                else                    {   m_tGrT.dPosY = CData.Dev.aGrd_Y_End[m_iWy];     }
                            }
                        }

                        //20200427 메뉴얼 정지버튼
                        if (m_bManualStop)
                        {
                            //그라인딩 종료                            
                            CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Wait[m_iWy]);// 스핀들 올리기
                            //CSpl.It.Write_Stop(m_eWy);    //스핀들 정지
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            Func_SplWater(false);    //그라인딩 워터 오프
                            Func_BtmWater(false);    //그라인딩 바텀 워터 오프
                            //200515 myk : Wheel Cleaner Water 추가 -> 200728 jym : 휠 클린 노즐 Skip 기능 추가
                            if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                            { Func_WhlClnWater(false); }    //휠 클리너 워터 오프

                            _SetLog("Manual stop.");

                            m_iStep = 10;
                            m_iPreStep = 0;
                            m_iGStep = 40;
                        }
                        else
                        {
                            //CSpl.It.Write_Run(m_eWy, m_iRpm);
                            // 2023.03.15 Max
                            bool bExit = false;
                            bool bTimeOutFlag = false;

                            // RPM Setting
                            CSpl_485.It.Write_Rpm(m_eWy, m_iRpm);
                            m_Timout_485.Set_Delay(300);
                            do
                            {
                                Application.DoEvents();
                                if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                                bExit = CSpl_485.It.GetAcceptRPMSpindle(m_eWy);
                            } while (bExit != true);
                            CSpl_485.It.SetAcceptRPMSpindle(m_eWy);

                            if (bTimeOutFlag)
                            {
                                if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                                if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                                return false;
                            }

                            // Spindle RUN
                            bExit = false;
                            bTimeOutFlag = false;
                            CSpl_485.It.Write_Run(m_eWy);
                            m_Timout_485.Set_Delay(300);
                            do
                            {
                                Application.DoEvents();
                                if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                                bExit = CSpl_485.It.GetAcceptRunSpindle(m_eWy);
                            } while (bExit != true);
                            CSpl_485.It.SetAcceptRunSpindle(m_eWy);

                            if (bTimeOutFlag)
                            {
                                if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_RUN_RPM_ERROR);
                                if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_RUN_RPM_ERROR);
                                return false;
                            }

                            _SetLog("Spindle run.  Vel : " + m_iRpm + "rpm", true);

                            //m_mSpl_Chk.Set_Delay(300); // 2023.03.15 Max Spindle RPM Check Delay

                            m_iGStep++;
                        }
                        return false;
                    }

                case 17: //스핀들 RPM 확인, Z축 그라인딩 시작 위치 이동
                    {
                        //if (!m_mSpl_Chk.Chk_Delay()) { return false; } // 2023.03.15 Max Spindle RPM Check Delay

                        if (CData.Spls[m_iWy].iRpm  < (m_iRpm - 20)) // 2023.03.15 Max Spindle RPM Check
                        {
                            _SetLog("Spindle RPM Get : " + CData.Spls[m_iWy].iRpm); // 2023.03.15 Max Spindle RPM Check

                            //CSpl.It.Write_Run(m_eWy, m_iRpm);   //191018 ksg :

                            //m_mSpl_Chk.Set_Delay(300); // 2023.03.15 Max Spindle RPM Check Delay

                            return false;
                        }

                        _SetLog("Spindle RPM Get END: " + CData.Spls[m_iWy].iRpm); // 2023.03.15 Max Spindle RPM Check - 확인용

                        // 2022.09.27 lhs Start : R1 Option 적용, AppCylDepOnFirst
                        if (CData.Dev.aData[m_iWy].bAppCylDepOnFirst)
                        {
                            if (m_iIndex == 0 && m_iCnt == 0) // 첫 Step, 첫 Count에서 Cycle Depth 적용
                            {
                                m_tGrT.dPosZ += m_dCylZ;
                                _SetLog("bAppCylDepOnFirst position = ", m_tGrT.dPosZ, true);
                            }
                        }
                        // 2022.09.27 lhs End

                        if (!(m_iIndex == 0 && m_iCnt == 0))    // 맨처음 사이클 빼고는 사이클 뎁스 적용
                        {
                            m_tGrT.dPosZ += m_dCylZ;
                        }
                        
                        CMot.It.Mv_S(m_iZ, m_tGrT.dPosZ);
                        _SetLog("Z axis move position(slow).", m_tGrT.dPosZ);

                        m_iGStep++;
                        return false;
                    }

                case 18: //Z축 그라인딩 시작위치 이동 확인, 그라인딩 워터 온, 그라인딩 바텀 워터 온
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_tGrT.dPosZ, GV.INPOS_GRD_CYCLE))
                        { return false; }

                        Func_SplWater(true);    //그라인딩 워터 온
                        Func_BtmWater(true);    //그라인딩 바텀 워터 온
                        //200515 myk : Wheel Cleaner Water 추가 -> 200728 jym : 휠 클린 노즐 Skip 기능 추가
                        if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                        { Func_WhlClnWater(true); }    //휠 클리너 워터 온
                        _SetLog("Spindle water on,  Bottom water on.");

                        m_iGStep++;
                        return false;
                    }

                case 19: //그라인딩 워터 온 확인, 그라인딩 바텀 워터 온 확인, 테이블 이동(그라인딩)
                    {
                        if (CIO.It.Get_X(m_tGrT.eIn1) && CIO.It.Get_X(m_tGrT.eIn2))
                        {
                            CMot.It.Mv_V(m_iY, m_tGrT.dPosY, m_dVelY);
                            _SetLog("Y axis move position.  Vel : " + m_dVelY + "mm/s", m_tGrT.dPosY);

                            // 201006 jym st
                            if (CDataOption.IsChkDI)
                            { m_tmChkDI.Set_Delay(CData.Opt.iChkDiTime); }
                            // 201006 jym ed

                            m_iGStep++;
                        }

                        return false;
                    }

                case 20: //테이블 이동 확인, 스텝 종료 여부 확인,
                    {
                        if (CDataOption.IsChkDI && !Chk_GrdWater(m_eWy))
                        {
                            //201006 jym : Time 추가 -> 200616 pjh : Grinding Water Check
                            if (CData.Opt.iChkDiTime != 0 && !m_tmChkDI.Chk_Delay())
                            {
                                return false;
                            }

                            _SetLog("Check DI fail.");

                            m_iGStep = 80;
                            return false;
                        }

                        if (!CMot.It.Get_Mv(m_iY, m_tGrT.dPosY, GV.INPOS_TBL))
                        {
                            //201202 jhc : 로그 추가
                            _SetLog(string.Format("Grind-Count [{0}/{1}], Y[{2}], Z[{3}], Load[{4}] Amp[{5}] Temp[{6}] RPM[{7}] Vac[{8}]", 
                                                               (m_iCnt+1).ToString(), CData.GrData[m_iWy].aCnt[m_iIndex].ToString(),
                                                               CMot.It.Get_FP(m_iY).ToString("0.00000"), 
                                                               CMot.It.Get_FP(m_iZ).ToString("0.00000"),
                                                               CData.Spls[m_iWy].dLoad.ToString(),
                                                               CData.Spls[m_iWy].nCurrent_Amp.ToString(),   // Grind
                                                               CData.Spls[m_iWy].dTemp_Val.ToString(),
                                                               CData.Spls[m_iWy].iRpm.ToString(),
                                                               CData.Parts[m_iPart].dChuck_Vacuum.ToString("0.0")));

                            ////-----------------------------------------------
                            //// 2022.08.30 lhs Start
                            //// Grinding시 Spindle의 최대/최소 전류 얻기
                            //int nCurr    = CData.Spls[m_iWy].nCurrent_Amp;
                            //int nMaxCurr = CData.GrData[m_iWy].nSplMaxCurr;
                            //int nMinCurr = CData.GrData[m_iWy].nSplMinCurr;

                            //if (nMaxCurr < nCurr) CData.GrData[m_iWy].nSplMaxCurr = nCurr;
                            //if (nMinCurr > nCurr) CData.GrData[m_iWy].nSplMinCurr = nCurr;
                            //// 2022.08.30 lhs End
                            ////-----------------------------------------------

                            return false;
                        }

                        m_iCnt++;
                        CData.GrData[m_iWy].aInx[m_iIndex] = m_iCnt;

                        //if(m_iCnt >= m_aGrd[m_iIndex])
                        // 200818 jym : 카운트 변수 변경
                        if (m_iCnt >= CData.GrData[m_iWy].aCnt[m_iIndex])
                        {//스텝 종료, 스핀들 정지, 그라인딩 워터 오프, 바텀 워터 오프,리그라인딩 유무 확인 스텝 이동
                            m_iCnt     = 0 ;                            
                            m_iStep    = 10;
                            m_iPreStep = 0 ;

                            //CSpl.It.Write_Stop(m_eWy);  //스핀들 정지
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);


                            CIO.It.Set_Y(m_tGrT.eOt1, false);    //그라인딩 워터 오프
                            CIO.It.Set_Y(m_tGrT.eOt2, false);    //그라인딩 바텀 워터 오프
                                                                 //200515 myk : Wheel Cleaner Water 추가 -> 200728 jym : 휠 클린 노즐 Skip 기능 추가
                            if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                            { Func_WhlClnWater(false); }    //휠 클리너 워터 오프

                            m_WrongCalFlag = false; //191018 ksg :
                            // 200920 jym : 프로브 반복 체크 초기화
                            m_iWrongCnt = 0;

                            _SetLog(string.Format("Step loop end.  Index : {0}  Count : {1}", m_iIndex, m_iCnt), true);

                            m_iGStep++;
                        }
                        else
                        {//스텝 종료 안됨, 스텝 반복 시작 위치로 이동
                            _SetLog(string.Format("Step loop.  Index : {0}  Count : {1}", m_iIndex, m_iCnt));
                            m_iGStep = 16;
                        }
                        return false;
                    }

                case 21: // One 포인트 측정
                    {
                        // 200327 mjy : 리그라인딩 스킵 사용시 스킵 판정 하여 진행
                        if ( (CDataOption.IsReSkip && CData.Dev.aData[m_iWy].aSteps[m_iIndex].bReSkip) || 
                             (m_iIndex == 0        && CData.Dev.aData[m_iWy].bAppLargeCylDep) )             // 2022.09.27 lhs : Large Depth일 경우 리그라인딩 스킵 추가
                        {
                            if (CDataOption.IsReSkip && CData.Dev.aData[m_iWy].aSteps[m_iIndex].bReSkip) 
                                _SetLog("Regrinding skip.  Index : " + m_iIndex, true);
                            if (m_iIndex == 0 && CData.Dev.aData[m_iWy].bAppLargeCylDep)        // 2022.09.27 lhs : Large Depth 그라인딩 추가            
                                _SetLog("Large Depth Grinding.  Index : " + m_iIndex, true);

                            m_iIndex++;

                            // 200919 jym : 프로브 체크 flag
                            m_bUsePrbFlag = false;

                            //201023 JSKim : Over Grinding Correction - Grinding Count Correction 기능
                            m_dRoughOver = 0.0; //리그라인딩 스킵 -> One Point 측정 스킵 -> 오버그라인딩 값 초기화
                            ////////

                            m_iGStep = 15;  //스텝 바뀌었을때 그라인딩 반복 시작 시점
                            return false;
                        }

                        if (m_iIndex == m_iStepMaxCnt - 1)      // 2020.09.08 SungTae : Modify
                        {
                            _SetLog("Index full.  Index : " + m_iIndex);
                            m_iIndex++;

                            // 200919 jym : 프로브 체크 flag
                            m_bUsePrbFlag = false;

                            m_iGStep = 15; // 스텝 바뀌었을때 그라인딩 반복 시작 시점 -> 그라인딩 종료
                            return false;
                        }

                        // 200919 jym : 프로브 체크 flag
                        m_bUsePrbFlag = true;

                        m_bSubErr = false;

                        // 200903 jym : Timeout 초기화
                        m_mGTimeout.Set_Delay(TIMEOUT);

                        // 2020-12-14, jhLee, One point 측정도 Motorize 구현
                        if ((CData.Opt.bPbType) ? Cyl_MeaStripOne_ZMotor() : Cyl_MeaStripOne())
                        {
                            // 200920 jym : Limit 검사 이후 잘못 되면 반복 측정
                            if (m_WrongCalFlag)
                            {
                                m_iWrongCnt++;

                                if (m_iWrongCnt == GV.MEASURE_RETRY)
                                {
                                    if (m_eWy == EWay.L)    {   CErr.Show(eErr.LEFT_ONE_POINT_VALUE_WRONG);     }
                                    else                    {   CErr.Show(eErr.RIGHT_ONE_POINT_VALUE_WRONG);    }

                                    m_WrongCalFlag = false;
                                    // 200919 jym : 프로브 체크 flag
                                    m_bUsePrbFlag = false;
                                    _SetLog("Error : 1 point measure fail.");

                                    m_iGStep = 0;
                                    return true;
                                }
                                else
                                {
                                    m_iStep = 10;
                                    m_iPreStep = 0;
                                    m_WrongCalFlag = false;
                                    _SetLog("1 point measure fail.  Retry.  Count : " + m_iWrongCnt);

                                    return false;
                                }
                            }
                            //211006 pjh : One point Error 발생 시 Sequence Stop
                            if (m_bProbeAbnormalCheck)
                            {
                                m_bProbeAbnormalCheck = false;

                                m_iGStep = 0;
                                return true;
                            }
                            //

                            m_dRoughtTotal = (m_dInspGrd - CData.GrData[m_iWy].aTar[m_iIndex]);

                            //20190421 ghk_휠 리그라인딩 옵셋
                            if (m_iIndex == 0)  // Rough1
                            {
                                if (m_dInspGrd >= (m_dStartHeight - 0.001))
                                {
                                    CData.Whls[m_iWy].dReGrdOffset += (m_dRoughtTotal - (m_dRoughtTotal / 3));
                                    _SetLog("Wheel Regrinding Offset : " + CData.Whls[m_iWy].dReGrdOffset + "mm", true);
                                }
                            }

                            // 200919 jym : 프로브 체크 flag
                            m_bUsePrbFlag = false;

                            m_iReCnt = 0;
                            _SetLog("Measure one point finish.");

                            m_iGStep++;
                        }

                        return false;
                    }

                case 22: //[리그라인딩] 유무 확인 및 스텝 종료 여부 확인
                    {
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max 
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);


                            return false;
                        }

                        //201023 JSKim : Over Grinding Correction - Grinding Count Correction 기능
                        if (CData.Opt.bOverGrdCountCorrectionUse && 
                            //CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].bOverGrdCorrectionUse &&
                            (m_dRoughtTotal < 0))
                        {
                            // 오버 그라인딩 발생
                            _SetLog("OverGrinding Correction.   RoughtTotal : " + m_dRoughtTotal);
                            m_dRoughOver = Math.Abs(m_dRoughtTotal);
                        }
                        else
                        {
                            // 오버 그라인딩 미 발생
                            m_dRoughOver = 0.0; //오버그라인딩 값 초기화
                        }
                        ////////

                        // 2020.08.19 JSKim St
                        double dOver = -(CData.Dev.aData[(CData.Dev.bDual == eDual.Normal) ? (int)EWay.L : m_iWy].dOneOver);

                        if (dOver != 0 && m_dRoughtTotal <= dOver)
                        {
                            if (m_eWy == EWay.L)    {   CErr.Show(eErr.LEFT_ONE_POINT_OVER_GRIND_CHECK_ERROR);  }
                            else                    {   CErr.Show(eErr.RIGHT_ONE_POINT_OVER_GRIND_CHECK_ERROR); }

                            _SetLog("Error : Over Grinding Check one point.");

                            //201023 JSKim : Over Grinding Correction - Grinding Count Correction 기능
                            m_dRoughOver = 0.0; //Over Grinding Error 기능을 사용하여 Error 발생 시 보정 불필요
                            ////////

                            // 2021-06-17, jhLee : Skyworks VOC, One Point Over-Grinding alram이 발생하더라도 기 수행된 그라인딩에 대해서는 카운트를 해줘야 한다.
                            if (CData.Dev.bMeasureMode == false)
                            {
                                // 드레싱 작업을 위한 그라인딩 횟수 누적
                                CData.Whls[m_iWy].iGtc++;
                                CData.Whls[m_iWy].iGdc++;

                                //210706 pjh : Add Log and save function of After Dressing Count
                                CData.WhlsLog[m_iWy].iGtc++;
                                CData.WhlsLog[m_iWy].iDrsCycleStrip++;

                                _SetLog(string.Format("Wheel total count : {0}  After dressing count : {1}", CData.Whls[m_iWy].iGtc, CData.Whls[m_iWy].iGdc), true);
                                CWhl.It.Save(m_eWy, CData.Whls[m_iWy]);
                                //
                            }

                            m_iGStep = 0;
                            return true;
                        }
                        // 2020.08.19 JSKim Ed

                        // 200327 mjy : 리그라인딩 판정 조건 디바이스 파라메터에서 가져옴
                        if (CDataOption.IsReJudge)
                        {
                            m_ReGrdDep = CData.Dev.aData[m_iWy].aSteps[m_iIndex].dReJud;
                        }
                        else
                        {
                            //190711 ksg : 리그라인딩 조건을 낮춤(Fine에 영향을 줌)
                            if (CData.CurCompany == ECompany.Qorvo      || CData.CurCompany == ECompany.Qorvo_DZ ||
                                CData.CurCompany == ECompany.Qorvo_RT   || CData.CurCompany == ECompany.Qorvo_NC ||  // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                                CData.CurCompany == ECompany.SST)
                            {
								m_ReGrdDep = 0.0017;
							}
							else
							{
								m_ReGrdDep = 0.003;
							}
						}

                        if (m_dRoughtTotal > m_ReGrdDep)  //3um 이상 언더 발생시 리그라인딩, 테이블 테이블 시작 위치 이동,  리그라인딩 횟수 계산
                        {
                            if (CData.Dev.bDual == eDual.Normal) //노멀 모드 일 경우, 왼쪽 파라미터 사용
                            {
                                if (CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].eDir == eStartDir.Forward)
                                {//해당 스텝 Forward 일 경우
                                    m_tGrT.dPosY = CData.Dev.aGrd_Y_Start[m_iWy];
                                }
                                else
                                {//해당 스텝 Backward 일 경우      
                                    m_tGrT.dPosY = CData.Dev.aGrd_Y_End[m_iWy];
                                }
                            }
                            else   //스텝 모드 일 경우, 각각 파라미터 사용
                            {
                                if (CData.Dev.aData[m_iWy].aSteps[m_iIndex].eDir == eStartDir.Forward)
                                {//해당 스텝 Forward 일 경우
                                    m_tGrT.dPosY = CData.Dev.aGrd_Y_Start[m_iWy];
                                }
                                else
                                {//해당 스텝 Backward 일 경우
                                    m_tGrT.dPosY = CData.Dev.aGrd_Y_End[m_iWy];
                                }
                            }

                            //---------------------
                            // 2022.09.26 lhs Start : Cal_ReCnt 함수로 변경
                            //if(m_dRoughtTotal < m_dCylZ) 
                            //{//남은 양이 사이클 뎁스량 보다 작을 경우 사이클 뎁스량 변경  <- Cal_ReCnt 함수에 기능 포함됨 
                            //    m_dCylZ = m_dRoughtTotal;
                            //    m_bRoughtLast = true;
                            //    _SetLog("Last Re-doing : m_dRoughtTotal < m_dCylZ -> m_bRoughtLast = true;");
                            //}
                            //CData.GrData[m_iWy].aReCnt[m_iIndex] = Cal_StepCnt(m_dRoughtTotal + m_ZPosUpOffset, m_dCylZ);   // ReGrd
                            
                            CData.GrData[m_iWy].aReCnt[m_iIndex] = Cal_ReCnt(m_dRoughtTotal + m_ZPosUpOffset, m_dCylZ);    // ReGrd
                            // 2022.09.26 lhs End : Cal_ReCnt 함수로 변경
                            //---------------------

                            // 2022.01.05 lhs Start : ReCount Max로 제한
                            if ((CData.Dev.iReDoCntMax > 0) && (CData.GrData[m_iWy].aReCnt[m_iIndex] > CData.Dev.iReDoCntMax))
                            {
                                CData.GrData[m_iWy].aReCnt[m_iIndex] = CData.Dev.iReDoCntMax;
                                _SetLog("Over regrinding count.  Max : " + CData.Dev.iReDoCntMax);
                            }
                            // 2022.01.05 lhs End : ReCount Max로 제한

                            // 2020.09.21 SungTae : Modify
                            //20191111 ghk_regrindinglog
                            if (CDataOption.StepCnt == (int)EStepCnt.DEFAULT_STEP)  {   CData.RedGrdCnt[m_iWy, m_iIndex].m_lRedCnt.Add(CData.GrData[m_iWy].aReCnt[m_iIndex]);   }
                            else                                                    {   CData.RedGrdCnt3[m_iWy, m_iIndex].m_lRedCnt.Add(CData.GrData[m_iWy].aReCnt[m_iIndex]);  }
                            //

                            _SetLog("[Re-grind Before] Z axis current position.",    m_tGrT.dPosZ);  // 2020.10.19 SungTae : 확인 위해 추가.
                            m_tGrT.dPosZ -= m_ZPosUpOffset;     //10 옵셋
                            _SetLog("[Re-grind Before] Z axis move start position.", m_tGrT.dPosZ);  // 2020.10.19 SungTae : 확인 위해 추가.

                            //----------------------------------------------
                            // 2020.10.19 SungTae Start : Modify(by Qorvo)
                            // 200803 jym : 리그라인딩 스킵 횟수 선택
                            if (CData.ReSkipCnt != 0)  // CData.ReSkipCnt 변수는 vwMst 화면에서 설정
                            {
                                //if (CData.GrData[m_iWy].aReCnt[m_iIndex] <= CData.ReSkipCnt)
                                if (CData.GrData[m_iWy].aReCnt[m_iIndex] >= CData.ReSkipCnt)    // 2022.09.07 lhs : 오류 수정
                                {
                                    m_bRoughtLast = true;
                                }
                                _SetLog(string.Format("Re-grind skip use(vwMst). Skip count = {0}", CData.ReSkipCnt));
                            }
                            else
                            {
                                _SetLog("Re-grind skip not use.");
                            }
                            // 2020.10.19 SungTae End
                            //----------------------------------------------

                            CMot.It.Mv_N(m_iY, m_tGrT.dPosY);
                            _SetLog("Y axis move position.", m_tGrT.dPosY);

                            //20190421 ghk 리그라인딩 회수 표시
                            CData.GrData[m_iWy].aReNum[m_iIndex]++;
                            _SetLog(string.Format("Regrinding.  Number : {0}  Count : {1}", CData.GrData[m_iWy].aReNum[m_iIndex], CData.GrData[m_iWy].aReCnt[m_iIndex]), true);

                            // 2022.01.06 lhs Start : m_iGStep = 15으로 점프시키지 않고 m_bRoughtLast를 true로 하여 마지막 redoing 하도록 수정
                            if ((CData.Dev.iReDoNumMax > 0) && (CData.GrData[m_iWy].aReNum[m_iIndex] >= CData.Dev.iReDoNumMax))
							{
                                _SetLog("Last Re-doing, Redoing Number(" + CData.GrData[m_iWy].aReNum[m_iIndex] + ") >= Redoing Max(" + CData.Dev.iReDoNumMax + ")");
                                m_bRoughtLast = true;
                            }
                            // 2022.01.06 lhs End

                            m_iGStep++;
                        }
                        else //리그라인딩 종료, 다음 스텝 시작 위치로 이동
                        {
                            _SetLog("Regrinding end.");
                            m_bRoughtLast = false;
                            m_iIndex++;

                            m_iGStep = 15;  //스텝 바뀌었을때 그라인딩 반복 시작 시점
                        }
                        return false;
                    }

                case 23: //[리그라인딩] 테이블 이동 확인
                    {
                        if (!CMot.It.Get_Mv(m_iY, m_tGrT.dPosY))
                        { return false; }

                        if (CData.Dev.bDual == eDual.Normal)
                        {
                            if (CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].eDir == eStartDir.Forward)
                            {//해당 스텝 Forward 일 경우 그라인딩 종료 위치
                                if ((m_iReCnt % 2) == 0)    {   m_tGrT.dPosY = CData.Dev.aGrd_Y_End[m_iWy];     }
                                else                        {   m_tGrT.dPosY = CData.Dev.aGrd_Y_Start[m_iWy];   }
                            }
                            else
                            {//해당 스텝 Backward 일 경우 그라인딩 종료 위치
                                if ((m_iReCnt % 2) == 0)    {   m_tGrT.dPosY = CData.Dev.aGrd_Y_Start[m_iWy];   }
                                else                        {   m_tGrT.dPosY = CData.Dev.aGrd_Y_End[m_iWy]; }
                            }
                        }
                        else
                        {
                            if (CData.Dev.aData[m_iWy].aSteps[m_iIndex].eDir == eStartDir.Forward)
                            {//해당 스텝 Forward 일 경우 그라인딩 종료 위치
                                if ((m_iReCnt % 2) == 0)    {   m_tGrT.dPosY = CData.Dev.aGrd_Y_End[m_iWy];     }
                                else                        {   m_tGrT.dPosY = CData.Dev.aGrd_Y_Start[m_iWy];   }
                            }
                            else
                            {//해당 스텝 Backward 일 경우 그라인딩 종료 위치
                                if ((m_iReCnt % 2) == 0)    {   m_tGrT.dPosY = CData.Dev.aGrd_Y_Start[m_iWy];   }
                                else                        {   m_tGrT.dPosY = CData.Dev.aGrd_Y_End[m_iWy];     }
                            }
                        }

                        //20200427 메뉴얼 정지버튼
                        if (m_bManualStop)
                        {
                            //그라인딩 종료
                            CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Wait[m_iWy]);// 스핀들 올리기
                            //CSpl.It.Write_Stop(m_eWy);    //스핀들 정지
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);


                            CIO.It.Set_Y(m_tGrT.eOt1, false);    //그라인딩 워터 오프
                            CIO.It.Set_Y(m_tGrT.eOt2, false);    //그라인딩 바텀 워터 오프
                                                                 //200515 myk : Wheel Cleaner Water 추가 -> 200728 jym : 휠 클린 노즐 Skip 기능 추가
                            if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                            {
                                Func_WhlClnWater(false);
                            }    //휠 클리너 워터 오프

                            _SetLog("Manual stop.");

                            m_iStep     = 10;
                            m_iPreStep  = 0;
                            m_iGStep    = 40;
                        }
                        else
                        {
                            //CSpl.It.Write_Run(m_eWy, m_iRpm);   //스핀들 Run
                            // 2023.03.15 Max
                            bool bExit = false;
                            bool bTimeOutFlag = false;

                            // RPM Setting
                            CSpl_485.It.Write_Rpm(m_eWy, m_iRpm);
                            m_Timout_485.Set_Delay(300);
                            do
                            {
                                Application.DoEvents();
                                if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                                bExit = CSpl_485.It.GetAcceptRPMSpindle(m_eWy);
                            } while (bExit != true);
                            CSpl_485.It.SetAcceptRPMSpindle(m_eWy);

                            if (bTimeOutFlag)
                            {
                                if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                                if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                                return false;
                            }

                            // Spindle RUN
                            bExit = false;
                            bTimeOutFlag = false;
                            CSpl_485.It.Write_Run(m_eWy);
                            m_Timout_485.Set_Delay(300);
                            do
                            {
                                Application.DoEvents();
                                if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                                bExit = CSpl_485.It.GetAcceptRunSpindle(m_eWy);
                            } while (bExit != true);
                            CSpl_485.It.SetAcceptRunSpindle(m_eWy);

                            if (bTimeOutFlag)
                            {
                                if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_RUN_RPM_ERROR);
                                if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_RUN_RPM_ERROR);
                                return false;
                            }

                            _SetLog("Spindle run.  Vel : " + m_iRpm + "rpm");

                            //m_mSpl_Chk.Set_Delay(300); // 2023.03.15 Max Spindle RPM Check Delay

                            m_iGStep++;
                        }
                        return false;
                    }

                case 24:    //[리그라인딩] 스핀들 RPM 확인, Z축 그라인딩 위치 이동
                    {
                        //if (!m_mSpl_Chk.Chk_Delay()) { return false; } // 2023.03.15 Max Spindle RPM Check Delay

                        if (CData.Spls[m_iWy].iRpm < (m_iRpm - 20)) // 2023.03.15 Max Spindle RPM Check
                        {
                            _SetLog("Spindle RPM Get : " + CData.Spls[m_iWy].iRpm); // 2023.03.15 Max Spindle RPM Check

                            //CSpl.It.Write_Run(m_eWy, m_iRpm); //191018 ksg :

                            //m_mSpl_Chk.Set_Delay(300); // 2023.03.15 Max Spindle RPM Check Delay

                            return false;
                        }

                        _SetLog("Spindle RPM Get END: " + CData.Spls[m_iWy].iRpm); // 2023.03.15 Max Spindle RPM Check - 확인용

                        // 2022.09.26 lhs Start : 나머지 리그라인딩이면 나머지를 Cycle Depth로 적용
                        if (m_bRemainder)
                        {
                            if ( (m_iReCnt + 1) == CData.GrData[m_iWy].aReCnt[m_iIndex] ) // 마지막 == 나머지
                            {
                                m_dCylZ = m_dRemainder;

                                _SetLog($"Rmainder ReGrd, m_iReCnt + 1 = {m_iReCnt + 1}, m_dCylZ = m_dRemainder = {m_dCylZ}");
                            }
                        }
                        // 2022.09.26 lhs End

                        m_tGrT.dPosZ += m_dCylZ;
                        CMot.It.Mv_N(m_iZ, m_tGrT.dPosZ);
                        _SetLog("Z axis move position.", m_tGrT.dPosZ);

                        m_iGStep++;
                        return false;
                    }

                case 25:    //[리그라인딩] Z축 그라인딩 위치 이동 확인,  그라인디 워터 온, 바텀 워터 온
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_tGrT.dPosZ))
                        {
                            return false;
                        }

                        Func_SplWater(true);    //그라인딩 워터 온
                        Func_BtmWater(true);    //그라인딩 바텀 워터 온

                        //200515 myk : Wheel Cleaner Water 추가 -> 200728 jym : 휠 클린 노즐 Skip 기능 추가
                        if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                        {
                            Func_WhlClnWater(true);
                        }    //휠 클리너 워터 온
                        
                        _SetLog("Spindle water on.  Bottom water on.");

                        m_iGStep++;
                        return false;
                    }

                case 26:    //[리그라인딩] 그라인딩 온, 바텀 워터 온 확인, 테이블 이동(그라인딩)
                    {
                        if (!CIO.It.Get_X(m_tGrT.eIn1) || !CIO.It.Get_X(m_tGrT.eIn2))
                        {
                            return false;
                        }

                        CMot.It.Mv_V(m_iY, m_tGrT.dPosY, m_dVelY);
                        _SetLog("Y axis move position.  Vel : " + m_dVelY + "mm/s", m_tGrT.dPosY);

                        // 201006 jym st
                        if (CDataOption.IsChkDI)
                        {
                            m_tmChkDI.Set_Delay(CData.Opt.iChkDiTime);
                        }
                        // 201006 jym ed

                        m_iGStep++;
                        return false;
                    }

                case 27:    //[리그라인딩] 테이블 이동 확인, 리그라인딩 종료 여부 확인 
                    {       
                        if (CDataOption.IsChkDI && !Chk_GrdWater(m_eWy))
                        {
                            //201006 jym : Time 추가 -> 200616 pjh : Grinding Water Check
                            if (CData.Opt.iChkDiTime != 0 && !m_tmChkDI.Chk_Delay())
                            {
                                return false;
                            }

                            _SetLog("Check DI fail.");

                            m_iGStep = 80;
                            return false;
                        }

                        if (!CMot.It.Get_Mv(m_iY, m_tGrT.dPosY))
                        {
                            //201202 jhc : 로그 추가
                            _SetLog(string.Format("ReGrind-Count [{0}/{1}], Y[{2}], Z[{3}], Load[{4}] Amp[{5}] Temp[{6}] RPM[{7}] Vac[{8}]",
                                                               (m_iReCnt+1).ToString(), CData.GrData[m_iWy].aReCnt[m_iIndex].ToString(),
                                                               CMot.It.Get_FP(m_iY).ToString("0.00000"),
                                                               CMot.It.Get_FP(m_iZ).ToString("0.00000"),
                                                               CData.Spls[m_iWy].dLoad.ToString(),
                                                               CData.Spls[m_iWy].nCurrent_Amp.ToString(),   // ReGrind
                                                               CData.Spls[m_iWy].dTemp_Val.ToString(),
                                                               CData.Spls[m_iWy].iRpm.ToString(),
                                                               CData.Parts[m_iPart].dChuck_Vacuum.ToString("0.0")));


                            ////-----------------------------------------------
                            //// 2022.08.30 lhs Start
                            //// Grinding시 Spindle의 최대/최소 전류 얻기
                            //int nCurr    = CData.Spls[m_iWy].nCurrent_Amp;
                            //int nMaxCurr = CData.GrData[m_iWy].nSplMaxCurr;
                            //int nMinCurr = CData.GrData[m_iWy].nSplMinCurr;

                            //if (nMaxCurr < nCurr) CData.GrData[m_iWy].nSplMaxCurr = nCurr;
                            //if (nMinCurr > nCurr) CData.GrData[m_iWy].nSplMinCurr = nCurr;
                            //// 2022.08.30 lhs End
                            ////-----------------------------------------------

                            return false;
                        }

                        m_iReCnt++;
                        CData.GrData[m_iWy].aReInx[m_iIndex] = m_iReCnt;

                        if (m_iReCnt >= CData.GrData[m_iWy].aReCnt[m_iIndex]) //리그라인딩 종료, 스핀들 정지, 그라인딩 워터 오프, 바텀 워터 오프, 다음 리그라인딩 유무 확인 스텝 이동
                        {
                            m_iReCnt = 0;
                            m_iStep = 10;
                            m_iPreStep = 0;

                            //CSpl.It.Write_Stop(m_eWy);  //스핀들 정지
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);


                            Func_SplWater(false);    //그라인딩 워터 오프
                            Func_BtmWater(false);    //그라인딩 바텀 워터 오프

                            //200515 myk : Wheel Cleaner Water 추가 -> 200728 jym : 휠 클린 노즐 Skip 기능 추가
                            if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                            {
                                Func_WhlClnWater(false);
                            }    //휠 클리너 워터 오프
                            
                            if (!m_bRoughtLast) //마지막 리그라인딩이 아닐 경우
                            {
                                _SetLog("Regrinding end.");

                                m_iGStep = 21;  // One 포인트 측정
                            }
                            else //마지막 리그라인딩 일 경우 ( 그라인딩 카운트 1번일때), 리그라인딩 종료 후 다음 스텝 그라인딩
                            {
                                _SetLog("Last regrinding end.");

                                m_bRoughtLast = false;
                                m_iIndex++;
                                m_iGStep = 15;  //스텝 바뀌었을때 그라인딩 반복 시작 시점
                            }
                        }
                        else //리그라인딩 종료 안됨, 리그라인딩 반복 시작 위치로 이동
                        {
                            _SetLog("Regrinding loop.");
                            m_iGStep = 23;  // [리그라인딩] 테이블 이동 확인
            }

                        return false;
                    }

                case 28: //휠 인스펙션 스텝 #1
                    {
                        // 200903 jym : Timeout 초기화
                        m_mGTimeout.Set_Delay(TIMEOUT);

                        m_bSubErr = false;

                        //20191105 ghk_measuretype
                        if (CDataOption.MeasureType == eMeasureType.Jog)
                        {//조그 무브 휠 측정 방식
                            if (Cyl_MeaWhl())
                            {
                                _SetLog("Wheel measure(jog).");

                                m_iGStep++;
                            }
                        }
                        else
                        {//스텝 무브 휠 측정 방식
                            if (Cyl_MeaWhl_Step())
                            {
                                _SetLog("Wheel measure(step).");

                                m_iGStep++;
                            }
                        }

                        //m_mGTimeout.Set_Delay(1000);
                        return false;
                    }

                case 29: //휠 인스펙션 스텝 #2
                    {
                        //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                        if (CData.bUseWheelZAxisAfterMeasureWheel)
                        {
                            m_tGrT.dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - m_dInspGrd
                                         + Math.Round((CData.WheelTipAfterZPos[m_iWy] - CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER) - CData.MPos[m_iWy].dTOOL_SETTER_GAP, 6); //프로브와 휠팁의 높이차(휠팁 Z축 위치 적용)
                            
                            _SetLog("Wheel Tip Z Axis: " + CData.WheelTipAfterZPos[m_iWy].ToString() + "  PRB_TOOL_SETTER: " + CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER.ToString() + "  TOOL_SETTER_GAP: " + CData.MPos[m_iWy].dTOOL_SETTER_GAP.ToString(), true );
                        }
                        else
                        {
                            m_tGrT.dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - CData.WhlAf[m_iWy] - m_dInspGrd + CData.MPos[m_iWy].dPRB_TO_WHL_BASE;
                        }
                        //
                        m_iIndex++;
                        _SetLog("Calculate Z axis position.", m_tGrT.dPosZ);

                        m_iGStep = 15;  //스텝 바뀌었을때 그라인딩 반복 시작 시점
                        return false;
                    }

                case 30: //그라인딩 종료
                    {
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {

                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);


                            if (CData.Opt.bWheelStopWaitSkip == false)   // 2021.02.20 lhs : true = 기다리지 않음, false = 기다림 (JCET VOC)
                            {
                                return false;
                            }
                        }

                        m_CntTimeFlag = false;
                        CData.GrdElp[m_iWy].dtEnd = DateTime.Now;
                        CData.GrdElp[m_iWy].tsEls = CData.GrdElp[m_iWy].dtEnd - CData.GrdElp[m_iWy].dtStr;

                        //200708 pjh : Grinding 중 Error Check 변수
                        if (m_eWy == EWay.L)    {   CData.Parts[(int)EPart.GRDL].bChkGrd = false;   }
                        else                    {   CData.Parts[(int)EPart.GRDR].bChkGrd = false;   }

                        _SetLog("Grinding finish.");

                        m_iGStep++;
                        return false;
                    }

                case 31:  //자재 높이 측정(After)
                    {
                        // 200919 jym : 프로브 체크 flag
                        m_bUsePrbFlag = true;

                        m_bSubErr = false;

                        // 200903 jym : Timeout 초기화
                        m_mGTimeout.Set_Delay(TIMEOUT);

                        // 2020-12-14, jhLee : Motorizing probe measure
                        if (CDataOption.Package == ePkg.Strip)
                        {
                            if (Cyl_MeaStrip((int)EMeaStep.After))  // After
                            {
                                // 200919 jym : 프로브 체크 flag
                                m_bUsePrbFlag = false;

                                // 200920 jym : 에러 상태 시 사이클 중단
                                if (m_bSubErr)
                                {
                                    _SetLog("Error : Before measure.");
                                    m_iGStep = 0;
                                    return true;
                                }
                                _SetLog("Masure strip finish.");
                                m_iGStep++;
                            }
                        }
                        else
                        {
                            if ((CData.Opt.bPbType) ? Cyl_MeaUnit_ZMotor(1) : Cyl_MeaUnit(1))
                            {
                                // 200919 jym : 프로브 체크 flag
                                m_bUsePrbFlag = false;

                                // 200920 jym : 에러 상태 시 사이클 중단
                                if (m_bSubErr)
                                {
                                    _SetLog("Error : Before measure.");
                                    m_iGStep = 0;
                                    return true;
                                }
                                _SetLog("Measure unit finish.");
                                m_iGStep++;
                            }
                        }

                        //191118 ksg :
                        if (CData.GemForm != null)
                        {
                            if (m_eWy == EWay.L)    {   CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].nUnit_LEFT_Work_End_Cnt++;  }
                            else                    {   CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].nUnit_RIGHT_Work_End_Cnt++; }

                            CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].nUnit_TOTAL_Work_Start_Cnt = CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].nUnit_LEFT_Work_Start_Cnt +
                                                                                                                CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].nUnit_RIGHT_Work_Start_Cnt;
                        }
                        //m_mGTimeout.Set_Delay(1000);
                        return false;
                    }

                case 32:  //종료
                    {
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        // 2020.11.05 JSKim St
                        if (CData.Dev.bMeasureMode == false)
                        {
                            CData.Whls[m_iWy].iGtc++; //201120 : DEBUG
                            CData.Whls[m_iWy].iGdc++; //201120 : DEBUG
                        }
                        // 2020.11.05 JSKim Ed

                        _SetLog(string.Format("Wheel total count : {0}  After dressing count : {1}", CData.Whls[m_iWy].iGtc, CData.Whls[m_iWy].iGdc), true);

                        if (m_eWy == EWay.L)
                        {
                            CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_WaterKnife;
                            if (CDataOption.Package == ePkg.Unit)
                            {
                                Array.Copy(CData.GrData[m_iWy].aUnitEx, CData.Parts[(int)EPart.GRDL].aUnitEx, CData.Dev.iUnitCnt);
                            }
                        }
                        else
                        {
                            CData.Parts[(int)EPart.GRDR].dShiftT = 0; //200408 ksg :
                            CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_WaterKnife;
                            if (CDataOption.Package == ePkg.Unit)
                            {
                                Array.Copy(CData.GrData[m_iWy].aUnitEx, CData.Parts[(int)EPart.GRDR].aUnitEx, CData.Dev.iUnitCnt);
                            }
                        }

                        _SetLog("Data copy.");

                        //lot Work Strip 계산 -> 오토러닝 일경우에만 저장
                        if (CData.LotInfo.bLotOpen)
                        {
                            if (CData.Dev.bDual == eDual.Dual)
                            {
                                if (m_eWy == EWay.R)    {   CData.SpcInfo.iWorkStrip++; }
                            }
                            else                        {   CData.SpcInfo.iWorkStrip++; }
                        }

                        //휠 히스토리
                        // 2020.11.05 JSKim St
                        if (CData.Dev.bMeasureMode == false)
                        {
                            CData.WhlsLog[m_iWy].iGtc++;
                            CData.WhlsLog[m_iWy].iDrsCycleStrip++;
                        }
                        // 2020.11.05 JSKim Ed

                        CWhl.It.Save(m_eWy, CData.Whls[m_iWy]);
                        _SetLog("Wheel data save.");

                        //200310 ksg : Spindle 부하
                        CData.GrData[m_iWy].bSplLoadFlag = false;

                        if ((CData.GrData[m_iWy].dSplMaxLoad >= CData.Dev.aData[m_iWy].dSpdAuto) && 
                            (CData.GrData[m_iWy].dSplMaxLoad < CData.Dev.aData[m_iWy].dSpdError) &&
                            (CData.Dev.aData[m_iWy].dSpdAuto > 0) && 
                            (CData.Dev.aData[m_iWy].dSpdError > 0))
                        {
                            m_NeedDrs = true;
                        }

                        // 2021.10.19 SungTae Start : [수정] (ASE-KR VOC) SECS/GEM Issue 관련 Flag 초기화
                        CData.bChkGrdM = false;
                        // 2021.10.19 SungTae End

                        _SetLog("Finish.  Status : " + CData.Parts[m_iPart].iStat);

                        m_iGStep = 0;
                        return true;
                    }

                case 40: //메뉴얼 종료버튼 그라인딩 종료
                    {
                        if (CData.Spls[m_iWy].iRpm != 0)
                        { return false; }
                        m_CntTimeFlag = false;
                        CData.GrdElp[m_iWy].dtEnd = DateTime.Now;
                        CData.GrdElp[m_iWy].tsEls = CData.GrdElp[m_iWy].dtEnd - CData.GrdElp[m_iWy].dtStr;
                        _SetLog("Check spindle rpm.  Elapse time : " + CData.GrdElp[m_iWy].tsEls);

                        m_iGStep++;
                        return false;
                    }
                case 41: // 스핀들 높이 (Z축) 확인
                    {
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Wait[m_iWy]))
                        { return false; }
                        _SetLog("Check Z axis move.");

                        m_iGStep++;
                        return false;
                    }
                case 42: //테이블 대기 위치 이동
                    {
                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]);
                        _SetLog("Y axis move wait.", CData.SPos.dGRD_Y_Wait[m_iWy]);

                        m_iGStep++;
                        return false;
                    }
                case 43: //테이블 대기 위치 이동 확인, 종료
                    {
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]))
                        { return false; }

                        //200330 mjy
                        if (!CDataOption.IsTblWater)
                        { ActWater(false); }

                        m_bManualStop = false;
                        _SetLog("Finish.");

                        m_iGStep = 0;
                        return true;
                    }

                case 50: // Over Wheel thickness error
                    {
                        if (!m_Delay.Chk_Delay())
                        { return false; }

                        if (m_eWy == EWay.L)
                        { CErr.Show(eErr.LEFT_GRIND_OVER_WHEEL_THICKNESS); }
                        else
                        { CErr.Show(eErr.RIGHT_GRIND_OVER_WHEEL_THICKNESS); }
                        _SetLog("Error : Over wheel thickness.");
                        
                        m_iGStep = 0;
                        return true;
                    }

                case 80:
                    {
                        if (m_eWy == EWay.L)
                        {
                            if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                            { CIO.It.Set_Y(eY.GRDL_WhlCleaner, false); }
                            CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                            //CSpl.It.Write_Stop(EWay.L);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(EWay.L);
                        }
                        else
                        {
                            if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                            { CIO.It.Set_Y(eY.GRDR_WhlCleaner, false); }
                            CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                            //CSpl.It.Write_Stop(EWay.R);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(EWay.R);
                        }
                        _SetLog("Z axis move able.", CData.SPos.dGRD_Z_Able[m_iWy]);

                        m_iGStep++;
                        return false;
                    }

                case 81:
                    {
                        if (CData.Spls[m_iWy].iRpm != 0 || !CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        if (m_eWy == EWay.L)
                        {
                            CIO.It.Set_Y(eY.GRDL_ProbeDn, false);
                            CIO.It.Set_Y(eY.GRDL_ProbeAir, false);
                        }
                        else
                        {
                            CIO.It.Set_Y(eY.GRDR_ProbeDn, false);
                            CIO.It.Set_Y(eY.GRDR_ProbeAir, false);
                        }
                        _SetLog("Probe up.  Probe air off.");

                        m_iGStep++;
                        return false;
                    }
                case 82:
                    {
                        if (m_eWy == EWay.L)
                        {
                            if (!CIO.It.Get_X(eX.GRDL_ProbeAMP))
                            { return false; }
                        }
                        else
                        {
                            if (!CIO.It.Get_X(eX.GRDR_ProbeAMP))
                            { return false; }
                        }
                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                        _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                        m_iGStep++;
                        return false;
                    }
                case 83:
                    {
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }

                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]);
                        _SetLog("Y axis move wait.", CData.SPos.dGRD_Y_Wait[m_iWy]);

                        m_iGStep++;
                        return false;
                    }
                case 84:
                    {
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]))
                        {
                            return false;
                        }
                        
                        //201003 pjh : Chk DI Error
                        Func_BtmWater(false);
                        Func_SplWater(false);
                        
                        _SetLog("Error : Check DI Error");
                        CErr.Show(eWater);

                        m_iGStep = 0;
                        return true;
                        //
                    }

                //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
                case 300:
                    {
                        //버퍼 시퀀스 아니지만 딜레이 대기 (버퍼 시퀀스인 경우 버퍼 스탑 후 모터 안정화 대기)
                        if (!m_Delay.Chk_Delay())
                        { return false; }

                        m_iGStep = 0;
                        m_iStep = 0;

                        Func_PrbUp();                     //프로브 업
                        //CSpl.It.Write_Stop(m_eWy);      //스핀들 정지
                        // 2023.03.15 Max
                        CSpl_485.It.Write_Stop(m_eWy);


                        Func_SplWater(false);           //그라인딩 워터(스핀들 워터) 끄기
                        Func_BtmWater(false);           //그라인딩 바텀 워터(스핀들 바텀 워터) 끄기
                        if (CDataOption.IsWhlCleaner)   
                        { 
                            Func_WhlClnWater(false);    //휠 클리너 워터 끄기
                        }
                        if (!CDataOption.IsTblWater)
                        {
                            ActWater(false);            //테이블 워터 끄기
                        }  

                        CMot.It.Mv_N(m_iZ, 0);          //Z축 UP

                        if (m_bErrTableVacuumLow)
                        {
                            CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_TABLE_VACUUM_LOW : eErr.RIGHT_GRIND_TABLE_VACUUM_LOW);
                            _SetLog("Error : Table Vacuum Fail.  Vacuum : " + CData.GrData[m_iWy].dTableVacuumMin.ToString("0.0")
                                        + "kPa / Vacuum Limit : " + CData.Dev.aData[m_iWy].dTableVacuumGrindLimit.ToString("0.0") + "kPa");
                        }
                        else
                        {
                            CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_SPINDLE_CURRENT_HIGH : eErr.RIGHT_GRIND_SPINDLE_CURRENT_HIGH);
                            _SetLog("Error : Spindle overload(Current Limit).  Load : " + CData.GrData[m_iWy].dSplMaxLoad + "%  Current : "
                                            + CData.GrData[m_iWy].nSpindleCurrentMax.ToString() + "mA / Current Limit : "
                                            + CData.Dev.aData[m_iWy].nSpindleCurrentGrindHigh.ToString() + "mA");
                        }

                        ClearAdvancedGrindConditionError(); //Limit Over 상태 초기화 (Spindle Current Low/High, Table Vacuum Low Limit)

                        return true;
                    }
                    //..
            }

        }

        public bool Cyl_GrdML()
        {
            //220801 pjh : Pump Error Check
            int iRet = ChkPumpErr();
            //
            // Probe down check & Probe up
            if (!m_bUsePrbFlag)
            {
                Func_PrbUp();

                if (!Chk_PrbUpAmp())
                {
                    m_iGStep = 0;
                    m_iStep = 0;
                    //200408 jym : 버퍼 스탑
                    Bf_Stop();

                    Func_SplWater(false);
                    Func_BtmWater(false);

                    if (CDataOption.IsWhlCleaner)   { Func_WhlClnWater(false); }

                    //CSpl.It.Write_Stop(m_eWy);
                    // 2023.03.15 Max
                    CSpl_485.It.Write_Stop(m_eWy);

                    CMot.It.Mv_N(m_iZ, 0);

                    CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET : eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                    _SetLog("Error : Probe down during grinding.");

                    return true;
                }
            }

            if ((CDataOption.Package == ePkg.Strip) ? !Chk_Strip() : !Chk_Unit())
            {
                m_iGStep = 0;
                m_iStep = 0;
                //200408 jym : 버퍼 스탑
                Bf_Stop();

                Func_SplWater(false);
                Func_BtmWater(false);

                if (CDataOption.IsWhlCleaner)   { Func_WhlClnWater(false); }

                //CSpl.It.Write_Stop(m_eWy);
                // 2023.03.15 Max
                CSpl_485.It.Write_Stop(m_eWy);

                CMot.It.Mv_N(m_iZ, 0);

                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_VACUUM_ERROR : eErr.RIGHT_GRIND_VACUUM_ERROR);
                _SetLog("Error : Table vacuum.");

                return true;
            }

            //220801 pjh : Pump Error 발생 시 Grinding Stop
            if(iRet != 0)
            {
                m_iGStep = 0;
                m_iStep  = 0;
                Bf_Stop();

                Func_SplWater(false);
                Func_BtmWater(false);

                if (CDataOption.IsWhlCleaner) { Func_WhlClnWater(false); }

                //CSpl.It.Write_Stop(m_eWy);
                // 2023.03.15 Max
                CSpl_485.It.Write_Stop(m_eWy);

                CMot.It.Mv_N(m_iZ, 0);

                switch(iRet)
                {
                    default:
                        {
                            break;
                        }
                    case 1:
                        {
                            CErr.Show(eErr.LEFT_PUMP_FLOW_LOW_ERROR);
                            _SetLog("Error : Left Pump Flow Error");
                            break;
                        }
                    case 2:
                        {
                            CErr.Show(eErr.LEFT_PUMP_TEMP_HIGH_ERROR);
                            _SetLog("Error : Left Pump Temp High Error");
                            break;
                        }
                    case 3:
                        {
                            CErr.Show(eErr.LEFT_PUMP_OVERLOAD_ERROR);
                            _SetLog("Error : Left Pump Overload Error");
                            break;
                        }
                    case 4:
                        {
                            CErr.Show(eErr.RIGHT_PUMP_FLOW_LOW_ERROR);
                            _SetLog("Error : Right Pump Flow Error");
                            break;
                        }
                    case 5:
                        {
                            CErr.Show(eErr.RIGHT_PUMP_TEMP_HIGH_ERROR);
                            _SetLog("Error : Right Pump Temp High Error");
                            break;
                        }
                    case 6:
                        {
                            CErr.Show(eErr.RIGHT_PUMP_OVERLOAD_ERROR);
                            _SetLog("Error : Right Pump Overload Error");
                            break;
                        }
                }
                return true;
            }

            // Spindle overloade check
            if (CData.Dev.aData[m_iWy].dSpdError > 0 && CData.GrData[m_iWy].dSplMaxLoad > CData.Dev.aData[m_iWy].dSpdError)
            {
                m_NeedDrs = true;
                m_iGStep = 0;
                m_iStep = 0;
                //200408 jym : 버퍼 스탑
                Bf_Stop();

                Func_SplWater(false);
                Func_BtmWater(false);

                if (CDataOption.IsWhlCleaner)   { Func_WhlClnWater(false); }

                //CSpl.It.Write_Stop(m_eWy);
                // 2023.03.15 Max
                CSpl_485.It.Write_Stop(m_eWy);

                CMot.It.Mv_N(m_iZ, 0);

                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_SPINDLE_OVERLOAD : eErr.RIGHT_GRIND_SPINDLE_OVERLOAD);
                _SetLog("Error : Spindle overload.  Load : " + CData.GrData[m_iWy].dSplMaxLoad + "%");

                // 2020.11.20 SungTae : Alarm 발생 후 초기화
                CData.GrData[m_iWy].dSplMaxLoad = 0;

                return true;
            }

            //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
            //if (CDataOption.UseDeviceAdvancedOption && CDataOption.UseAdvancedGrindCondition && (CDataOption.SplType == eSpindleType.EtherCat)) //Advanced Grind Condition 체크 사용 조건 (라이선스)
            // 2023.03.15 Max
            if (CDataOption.UseDeviceAdvancedOption && CDataOption.UseAdvancedGrindCondition)
            {
                if (0 != CheckAdvancedGrindCondition(0)) //여기서 체크하지만 Step 10에서 체크 시작 => Step 10 이 후부터 체크하게 됨
                {
                    if (m_bErrTableVacuumLow || m_bErrSpindleCurrentHigh)
                    {
                        //스핀들 과부하 => 드레싱 필요
                        if (m_bErrSpindleCurrentHigh)
                        { m_NeedDrs = true; }

                        Bf_Stop(); //버퍼 스탑

                        //버퍼 스탑 후 모터 레디 대기 시간 설정
                        m_Delay.Set_Delay(500);
                        _SetLog("Set delay : 500ms");

                        ResetAdvancedGrindCondition(0, false); //Condition 체크 플래그 리셋

                        m_iGStep = 300; //종료 처리 및 Alarm
                        return false;
                    }
                }
            }
            //..

            // Timeout check
            // 2020.09.16 JSKim St - Fine Grinding 진행 시 Table Speed 설정이 낮은 경우 Timeout 가 발생하여 수정
            // 시퀀스가 변경되면 m_iGStep == 16 도 변경해줘야 함
            //if (m_iGPreStep != m_iGStep)
            //{ m_mGTimeout.Set_Delay(TIMEOUT); }
            int nTimeOut = 30000;

            if (m_iGPreStep != m_iGStep)
            {
                //if (m_iGStep == 20 && m_dVelY >= 5)     // Table Speed 가 5미만인 경우 Timeout 시간이 너무 길어짐..
                if ((m_iGStep == 20 || m_iGStep == 27) && m_dVelY >= 1)     // 2021.04.20 lhs
                {
                    nTimeOut = Convert.ToInt32(Math.Abs(CData.Dev.aGrd_Y_End[m_iWy] - CData.Dev.aGrd_Y_Start[m_iWy]) / m_dVelY) * 1000 + 10000;
                    m_mGTimeout.Set_Delay(nTimeOut);
                }
                else
                {
                    m_mGTimeout.Set_Delay(TIMEOUT);
                }
            }
            // 2020.09.16 JSKim Ed
            else
            {
                if (m_mGTimeout.Chk_Delay())
                {
                    if (m_eWy == EWay.L)    { CErr.Show(eErr.LEFT_GRIND_STRIP_GRINDING_TIMEOUT); }
                    else                    { CErr.Show(eErr.RIGHT_GRIND_STRIP_GRINDING_TIMEOUT); }

                    _SetLog("Error : Timeout.");

                    m_iCnt = 0;
                    m_iGStep = 0;
                    return true;
                }
            }

            m_iGPreStep = m_iGStep;

            //if (CDataOption.SplType == eSpindleType.EtherCat)
            //{
            //    CData.Spls[0].iRpm = Convert.ToInt32(CSpl.It.GetFrpm(true));
            //    CData.Spls[1].iRpm = Convert.ToInt32(CSpl.It.GetFrpm(false));
            //}
            // 2023.03.15 Max : CSpl_485.cs에서 CData.Spls[(int)EWay.L].iRpm, CData.Spls[(int)EWay.R].iRpm 값 Update 되어
            // 하기 주석 처리
            //CData.Spls[(int)EWay.L].iRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.L));
            //CData.Spls[(int)EWay.R].iRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.R));


            // 201006 jym st : Delay 추가
            if (CDataOption.IsChkDI && ((m_iGStep > 19 && m_iGStep < 21) || (m_iGStep > 26 && m_iGStep < 28)))
            {
                if (!Chk_GrdWater(m_eWy))
                {
                    if (CData.Opt.iChkDiTime != 0 && !m_tmChkDI.Chk_Delay())
                    { return false; }

                    Bf_Stop();

                    if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip) { Func_WhlClnWater(false); }
                    
                    m_Delay.Set_Delay(500);
                    
                    m_iGStep = 80;
                    return false;
                }
                else
                {
                    m_tmChkDI.Set_Delay(CData.Opt.iChkDiTime);
                }
            }
            // 201006 jym ed

            // 2021.05.21 SungTae Start : [추가] Device Parameter 변경 시 새로 추가한 SVID 설정
            if (CData.CurCompany == ECompany.SPIL)
            {
                CData.GemForm.OnSetAddSVID_ActualSpeed();
            }
            // 2021.05.21 SungTae End

            switch (m_iGStep)
            {
                default:
                    {
                        m_iGStep = 0;
                        return true;
                    }

                case 10:
                    {
                        // 1. 축 상태 체크                
                        if (Chk_Axes())
                        {
                            m_iGStep = 0;
                            return true;
                        }
                        _SetLog("Check axes.");

                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }
                        _SetLog("Check spindle.");

                        // 200919 jym : 프로브 체크 flag
                        m_bUsePrbFlag = false;
                        // 200921 jym : Sub error initial
                        m_bSubErr = false;

                        //20190618 ghk_dfserver
                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            if (!CData.dfInfo.bBusy)
                            {
                                CDf.It.SendGrdReady((m_eWy == EWay.L) ? "LGD" : "RGD");
                            }
                            else
                            { return false; }
                        }

                        //20191111 ghk_regrindinglog
                        InitReGrd(m_iWy);    //List 초기화

                        m_iIndex = 0;
                        m_iCnt = 0;
                        m_iReCnt = 0;
                        //20190421 ghk_휠 리그라인딩 옵셋
                        m_dStartHeight = 0;
                        m_bRoughtLast = false;
                        m_bFineCheck = false;

                        if (CDataOption.IsChkDI && (CSQ_Main.It.m_iStat == EStatus.Auto_Running || CSQ_Main.It.m_bRun))
                        {//200708 pjh : Auto Running 중 일때만 Check
                            if (CData.Parts[m_iPart].bChkGrd)
                            {
                                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_DETECT_REJECT_STRIP_ERROR :
                                                              eErr.RIGHT_GRIND_DETECT_REJECT_STRIP_ERROR);
                                _SetLog("Error : Detect reject strip.");

                                m_iGStep = 0;
                                return true;
                            }
                        }

                        // jhLee, Multi-LOT의 경우에도 SPC 기록
                        SetMyLotInfo();     // 내부 사용 LotInfo  대입

                        m_iGStep++;

                        //190419 ksg : Z축 옵셋 강제 10um 띄우는 옵셋 정하는 곳
                        if (CDataOption.ZUpOffset == eZUpOffset.Use)
                        {
                            // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                            if (CData.CurCompany == ECompany.Qorvo_RT || CData.CurCompany == ECompany.Qorvo_NC ||
                                CData.CurCompany == ECompany.SST)
                            {
                                m_ZPosUpOffset = 0.004;
                            }
                            else if (CData.CurCompany == ECompany.Qorvo || CData.CurCompany == ECompany.Qorvo_DZ) // syc : Qorvo 리그라인딩 에어컷 수정 210520
                            {
                                m_ZPosUpOffset = 0.0049;
                            } 
                            else
                            {
                                m_ZPosUpOffset = 0.01;
                            }
                        }
                        else
                        {
                            m_ZPosUpOffset = 0;
                        }

                        if (CData.CurCompany == ECompany.SCK || CData.CurCompany == ECompany.JSCK || CData.CurCompany == ECompany.JCET) //200121 ksg : , 200625 lks
                        {
                            if (!CIO.It.Get_Y(eY.IOZT_Power)) CIO.It.Set_Y(eY.IOZT_Power, true);  // SCK, JSCK, JCET
                            CData.Opt.bIOZT_ManualClick = false;    // 2021.09.15 lhs 수동클릭 아님
                        }

                        //휠 리미터 검사
                        if (CData.Whls[m_iWy].dWhlLimit > CData.Whls[m_iWy].dWhlAf)
                        {
                            //200730 jhc : Wheel/Dresser Limit Alaram 보류용 (ASE-Kr VOC)
                            if(CData.CurCompany != ECompany.ASE_KR || CData.bWhlDrsLimitAlarmSkip == false)
                            {
                                CSQ_Main.It.m_bWhlLimitArm = true;
                                frmMain.bShowWhlView = true;
                                m_Delay.Set_Delay(1000);
                                m_iGStep = 70;
                                return false;
                            }
                        }

                        //200310 ksg : Spindle 부하
                        CData.GrData[m_iWy].dSplMaxLoad = 0;
                        CData.GrData[m_iWy].bSplLoadFlag = true;

                        //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
                        ResetAdvancedGrindCondition(0, true); //Condition 체그 플래그 셋 (체크 시작)
                        //..

                        _SetLog("Ready.");

                        // 2021.08.26 SungTae Start : 현재 Grinding 하는 자재 정보 확인하기 위해 추가
                        string sWay = (m_eWy == EWay.L) ? "Left" : "Right";

                        _SetLog("");
                        _SetLog(">>>>> Strip Infomation <<<<<");
                        _SetLog(" Grind Way : " + sWay);
                        _SetLog("Grind Mode : " + CData.Dev.bDual.ToString());
                        
                        if (m_eWy == EWay.L)
                        {
                            _SetLog("    LOT ID : " + CData.Parts[(int)EPart.GRDL].sLotName);
                            _SetLog("  STRIP ID : " + CData.Parts[(int)EPart.GRDL].sBcr);
                        }
                        else
                        {
                            _SetLog("    LOT ID : " + CData.Parts[(int)EPart.GRDR].sLotName);
                            _SetLog("  STRIP ID : " + CData.Parts[(int)EPart.GRDR].sBcr);
                        }

                        _SetLog("");
                        // 2021.08.26 SungTae End
                        return false;
                    }

                case 11:
                    {//IO 초기화
                        //20190618 ghk_dfserver
                        //if ((CData.CurCompany == eCompany.AseKr || CData.CurCompany == eCompany.AseK26) && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == eStatus.Auto_Running)
                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            if (m_eWy == EWay.L)
                            {
                                if (!CDf.It.ReciveAckGRL((int)ECMD.scGrdReadyL))    { return false; }
                            }
                            else
                            {
                                if (!CDf.It.ReciveAckGRR((int)ECMD.scGrdReadyR))    { return false; }
                            }
                        }

                        _InitCycle();

                        CData.GrData[m_iWy].iStep  = 0;

                        CData.GrData[m_iWy].aInx   = new int    [m_iStepMaxCnt];
                        CData.GrData[m_iWy].aCnt   = new int    [m_iStepMaxCnt];
                        CData.GrData[m_iWy].aTar   = new double [m_iStepMaxCnt];
                        CData.GrData[m_iWy].aReNum = new int    [m_iStepMaxCnt];
                        CData.GrData[m_iWy].aReInx = new int    [m_iStepMaxCnt];
                        CData.GrData[m_iWy].aReCnt = new int    [m_iStepMaxCnt];
                        CData.GrData[m_iWy].a1Pt   = new double [m_iStepMaxCnt];

                        //201023 JSKim : Over Grinding Correction - Grinding Count Correction 기능
                        m_dRoughOver = 0.0;
                        ////////

                        _SetLog("Init cycle.");

                        m_iGStep++;
                        return false;
                    }

                case 12:
                    {//데이터 저장 변수 초기화, m_iStep = 10, iPreStep = 0 
                        m_tGrT = new tTempData();

                        // 200317 mjy : 그라인딩 Start, End position 계산 후 설정
                        if (CDataOption.Package == ePkg.Unit)
                        {
                            int iUnit = 0;
                            double dPos = 0;

                            // Start position
                            iUnit = Cal_LastU();
                            // ([휠센터 <-> 테이블 센터 포지션] - ([휠 외경] / 2)) + [테이블 센터에서 해당 유닛 센터까지 거리]
                            // 해당 계산으로 휠팁이 마지막 유닛(휠에서 가장 가까운 유닛) 센터에 오는 위치 계산
                            dPos = (CData.MPos[m_iWy].dY_WHL_TBL_CENTER - (CData.Whls[m_iWy].dWhlO / 2)) + CData.Dev.aUnitCen[iUnit];
                            // [휠팁 <-> 마지막 유닛 센터] - ([자재 사이즈(세로) / 2] + [옵셋값])
                            CData.Dev.aGrd_Y_Start[m_iWy] = dPos - ((CData.Dev.dChipH / 2) + GV.GRD_WHL_OFFSET);
                            _SetLog("Last unit index : " + iUnit, true);

                            // End position
                            iUnit = Cal_FirstU();
                            // ([휠센터 <-> 테이블 센터 포지션] - ([휠 외경] / 2)) + [테이블 센터에서 해당 유닛 센터까지 거리]
                            // 해당 계산으로 휠팁이 마지막 유닛(휠에서 가장 가까운 유닛) 센터에 오는 위치 계산
                            dPos = (CData.MPos[m_iWy].dY_WHL_TBL_CENTER - (CData.Whls[m_iWy].dWhlO / 2)) + CData.Dev.aUnitCen[iUnit];
                            // [휠팁 <-> 마지막 유닛 센터] + ([자재 사이즈(세로) / 2] + [옵셋값])
                            CData.Dev.aGrd_Y_End[m_iWy] = dPos + ((CData.Dev.dChipH / 2) + GV.GRD_WHL_OFFSET);
                            _SetLog("First unit index : " + iUnit, true);
                        }

                        if (m_eWy == EWay.L)
                        {//왼쪽 테이블
                            m_tGrT.eIn1 = eX.GRDL_SplWater;
                            m_tGrT.eIn2 = eX.GRDL_SplBtmWater;
                            m_tGrT.eOt1 = eY.GRDL_SplWater;
                            m_tGrT.eOt2 = eY.GRDL_SplBtmWater;
                            m_tGrT.dPosX = CData.SPos.dGRD_X_Wait[m_iWy];
                            m_tGrT.dPosY = CData.Dev.aData[m_iWy].aSteps[0].eDir == eStartDir.Forward ? CData.Dev.aGrd_Y_Start[m_iWy] : CData.Dev.aGrd_Y_End[m_iWy];
                            //191019 ksg :
                            CData.GrData[m_iWy].aOldOnPont[0] = 0;
                        }
                        else
                        {//오른쪽 테이블
                            m_tGrT.eIn1 = eX.GRDR_SplWater;
                            m_tGrT.eIn2 = eX.GRDR_SplBtmWater;
                            m_tGrT.eOt1 = eY.GRDR_SplWater;
                            m_tGrT.eOt2 = eY.GRDR_SplBtmWater;
                            m_tGrT.dPosX = CData.SPos.dGRD_X_Wait[m_iWy];

                            if (CData.Dev.bDual == eDual.Normal)
                            {//노멀 모드 일경우 왼쪽 파라미터 사용
                                m_tGrT.dPosY = CData.Dev.aData[(int)EWay.L].aSteps[0].eDir == eStartDir.Forward ? CData.Dev.aGrd_Y_Start[m_iWy] : CData.Dev.aGrd_Y_End[m_iWy];
                            }
                            else
                            {//듀얼 모드 일경우 오른쪽 파라미터 사용
                                m_tGrT.dPosY = CData.Dev.aData[m_iWy].aSteps[0].eDir == eStartDir.Forward ? CData.Dev.aGrd_Y_Start[m_iWy] : CData.Dev.aGrd_Y_End[m_iWy];
                            }
                            //191019 ksg :
                            CData.GrData[m_iWy].aOldOnPont[0] = 0;
                        }
                        _SetLog("Table start position : " + m_tGrT.dPosY + "mm", true);

                        m_iStep = 10;
                        m_iPreStep = 0;
                        m_iGStep++;
                        return false;
                    }

                case 13:
                    {//자재 높이 측정(Before)
                        // 200919 jym : 프로브 체크 flag
                        m_bUsePrbFlag = true;

                        m_bSubErr = false;

                        // 200903 jym : timeout 초기화
                        m_mGTimeout.Set_Delay(TIMEOUT);


                        // 2020-12-14, jhLee : Motorizing probe measure
                        if (CDataOption.Package == ePkg.Strip)
                        {
                            if (Cyl_MeaStrip((int)EMeaStep.Before))    // Before 
                            {
                                // 200919 jym : 프로브 체크 flag
                                m_bUsePrbFlag = false;

                                // 200920 jym : 에러 상태 시 사이클 중단
                                if (m_bSubErr)
                                {
                                    _SetLog("Error : Before measure.");
                                    m_iGStep = 0;
                                    return true;
                                }

                                _SetLog("Measure strip end.");
                                m_iGStep++;
                            }
                        }
                        else
                        {
                            //d if (Cyl_MeaUnit(0))
                            if ((CData.Opt.bPbType) ? Cyl_MeaUnit_ZMotor(0) : Cyl_MeaUnit(0))
                            {
                                // 200919 jym : 프로브 체크 flag
                                m_bUsePrbFlag = false;

                                // 200920 jym : 에러 상태 시 사이클 중단
                                if (m_bSubErr)
                                {
                                    _SetLog("Error : Before measure.");
                                    m_iGStep = 0;
                                    return true;
                                }

                                _SetLog("Measure unit end.");
                                m_iGStep++;
                            }
                        }

                        return false;
                    }

                case 14:
                    {
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        //20200723 lks : 메저모드이면 그라인딩 스킵     // 2020.09.11 JSKim St
                        if (CData.Dev.bMeasureMode)
                        {
                            m_LogVal.iStep = m_iGStep;
                            m_LogVal.sMsg = "Measure Mode : " + CData.Dev.bMeasureMode;
                            SaveLog();
                            m_iGStep = 60;
                            m_iStep = 10;
                            m_iPreStep = 0;
                            return false;
                        }
                        // 2020.09.11 JSKim Ed

                        //그라인딩 시작 위치 계산, 각 스텝 별 타켓 계산(기본 횟수)
                        CData.GrdElp[m_iWy].dtStr = DateTime.Now;
                        m_CntTimeFlag  = true;
                        m_WrongCalFlag = false; //190813 ksg :
                        m_WrongPCBThicknessFlag = false;    // 2021.07.30 SungTae 

                        // 2021.07.31 lhs Start : 새로운 Grind Process 추가 (SCK 전용)
                        if (CDataOption.UseNewSckGrindProc)
                        {
                            m_tGrT.dPosZ = Cal_GrdStart_NewSck(); // 함수안에서 m_WrongCalFlag 변경
                        }
                        else  // 기존방식
                        // 2021.07.31 lhs End
                        {
                            m_tGrT.dPosZ = Cal_GrdStart(); // 함수안에서 m_WrongCalFlag 변경
                        }

                        _SetLog("Grind start position : " + m_tGrT.dPosZ + "mm", true);

                        // 2021.07.30 SungTae Start : [추가] ASE-KR VOC로 Grinding이 완료된 자재가 재투입 시 Over Grinding 되는 Issue 관련 조건 추가
                        if (m_WrongPCBThicknessFlag)
                        {
                            if (m_eWy == EWay.L)
                            {
                                CErr.Show(eErr.LEFT_WRONG_PCB_THICKNESS_DATA_ERROR);
                                _SetLog("[ERROR] : LEFT_WRONG_PCB_THICKNESS_DATA_ERROR", true);

                                m_WrongPCBThicknessFlag = false;
                                m_iGStep = 0;
                                return true;
                            }
                        }
                        // 2021.07.30 SungTae End

                        //200708 pjh : Grinding 중 Error Check 변수
                        if (CData.Parts[m_iPart].bChkGrd == false)
                        {
                            CData.Parts[m_iPart].bChkGrd = true;
                        }

                        //20190421 ghk_휠 리그라인딩 옵셋
                        if (m_WrongCalFlag)
                        {
                            if (m_eWy == EWay.L)
                            {
                                CErr.Show(eErr.LEFT_WRONG_CALCULATOR_GRIND_START_POSITION);

                                m_iGStep = 0;
                                return true;
                            }
                            else
                            {
                                CErr.Show(eErr.RIGHT_WRONG_CALCULATOR_GRIND_START_POSITION);

                                m_iGStep = 0;
                                return true;
                            }
                        }

                        //201203 jhc : 드레싱 후 N번째 그라인딩 시 휠 소모량 보정 기능
                        if (CDataOption.UseDeviceAdvancedOption && CDataOption.UseWheelLossCorrect) //(DEVICE > PARAM > ADVANCED 메뉴 표시) + (드레싱 후 N번째 그라인딩 시 휠 소모량 보정 기능 사용)
                        {
                            if (m_TotalWheelLossLimitOver) //누적 Wheel Loss 제한량 초과 (Z축 과도 DOWN 제한 ==> 해제하려면 드레싱 해야 함)
                            {
                                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_WHEEL_LOSS_CORRECT_LIMIT_OVER : eErr.RIGHT_WHEEL_LOSS_CORRECT_LIMIT_OVER);
                                _SetLog("Error : Total Wheel Loss Correction Limit Over.");

                                m_TotalWheelLossLimitOver = false;

                                m_iGStep = 0;
                                return true;
                            }
                        }
                        //

                        if (CData.Whls[m_iWy].dReGrdOffset > 0)
                        {
                            m_tGrT.dPosZ += CData.Whls[m_iWy].dReGrdOffset;
                            _SetLog("Wheel Regrinding Offset : " + CData.Whls[m_iWy].dReGrdOffset + "mm", m_tGrT.dPosZ, true);
                        }
                        
                        m_WrongCalFlag = false; //190813 ksg :

                        Cal_GrdTarget();

                        if (m_WrongCalFlag)
                        {
                            if (m_eWy == EWay.L)
                            {
                                CErr.Show(eErr.LEFT_WRONG_CALCULATOR_GRIND_TARGET_POSITION);

                                m_iGStep = 0;
                                return true;
                            }
                            else
                            {
                                CErr.Show(eErr.RIGHT_WRONG_CALCULATOR_GRIND_TARGET_POSITION);

                                m_iGStep = 0;
                                return true;
                            }
                        }

                        //191118 ksg :
                        if (CData.GemForm != null)
                        {
                            if (m_eWy == EWay.L)
                            { CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].nUnit_LEFT_Work_Start_Cnt++; }
                            else
                            { CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].nUnit_RIGHT_Work_Start_Cnt++; }

                            CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].nUnit_TOTAL_Work_Start_Cnt = CData.JSCK_Gem_Data[(int)EDataShift.GRL_BF_MEAS/*7*/].nUnit_LEFT_Work_Start_Cnt + 
                                                                                                                CData.JSCK_Gem_Data[(int)EDataShift.GRR_BF_MEAS/*13*/].nUnit_RIGHT_Work_Start_Cnt;
                        }

                        _SetLog("Calculate target.");

                        m_iGStep++;
                        return false;
                    }

                case 15: //== 스텝 바뀌었을때 그라인딩 반복 시작 시점 == 스텝별 파라미터 선택, Y축 그라인딩 시작 위치 이동
                    {
                        if (CData.Dev.bDual == eDual.Normal)  //스텝 모드 아닐 경우, 테이블 왼쪽 오른쪽 상관 없이 왼쪽 파라미터 사용
                        { 
                            if (m_iIndex > m_iStepMaxCnt - 1)  //그라인딩 종료
                            {
                                //CSpl.It.Write_Stop(m_eWy);  //스핀들 정지
                                // 2023.03.15 Max
                                CSpl_485.It.Write_Stop(m_eWy);

                                Func_SplWater(false);       //그라인딩 워터 오프
                                Func_BtmWater(false);       //그라인딩 바텀 워터 오프

                                //200515 myk : Wheel Cleaner Water 추가
                                if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip) { Func_WhlClnWater(false); }    //휠 클리너 워터 오프

                                _SetLog("Normal spindle stop.  Index : " + m_iIndex, true);

                                m_iStep = 10;
                                m_iPreStep = 0;
                                m_iGStep = 60;
                                return false;
                            }

                            if (!CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].bUse)
                            {//해당 스텝 사용 안할 경우, 다음 스텝으로 이동
                                m_iIndex++;
                                return false;
                            }
                            else
                            {//해당 스텝 사용 할 경우, 스텝 파라미터 및 테이블 시작위치 값 설정 *****Fine 그라인딩 경우 조건 추가 해야됨

                                //201023 JSKim : Over Grinding Correction - Grinding Count Correction 기능
                                if (CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].bOverGrdCorrectionUse)
                                {
                                    if (CData.Opt.bOverGrdCountCorrectionUse)
                                    {
                                        if (OverGrindingCountCorrection() == false)
                                        {
                                            m_iIndex++;

                                            if (m_iIndex > (m_iStepMaxCnt - 1))
                                            {
                                                //그라인딩 종료
                                                //CSpl.It.Write_Stop(m_eWy);                           //스핀들 정지
                                                // 2023.03.15 Max
                                                CSpl_485.It.Write_Stop(m_eWy);

                                                Func_SplWater(false);                                //그라인딩 워터 오프
                                                Func_BtmWater(false);                                //그라인딩 바텀 워터 오프
                                                //200515 myk : Wheel Cleaner Water 추가                 
                                                if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                                                { Func_WhlClnWater(false); }                         //휠 클리너 워터 오프

                                                _SetLog("NORMAL mode - OverGrinding Correction spindle stop.  Index : " + m_iIndex);

                                                m_iStep = 10;
                                                m_iPreStep = 0;
                                                m_iGStep = 60;

                                                ///////////////////////////////////////////
                                                m_dRoughOver = 0.0; //오버그라인딩 값 초기화
                                                ///////////////////////////////////////////
                                            }
                                            return false;
                                        }
                                    }
                                }
                                ////////

                                //if (m_iIndex == GV.StepMaxCnt - 1 && !m_bFineCheck)
                                if (m_iIndex == m_iStepMaxCnt - 1 && !m_bFineCheck)     // 2020.09.08 SungTae : modify
                                {//Fine Grinding 일 경우
                                    if (CData.Dev.aData[(int)EWay.L].eFine == eFineMode.WheelInsp)
                                    {   //휠 인스펙션 스텝으로 이동
                                        m_bFineCheck = true;
                                        _SetLog("Normal fine step.  wheel inspection.  Index : " + m_iIndex, true);

                                        m_iStep = 10;
                                        m_iPreStep = 0;
                                        m_iGStep = 50;  
                                        return false;
                                    }
                                    else
                                    {   //보정 값 적용
                                        m_bFineCheck = true;

                                        m_tGrT.dPosZ -= CData.Dev.aData[m_iWy].dCpen;
                                        _SetLog("Normal fine step.  Compensation offset : " + CData.Dev.aData[m_iWy].dCpen + "mm", m_tGrT.dPosZ, true);
                                    }
                                }

                                // 테이블 시작 위치 계산
                                m_tGrT.dPosY = (CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].eDir == eStartDir.Forward) ? CData.Dev.aGrd_Y_Start[m_iWy] : CData.Dev.aGrd_Y_End[m_iWy];
                                m_iRpm = CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].iSplSpd;
                                m_dCylZ = CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].dCycleDep;
                                _SetLog(string.Format("Tbl : {0}mm  Spl : {1}rpm  Cycle : {2}mm", m_tGrT.dPosY, m_iRpm, m_dCylZ), true);
                            }
                        }
                        else  //스텝 모드 일 경우, 테이블 왼쪽 오른쪽 각각 파라미터 사용
                        {
                            if (m_iIndex > m_iStepMaxCnt - 1)  //그라인딩 종료
                            {
                                //CSpl.It.Write_Stop(m_eWy);  //스핀들 정지
                                // 2023.03.15 Max
                                CSpl_485.It.Write_Stop(m_eWy);


                                Func_SplWater(false);       //그라인딩 워터 오프
                                Func_BtmWater(false);       //그라인딩 바텀 워터 오프
                                
                                //200515 myk : Wheel Cleaner Water 추가
                                if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                                {
                                    Func_WhlClnWater(false);
                                }    //휠 클리너 워터 오프

                                _SetLog("Step spindle stop.  Index : " + m_iIndex, true);

                                m_iStep     = 10;
                                m_iPreStep  = 0;
                                m_iGStep    = 60;

                                return false;
                            }

                            if (!CData.Dev.aData[m_iWy].aSteps[m_iIndex].bUse)
                            {//해당 스텝 사용 안할 경우, 다음 스텝으로 이동
                                m_iIndex++;
                                return false;
                            }
                            else
                            {//해당 스텝 사용 할 경우, 스텝 파라미터 및 테이블 시작위치 값 설정 *****Fine 그라인딩 경우 조건 추가 해야됨

                                //201023 JSKim : Over Grinding Correction - Grinding Count Correction 기능
                                if (CData.Dev.aData[m_iWy].aSteps[m_iIndex].bOverGrdCorrectionUse)
                                {
                                    if (CData.Opt.bOverGrdCountCorrectionUse)
                                    {
                                        if (OverGrindingCountCorrection() == false)
                                        {
                                            m_iIndex++;

                                            if (m_iIndex > (m_iStepMaxCnt - 1))
                                            {
                                                //그라인딩 종료
                                                //CSpl.It.Write_Stop(m_eWy);                           //스핀들 정지
                                                // 2023.03.15 Max
                                                CSpl_485.It.Write_Stop(m_eWy);

                                                Func_SplWater(false);                                //그라인딩 워터 오프
                                                Func_BtmWater(false);                                //그라인딩 바텀 워터 오프
                                                
                                                //200515 myk : Wheel Cleaner Water 추가
                                                if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                                                {
                                                    Func_WhlClnWater(false);
                                                }                         //휠 클리너 워터 오프

                                                _SetLog("STEP mode - OverGrinding Correction Step spindle stop.  Index : " + m_iIndex);

                                                m_iStep     = 10;
                                                m_iPreStep  = 0;
                                                m_iGStep    = 60;

                                                ///////////////////////////////////////////
                                                m_dRoughOver = 0.0; //오버그라인딩 값 초기화
                                                ///////////////////////////////////////////
                                            }
                                            return false;
                                        }
                                    }
                                }
                                ////////

                                if (m_iIndex == m_iStepMaxCnt - 1 && !m_bFineCheck)  
                                {//Fine Grinding 일 경우
                                    if (CData.Dev.aData[m_iWy].eFine == eFineMode.WheelInsp)
                                    {   //휠 인스펙션 스텝으로 이동
                                        m_bFineCheck = true;
                                        _SetLog("Step fine step.  wheel inspection.", true);

                                        m_iStep = 10;
                                        m_iPreStep = 0;
                                        m_iGStep = 50; 
                                        return false;
                                    }
                                    else
                                    {   //보정 값 적용
                                        m_bFineCheck = true;
                                        m_tGrT.dPosZ -= CData.Dev.aData[m_iWy].dCpen;
                                        _SetLog("Step fine step.  Compensation offset : " + CData.Dev.aData[m_iWy].dCpen + "mm", m_tGrT.dPosZ, true);
                                    }
                                }

                                // 테이블 시작 위치 계산
                                m_tGrT.dPosY = (CData.Dev.aData[m_iWy].aSteps[m_iIndex].eDir == eStartDir.Forward) ? CData.Dev.aGrd_Y_Start[m_iWy] : CData.Dev.aGrd_Y_End[m_iWy];
                                m_iRpm       = CData.Dev.aData[m_iWy].aSteps[m_iIndex].iSplSpd;
                                m_dCylZ      = CData.Dev.aData[m_iWy].aSteps[m_iIndex].dCycleDep;

                                _SetLog(string.Format("Tbl : {0}mm  Spl : {1}rpm  Cycle : {2}mm", m_tGrT.dPosY, m_iRpm, m_dCylZ), true);
                            }
                        }

                        //if (m_iCnt == 0 && m_iIndex != 0 && m_iIndex != GV.StepMaxCnt - 1)
                        if (m_iCnt == 0 && m_iIndex != 0 && m_iIndex != m_iStepMaxCnt - 1)      // 2020.09.08 SungTae : modify
                        {
                            m_tGrT.dPosZ -= m_ZPosUpOffset; //Z축 옵셋 //190419 ksg :
                            _SetLog("Up offset : " + m_ZPosUpOffset + "mm", m_tGrT.dPosZ, true);
                        }

                        CMot.It.Mv_N(m_iY, m_tGrT.dPosY);
                        _SetLog("Y axis move position.", m_tGrT.dPosY);

                        m_iGStep++;
                        return false;
                    }

                case 16: // 테이블 시작 위치로 이동 및 스핀들 동작
                    {
                        if (!CMot.It.Get_Mv(m_iY, m_tGrT.dPosY))
                        { return false; }

                        // 200723 jym : 버퍼 모드 에서 1번째 스탭 빼고는 시작 시  사이클 뎁스 만큼 하강 후 시작 (ASE KR 제외)
                        if (m_iIndex != 0 && CData.CurCompany != ECompany.ASE_KR) //200903 jhc : ASE-KR 이전 소스로 원복(Over-grinding 이슈) //if (m_iIndex != 0) //200824 jhc : ASE-KR도 개선 적용
                        {
                            m_tGrT.dPosZ += m_dCylZ;
                        }
                        _SetLog("Z axis start position : " + m_tGrT.dPosZ + "mm", true);

                        //CSpl.It.Write_Run(m_eWy, m_iRpm);
                        // 2023.03.15 Max
                        bool bExit = false;
                        bool bTimeOutFlag = false;

                        // RPM Setting
                        CSpl_485.It.Write_Rpm(m_eWy, m_iRpm);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRPMSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRPMSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                            return false;
                        }

                        // Spindle RUN
                        bExit = false;
                        bTimeOutFlag = false;
                        CSpl_485.It.Write_Run(m_eWy);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRunSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRunSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            return false;
                        }

                        _SetLog("Spindle run.  RPM : " + m_iRpm);

                        //m_mSpl_Chk.Set_Delay(300); // 2023.03.15 Max Spindle RPM Check Delay

                        m_iGStep++;
                        return false;
                    }

                case 17: //스핀들 RPM 확인, Z축 그라인딩 시작 위치 이동
                    {
                        //if (!m_mSpl_Chk.Chk_Delay()) { return false; } // 2023.03.15 Max Spindle RPM Check Delay

                        if (CData.Spls[m_iWy].iRpm < (m_iRpm - 20)) // 2023.03.15 Max Spindle RPM Check
                        {
                            _SetLog("Spindle RPM Get : " + CData.Spls[m_iWy].iRpm); // 2023.03.15 Max Spindle RPM Check

                            //CSpl.It.Write_Run(m_eWy, m_iRpm); //191018 ksg :

                            //m_mSpl_Chk.Set_Delay(300); // 2023.03.15 Max Spindle RPM Check Delay
                            return false;
                        }

                        _SetLog("Spindle RPM Get END: " + CData.Spls[m_iWy].iRpm); // 2023.03.15 Max Spindle RPM Check - 확인용

                        // 시작 높이로 이동
                        CMot.It.Mv_N(m_iZ, m_tGrT.dPosZ);
                        _SetLog("Z axis move start.", m_tGrT.dPosZ);

                        m_iGStep++;
                        return false;
                    }

                case 18: // Z축 그라인딩 시작위치 이동 확인, 그라인딩 워터 온, 그라인딩 바텀 워터 온
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_tGrT.dPosZ, GV.INPOS_GRD_CYCLE))
                        { return false; }

                        Func_SplWater(true); //그라인딩 워터 온
                        Func_BtmWater(true); //그라인딩 바텀 워터 온

                        //200515 myk : Wheel Cleaner Water 추가
                        if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                        {
                            Func_WhlClnWater(true);
                        }    //휠 클리너 워터 온
                        
                        _SetLog("Wheel Cleaner Water on.");

                        m_iGStep++;
                        return false;
                    }

                case 19:
                    {//그라인딩 워터 온 확인, 그라인딩 바텀 워터 온 확인, 테이블 이동(그라인딩)
                        if (CIO.It.Get_X(m_tGrT.eIn1) && CIO.It.Get_X(m_tGrT.eIn2))
                        {
                            // 버퍼 시퀀스 구성
                            _Bf_Grd();
                            // 버퍼 시작
                            _Bf_Start();
                            _SetLog("Buffer setting.  Buffer start.  Count : " + CData.GrData[m_iWy].aCnt[m_iIndex]);

                            m_iGStep++;
                        }

                        return false;
                    }

                case 20:
                    {//테이블 이동 확인, 스텝 종료 여부 확인,
                        _Bf_GetStatus();

                        //200814 jhc : 버퍼모드에서 그라인딩/드레싱 카운트 계산
                        CData.GrData[m_iWy].aInx[m_iIndex] = CalcBfCount(2, CData.GrData[m_iWy].aCnt[m_iIndex]);

                        m_iGStep++;
                        return false;
                    }

                case 21: // 버퍼 동작 완료 확인
                    {
                        // 200831 jym : 축 상태 검사 추가
                        if (Chk_AxesML())
                        {
                            Bf_Stop();

                            _SetLog(string.Format("Error : X axis  Cmd : {0}mm  Fed : {1}mm", CMot.It.Get_CP(m_iX), CMot.It.Get_FP(m_iX)));
                            _SetLog(string.Format("Error : Y axis  Cmd : {0}mm  Fed : {1}mm", CMot.It.Get_CP(m_iY), CMot.It.Get_FP(m_iY)));
                            _SetLog(string.Format("Error : Z axis  Cmd : {0}mm  Fed : {1}mm", CMot.It.Get_CP(m_iZ), CMot.It.Get_FP(m_iZ)));

                            m_iGStep = 0;
                            return true;
                        }

                        if (!CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_ProbeAMP : eX.GRDR_ProbeAMP))
                        {
                            Bf_Stop();

                            CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET : eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                            _SetLog("Error : Probe down.");

                            m_iGStep = 0;
                            return true;
                        }                       

                        if (m_mBfStat.State != BufferState.Active)
                        {   // 버퍼 완료

                            //200814 jhc : 버퍼 동작 완료 시 최종 카운트 재차 업데이트
                            CData.GrData[m_iWy].aInx[m_iIndex] = CData.GrData[m_iWy].aCnt[m_iIndex];

                            //CSpl.It.Write_Stop(m_eWy);    //스핀들 정지
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);


                            Func_SplWater(false); //그라인딩 워터 오프
                            Func_BtmWater(false); //그라인딩 바텀 워터 오프
                            
                            //200515 myk : Wheel Cleaner Water 추가
                            if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                            {
                                Func_WhlClnWater(false);
                            }    //휠 클리너 워터 오프

                            m_tGrT.dPosZ = CMot.It.Get_FP(m_iZ);
                            m_WrongCalFlag = false; //191018 ksg :
                            // 200920 jym : 프로브 반복 체크 초기화
                            m_iWrongCnt = 0;

                            _SetLog("Buffer end.", m_tGrT.dPosZ, true);

                            m_iStep     = 10;
                            m_iPreStep  = 0;
                            m_iGStep++;
                        }
                        else
                        {   //버퍼 동작 중
                            m_iGStep = 20;
                        }

                        return false;
                    }

                case 22: // 한 포인트 측정
                    {
                        // 200327 mjy : 리그라인딩 스킵 사용시 스킵 판정 하여 진행
                        if (CDataOption.IsReSkip && CData.Dev.aData[m_iWy].aSteps[m_iIndex].bReSkip)
                        {   //리그라인딩 스킵으로 리그라인딩 구문 이탈
                            m_iIndex++;

                            // 200919 jym : 프로브 체크 flag
                            m_bUsePrbFlag = false;

                            //201023 JSKim : Over Grinding Correction - Grinding Count Correction 기능
                            m_dRoughOver = 0.0; //리그라인딩 스킵 -> One Point 측정 스킵 -> 오버그라인딩 값 초기화
                            ////////

                            _SetLog("Regrinding skip.  Index : " + m_iIndex, true);

                            m_iGStep = 15;
                            return false;
                        }

                        if (m_iIndex == m_iStepMaxCnt - 1)
                        {   // 러프 스텝 완료 리그라인딩 구문 이탈
                            m_iIndex++;

                            // 200919 jym : 프로브 체크 flag
                            m_bUsePrbFlag = false;

                            _SetLog("Rough end.  Index : " + m_iIndex, true);

                            m_iGStep = 15;
                            return false;
                        }

                        // 200919 jym : 프로브 체크 flag
                        m_bUsePrbFlag = true;

                        m_bSubErr = false;

                        // 200903 jym : timeout 초기화
                        m_mGTimeout.Set_Delay(TIMEOUT);

                        // 2020-12-14, jhLee, 신규 Motorize
                        // 1포인트 측정 시작
                        if ((CData.Opt.bPbType) ? Cyl_MeaStripOne_ZMotor() : Cyl_MeaStripOne())
                        {
                            // 200920 jym : Limit 검사 이후 잘못 되면 반복 측정
                            if (m_WrongCalFlag)
                            {
                                m_iWrongCnt++;

                                if (m_iWrongCnt == GV.MEASURE_RETRY)
                                {
                                    if (m_eWy == EWay.L)    { CErr.Show(eErr.LEFT_ONE_POINT_VALUE_WRONG); }
                                    else                    { CErr.Show(eErr.RIGHT_ONE_POINT_VALUE_WRONG); }

                                    m_WrongCalFlag = false;
                                    // 200919 jym : 프로브 체크 flag
                                    m_bUsePrbFlag = false;

                                    _SetLog("Error : 1 point measure fail.");

                                    m_iGStep = 0;
                                    return true;
                                }
                                else
                                {
                                    m_iStep     = 10;
                                    m_iPreStep  = 0;

                                    m_WrongCalFlag = false;
                                    
                                    _SetLog("1 point measure fail.  Retry.  Count : " + m_iWrongCnt);

                                    return false;
                                }
                            }
                            //211006 pjh : One point Error 발생 시 Sequence Stop
                            if (m_bProbeAbnormalCheck)
                            {
                                m_bProbeAbnormalCheck = false;

                                m_iGStep = 0;
                                return true;
                            }
                            //

                            m_dRoughtTotal = (m_dInspGrd - CData.GrData[m_iWy].aTar[m_iIndex]);

                            //20190421 ghk_휠 리그라인딩 옵셋
                            if (m_iIndex == 0)
                            {
                                if (m_dInspGrd >= (m_dStartHeight - 0.001))
                                {
                                    CData.Whls[m_iWy].dReGrdOffset += (m_dRoughtTotal - (m_dRoughtTotal / 3));
                                    _SetLog("Wheel Regrinding Offset : " + CData.Whls[m_iWy].dReGrdOffset + "mm", true);
                                }
                            }

                            // 200919 jym : 프로브 체크 flag
                            m_bUsePrbFlag = false;
                            // 200920 jym : 프로브 반복 체크 초기화
                            m_iWrongCnt = 0;

                            m_iReCnt = 0;
                            _SetLog(string.Format("One point : {0}mm  Target : {1}mm", m_dInspGrd, CData.GrData[m_iWy].aTar[m_iIndex]), true);

                            m_iGStep++;
                        }

                        return false;
                    }

                case 23: //[리그라인딩] 유무 확인 및 스텝 종료 여부 확인
                    {
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max 
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        //201023 JSKim : Over Grinding Correction - Grinding Count Correction 기능
                        if (CData.Opt.bOverGrdCountCorrectionUse && 
                            //CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].bOverGrdCorrectionUse &&
                            (m_dRoughtTotal < 0))
                        {
                            // 오버 그라인딩 발생
                            _SetLog("OverGrinding Correction.   RoughtTotal : " + m_dRoughtTotal);
                            m_dRoughOver = Math.Abs(m_dRoughtTotal);
                        }
                        else
                        {
                            // 오버 그라인딩 미 발생
                            m_dRoughOver = 0.0; //오버그라인딩 값 초기화
                        }
                        ////////

                        // 2020.08.19 JSKim St
                        double dOver = -(CData.Dev.aData[(CData.Dev.bDual == eDual.Normal) ? (int)EWay.L : m_iWy].dOneOver);

                        if (dOver != 0 && m_dRoughtTotal <= dOver)
                        {
                            if (m_eWy == EWay.L)    {   CErr.Show(eErr.LEFT_ONE_POINT_OVER_GRIND_CHECK_ERROR);  }
                            else                    {   CErr.Show(eErr.RIGHT_ONE_POINT_OVER_GRIND_CHECK_ERROR); }

                            _SetLog("Error : Over Grinding Check one point.");

                            //201023 JSKim : Over Grinding Correction - Grinding Count Correction 기능
                            m_dRoughOver = 0.0; //Over Grinding Error 기능을 사용하여 Error 발생 시 보정 불필요
 

                            // 2021-06-15, jhLee : Skyworks VOC, One Point Over-Grinding alram이 발생하더라도 기 수행된 그라인딩에 대해서는 카운트를 해줘야 한다.
                            if (CData.Dev.bMeasureMode == false)
                            {
                                // 드레싱 작업을 위한 그라인딩 횟수 누적
                                CData.Whls[m_iWy].iGtc++;
                                CData.Whls[m_iWy].iGdc++;

                                //210706 pjh : Add Log and save function of After Dressing Count 
                                CData.WhlsLog[m_iWy].iGtc++;
                                CData.WhlsLog[m_iWy].iDrsCycleStrip++;

                                _SetLog(string.Format("Wheel total count : {0}  After dressing count : {1}", CData.Whls[m_iWy].iGtc, CData.Whls[m_iWy].iGdc), true);
                                CWhl.It.Save(m_eWy, CData.Whls[m_iWy]);
                                //
                            }


                            m_iGStep = 0;
                            return true;
                        }
                        // 2020.08.19 JSKim Ed

                        // 200327 mjy : 리그라인딩 판정 조건 디바이스 파라메터에서 가져옴
                        if (CDataOption.IsReJudge)
                        {
                            m_ReGrdDep = CData.Dev.aData[m_iWy].aSteps[m_iIndex].dReJud;
                        }
                        else
                        {
                            //190711 ksg : 리그라인딩 조건을 낮춤(Fine에 영향을 줌)
                            if (CData.CurCompany == ECompany.Qorvo      || CData.CurCompany == ECompany.Qorvo_DZ ||
                                CData.CurCompany == ECompany.Qorvo_RT   || CData.CurCompany == ECompany.Qorvo_NC ||  // 2021.03.29 SungTae : Qorvo_RT & NC 조건 추가
                                CData.CurCompany == ECompany.SST)
                            {
                                m_ReGrdDep = 0.0017;
                            }
                            else
                            {
                                m_ReGrdDep = 0.003;
                            }
                        }

                        if (m_dRoughtTotal > m_ReGrdDep)  //3um 이상 언더 발생시 리그라인딩, 테이블 테이블 시작 위치 이동,  리그라인딩 횟수 계산
                        {
                            if (CData.Dev.bDual == eDual.Normal)
                            {//노멀 모드 일 경우, 왼쪽 파라미터 사용
                                m_tGrT.dPosY = (CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].eDir == eStartDir.Forward) ? CData.Dev.aGrd_Y_Start[m_iWy] : CData.Dev.aGrd_Y_End[m_iWy];
                            }
                            else
                            {//스텝 모드 일 경우, 각각 파라미터 사용
                                m_tGrT.dPosY = (CData.Dev.aData[m_iWy].aSteps[m_iIndex].eDir == eStartDir.Forward) ? CData.Dev.aGrd_Y_Start[m_iWy] : CData.Dev.aGrd_Y_End[m_iWy];
                            }

                            //---------------------
                            // 2022.09.26 lhs Start : Cal_ReCnt 함수로 변경
                            //if(m_dRoughtTotal < m_dCylZ) 
                            //{//남은 양이 사이클 뎁스량 보다 작을 경우 사이클 뎁스량 변경  <- Cal_ReCnt 함수에 기능 포함됨 
                            //    m_dCylZ = m_dRoughtTotal;
                            //    m_bRoughtLast = true;
                            //    _SetLog("Last Re-doing : m_dRoughtTotal < m_dCylZ -> m_bRoughtLast = true;");
                            //}
                            //CData.GrData[m_iWy].aReCnt[m_iIndex] = Cal_StepCnt(m_dRoughtTotal + m_ZPosUpOffset, m_dCylZ);   // ReGrd

                            CData.GrData[m_iWy].aReCnt[m_iIndex] = Cal_ReCnt(m_dRoughtTotal + m_ZPosUpOffset, m_dCylZ);    // ReGrd
                            // 2022.09.26 lhs End : Cal_ReCnt 함수로 변경
                            //---------------------

                            // 2022.01.05 lhs Start : ReCount Max로 제한
                            if ((CData.Dev.iReDoCntMax > 0) && (CData.GrData[m_iWy].aReCnt[m_iIndex] > CData.Dev.iReDoCntMax))
                            {
                                CData.GrData[m_iWy].aReCnt[m_iIndex] = CData.Dev.iReDoCntMax;
                                _SetLog("Over Re-doing count.  Max = " + CData.Dev.iReDoCntMax);
                            }
                            // 2022.01.05 lhs End : ReCount Max로 제한

                            // 2020.09.21 SungTae : Modify
                            //20191111 ghk_regrindinglog
                            if (CDataOption.StepCnt == (int)EStepCnt.DEFAULT_STEP)  {   CData.RedGrdCnt[m_iWy,  m_iIndex].m_lRedCnt.Add(CData.GrData[m_iWy].aReCnt[m_iIndex]);   }
                            else                                                    {   CData.RedGrdCnt3[m_iWy, m_iIndex].m_lRedCnt.Add(CData.GrData[m_iWy].aReCnt[m_iIndex]);  }

                            // 2020.10.19 SungTae : 확인 위해 추가.
                            _SetLog("[Re-grind Before] Z axis current position.", m_tGrT.dPosZ);
                            
                            m_tGrT.dPosZ -= m_ZPosUpOffset; //10 옵셋
                            
                            _SetLog("[Re-grind Before] Z axis move start position.", m_tGrT.dPosZ);

                            // 2020.10.19 SungTae Start : Modify(by Qorvo)
                            // 200803 jym : 리그라인딩 스킵 횟수 선택
                            if (CData.ReSkipCnt != 0)
                            {
                                //if (CData.GrData[m_iWy].aReCnt[m_iIndex] <= CData.ReSkipCnt)
                                if (CData.GrData[m_iWy].aReCnt[m_iIndex] >= CData.ReSkipCnt)    // 2022.09.07 lhs : 오류 수정
                                {
                                    m_bRoughtLast = true;
                                }
                                _SetLog(string.Format("Re-grind skip use. Skip count = {0}", CData.ReSkipCnt));
                            }
                            else
                            {
                                _SetLog("Re-grind skip not use.");
                            }
                            // 2020.10.19 SungTae End

                            CMot.It.Mv_N(m_iY, m_tGrT.dPosY);
                            _SetLog("Y axis move position.", m_tGrT.dPosY);

                            //20190421 ghk 리그라인딩 회수 표시
                            CData.GrData[m_iWy].aReNum[m_iIndex]++;
                            _SetLog(string.Format("Regrinding.  Number : {0}  Count : {1}", CData.GrData[m_iWy].aReNum[m_iIndex], CData.GrData[m_iWy].aReCnt[m_iIndex]), true);

                            // 2022.01.06 lhs Start : m_iGStep = 15으로 점프시키지 않고 m_bRoughtLast를 true로 하여 마지막 redoing 하도록 수정
                            // 2021.06.15. SungTae Start : [추가] ASE-KR SSG009호기에서 발생한 Re-Doing 무한반복 Issue 관련하여 하기 조건 추가.
                            if ((CData.Dev.iReDoNumMax > 0) && (CData.GrData[m_iWy].aReNum[m_iIndex] >= CData.Dev.iReDoNumMax))
							{
                                _SetLog("Last Re-doing, Redoing Number(" + CData.GrData[m_iWy].aReNum[m_iIndex] + ") >= Redoing Max(" + CData.Dev.iReDoNumMax + ")");
                                m_bRoughtLast = true;

                                //m_bRoughtLast = false;
                                //m_iIndex++;
                                //m_iGStep = 15;
                                //return false;
                            }
                            // 2022.01.06 lhs End

                            //2022.01.05 lhs Start : aReCnt는 계산으로 나오는 값으로 이 구문은 단지 ReGrinding을 스킵하므로 삭제하고, 위 부분에서 Max로 제한함.
                            //if ((CData.Dev.iReDoCntMax > 0) && (CData.GrData[m_iWy].aReCnt[m_iIndex] > CData.Dev.iReDoCntMax))
                            //{
                            //    _SetLog("Over regrinding count.  Max : " + CData.Dev.iReDoCntMax);

                            //    m_bRoughtLast = false;
                            //    m_iIndex++;
                            //    m_iGStep = 15;

                            //    return false;
                            //}
                            //// 2021.06.15. SungTae End
                            // 2022.01.05 lhs End

                            m_iGStep++;
                        }
                        else
                        {//리그라인딩 종료, 다음 스텝 시작 위치로 이동
                            m_bRoughtLast = false;
                            m_iIndex++;
                            _SetLog("Regrinding finish.");

                            m_iGStep = 15;
                        }

                        return false;
                    }

                case 24: //[리그라인딩] 테이블 이동 확인
                    {
                        if (!CMot.It.Get_Mv(m_iY, m_tGrT.dPosY))
                        { return false; }

                        //CSpl.It.Write_Run(m_eWy, m_iRpm);   //스핀들 Run
                        // 2023.03.15 Max
                        bool bExit = false;
                        bool bTimeOutFlag = false;

                        // RPM Setting
                        CSpl_485.It.Write_Rpm(m_eWy, m_iRpm);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRPMSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRPMSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                            return false;
                        }

                        // Spindle RUN
                        bExit = false;
                        bTimeOutFlag = false;
                        CSpl_485.It.Write_Run(m_eWy);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRunSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRunSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            return false;
                        }

                        _SetLog("Spindle run.  RPM : " + m_iRpm);

                        //m_mSpl_Chk.Set_Delay(300); // 2023.03.15 Max Spindle RPM Check Delay

                        m_iGStep++;
                        return false;
                    }

                case 25: //[리그라인딩] 스핀들 RPM 확인, Z축 그라인딩 위치 이동
                    {
                        //if (!m_mSpl_Chk.Chk_Delay()) { return false; } // 2023.03.15 Max Spindle RPM Check Delay

                        if (CData.Spls[m_iWy].iRpm < (m_iRpm - 20)) // 2023.03.15 Max Spindle RPM Check
                        {
                            _SetLog("Spindle RPM Get : " + CData.Spls[m_iWy].iRpm); // 2023.03.15 Max Spindle RPM Check

                            //CSpl.It.Write_Run(m_eWy, m_iRpm); //191018 ksg :

                            //m_mSpl_Chk.Set_Delay(300); // 2023.03.15 Max Spindle RPM Check Delay
                            return false;
                        }

                        _SetLog("Spindle RPM Get END: " + CData.Spls[m_iWy].iRpm); // 2023.03.15 Max Spindle RPM Check - 확인용

                        Func_SplWater(true); // 그라인딩 워터 온
                        Func_BtmWater(true); // 그라인딩 바텀 워터 온
                        
                        //200515 myk : Wheel Cleaner Water 추가
                        if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                        {
                            Func_WhlClnWater(true);
                        }    //휠 클리너 워터 온

                        // 200723 jym : 버퍼 모드 에서 1번째 스탭 빼고는 시작 시  사이클 뎁스 만큼 하강 후 시작 (ASE KR 제외)
                        if (CData.CurCompany != ECompany.ASE_KR) //200903 jhc : ASE-KR 이전 소스로 원복(Over-grinding 이슈) //200824 jhc : ASE-KR도 개선 적용
                        {
                            m_tGrT.dPosZ += m_dCylZ;
                        }

                        CMot.It.Mv_N(m_iZ, m_tGrT.dPosZ);
                        _SetLog("Z axis move position.", m_tGrT.dPosZ);

                        m_iGStep++;
                        return false;
                    }

                case 26://[리그라인딩] 그라인딩 온, 바텀 워터 온 확인, 테이블 이동(그라인딩)
                    {
                        if (!CIO.It.Get_X(m_tGrT.eIn1) || !CIO.It.Get_X(m_tGrT.eIn2))
                        { return false; }
                        if (!CMot.It.Get_Mv(m_iZ, m_tGrT.dPosZ))
                        { return false; }

                        _Bf_GrdRe();
                        _Bf_Start();

                        _SetLog("Regrinding start.", m_tGrT.dPosZ, true);

                        m_iGStep++;
                        return false;
                    }

                case 27: //[리그라인딩] 테이블 이동 확인, 리그라인딩 종료 여부 확인
                    {
                        _Bf_GetStatus();

                        //200814 jhc : 버퍼모드에서 그라인딩/드레싱 카운트 계산
                        CData.GrData[m_iWy].aReInx[m_iIndex] = CalcBfCount(2, CData.GrData[m_iWy].aReCnt[m_iIndex]);

                        m_iGStep++;
                        return false;
                    }

                case 28: //[리그라인딩] 테이블 이동 확인, 리그라인딩 종료 여부 확인
                    {
                        // 200831 jym : 축 상태 검사 추가
                        if (Chk_AxesML())
                        {                            
                            Bf_Stop();
                            _SetLog(string.Format("Error : X axis  Cmd : {0}mm  Fed : {1}mm", CMot.It.Get_CP(m_iX), CMot.It.Get_FP(m_iX)));
                            _SetLog(string.Format("Error : Y axis  Cmd : {0}mm  Fed : {1}mm", CMot.It.Get_CP(m_iY), CMot.It.Get_FP(m_iY)));
                            _SetLog(string.Format("Error : Z axis  Cmd : {0}mm  Fed : {1}mm", CMot.It.Get_CP(m_iZ), CMot.It.Get_FP(m_iZ)));

                            m_iGStep = 0;
                            return true;
                        }

                        if (!CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_ProbeAMP : eX.GRDR_ProbeAMP))
                        {
                            Bf_Stop();
                            CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET : eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                            _SetLog("Error : Probe down.");

                            m_iGStep = 0;
                            return true;
                        }

                        if (m_mBfStat.State != BufferState.Active)
                        {   //리그라인딩 종료, 스핀들 정지, 그라인딩 워터 오프, 바텀 워터 오프, 다음 리그라인딩 유무 확인 스텝 이동

                            //200814 jhc : 버퍼 동작 완료 시 최종 카운트 재차 업데이트
                            CData.GrData[m_iWy].aReInx[m_iIndex] = CData.GrData[m_iWy].aReCnt[m_iIndex];

                            m_iReCnt = 0;
                            m_iStep = 10;
                            m_iPreStep = 0;

                            //CSpl.It.Write_Stop(m_eWy);           //스핀들 정지
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            Func_SplWater(false);
                            Func_BtmWater(false);
                            //200515 myk : Wheel Cleaner Water 추가
                            if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                            { Func_WhlClnWater(false); }    //휠 클리너 워터 오프

                            m_tGrT.dPosZ = CMot.It.Get_FP(m_iZ);

                            _SetLog("Regrinding end.", m_tGrT.dPosZ, true);

                            if (!m_bRoughtLast)
                            {   //마지막 리그라인딩이 아닐 경우
                                m_iGStep = 22;
                            }
                            else
                            {   //마지막 리그라인딩 일 경우 ( 그라인딩 카운트 1번일때), 리그라인딩 종료 후 다음 스텝 그라인딩
                                m_bRoughtLast = false;
                                m_iIndex++;
                                m_iGStep = 15;
                            }
                        }
                        else
                        {   //리그라인딩 종료 안됨, 리그라인딩 반복 시작 위치로 이동
                            m_iGStep = 27;
                        }

                        return false;
                    }

                case 50: //휠 인스펙션 스텝 #1
                    {
                        // 200903 jym : timeout 초기화
                        m_mGTimeout.Set_Delay(TIMEOUT);

                        if (CDataOption.MeasureType == eMeasureType.Jog)
                        {//조그 무브 휠 측정 방식
                            if (Cyl_MeaWhl())
                            {
                                _SetLog("Measure wheel end(jog).");

                                m_iGStep++;
                            }
                        }
                        else
                        {//스텝 무브 휠 측정 방식
                            if (Cyl_MeaWhl_Step())
                            {
                                _SetLog("Measure wheel end(step).");

                                m_iGStep++;
                            }
                        }
                        return false;
                    }

                case 51: //휠 인스펙션 스텝 #2
                    {
                        //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                        if (CData.bUseWheelZAxisAfterMeasureWheel)
                        {
                            m_tGrT.dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - m_dInspGrd
                                         + Math.Round((CData.WheelTipAfterZPos[m_iWy] - CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER) - CData.MPos[m_iWy].dTOOL_SETTER_GAP, 6); //프로브와 휠팁의 높이차(휠팁 Z축 위치 적용)
                            _SetLog("Wheel Tip Z Axis: " + CData.WheelTipAfterZPos[m_iWy].ToString() + "  PRB_TOOL_SETTER: " + CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER.ToString() + "  TOOL_SETTER_GAP: " + CData.MPos[m_iWy].dTOOL_SETTER_GAP.ToString(), true);
                        }
                        else
                        {
                            m_tGrT.dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - CData.WhlAf[m_iWy] - m_dInspGrd + CData.MPos[m_iWy].dPRB_TO_WHL_BASE;
                        }
                        //
                        m_iIndex++;
                        _SetLog("Calculate position : " + m_tGrT.dPosZ + "mm");

                        m_iGStep = 15;
                        return false;
                    }

                case 60:
                    {//그라인딩 종료
                        
                        // 2021.06.30 lhs Start : 
                        //if (CData.Spls[m_iWy].iRpm != 0)  // 아래로 수정
                        //{ return false; }

                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max 
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            if (CData.Opt.bWheelStopWaitSkip == false)   // 2021.02.20 lhs : true = 기다리지 않음, false = 기다림 (JCET VOC)
                            {
                                return false;
                            }
                        }
                        // 2021.06.30 lhs End

                        m_CntTimeFlag = false;
                        CData.GrdElp[m_iWy].dtEnd = DateTime.Now;
                        CData.GrdElp[m_iWy].tsEls = CData.GrdElp[m_iWy].dtEnd - CData.GrdElp[m_iWy].dtStr;

                        //200708 pjh : Grinding 중 Error Check 변수
                        CData.Parts[m_iPart].bChkGrd = false;

                        _SetLog("Grinding time : " + CData.GrdElp[m_iWy].tsEls, true);

                        m_iGStep++;
                        return false;
                    }

                case 61:
                    {
                        // 200919 jym : 프로브 체크 flag
                        m_bUsePrbFlag = true;

                        m_bSubErr = false;

                        // 200903 jym : timeout 초기화
                        m_mGTimeout.Set_Delay(TIMEOUT);


                        if (CDataOption.Package == ePkg.Strip)
                        {
                            if (Cyl_MeaStrip((int)EMeaStep.After))    // After
                            {
                                // 200919 jym : 프로브 체크 flag
                                m_bUsePrbFlag = false;

                                // 200920 jym : 에러 상태 시 사이클 중단
                                if (m_bSubErr)
                                {
                                    _SetLog("Error : After measure.");
                                    m_iGStep = 0;
                                    return true;
                                }

                                _SetLog("Measure strip end.");
                                m_iGStep++;
                            }
                        }
                        else
                        {
                            // 2020-11-14, jhLee : Motorizing probe measure
                            if ((CData.Opt.bPbType) ? Cyl_MeaUnit_ZMotor(1) : Cyl_MeaUnit(1))
                            {
                                // 200919 jym : 프로브 체크 flag
                                m_bUsePrbFlag = false;

                                // 200920 jym : 에러 상태 시 사이클 중단
                                if (m_bSubErr)
                                {
                                    _SetLog("Error : After measure.");
                                    m_iGStep = 0;
                                    return true;
                                }

                                _SetLog("Measure unit end.");
                                m_iGStep++;
                            }
                        }



                        //if (CData.Opt.bPbType)
                        //{
                        //    if (Cyl_MeaStripZAxis(1))
                        //    {
                        //        // 200919 jym : 프로브 체크 flag
                        //        m_bUsePrbFlag = false;

                        //        // 200920 jym : 에러 상태 시 사이클 중단
                        //        if (m_bSubErr)
                        //        {
                        //            _SetLog("Error : After measure.");
                        //            m_iGStep = 0;
                        //            return true;
                        //        }

                        //        _SetLog("Measure strip end.  Z axis mode.");
                        //        m_iGStep++;
                        //    }
                        //}
                        //else
                        //{
                        //    if (CDataOption.Package == ePkg.Strip)
                        //    {
                        //        if (Cyl_MeaStrip(1))
                        //        {
                        //            // 200919 jym : 프로브 체크 flag
                        //            m_bUsePrbFlag = false;

                        //            // 200920 jym : 에러 상태 시 사이클 중단
                        //            if (m_bSubErr)
                        //            {
                        //                _SetLog("Error : After measure.");
                        //                m_iGStep = 0;
                        //                return true;
                        //            }

                        //            _SetLog("Measure strip end.");
                        //            m_iGStep++;
                        //        }
                        //    }
                        //    else
                        //    {
                        //        if (Cyl_MeaUnit(1))
                        //        {
                        //            // 200919 jym : 프로브 체크 flag
                        //            m_bUsePrbFlag = false;

                        //            // 200920 jym : 에러 상태 시 사이클 중단
                        //            if (m_bSubErr)
                        //            {
                        //                _SetLog("Error : After measure.");
                        //                m_iGStep = 0;
                        //                return true;
                        //            }

                        //            _SetLog("Measure unit end.");
                        //            m_iGStep++;
                        //        }
                        //    }
                        //}

                        //191118 ksg :
                        if (CData.GemForm != null)
                        {
                            if (m_eWy == EWay.L)
                            {
                                CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].nUnit_LEFT_Work_End_Cnt++;
                            }
                            else
                            {
                                CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].nUnit_RIGHT_Work_End_Cnt++;
                            }
                            CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].nUnit_TOTAL_Work_Start_Cnt = CData.JSCK_Gem_Data[(int)EDataShift.GRL_AF_MEAS/*10*/].nUnit_LEFT_Work_Start_Cnt +
                                                                                                                CData.JSCK_Gem_Data[(int)EDataShift.GRR_AF_MEAS/*16*/].nUnit_RIGHT_Work_Start_Cnt;
                        }
                        return false;
                    }

                case 62:
                    {//종료
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max 
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        // 2020.11.05 JSKim St
                        //CData.Whls[m_iWy].iGtc++;
                        //CData.Whls[m_iWy].iGdc++;
                        if (CData.Dev.bMeasureMode == false)
                        {
                            CData.Whls[m_iWy].iGtc++;
                            CData.Whls[m_iWy].iGdc++;
                        }
                        // 2020.11.05 JSKim Ed

                        CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_WaterKnife : ESeq.GRR_WaterKnife;
                        if (CDataOption.Package == ePkg.Unit)
                        {
                            Array.Copy(CData.GrData[m_iWy].aUnitEx, CData.Parts[m_iPart].aUnitEx, CData.Dev.iUnitCnt);
                        }

                        _SetLog(string.Format("Wheel total count : {0}  Dressing after count : {1}", CData.Whls[m_iWy].iGtc, CData.Whls[m_iWy].iGdc), true);

                        //lot Work Strip 계산 -> 오토러닝 일경우에만 저장
                        if (CData.LotInfo.bLotOpen)
                        {
                            if (CData.Dev.bDual == eDual.Dual)
                            {
                                if (m_eWy == EWay.R)
                                {
                                    CData.SpcInfo.iWorkStrip++;
                                }
                            }
                            else
                            {
                                CData.SpcInfo.iWorkStrip++;
                            }
                        }

                        //휠 히스토리
                        // 2020.11.05 JSKim St
                        //CData.WhlsLog[m_iWy].iGtc++;
                        //CData.WhlsLog[m_iWy].iDrsCycleStrip++;
                        if (CData.Dev.bMeasureMode == false)
                        {
                            CData.WhlsLog[m_iWy].iGtc++;
                            CData.WhlsLog[m_iWy].iDrsCycleStrip++;
                        }
                        // 2020.11.05 JSKim Ed

                        CWhl.It.Save(m_eWy, CData.Whls[m_iWy]);

                        //200310 ksg : Spindle 부하
                        CData.GrData[m_iWy].bSplLoadFlag = false;

                        if ((CData.GrData[m_iWy].dSplMaxLoad >= CData.Dev.aData[m_iWy].dSpdAuto) && 
                            (CData.GrData[m_iWy].dSplMaxLoad < CData.Dev.aData[m_iWy].dSpdError) &&
                            (CData.Dev.aData[m_iWy].dSpdAuto > 0) && 
                            (CData.Dev.aData[m_iWy].dSpdError > 0))
                        {
                            m_NeedDrs = true;
                        }

                        // 2021.10.19 SungTae Start : [수정] (ASE-KR VOC) SECS/GEM Issue 관련 Flag 초기화
                        CData.bChkGrdM = false;
                        // 2021.10.19 SungTae End

                        _SetLog("Finish.  Status : " + CData.Parts[m_iPart].iStat);

                        m_iGStep = 0;
                        return true;
                    }

                case 70:
                    {
                        if (!m_Delay.Chk_Delay())
                        { return false; }

                        if (m_eWy == EWay.L)
                        { CErr.Show(eErr.LEFT_GRIND_OVER_WHEEL_THICKNESS); }
                        else
                        { CErr.Show(eErr.RIGHT_GRIND_OVER_WHEEL_THICKNESS); }
                        _SetLog("Error : Wheel over thickness.");

                        m_iGStep = 0;
                        return true;
                    }

                case 80:
                    {//200616 pjh : Grinding Water Check 80~84
                        if (!m_Delay.Chk_Delay())
                        { return false; }

                        CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                        //CSpl.It.Write_Stop(m_eWy);
                        // 2023.03.15 Max
                        CSpl_485.It.Write_Stop(m_eWy);

                        _SetLog("Spindle stop.  Z axis move able.", CData.SPos.dGRD_Z_Able[m_iWy]);
                        
                        m_iGStep++;
                        return false;
                    }
                case 81:
                    {
                        if (CData.Spls[m_iWy].iRpm != 0 || !CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        if (m_eWy == EWay.L)
                        {
                            CIO.It.Set_Y(eY.GRDL_ProbeDn, false);
                            CIO.It.Set_Y(eY.GRDL_ProbeAir, false);
                        }
                        else
                        {
                            CIO.It.Set_Y(eY.GRDR_ProbeDn, false);
                            CIO.It.Set_Y(eY.GRDR_ProbeAir, false);
                        }
                        _SetLog("Probe up.");

                        m_iGStep++;
                        return false;
                    }
                case 82:
                    {
                        if (m_eWy == EWay.L)
                        {
                            if (!CIO.It.Get_X(eX.GRDL_ProbeAMP))
                            { return false; }
                        }
                        else
                        {
                            if (!CIO.It.Get_X(eX.GRDR_ProbeAMP))
                            { return false; }
                        }

                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                        _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                        m_iGStep++;
                        return false;
                    }
                case 83:
                    {
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }

                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]);
                        _SetLog("Y axis move wait.", CData.SPos.dGRD_Y_Wait[m_iWy]);
                        
                        m_iGStep++;
                        return false;
                    }
                case 84:
                    {
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]))
                        { return false; }

                        //201003 pjh : Chk DI Error
                        Func_BtmWater(false);
                        Func_SplWater(false);

                        _SetLog("Error : Check DI Error");
                        CErr.Show(eWater);

                        m_iGStep = 0;
                        return true;
                        //
                    }

                //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
                case 300:
                    {
                        //버퍼 스탑 후 모터 레디 대기 시간
                        if (!m_Delay.Chk_Delay())
                        { return false; }

                        m_iGStep = 0;
                        m_iStep = 0;

                        //프로브 업
                        Func_PrbUp();
                        //스핀들 정지
                        //CSpl.It.Write_Stop(m_eWy);
                        // 2023.03.15 Max
                        CSpl_485.It.Write_Stop(m_eWy);

                        //그라인딩 워터(스핀들 워터) 끄기
                        Func_SplWater(false);
                        //그라인딩 바텀 워터(스핀들 바텀 워터) 끄기
                        Func_BtmWater(false);
                        //휠 클리너 워터 끄기
                        if (CDataOption.IsWhlCleaner)
                        { Func_WhlClnWater(false); }
                        //테이블 워터 끄기
                        if (!CDataOption.IsTblWater)
                        { ActWater(false); }
                        //Z축 UP
                        CMot.It.Mv_N(m_iZ, 0);

                        if (m_bErrTableVacuumLow)
                        {
                            CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_TABLE_VACUUM_LOW : eErr.RIGHT_GRIND_TABLE_VACUUM_LOW);
                            _SetLog("Error : Table Vacuum Fail.  Vacuum : " + CData.GrData[m_iWy].dTableVacuumMin.ToString("0.0")
                                        + "kPa / Vacuum Limit : " + CData.Dev.aData[m_iWy].dTableVacuumGrindLimit.ToString("0.0") + "kPa");
                        }
                        else
                        {
                            CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_SPINDLE_CURRENT_HIGH : eErr.RIGHT_GRIND_SPINDLE_CURRENT_HIGH);
                            _SetLog("Error : Spindle overload(Current Limit).  Load : " + CData.GrData[m_iWy].dSplMaxLoad + "%  Current : "
                                            + CData.GrData[m_iWy].nSpindleCurrentMax.ToString() + "mA / Current Limit : "
                                            + CData.Dev.aData[m_iWy].nSpindleCurrentGrindHigh.ToString() + "mA");
                        }

                        ClearAdvancedGrindConditionError(); //Limit Over 상태 초기화 (Spindle Current Low/High, Table Vacuum Low Limit)

                        return true;
                    }
                    //..
            }

        }

        /// <summary>
        /// Dressing
        /// 드레싱 함수
        /// </summary>
        /// <returns></returns>
        public bool Cyl_Drs()
        {
            // Probe down check & Probe up
            if (!m_bUsePrbFlag)
            {
                Func_PrbUp();

                if (!Chk_PrbUpAmp())
                {
                    m_iGStep = 0;
                    m_iStep = 0;

                    Func_SplWater(false);
                    Func_BtmWater(false);
                    if (CDataOption.IsWhlCleaner)
                    { Func_WhlClnWater(false); }
                    //CSpl.It.Write_Stop(m_eWy);
                    // 2023.03.15 Max
                    CSpl_485.It.Write_Stop(m_eWy);

                    CMot.It.Mv_N(m_iZ, 0);

                    CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET : eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                    _SetLog("Error : Probe down during dressing.");

                    return true;
                } 
            }

            // 2020.12.12 JSKim St
            if (m_eWy == EWay.L)
            {
                // 2021-05-28, jhLee : 2000U 설비인 경우 Dressing과 Table Cleaning시에는 Carrier 유무만 체크한다. Chk_Unit 함수를 변경하였다.

                if (CData.Parts[(int)EPart.GRDL].bExistStrip == true || (CDataOption.Package == ePkg.Strip) ? Chk_Strip() : Chk_Unit(true))
                {
                    // Left Alarm 추가 -  있는 거 쓰자
                    CErr.Show(eErr.UNKNOWN_STRIP_ON_THE_TABLE_TO_THE_LEFT);

                    m_iGStep = 0;
                    return true;
                }
            }
            else
            {
                if (CData.Parts[(int)EPart.GRDR].bExistStrip == true || (CDataOption.Package == ePkg.Strip) ? Chk_Strip() : Chk_Unit(true))
                {
                    // Right Alarm 추가 - 있는 거 쓰자
                    CErr.Show(eErr.UNKNOWN_STRIP_ON_THE_TABLE_TO_THE_RIGHT);

                    m_iGStep = 0;
                    return true;
                }
            }
            // 2020.12.12 JSKim Ed

            //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
            //if (CDataOption.UseDeviceAdvancedOption && CDataOption.UseAdvancedGrindCondition && (CDataOption.SplType == eSpindleType.EtherCat)) //Advanced Grind Condition 체크 사용 조건 (라이선스)
            // 2023.03.15 Max
            if (CDataOption.UseDeviceAdvancedOption && CDataOption.UseAdvancedGrindCondition)
            {
                if (0 != CheckAdvancedGrindCondition(1)) //여기서 체크하지만 Step 10에서 체크 시작 => Step 10 이 후부터 체크하게 됨
                {
                    if (m_bErrSpindleCurrentHigh)
                    {
                        //버퍼 모드 아니지만 일단 대기 시간 적용 (버퍼 모드의 경우 버퍼 스탑 후 모터 레디 대기 시간 설정)
                        m_Delay.Set_Delay(500);
                        _SetLog("Set delay : 500ms");

                        ResetAdvancedGrindCondition(1, false); //Condition 체크 플래그 리셋

                        m_iGStep = 300; //종료 처리 및 Alarm
                        return false;
                    }
                }
            }
            //..

            // Timeout check
            if (m_iGPreStep != m_iGStep)
            { m_mGTimeout.Set_Delay(TIMEOUT * 3); }
            else
            {
                if (m_mGTimeout.Chk_Delay())
                {
                    //200717 jhc : Dressing 중 Timeout Error 발생 => 스핀들 정지, 물끄기, Z축 대기위치
                    //1) 스핀들 정지
                    //CSpl.It.Write_Stop(m_eWy);
                    // 2023.03.15 Max
                    CSpl_485.It.Write_Stop(m_eWy);

                    //2) 물 끄기 (스핀들 워터)
                    Func_SplWater(false);
                    //3) 물 끄기 (바텀 워터)
                    Func_BtmWater(false);
                    //4) 물 끄기 (휠 크리너)
                    if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                    {
                        Func_WhlClnWater(false);
                    }
                    //5) Z축 대기위치
                    int iZAxis = (m_eWy == EWay.L) ? (int)EAx.LeftGrindZone_Z : (int)EAx.RightGrindZone_Z;
                    CMot.It.Mv_N(iZAxis, 0);
                    //

                    CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_DRESSING_TIMEOUT :
                                                  eErr.RIGHT_GRIND_DRESSING_TIMEOUT);
                    _SetLog("Error : Timeout.");

                    m_iCnt = 0;
                    m_iGStep = 0;
                    return true;
                }
            }

            m_iGPreStep = m_iGStep;

            //if(CDataOption.SplType == eSpindleType.EtherCat)
            //{
            //    CData.Spls[0].iRpm =  Convert.ToInt32(CSpl.It.GetFrpm(true));
            //    CData.Spls[1].iRpm =  Convert.ToInt32(CSpl.It.GetFrpm(false));
            //}
            // 2023.03.15 Max : CSpl_485.cs에서 CData.Spls[(int)EWay.L].iRpm, CData.Spls[(int)EWay.R].iRpm 값 Update 되어
            // 하기 주석 처리
            //CData.Spls[(int)EWay.L].iRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.L));
            //CData.Spls[(int)EWay.R].iRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.R));


            // 201006 jym st : Delay 추가
            if (CDataOption.IsChkDI && (m_iGStep > 23 && m_iGStep < 31))
            {//200616 pjh : Grinding Water Check
                if (!Chk_GrdWater(m_eWy))
                {
                    if (CData.Opt.iChkDiTime != 0 && !m_tmChkDI.Chk_Delay())
                    { return false; }

                    if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                    { Func_WhlClnWater(false); }
                    //CSpl.It.Write_Stop(m_eWy);
                    // 2023.03.15 Max
                    CSpl_485.It.Write_Stop(m_eWy);

                    m_iGStep = 60;
                    return false;
                }
                else
                { m_tmChkDI.Set_Delay(CData.Opt.iChkDiTime); }
            }
            // 201006 jym ed

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if ((CData.CurCompany == ECompany.ASE_KR) && 
                (m_iGStep == 17 || m_iGStep == 18))
            {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                if (0 != m_iPickerVacErr)
                {
                    CMot.It.EStop(m_iY); //Table Y축 즉시 Stop

                    _SetLog("Error : Picker Vacuum : " + m_siY + " STOP : " + CMot.It.Get_FP(m_iY).ToString());

                    m_iGStep = 100; //정리 스텝으로
                    return false;
                }
            }
            ///////////////////////////////////////////////////////////////////////////////////////

            switch (m_iGStep)
            {
                default:
                    {
                        m_iGStep = 0;
                        return true;
                    }

                case 10:
                    {// 1. 축 상태 체크   
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max 
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iGStep = 0;
                            return true;
                        }

                        // 200919 jym : 프로브 체크 flag
                        m_bUsePrbFlag = false;

                        //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
                        ResetAdvancedGrindCondition(1, true); //Condition 체그 플래그 셋 (체크 시작)
                        //..

                        double dPrid = CData.Dev.aData[m_iWy].dDrsPrid;
                        _SetLog(string.Format("Check axes.  Priod : " + dPrid + "  GDC : " + CData.Whls[m_iWy].iGdc), true);

                        m_iGStep++;
                        return false;
                    }

                case 11:
                    {// 2. 초기화
                        _InitCycle();
                        m_tGrT = new tTempData();
                        m_iStep = 10;
                        m_iCnt = 0;
                        CData.DrData[m_iWy].aInx[0] = 0;
                        CData.DrData[m_iWy].aInx[1] = 0;
                        
                        //20200427 lks 시작시 초기화
                        m_bManualStop = false;
                        _SetLog("Init cycle.");
                                                
                        m_iGStep++;
                        return false;
                    }

                case 12:
                    {// 휠 높이 측정
                        //20191105 ghk_measuretype
                        if (CDataOption.MeasureType == eMeasureType.Jog)
                        {//조그 무브 휠 측정 방식
                            // 201006 jym : Before 측정 시 TTV 검사 안함.
                            if (Cyl_MeaWhl(false) && CSQ_Main.It.m_iStat != EStatus.Error)
                            {
                                //휠 리미트 검사
                                double dTempWhlT = 0.0;
                                if (CData.DrData[m_iWy].bDrsR)
                                { dTempWhlT = CData.Whls[m_iWy].aNewP[0].dTotalDep + CData.Whls[m_iWy].aNewP[1].dTotalDep; }
                                else
                                { dTempWhlT = CData.Whls[m_iWy].aUsedP[0].dTotalDep + CData.Whls[m_iWy].aUsedP[1].dTotalDep; }

                                if (CData.Whls[m_iWy].dWhlLimit > (CData.Whls[m_iWy].dWhlAf - dTempWhlT))
                                {
                                    //200730 jhc : Wheel/Dresser Limit Alaram 보류용 (ASE-Kr VOC)
                                    if ((CData.CurCompany != ECompany.ASE_KR) || (CData.bWhlDrsLimitAlarmSkip == false))
                                    {
                                        CSQ_Main.It.m_bWhlLimitArm = true;
                                        frmMain.bShowWhlView = true;
                                        m_Delay.Set_Delay(1000);
                                        m_iGStep = 50;
                                        return false;
                                    }
                                }

                                if (CData.Whls[m_iWy].iGdc != 0)
                                {
                                    //드레싱 주기 그라인딩 휠 소모량
                                    CData.Whls[m_iWy].dWhldcL = CData.Whls[m_iWy].dWhlBf - CData.Whls[m_iWy].dWhlAf;

                                    if (CData.Whls[m_iWy].iGdc >= CData.Dev.aData[m_iWy].dDrsPrid)
                                    {
                                        // 테이블 자재 한장당 휠 소모량(소수점 4자리까지) (평균 값 로그에 남길 데이터)
                                        CData.Whls[m_iWy].dWhloL = Math.Round((CData.Whls[m_iWy].dWhldcL / CData.Whls[m_iWy].iGdc), 4);
                                    }


                                }

                                //휠 히스토리
                                if (CSQ_Main.It.m_iStat == EStatus.Manual)
                                { CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.BeforeManual.ToString(); }
                                else
                                { CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.BeforeAuto.ToString(); }

			                    //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                if (CData.bUseWheelZAxisAfterMeasureWheel)
                                {
                                    CData.WhlsLog[m_iWy].dWhltL = Math.Round(CData.WheelTipAfterZPos[m_iWy] - CData.WheelTipBeforeZPos[m_iWy], 6);
                                    _SetLog("Z Axis Wheel Loss: " + CData.WhlsLog[m_iWy].dWhltL.ToString(), true);
                                }
                                else
                                {
                                    CData.WhlsLog[m_iWy].dWhltL = CData.WhlBf[m_iWy] - CData.WhlAf[m_iWy];
                                    _SetLog("Wheel Loss: " + CData.WhlsLog[m_iWy].dWhltL.ToString(), true);
                                }
                                //
                                CData.WhlsLog[m_iWy].dWhltipH = CData.WhlAf[m_iWy];
                                if (CData.WhlsLog[m_iWy].iDrsCycleStrip != 0)
                                {
                                    CData.WhlsLog[m_iWy].dOneStripLoss = CData.WhlsLog[m_iWy].dWhltL / CData.WhlsLog[m_iWy].iDrsCycleStrip;
                                }

                                _SetLog("Measure wheel finish(jog).");

                                m_iStep = 10;
                                m_iGStep++;
                            }
                        }
                        else
                        {//스텝 무브 휠 측정 방식
                            // 200903 jym : Timeout 초기화
                            m_mGTimeout.Set_Delay(TIMEOUT * 3);

                            if (Cyl_MeaWhl_Step() && CSQ_Main.It.m_iStat != EStatus.Error)
                            {
                                //휠 리미트 검사
                                double dTempWhlT = 0.0;
                                if (CData.DrData[m_iWy].bDrsR)
                                { dTempWhlT = CData.Whls[m_iWy].aNewP[0].dTotalDep + CData.Whls[m_iWy].aNewP[1].dTotalDep; }
                                else
                                { dTempWhlT = CData.Whls[m_iWy].aUsedP[0].dTotalDep + CData.Whls[m_iWy].aUsedP[1].dTotalDep; }

                                if (CData.Whls[m_iWy].dWhlLimit > (CData.Whls[m_iWy].dWhlAf - dTempWhlT))
                                {
                                    //200730 jhc : Wheel/Dresser Limit Alaram 보류용 (ASE-Kr VOC)
                                    if((CData.CurCompany != ECompany.ASE_KR) || (CData.bWhlDrsLimitAlarmSkip == false))
                                    {
                                        CSQ_Main.It.m_bWhlLimitArm = true;
                                        frmMain.bShowWhlView = true;
                                        m_Delay.Set_Delay(1000);
                                        m_iGStep = 50;
                                        return false;
                                    }
                                }

                                if (CData.Whls[m_iWy].iGdc != 0)
                                {
                                    //드레싱 주기 그라인딩 휠 소모량
                                    CData.Whls[m_iWy].dWhldcL = CData.Whls[m_iWy].dWhlBf - CData.Whls[m_iWy].dWhlAf;

                                    if (CData.Whls[m_iWy].iGdc >= CData.Dev.aData[m_iWy].dDrsPrid)
                                    {
                                        //왼쪽 테이블 자재 한장당 휠 소모량(소수점 4자리까지) (평균 값 로그에 남길 데이터)
                                        CData.Whls[m_iWy].dWhloL = Math.Round((CData.Whls[m_iWy].dWhldcL / CData.Whls[m_iWy].iGdc), 4);
                                    }
                                }

                                //휠 히스토리
                                if (CSQ_Main.It.m_iStat == EStatus.Manual)
                                { CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.BeforeManual.ToString(); }
                                else
                                { CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.BeforeAuto.ToString(); }

			                    //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                if (CData.bUseWheelZAxisAfterMeasureWheel)
                                {
                                    CData.WhlsLog[m_iWy].dWhltL = Math.Round(CData.WheelTipAfterZPos[m_iWy] - CData.WheelTipBeforeZPos[m_iWy], 6);
                                    _SetLog("Z Axis Wheel Loss: " + CData.WhlsLog[m_iWy].dWhltL.ToString(), true);
                                }
                                else
                                {
                                    CData.WhlsLog[m_iWy].dWhltL = CData.WhlBf[m_iWy] - CData.WhlAf[m_iWy];
                                    _SetLog("Wheel Loss: " + CData.WhlsLog[m_iWy].dWhltL.ToString(), true);
                                }
                                //
                                CData.WhlsLog[m_iWy].dWhltipH = CData.WhlAf[m_iWy];
                                if (CData.WhlsLog[m_iWy].iDrsCycleStrip != 0)
                                {
                                    CData.WhlsLog[m_iWy].dOneStripLoss = CData.WhlsLog[m_iWy].dWhltL / CData.WhlsLog[m_iWy].iDrsCycleStrip;
                                }

                                _SetLog("Measure wheel finish(step).");

                                m_iStep = 10;
                                m_iGStep++;
                            }
                        }
                        return false;
                    }

                case 13:
                    {// 드레셔 높이 측정
                        // 200919 jym : 프로브 체크 flag
                        m_bUsePrbFlag = true;

                        // 200903 jym : Timeout 초기화
                        m_mGTimeout.Set_Delay(TIMEOUT * 3);

                        if (Cyl_MeaDrs() && CSQ_Main.It.m_iStat != EStatus.Error)
                        {
                            //드레셔 리미트 검사
                            double dTempDrsT = 0.0;
                            if (CData.DrData[m_iWy].bDrsR)
                            { dTempDrsT = CData.Whls[m_iWy].aNewP[0].dTotalDep + CData.Whls[m_iWy].aNewP[1].dTotalDep; }
                            else
                            { dTempDrsT = CData.Whls[m_iWy].aUsedP[0].dTotalDep + CData.Whls[m_iWy].aUsedP[1].dTotalDep; }

                            if (CData.Whls[m_iWy].dDrsLimit > (CData.Whls[m_iWy].dDrsAf - dTempDrsT))
                            {
                                //200730 jhc : Wheel/Dresser Limit Alaram 보류용 (ASE-Kr VOC)
                                if((CData.CurCompany != ECompany.ASE_KR) || (CData.bWhlDrsLimitAlarmSkip == false))
                                {
                                    CSQ_Main.It.m_bDrsLimitArm = true;
                                    frmMain .bShowWhlView      = true;
                                    m_Delay.Set_Delay(1000);
                                    // 200919 jym : 프로브 체크 flag
                                    m_bUsePrbFlag = false;

                                    m_iGStep = 51;
                                    return false;
                                }
                            }

                            //휠 히스토리
							//220106 pjh : Dresser History 저장							
                            if (CDataOption.UseSeperateDresser)
                            {
                                if(CSQ_Main.It.m_iStat == EStatus.Manual) CData.DrsLog[m_iWy].sMeaType = eDrsMeasureType.BeforeManual.ToString();
                                else CData.DrsLog[m_iWy].sMeaType = eDrsMeasureType.BeforeAuto.ToString();

                                CData.WhlsLog[m_iWy].dDrsL = CData.DrsLog[m_iWy].dDrsL = CData.DrsBf[m_iWy] - CData.DrsAf[m_iWy];
                                CData.WhlsLog[m_iWy].dDrsH = CData.DrsLog[m_iWy].dDrsH = CData.DrsAf[m_iWy];

                                CWhl.It.SaveDrsHistory(m_eWy);
                            }
                            else
                            {
                                CData.WhlsLog[m_iWy].dDrsL = CData.DrsBf[m_iWy] - CData.DrsAf[m_iWy];
                                CData.WhlsLog[m_iWy].dDrsH = CData.DrsAf[m_iWy];
                            }
                            CWhl.It.SaveHistory(m_eWy);

                            // 200919 jym : 프로브 체크 flag
                            m_bUsePrbFlag = false;

                            _SetLog("Measure dresser finish.");

                            m_iStep = 0;
                            m_iGStep++;                            
                        }

                        return false;
                    }

                case 14:
                    {// 탑 클리너 업 및 체크
                        if (m_eWy == EWay.L)
                        { m_tGrT.eIn1 = eX.GRDL_TopClnDn; m_tGrT.eOt1 = eY.GRDL_TopClnDn; }
                        else
                        { m_tGrT.eIn1 = eX.GRDR_TopClnDn; m_tGrT.eOt1 = eY.GRDR_TopClnDn; }

                        Func_TcDown(false);

                        // syc : new cleaner
                        //if (!CIO.It.Get_X(m_tGrT.eIn1))
                        if (!Chk_CleanerDn(false))
                        {
                            _SetLog("Top cleaner up.");
                            
                            m_iGStep++; 
                        }

                        return false;
                    }

                case 15:
                    {// 프로브 업
                        if (m_eWy == EWay.L)    // 왼쪽
                        {
                            m_tGrT.eOt1 = eY.GRDL_ProbeDn;
                            m_tGrT.eIn2 = eX.GRDL_ProbeAMP;
                        }
                        else    // 오른쪽
                        {
                            m_tGrT.eOt1 = eY.GRDR_ProbeDn;
                            m_tGrT.eIn2 = eX.GRDR_ProbeAMP;
                        }

                        //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(true);
                        }
                        Func_PrbDown(false);
                        _SetLog("Probe up.");

                        m_iGStep++;
                        return false;
                    }

                case 16:
                    {// 프로브 업 체크
                        if(CIO.It.Get_X(m_tGrT.eIn2))
                        {
                            //211227 pjh : Ejector off
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(false);
                            }
                            //

                            _SetLog("Check probe up.");

                            m_iGStep++;
                        }

                        return false;
                    }

                case 17:
                    {// 테이블 드레싱 스타트 위치로 최초 이동(Run 스피드) 테이블 워터 온
                        ActWater(true);

                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_DrsStart[m_iWy]);
                        _SetLog("Y axis move dressing start.", CData.SPos.dGRD_Y_DrsStart[m_iWy]);

                        m_iGStep++;
                        return false;
                    }

                case 18:
                    {
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_DrsStart[m_iWy]))
                        { return false; }

                        _SetLog("Check Y axis move.");  
                        
                        m_iGStep++;
                        return false;
                    }

                case 19:
                    {// Z축 드레싱 시작 위치 계산 및 카운트 계산
                        // 200326 mjy : 드레싱 시작 시간 저장
                        CData.DrsElp[m_iWy].dtStr = DateTime.Now;
                        //200406 jym : 드레싱 시작 플래그
                        CData.IsDrsStart[m_iWy] = true;

                        m_dStartZ = Cal_DrsStart();
                        _SetLog("Dresser start position : " + m_dStartZ + "mm", true);

                        // 2020.11.23 JSKim St
                        double dDrsAirCut = CData.Whls[m_iWy].dDair;

                        if (CDataOption.IsDrsAirCutReplace && CData.DrData[m_iWy].bDrsR)
                        {
                            dDrsAirCut = CData.Whls[m_iWy].dDairRep;
                        }
                        // 2020.11.23 JSKim Ed

                        // Dressing Parameter 판단 (Using or New)
                        // 사용할 파라메터 정보 및 진행 카운트 갯수 계산하여 DrData에 입력
                        if (CData.DrData[m_iWy].bDrsR)
                        {
                            CData.DrData[m_iWy].aParm   = CData.Whls[m_iWy].aNewP;
                            // 2020.11.23 JSKim St
                            //CData.DrData[m_iWy].aCnt[0] = Cal_StepCnt(CData.Whls[m_iWy].aNewP[0].dTotalDep + CData.Whls[m_iWy].dDair, CData.Whls[m_iWy].aNewP[0].dCycleDep);
                            CData.DrData[m_iWy].aCnt[0] = Cal_StepCnt(CData.Whls[m_iWy].aNewP[0].dTotalDep + dDrsAirCut, CData.Whls[m_iWy].aNewP[0].dCycleDep);
                            // 2020.11.23 JSKim Ed
                            CData.DrData[m_iWy].aCnt[1] = Cal_StepCnt(CData.Whls[m_iWy].aNewP[1].dTotalDep             , CData.Whls[m_iWy].aNewP[1].dCycleDep);
                            _SetLog(string.Format("New parameter.  Count 1 : {0}  Count 2 : {1}", CData.DrData[m_iWy].aCnt[0], CData.DrData[m_iWy].aCnt[1]), true);
                        }
                        else
                        {
                            CData.DrData[m_iWy].aParm   = CData.Whls[m_iWy].aUsedP;
                            // 2020.11.23 JSKim St
                            //CData.DrData[m_iWy].aCnt[0] = Cal_StepCnt(CData.Whls[m_iWy].aUsedP[0].dTotalDep + CData.Whls[m_iWy].dDair, CData.Whls[m_iWy].aUsedP[0].dCycleDep);
                            CData.DrData[m_iWy].aCnt[0] = Cal_StepCnt(CData.Whls[m_iWy].aUsedP[0].dTotalDep + dDrsAirCut, CData.Whls[m_iWy].aUsedP[0].dCycleDep);
                            // 2020.11.23 JSKim Ed
                            CData.DrData[m_iWy].aCnt[1] = Cal_StepCnt(CData.Whls[m_iWy].aUsedP[1].dTotalDep             , CData.Whls[m_iWy].aUsedP[1].dCycleDep);
                            _SetLog(string.Format("Using parameter.  Count 1 : {0}  Count 2 : {1}", CData.DrData[m_iWy].aCnt[0], CData.DrData[m_iWy].aCnt[1]), true);
                        }  
                        
                        m_iGStep++;
                        return false;
                    }

                case 20:
                    {// Z축 드레싱 시작 위치로 이동
                        CMot.It.Mv_N(m_iZ, m_dStartZ);
                        _SetLog("Z axis move position.", m_dStartZ);   
                        
                        m_iGStep++;
                        return false;
                    }

                case 21:
                    {// Z축 드레싱 시작위치 이동 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dStartZ))
                        { return false; }
                        _SetLog("Check Z axis move.");   
                        
                        m_iGStep++;
                        return false;
                    }

                case 22:
                    {// 그라인딩 워터, 바텀 워터 온
                        if (m_eWy == EWay.L)
                        {
                            m_tGrT.eIn1 = eX.GRDL_SplWater;
                            m_tGrT.eIn2 = eX.GRDL_SplBtmWater;
                            m_tGrT.eOt1 = eY.GRDL_SplWater;
                            m_tGrT.eOt2 = eY.GRDL_SplBtmWater;
                        }
                        else
                        {
                            m_tGrT.eIn1 = eX.GRDR_SplWater;
                            m_tGrT.eIn2 = eX.GRDR_SplBtmWater;
                            m_tGrT.eOt1 = eY.GRDR_SplWater;
                            m_tGrT.eOt2 = eY.GRDR_SplBtmWater;
                        }

                        Func_SplWater(true);
                        Func_BtmWater(true);
                        //200515 myk : Wheel Cleaner Water 추가
                        if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                        { Func_WhlClnWater(true); }

                        _SetLog("Spindle water on.  Bottom water on.");  
                       
                        m_iGStep++;
                        return false;
                    }

                case 23:
                    {// 그라인딩 워터, 바텀 워터 온 체크
                        if (CIO.It.Set_Y(m_tGrT.eOt1, true) &&
                            CIO.It.Set_Y(m_tGrT.eOt2, true) &&
                            CIO.It.Get_X(m_tGrT.eIn1) &&
                            CIO.It.Get_X(m_tGrT.eIn2))
                        {
                            _SetLog("Check water.");

                            m_iGStep++; 
                        }
                        return false;
                    }

                case 24:
                    {// 테이블 속도, 테이블 타켓 위치, Z축 CycleDepth,카운트(드레싱 스텝 확인)  == 반복 시작 점 ==
                        //m_bManualStop = true;
                        if (m_bManualStop)
                        {
                            _SetLog("Manual stop.");

                            m_iGStep = 30;
                            return false;
                        }

                        if (m_iCnt % 2 == 0)
                        { m_tGrT.dPosY = CData.SPos.dGRD_Y_DrsEnd[m_iWy]; }
                        else
                        { m_tGrT.dPosY = CData.SPos.dGRD_Y_DrsStart[m_iWy]; }

                        // 2020.11.23 JSKim St
                        //CData.WhlsLog[m_iWy].dAirCut = CData.Whls[m_iWy].dDair;
                        double dDrsAirCut = CData.Whls[m_iWy].dDair;

                        if (CDataOption.IsDrsAirCutReplace && CData.DrData[m_iWy].bDrsR)
                        {
                            dDrsAirCut = CData.Whls[m_iWy].dDairRep;
                        }

                        CData.WhlsLog[m_iWy].dAirCut = dDrsAirCut;
                        // 2020.11.23 JSKim Ed

                        if (CData.DrData[m_iWy].bDrsR)
                        {
                            if (m_iCnt <= CData.DrData[m_iWy].aCnt[0])
                            {//replace parameter 1번 스텝 테이블 속도, Z축 CycleDepth, rpm
                                m_dVelY = CData.Whls[m_iWy].aNewP[0].dTblSpd  ;
                                m_iRpm  = CData.Whls[m_iWy].aNewP[0].iSplSpd  ;
                                m_dCylZ = CData.Whls[m_iWy].aNewP[0].dCycleDep;

                                // 현재 진행 카운트 갱신
                                CData.DrData[m_iWy].aInx[0] = m_iCnt;
                                CData.DrData[m_iWy].aInx[1] = 0;

                                CData.WhlsLog[m_iWy].dStep1Total   = CData.Whls[m_iWy].aNewP[0].dTotalDep;
                                CData.WhlsLog[m_iWy].dStep1Cycle   = CData.Whls[m_iWy].aNewP[0].dCycleDep;
                                CData.WhlsLog[m_iWy].dStep1TbSpeed = CData.Whls[m_iWy].aNewP[0].dTblSpd  ;
                                CData.WhlsLog[m_iWy].iStep1Rpm     = CData.Whls[m_iWy].aNewP[0].iSplSpd  ;
                            }
                            else
                            {//replace parameter 2번 스텝 테이블 속도, Z축 CycleDepth, rpm
                                m_dVelY = CData.Whls[m_iWy].aNewP[1].dTblSpd  ;
                                m_iRpm  = CData.Whls[m_iWy].aNewP[1].iSplSpd  ;
                                m_dCylZ = CData.Whls[m_iWy].aNewP[1].dCycleDep;

                                // 현재 진행 카운트 갱신
                                CData.DrData[m_iWy].aInx[0] =          CData.DrData[m_iWy].aCnt[0];
                                //CData.DrData[m_iWy].aInx[1] = 0;
                                CData.DrData[m_iWy].aInx[1] = m_iCnt - CData.DrData[m_iWy].aCnt[0]; //190430 ksg : Cnt가 잘 못 표시 되는 현상 수정

                                CData.WhlsLog[m_iWy].dStep2Total   = CData.Whls[m_iWy].aNewP[1].dTotalDep;
                                CData.WhlsLog[m_iWy].dStep2Cycle   = CData.Whls[m_iWy].aNewP[1].dCycleDep;
                                CData.WhlsLog[m_iWy].dStep2TbSpeed = CData.Whls[m_iWy].aNewP[1].dTblSpd  ;
                                CData.WhlsLog[m_iWy].iStep2Rpm     = CData.Whls[m_iWy].aNewP[1].iSplSpd  ;
                            }
                        }
                        else
                        {
                            if (m_iCnt <= CData.DrData[m_iWy].aCnt[0])
                            {//using parameter 1번 스텝 테이블 속도, Z축 CycleDepth, rpm
                                m_dVelY = CData.Whls[m_iWy].aUsedP[0].dTblSpd  ;
                                m_iRpm  = CData.Whls[m_iWy].aUsedP[0].iSplSpd  ;
                                m_dCylZ = CData.Whls[m_iWy].aUsedP[0].dCycleDep;

                                // 현재 진행 카운트 갱신
                                CData.DrData[m_iWy].aInx[0] = m_iCnt;
                                CData.DrData[m_iWy].aInx[1] = 0;

                                CData.WhlsLog[m_iWy].dStep1Total   = CData.Whls[m_iWy].aUsedP[0].dTotalDep;
                                CData.WhlsLog[m_iWy].dStep1Cycle   = CData.Whls[m_iWy].aUsedP[0].dCycleDep;
                                CData.WhlsLog[m_iWy].dStep1TbSpeed = CData.Whls[m_iWy].aUsedP[0].dTblSpd  ;
                                CData.WhlsLog[m_iWy].iStep1Rpm     = CData.Whls[m_iWy].aUsedP[0].iSplSpd  ;
                            }
                            else
                            {//using parameter 2번 스텝 테이블 속도, Z축 CycleDepth, rpm
                                m_dVelY = CData.Whls[m_iWy].aUsedP[1].dTblSpd  ;
                                m_iRpm  = CData.Whls[m_iWy].aUsedP[1].iSplSpd  ;
                                m_dCylZ = CData.Whls[m_iWy].aUsedP[1].dCycleDep;

                                // 현재 진행 카운트 갱신
                                CData.DrData[m_iWy].aInx[0] =          CData.DrData[m_iWy].aCnt[0];
                                CData.DrData[m_iWy].aInx[1] = m_iCnt - CData.DrData[m_iWy].aCnt[0];

                                CData.WhlsLog[m_iWy].dStep2Total   = CData.Whls[m_iWy].aUsedP[1].dTotalDep;
                                CData.WhlsLog[m_iWy].dStep2Cycle   = CData.Whls[m_iWy].aUsedP[1].dCycleDep;
                                CData.WhlsLog[m_iWy].dStep2TbSpeed = CData.Whls[m_iWy].aUsedP[1].dTblSpd  ;
                                CData.WhlsLog[m_iWy].iStep2Rpm     = CData.Whls[m_iWy].aUsedP[1].iSplSpd  ;
                            }
                        }

                        _SetLog("Loop start."); 

                        m_iGStep++;
                        return false;
                    }

                case 25:
                    {// 휠 회전
                     //CSpl.It.Write_Run(m_eWy, m_iRpm);
                     // 2023.03.15 Max
                        bool bExit = false;
                        bool bTimeOutFlag = false;

                        // RPM Setting
                        CSpl_485.It.Write_Rpm(m_eWy, m_iRpm);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRPMSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRPMSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                            return false;
                        }

                        // Spindle RUN
                        bExit = false;
                        bTimeOutFlag = false;
                        CSpl_485.It.Write_Run(m_eWy);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRunSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRunSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            return false;
                        }

                        _SetLog("Spindle run.  Vel : " + m_iRpm + "rpm", true);

                        //m_mSpl_Chk.Set_Delay(300); // 2023.03.15 Max Spindle RPM Check Delay

                        m_iGStep++;
                        return false;
                    }

                case 26:
                    {// 휠 회전 확인

                        //if (!m_mSpl_Chk.Chk_Delay()) { return false; }

                        if (CData.Spls[m_iWy].iRpm > (m_iRpm - 20)) // 2023.03.15 Max Spindle RPM Check
                        {
                            _SetLog("Check spindle run.");
                            
                            m_iGStep++; 
                        }

                        //m_mSpl_Chk.Set_Delay(300); // 2023.03.15 Max Spindle RPM Check Delay

                        return false;
                    }

                case 27:
                    {// 테이블 이동, 카운터 계산
                        CMot.It.Mv_V(m_iY, m_tGrT.dPosY, m_dVelY);
                        _SetLog("Y axis move position.  Vel : " + m_dVelY, m_tGrT.dPosY, true);

                        m_iGStep++;
                        return false;
                    }

                case 28:
                    {
                        if (!CMot.It.Get_Mv(m_iY, m_tGrT.dPosY, GV.INPOS_TBL))
                        {
                            //201202 jhc : 로그 추가
                            _SetLog(string.Format("Dress-Count [{0}/{1}], Y[{2}], Z[{3}], Load[{4}] Amp[{5}] Temp[{6}] RPM[{7}] Vac[{8}]",
                                                               (m_iCnt+1).ToString(), (CData.DrData[m_iWy].aCnt[0] + CData.DrData[m_iWy].aCnt[1]).ToString(),
                                                               CMot.It.Get_FP(m_iY).ToString("0.00000"),
                                                               CMot.It.Get_FP(m_iZ).ToString("0.00000"),
                                                               CData.Spls[m_iWy].dLoad.ToString(),
                                                               CData.Spls[m_iWy].nCurrent_Amp.ToString(),   // Dress
                                                               CData.Spls[m_iWy].dTemp_Val.ToString(),
                                                               CData.Spls[m_iWy].iRpm.ToString(),
                                                               CData.Parts[m_iPart].dChuck_Vacuum.ToString("0.0")));

                            return false;
                        }

                        m_iCnt++;

                        // == 반복 끝 부분 ==
                        if (m_iCnt >= (CData.DrData[m_iWy].aCnt[0] + CData.DrData[m_iWy].aCnt[1]))
                        { m_iGStep = 30; }
                        else
                        {
                            m_tGrT.dPosZ = CMot.It.Get_CP(m_iZ) + m_dCylZ;
                            //200407 jym : 스텝 이동 시 슬로우로 변경
                            CMot.It.Mv_S(m_iZ, m_tGrT.dPosZ);
                            _SetLog("Count : " + m_iCnt + "  Z axis move position(slow).", m_tGrT.dPosZ);
                            
                            m_iGStep++;                            
                        }

                        return false;
                    }

                case 29:
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_tGrT.dPosZ, GV.INPOS_GRD_CYCLE))
                        { return false; }
                        _SetLog("Check Z axis move.");

                        m_iGStep = 24;
                        return false;
                    }

                case 30:
                    {// 워터 오프
                        // 200326 mjy : 드레싱 종료 시간 등록
                        CData.DrsElp[m_iWy].dtEnd = DateTime.Now;
                        CData.DrsElp[m_iWy].tsEls = CData.DrsElp[m_iWy].dtEnd - CData.DrsElp[m_iWy].dtStr;

                        //190430 ksg : Dressing Cnt가 -1 되는 현상 수정 
                        if (CData.DrData[m_iWy].bDrsR)
                        {
                            CData.DrData[m_iWy].aInx[1] = m_iCnt - CData.DrData[m_iWy].aCnt[0]; //190430 ksg : Cnt가 잘 못 표시 되는 현상 수정
                        }
                        else
                        {
                            CData.DrData[m_iWy].aInx[1] = m_iCnt - CData.DrData[m_iWy].aCnt[0];
                        }

                        Func_SplWater(false);
                        Func_BtmWater(false);
                        //200515 myk : Wheel Cleaner Water 추가
                        if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                        { Func_WhlClnWater(false); }

                        _SetLog("Dressing end.  Water off.");
                        
                        m_iGStep++;
                        return false;
                    }

                case 31:
                    {// 워터 오프 체크
                        if (CIO.It.Set_Y(m_tGrT.eOt1, false) &&
                            CIO.It.Set_Y(m_tGrT.eOt2, false) &&
                            !CIO.It.Get_X(m_tGrT.eIn1) &&
                            !CIO.It.Get_X(m_tGrT.eIn2))
                        {
                            CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                            _SetLog("Z axis move able.", CData.SPos.dGRD_Z_Able[m_iWy]);
                            
                            m_iGStep++; 
                        }

                        return false;
                    }

                case 32:
                    {// 스핀들 스탑
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        //CSpl.It.Write_Stop(m_eWy);
                        // 2023.03.15 Max
                        CSpl_485.It.Write_Stop(m_eWy);

                        _SetLog("Spindle stop.");
                        
                        m_iGStep++;
                        return false;
                    }

                case 33:
                    {// 스핀들 스탑 확인
                        if (CData.Spls[m_iWy].iRpm == 0)
                        {
                            m_iStep = 10;
                            _SetLog("Check spindle stop.");

                            if (m_bManualStop)
                            {
                                m_iGStep = 36;
                            }
                            else
                            {
                                m_iGStep++;
                            }
                        }

                        return false;
                    }

                case 34:
                    {// 드레셔 높이 측정
                        // 200919 jym : 프로브 체크 flag
                        m_bUsePrbFlag = true;

                        // 200903 jym : Timeout 초기화
                        m_mGTimeout.Set_Delay(TIMEOUT * 3);

                        if (Cyl_MeaDrs()) //190929 ksg :
                        {
                            if(m_bSubErr)
                            {
                                // 200919 jym : 프로브 체크 flag
                                m_bUsePrbFlag = false;

                                _SetLog("Error : Measure dressing error.");

                                m_iGStep = 0;
                                return true;
                            }
                            //
                            //휠 히스토리
							//220106 pjh : Dresser History 저장							
                            if (CDataOption.UseSeperateDresser)
                            {
                                if(CSQ_Main.It.m_iStat == EStatus.Manual) CData.DrsLog[m_iWy].sMeaType = eDrsMeasureType.AfterManual.ToString();
                                else CData.DrsLog[m_iWy].sMeaType = eDrsMeasureType.AfterAuto.ToString();

                                CData.WhlsLog[m_iWy].dDrsL = CData.DrsLog[m_iWy].dDrsL = CData.DrsBf[m_iWy] - CData.DrsAf[m_iWy];
                                CData.WhlsLog[m_iWy].dDrsH = CData.DrsLog[m_iWy].dDrsH = CData.DrsAf[m_iWy];

                                CWhl.It.SaveDrsHistory(m_eWy);
                            }
                            else
                            {
                                CData.WhlsLog[m_iWy].dDrsL = CData.DrsBf[m_iWy] - CData.DrsAf[m_iWy];
                                CData.WhlsLog[m_iWy].dDrsH = CData.DrsAf[m_iWy];
                            }

                            // 200919 jym : 프로브 체크 flag
                            m_bUsePrbFlag = false;
                            
                            _SetLog("Measure dresser finish.");

                            m_iStep = 10;
                            m_iGStep++;
                        }

                        return false;
                    }

                case 35:
                    {// 휠 높이 측정
                        // 200903 jym : Timeout 초기화
                        m_mGTimeout.Set_Delay(TIMEOUT * 3);

                        if (CDataOption.MeasureType == eMeasureType.Jog)
                        {//조그 무브 휠 측정 방식
                            if (Cyl_MeaWhl())
                            {
                                if (m_bSubErr)
                                {
                                    m_iGStep = 0;
                                    return true;
                                }

                                //휠 히스토리
                                if (CSQ_Main.It.m_iStat == EStatus.Manual)
                                { CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.AfterManual.ToString(); }
                                else
                                { CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.AfterAuto.ToString(); }

			                    //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                if (CData.bUseWheelZAxisAfterMeasureWheel)
                                {
                                    CData.WhlsLog[m_iWy].dWhltL = Math.Round(CData.WheelTipAfterZPos[m_iWy] - CData.WheelTipBeforeZPos[m_iWy], 6);
                                    _SetLog("Z Axis Wheel Loss: " + CData.WhlsLog[m_iWy].dWhltL.ToString(), true);
                                }
                                else
                                {
                                    CData.WhlsLog[m_iWy].dWhltL = CData.WhlBf[m_iWy] - CData.WhlAf[m_iWy];
                                    _SetLog("Wheel Loss: " + CData.WhlsLog[m_iWy].dWhltL.ToString(), true);
                                }
                                //
                                CData.WhlsLog[m_iWy].dWhltipH = CData.WhlAf[m_iWy];
                                CData.WhlsLog[m_iWy].iDrsC++;
                                CData.WhlsLog[m_iWy].iDrsCycleStrip = 0;
                                CWhl.It.SaveHistory(m_eWy);
                                //
                                CData.Whls[m_iWy].dWhldoL = CData.WhlsLog[m_iWy].dWhltL;

                                _SetLog("Measure wheel finish.");

                                m_iGStep++;
                            }
                        }
                        else
                        {//스텝 무브 휠 측정 방식
                            if (Cyl_MeaWhl_Step())
                            {
                                if (m_bSubErr)
                                {
                                    m_iGStep = 0;
                                    return true;
                                }
                                //휠 히스토리
                                if (CSQ_Main.It.m_iStat == EStatus.Manual)
                                { CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.AfterManual.ToString(); }
                                else
                                { CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.AfterAuto.ToString(); }

			                    //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                if (CData.bUseWheelZAxisAfterMeasureWheel)
                                {
                                    CData.WhlsLog[m_iWy].dWhltL = Math.Round(CData.WheelTipAfterZPos[m_iWy] - CData.WheelTipBeforeZPos[m_iWy], 6);
                                    _SetLog("Z Axis Wheel Loss: " + CData.WhlsLog[m_iWy].dWhltL.ToString(), true);
                                }
                                else
                                {
                                    CData.WhlsLog[m_iWy].dWhltL = CData.WhlBf[m_iWy] - CData.WhlAf[m_iWy];
                                    _SetLog("Wheel Loss: " + CData.WhlsLog[m_iWy].dWhltL.ToString(), true);
                                }
                                //
                                CData.WhlsLog[m_iWy].dWhltipH = CData.WhlAf[m_iWy];
                                CData.WhlsLog[m_iWy].iDrsC++;
                                CData.WhlsLog[m_iWy].iDrsCycleStrip = 0;

                                CWhl.It.SaveHistory(m_eWy);

                                CData.Whls[m_iWy].dWhldoL = CData.WhlsLog[m_iWy].dWhltL;

                                _SetLog("Measure wheel finish(step).");

                                m_iGStep++;
                            }
                        }

                        return false;
                    }

                case 36:
                    {//테이블 대기 위치 이동

                        //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                        if (CData.CurCompany == ECompany.ASE_KR)
                        {
                            m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                            if (0 != m_iPickerVacErr)
                            {
                                //200429 jym : 메뉴얼 동작 일때도 테이블 워터 종료
                                if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                                { ActWater(false); }

                                //20200427 lks
                                m_bManualStop = false;

                                _SetLog("ERROR : Picker Vacuum (Step 36)");

                                m_iGStep = 200; //Y축 이동하지 않고 종료 => Error 표시, 드레싱은 완료된 것으로!
                                return false;
                            }
                        }
                        ///////////////////////////////////////////////////////////////////////////////////////

                        // 210106 myk : Dressing 후 휠 높이 측정 시 드레싱 후 휠 두께가 드레싱 전 휠 두께보다 두꺼우면 에러 발생
                        if (CData.CurCompany == ECompany.SkyWorks)
                        {
                            if (CData.WhlBf[m_iWy] < CData.WhlAf[m_iWy])
                            {
                                if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                                { ActWater(false); }

                                m_bManualStop = false;

                                _SetLog("ERROR : Before Wheel Thickness < After Wheel Thickness (Step 36)");

                                m_iGStep = 400;
                                return false;
                            }
                        }

                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]);
                        _SetLog("Y axis move wait.", CData.SPos.dGRD_Y_Wait[m_iWy]);

                        m_iGStep++;
                        return false;
                    }

                case 37:
                    {//테이블 대기 위치 이동 확인, 종료

                        //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                        if (CData.CurCompany == ECompany.ASE_KR)
                        {
                            m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                            if (0 != m_iPickerVacErr)
                            {
                                CMot.It.EStop(m_iY); //Table Y축 즉시 Stop

                                //200429 jym : 메뉴얼 동작 일때도 테이블 워터 종료
                                if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                                { ActWater(false); }

                                //20200427 lks
                                m_bManualStop = false;

                                _SetLog("ERROR : Picker Vacuum (Step 37) : " + m_siY + " STOP : " + CMot.It.Get_FP(m_iY).ToString());

                                m_iGStep = 200; //Y축 즉시 정지 후 종료 => Error 표시, 드레싱은 완료된 것으로!
                                return false;
                            }
                        }
                        ///////////////////////////////////////////////////////////////////////////////////////

                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]))
                        { return false; }

                        //200429 jym : 메뉴얼 동작 일때도 테이블 워터 종료
                        if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                        { ActWater(false); }

                        //20200427 lks
                        if (m_bManualStop)
                        {                            
                            m_bManualStop = false;
                            _SetLog("Manual stop.");

                            m_iCnt = 0;
                            m_iStep = 0;
                            m_iGStep = 0;

                            return true;
                        }

                        _SetLog("Check Y axis move.");

                        m_iGStep++;
                        return false;
                    }

                case 38:
                    {
                        //200429 jym : 메뉴얼 동작 일때도 테이블 워터 종료
                        if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                        {
                            if (CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_TbFlow : eX.GRDR_TbFlow))
                            { return false; }
                        }

                        //200402 jym : 드레싱 이후 테이블 크리닝
                        CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_Table_Clean : ESeq.GRR_Table_Clean;

                        CData.Whls[m_iWy].iGdc = 0;
                        if (CData.Whls[m_iWy].dWhlFtH != 0.0)
                        {
                            //휠 총 소모량
                            CData.Whls[m_iWy].dWhltL = CData.Whls[m_iWy].dWhlFtH - CData.Whls[m_iWy].dWhlAf;
                        }

                        CData.Whls[m_iWy].iDrsC++;                        

                        CWhl.It.Save(m_eWy, CData.Whls[m_iWy]);
                        _SetLog("Wheel file save.");

                        if (CDataOption.AutoOffset == eAutoToolOffset.Use)
                        {
                            double dTotalDepth = 0.0;
                            double dDrsLos     = 0.0;
                            double dWhlLos     = 0.0;
                            double dGap        = 0.0;
                            double dPre = 0.0;

                            if (CData.DrData[m_iWy].bDrsR)
                            {
                                dTotalDepth = CData.Whls[m_iWy].aNewP[0].dTotalDep + CData.Whls[m_iWy].aNewP[1].dTotalDep;
                            }
                            else
                            {
                                dTotalDepth = CData.Whls[m_iWy].aUsedP[0].dTotalDep + CData.Whls[m_iWy].aUsedP[1].dTotalDep;
                            }

                            dDrsLos = CData.WhlsLog[m_iWy].dDrsL  ;
                            dWhlLos = CData.Whls   [m_iWy].dWhldoL;

                            dPre = CData.MPos[m_iWy].dTOOL_SETTER_GAP;
                            dGap = dTotalDepth - (dDrsLos + dWhlLos);

                            //210727 pjh : Tool Setter Gap 변화량이 최대 설정치 이상일 때 Error 발생 및 Tool setter gap값 Update 하지 않음
                            if(CDataOption.UseAutoToolSetterGapLimit && (CData.Opt.dToolMax != 0) && (Math.Abs(dGap) > CData.Opt.dToolMax))
                            {
                                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_AUTO_OFFSET_RANGEOVER : eErr.RIGHT_AUTO_OFFSET_RANGEOVER);
                                _SetLog("Error : Auto offset rangeover. Gap : " + dGap + "mm" + "Tool Setter Gap changed over than Maximum Limit");

                                m_iStep = 0;
                                m_iGStep = 0;
                                return true;
                            }
                            //

                            // 201110 jym : 소수점 자리수 보완
                            //CData.MPos[m_iWy].dTOOL_SETTER_GAP -= dGap;
                            CData.MPos[m_iWy].dTOOL_SETTER_GAP = Math.Round(dPre - dGap, 8);

                            CSetup.It.Save_Offset();
                            CSetup.It.Load_Offset();

                            // 201030 jym : 에러 검사 전에 로그 저장으로 위치 이동
                            //201202 jhc : 로그 보강
                            //_SetLog(string.Format("Tool setter gap : {0} -> {1}", dPre, CData.MPos[m_iWy].dTOOL_SETTER_GAP), true);
                            _SetLog(string.Format("Tool setter gap : {0} -> {1}mm : dGap [{2}] = dTotalDepth [{3}]- (dDrsLos [{4}] + dWhlLos [{5}])",
                                                  dPre, CData.MPos[m_iWy].dTOOL_SETTER_GAP, dGap, dTotalDepth, dDrsLos, dWhlLos), true);

                            // 201022 jym : Auto offset limit 확인 기능 추가
#if true //201202 jhc : Auto offset limit 확인 기능 라이선스 옵션으로 적용
                            if (CDataOption.UseAutoToolSetterGapLimit && //라이선스 체크
                                (CData.Opt.aAtoLimit[m_iWy] != 0) &&     //설정값 0 아님 체크
                                (dGap >= CData.Opt.aAtoLimit[m_iWy]))    //설정 Limit 체크
#else
                            if (CData.CurCompany == ECompany.SkyWorks && CData.Opt.aAtoLimit[m_iWy] != 0 &&
                                dGap >= CData.Opt.aAtoLimit[m_iWy])
#endif
                            {
                                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_AUTO_OFFSET_RANGEOVER : eErr.RIGHT_AUTO_OFFSET_RANGEOVER);
                                _SetLog("Error : Auto offset rangeover.  Gap : " + dGap + "mm");

                                m_iStep = 0;
                                m_iGStep = 0;
                                return true;
                            }
                        }

                        //20190421 ghk_휠 리그라인딩 옵셋
                        CData.Whls[m_iWy].dReGrdOffset = 0;
                        //20190421 ghk_휠 파라미터 선택
                        CData.DrData[m_iWy].bDrsR = false;
                        CData.DrData[m_iWy].bDrs = false;

                        // 2021-10-25, jhLee, For SkyWorks Dressing Sync VOC
                        // Manual Dressing인 경우에만 동기화 플랙을 지정한다.
                        if (CSQ_Main.It.m_iStat == EStatus.Manual)
                        {
                            CData.DrData[m_iWy].bDrsPerformed = true;      // Dressing 작업을 수행했는가 ? Auto-Run 진행시 check한다.
                            _SetLog($"[Dressing Sync] : Set side {m_iWy} Dressing Perform flag");
                        }


                        m_iCnt        = 0;
                        m_iStep       = 0;
                        m_iGStep      = 0;
                        return true;
                    }

                case 50: //190714 ksg :Auto Run 중 화면 변환 후 Error 표시로 변경
                    {
                        if (m_Delay.Chk_Delay()) return false;

                        CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_OVER_WHEEL_THICKNESS :
                                                      eErr.RIGHT_GRIND_OVER_WHEEL_THICKNESS);

                        m_iGStep = 0;
                        return true;
                    }

                case 51: //190714 ksg :Auto Run 중 화면 변환 후 Error 표시로 변경
                    {
                        if (m_Delay.Chk_Delay()) return false;

                        CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_OVER_DRESSER_THICKNESS :
                                                      eErr.RIGHT_GRIND_OVER_DRESSER_THICKNESS);

                        m_iGStep = 0;
                        return true;
                    }
                case 60:
                    {//200616 pjh : Grinding Water Check 60~64
                        CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                        //CSpl.It.Write_Stop(m_eWy);
                        // 2023.03.15 Max
                        CSpl_485.It.Write_Stop(m_eWy);


                        m_iGStep++;

                        return false;
                    }
                case 61:
                    {
                        if (CData.Spls[m_iWy].iRpm != 0 || !CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        if (m_eWy == EWay.L)
                        {
                            CIO.It.Set_Y(eY.GRDL_ProbeDn, false);
                            CIO.It.Set_Y(eY.GRDL_ProbeAir, false);
                        }
                        else
                        {
                            CIO.It.Set_Y(eY.GRDR_ProbeDn, false);
                            CIO.It.Set_Y(eY.GRDR_ProbeAir, false);
                        }
                        //210907 pjh : Probe Up Log 추가
                        _SetLog("Probe up. Probe air off");
                        //
                        m_iGStep++;

                        return false;
                    }
                case 62:
                    {
#if true //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        bool   bProbeUp  = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값
                        if (!bProbeUp || (dProbeVal < GV.dProbeUpHeight))
                        { return false; }
#else
                        if (m_eWy == EWay.L)
                        {
                            if (!CIO.It.Get_X(eX.GRDL_ProbeAMP))
                            { return false; }
                        }
                        else
                        {
                            if (!CIO.It.Get_X(eX.GRDR_ProbeAMP))
                            { return false; }
                        }
#endif

                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);

                        m_iGStep++;

                        return false;
                    }
                case 63:
                    {
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }

                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]);
                        m_iGStep++;

                        return false;
                    }
                case 64:
                    {
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]))
                        { return false; }

                        //201003 pjh : Chk DI Error
                        Func_BtmWater(false);
                        Func_SplWater(false);

                        _SetLog("Error : Check DI Error");
                        CErr.Show(eWater);

                        m_iGStep = 0;
                        return true;
                        //
                    }

                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스
                case 100:
                    {//Z축 대기 위치 이동
                        //200429 jym : 메뉴얼 동작 일때도 테이블 워터 종료
                        if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                        { ActWater(false); }

                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        { m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy]; }
                        else
                        { m_dPosZ = CData.SPos.dGRD_Z_Wait[m_iWy]; }
                        CMot.It.Stop(m_iZ);
                        CMot.It.Mv_N(m_iZ, m_dPosZ);

                        _SetLog("ERROR : Picker Vacuum (Step 100) : " + m_siZ + " UP : " + m_dPosZ.ToString());
                        
                        m_iGStep++;
                        return false;
                    }

                case 101:
                    {//Z축 대기 위치 이동 확인
                        //200429 jym : 메뉴얼 동작 일때도 테이블 워터 종료
                        if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                        {
                            if (CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_TbFlow : eX.GRDR_TbFlow))
                            { return false; }
                        }

                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }

                        if (m_iPickerVacErr == 1)
                        { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else
                        { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        _SetLog("ERROR : Picker Vacuum (Step 101) : " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        m_iGStep = 0;
                        return true;
                    }

                case 200:
                    {
                        //200429 jym : 메뉴얼 동작 일때도 테이블 워터 종료
                        if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                        {
                            if (CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_TbFlow : eX.GRDR_TbFlow))
                            { return false; }
                        }

                        //200402 jym : 드레싱 이후 테이블 크리닝
                        CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_Table_Clean : ESeq.GRR_Table_Clean;

                        CData.Whls[m_iWy].iGdc = 0;
                        if (CData.Whls[m_iWy].dWhlFtH != 0.0)
                        {
                            //휠 총 소모량
                            CData.Whls[m_iWy].dWhltL = CData.Whls[m_iWy].dWhlFtH - CData.Whls[m_iWy].dWhlAf;
                        }
                        CData.Whls[m_iWy].iDrsC++;
                        CWhl.It.Save(m_eWy, CData.Whls[m_iWy]);

                        _SetLog("ERROR : Picker Vacuum (Step 200) : " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        //20191028 ghk_auto_tool_offset
                        if (CDataOption.AutoOffset == eAutoToolOffset.Use)
                        {
                            double dTotalDepth = 0.0;
                            double dDrsLos     = 0.0;
                            double dWhlLos     = 0.0;
                            double dGap        = 0.0;

                            if (CData.DrData[m_iWy].bDrsR)
                            {
                                dTotalDepth = CData.Whls[m_iWy].aNewP[0].dTotalDep + CData.Whls[m_iWy].aNewP[1].dTotalDep;
                            }
                            else
                            {
                                dTotalDepth = CData.Whls[m_iWy].aUsedP[0].dTotalDep + CData.Whls[m_iWy].aUsedP[1].dTotalDep;
                            }

                            dDrsLos = CData.WhlsLog[m_iWy].dDrsL  ;
                            dWhlLos = CData.Whls   [m_iWy].dWhldoL;

                            dGap = dTotalDepth - (dDrsLos + dWhlLos);
                            CData.MPos[m_iWy].dTOOL_SETTER_GAP -= dGap;
                            CSetup.It.Save_Offset();
                            CSetup.It.Load_Offset();
                        }
                        //

                        //20190421 ghk_휠 리그라인딩 옵셋
                        CData.Whls[m_iWy].dReGrdOffset = 0;

                        //20190421 ghk_휠 파라미터 선택
                        CData.DrData[m_iWy].bDrsR = false;
                        CData.DrData[m_iWy].bDrs  = false;
                        m_iCnt        = 0;
                        m_iStep       = 0;
                        m_iGStep      = 0;

                        // 2021-10-25, jhLee, For SkyWorks Dressing Sync VOC
                        // Manual Dressing인 경우에만 동기화 플랙을 지정한다.
                        if (CSQ_Main.It.m_iStat == EStatus.Manual)
                        {
                            CData.DrData[m_iWy].bDrsPerformed = true;      // Dressing 작업을 수행했는가 ? Auto-Run 진행시 check한다.
                            _SetLog($"[Dressing Sync] : Set side {m_iWy} Dressing Perform flag");
                        }



                        if (m_iPickerVacErr == 1)
                        { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else
                        { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        return true;
                    }
                ///////////////////////////////////////////////////////////////////////////////////

                //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
                case 300:
                    {
                        //버퍼 시퀀스 아니지만 딜레이 대기 (버퍼 시퀀스인 경우 버퍼 스탑 후 모터 안정화 대기)
                        if (!m_Delay.Chk_Delay())
                        { return false; }

                        m_iGStep = 0;
                        m_iStep = 0;

                        //프로브 업
                        Func_PrbUp();
                        //스핀들 정지
                        //CSpl.It.Write_Stop(m_eWy);
                        // 2023.03.15 Max
                        CSpl_485.It.Write_Stop(m_eWy);

                        //그라인딩 워터(스핀들 워터) 끄기
                        Func_SplWater(false);
                        //그라인딩 바텀 워터(스핀들 바텀 워터) 끄기
                        Func_BtmWater(false);
                        //휠 클리너 워터 끄기
                        if (CDataOption.IsWhlCleaner)
                        { Func_WhlClnWater(false); }
                        //테이블 워터 끄기
                        if (!CDataOption.IsTblWater)
                        { ActWater(false); }
                        //Z축 UP
                        CMot.It.Mv_N(m_iZ, 0);

                        CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_SPINDLE_CURRENT_HIGH : eErr.RIGHT_GRIND_SPINDLE_CURRENT_HIGH);
                        _SetLog("Error : Spindle overload(Current Limit).  Load : " + CData.GrData[m_iWy].dSplMaxLoad + "%  Current : "
                                        + CData.GrData[m_iWy].nSpindleCurrentMax.ToString() + "mA / Current Limit : "
                                        + CData.Dev.aData[m_iWy].nSpindleCurrentDressHigh.ToString() + "mA");

                        ClearAdvancedGrindConditionError(); //Limit Over 상태 초기화 (Spindle Current Low/High, Table Vacuum Low Limit)

                        return true;
                    }
                //..

                // 210106 myk : Dressing 후 휠 높이 측정 시 드레싱 후 휠 두께가 드레싱 전 휠 두께보다 두꺼우면 에러 발생
                case 400:
                    {
                        if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                        {
                            if (CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_TbFlow : eX.GRDR_TbFlow))
                            { return false; }
                        }

                        CData.DrData[m_iWy].bDrs = true;

                        CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_DRESSING_FAIL :
                                                      eErr.RIGHT_GRIND_DRESSING_FAIL);

                        _SetLog("ERROR : Dressing Fail (Step 400). Bf : " + CData.WhlBf[m_iWy] + " Af : " + CData.WhlAf[m_iWy]);

                        m_iCnt = 0;
                        m_iStep = 0;
                        m_iGStep = 0;
                        return true;
                    }
            }
        }

        public bool Cyl_DrsML()
        {
            // Probe down check & Probe up
            if (!m_bUsePrbFlag)
            {
                Func_PrbUp();

                if (!Chk_PrbUpAmp())
                {
                    m_iGStep = 0;
                    m_iStep = 0;
                    //200408 jym : 버퍼 스탑
                    Bf_Stop();

                    Func_SplWater(false);
                    Func_BtmWater(false);
                    if (CDataOption.IsWhlCleaner)
                    { Func_WhlClnWater(false); }
                    //CSpl.It.Write_Stop(m_eWy);
                    // 2023.03.15 Max
                    CSpl_485.It.Write_Stop(m_eWy);

                    CMot.It.Mv_N(m_iZ, 0);

                    CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET : eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                    _SetLog("Error : Probe down during dressing.");

                    return true;
                }
            }

            // 2020.12.12 JSKim St
            if (m_eWy == EWay.L)
            {
                // 2021-05-28, jhLee, 2000U설비에서 Unit 존재여부를 Carrier 감지 유무로 변경하였다.
                if (CData.Parts[(int)EPart.GRDL].bExistStrip == true || (CDataOption.Package == ePkg.Strip) ? Chk_Strip() : Chk_Unit(true))
                {
                    // Left Alarm 추가 -  있는 거 쓰자
                    CErr.Show(eErr.UNKNOWN_STRIP_ON_THE_TABLE_TO_THE_LEFT);

                    m_iGStep = 0;
                    return true;
                }
            }
            else
            {
                if (CData.Parts[(int)EPart.GRDR].bExistStrip == true || (CDataOption.Package == ePkg.Strip) ? Chk_Strip() : Chk_Unit(true))
                {
                    // Right Alarm 추가 - 있는 거 쓰자
                    CErr.Show(eErr.UNKNOWN_STRIP_ON_THE_TABLE_TO_THE_RIGHT);

                    m_iGStep = 0;
                    return true;
                }
            }
            // 2020.12.12 JSKim Ed

            //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
            //if (CDataOption.UseDeviceAdvancedOption && CDataOption.UseAdvancedGrindCondition && (CDataOption.SplType == eSpindleType.EtherCat)) //Advanced Grind Condition 체크 사용 조건 (라이선스)
            // 2023.03.15 Max
            if (CDataOption.UseDeviceAdvancedOption && CDataOption.UseAdvancedGrindCondition)
            {
                if (0 != CheckAdvancedGrindCondition(1)) //여기서 체크하지만 Step 10에서 체크 시작 => Step 10 이 후부터 체크하게 됨
                {
                    if (m_bErrSpindleCurrentHigh)
                    {
                        Bf_Stop(); //버퍼 스탑

                        //버퍼 스탑 후 모터 레디 대기 시간 설정
                        m_Delay.Set_Delay(500);
                        _SetLog("Set delay : 500ms");

                        ResetAdvancedGrindCondition(1, false); //Condition 체크 플래그 리셋

                        m_iGStep = 300; //종료 처리 및 Alarm
                        return false;
                    }
                }
            }
            //..

            // Timeout check
            if (m_iGPreStep != m_iGStep)
            { m_mGTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mGTimeout.Chk_Delay())
                {
                    //200717 jhc : Dressing 중 Timeout Error 발생 => 스핀들 정지, 물끄기, Z축 대기위치
                    //1) 스핀들 정지
                    //CSpl.It.Write_Stop(m_eWy);
                    // 2023.03.15 Max
                    CSpl_485.It.Write_Stop(m_eWy);

                    //2) 물 끄기 (스핀들 워터)
                    Func_SplWater(false);
                    //3) 물 끄기 (바텀 워터)
                    Func_BtmWater(false);
                    //4) 물 끄기 (휠 크리너)
                    if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                    { Func_WhlClnWater(false); }
                    //5) Z축 대기위치
                    CMot.It.Mv_N(m_iZ, 0);
                    //
                    m_iCnt = 0;
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_DRESSING_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_DRESSING_TIMEOUT); }
                    _SetLog("Error : Timeout.");

                    m_iGStep = 0;
                    return true;
                }
            }

            m_iGPreStep = m_iGStep;

            //if (CDataOption.SplType == eSpindleType.EtherCat)
            //{
            //    CData.Spls[0].iRpm = Convert.ToInt32(CSpl.It.GetFrpm(true));
            //    CData.Spls[1].iRpm = Convert.ToInt32(CSpl.It.GetFrpm(false));
            //}
            // 2023.03.15 Max : CSpl_485.cs에서 CData.Spls[(int)EWay.L].iRpm, CData.Spls[(int)EWay.R].iRpm 값 Update 되어
            // 하기 주석 처리
            //CData.Spls[(int)EWay.L].iRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.L));
            //CData.Spls[(int)EWay.R].iRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.R));


            // 201006 jym st : Delay add
            if (CDataOption.IsChkDI && (m_iGStep > 23 && m_iGStep < 32))
            {   //200616 pjh : Grinding Water Check
                if (!Chk_GrdWater(m_eWy))
                {
                    if (CData.Opt.iChkDiTime != 0 && !m_tmChkDI.Chk_Delay())
                    { return false; }

                    Bf_Stop();
                    if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                    { Func_WhlClnWater(false); }
                    m_Delay.Set_Delay(500);

                    m_iGStep = 60;
                    return false;
                }
                else
                { m_tmChkDI.Set_Delay(CData.Opt.iChkDiTime); }
            }
            // 201006 jym ed

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if ((CData.CurCompany == ECompany.ASE_KR) && 
                (m_iGStep == 17 || m_iGStep == 18))
            {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                if (0 != m_iPickerVacErr)
                {
                    CMot.It.EStop(m_iY); //Table Y축 즉시 Stop

                    _SetLog("ERROR : Picker Vacuum : " + m_siY + " STOP : " + CMot.It.Get_FP(m_iY).ToString());

                    m_iGStep = 100; //정리 스텝으로
                    return false;
                }
            }
            ///////////////////////////////////////////////////////////////////////////////////////

            switch (m_iGStep)
            {
                default:
                    {
                        m_iGStep = 0;
                        return true;
                    }

                case 10:
                    {// 1. 축 상태 체크    
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //Spl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iGStep = 0;
                            return true;
                        }

                        // 200424 jym : ASE KR는 측정 시간을 포함하여 표시
                        if (CData.CurCompany == ECompany.ASE_KR)
                        {
                            // 200326 mjy : 드레싱 시작 시간 저장
                            CData.DrsElp[m_iWy].dtStr = DateTime.Now;
                            //200406 jym : 드레싱 시작 플래그
                            CData.IsDrsStart[m_iWy] = true;
                        }

                        // 200919 jym : 프로브 체크 flag
                        m_bUsePrbFlag = false;

                        //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
                        ResetAdvancedGrindCondition(1, true); //Condition 체그 플래그 셋 (체크 시작)
                        //..

                        //20200625 jhc : 드레싱 시작 시 로그 정보 추가 (드레싱 주기, 드레싱 이후 스트립 그라인딩 카운트)
                        double dPrid = CData.Dev.aData[m_iWy].dDrsPrid;
                        _SetLog(string.Format("Check axes.  Priod : " + dPrid + "  GDC : " + CData.Whls[m_iWy].iGdc), true);

                        m_iGStep++;
                        return false;
                    }

                case 11:
                    {// 2. 초기화
                        _InitCycle();
                        m_tGrT = new tTempData();
                        m_iStep = 10;
                        m_iCnt = 0;
                        CData.DrData[m_iWy].aInx = new int[2];
                        CData.DrData[m_iWy].aCnt = new int[2];
                        _SetLog("Init cycle.");

                        m_iGStep++;
                        return false;
                    }

                case 12:
                    {// 휠 높이 측정
                        // 200903 jym : Timeout 초기화
                        m_mGTimeout.Set_Delay(TIMEOUT);

                        if (CDataOption.MeasureType == eMeasureType.Jog)
                        {//조그 무브 휠 측정 방식
                            // 201006 jym : Before 측정 시 TTV 검사 안함.
                            if (Cyl_MeaWhl(false) && CSQ_Main.It.m_iStat != EStatus.Error)
                            {
                                //휠 리미트 검사
                                double dDrsTotal = 0.0;
                                if (CData.DrData[m_iWy].bDrsR)
                                {
                                    //211014 pjh : Device Wheel 사용 시 Dressing Parameter 변경
                                    if (CDataOption.UseDeviceWheel) dDrsTotal = CDev.It.a_tWhl[m_iWy].aNewP[0].dTotalDep + CDev.It.a_tWhl[m_iWy].aNewP[1].dTotalDep;//211011 pjh : Device Dressing Parameter 조건 추가
                                    else                            dDrsTotal = CData.Whls[m_iWy].aNewP[0].dTotalDep + CData.Whls[m_iWy].aNewP[1].dTotalDep;
                                    _SetLog("Replace parameter.  Total depth : " + dDrsTotal + "mm", true);
                                }
                                else
                                {
                                    //211014 pjh : Device Wheel 사용 시 Dressing Parameter 변경								
                                    if (CDataOption.UseDeviceWheel) dDrsTotal = CDev.It.a_tWhl[m_iWy].aUsedP[0].dTotalDep + CDev.It.a_tWhl[m_iWy].aUsedP[1].dTotalDep;
                                    else                            dDrsTotal = CData.Whls[m_iWy].aUsedP[0].dTotalDep + CData.Whls[m_iWy].aUsedP[1].dTotalDep;
                                    _SetLog("Using parameter.  Total depth : " + dDrsTotal + "mm", true);
                                }

                                if (CData.Whls[m_iWy].dWhlLimit > (CData.Whls[m_iWy].dWhlAf - dDrsTotal))
                                {
                                    //200730 jhc : Wheel/Dresser Limit Alaram 보류용 (ASE-Kr VOC)
                                    if((CData.CurCompany != ECompany.ASE_KR) || (CData.bWhlDrsLimitAlarmSkip == false))
                                    {
                                        CSQ_Main.It.m_bWhlLimitArm = true;
                                        frmMain.bShowWhlView = true;
                                        m_Delay.Set_Delay(1000);
                                        _SetLog("Wheel limit.  Set delay : 1000ms");

                                        m_iGStep = 50;
                                        return false;
                                    }
                                }

                                if (CData.Whls[m_iWy].iGdc != 0)
                                {
                                    //드레싱 주기 그라인딩 휠 소모량
                                    CData.Whls[m_iWy].dWhldcL = CData.Whls[m_iWy].dWhlBf - CData.Whls[m_iWy].dWhlAf;
                                    double dPrid =  CData.Dev.aData[m_iWy].dDrsPrid;

                                    if (CData.Whls[m_iWy].iGdc >= dPrid)
                                    {
                                        //왼쪽 테이블 자재 한장당 휠 소모량(소수점 4자리까지) (평균 값 로그에 남길 데이터)
                                        CData.Whls[m_iWy].dWhloL = Math.Round((CData.Whls[m_iWy].dWhldcL / CData.Whls[m_iWy].iGdc), 4);
                                    }
                                }
                                //휠 히스토리
                                if (CSQ_Main.It.m_iStat == EStatus.Manual)
                                {
                                    CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.BeforeManual.ToString();
                                }
                                else
                                {
                                    CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.BeforeAuto.ToString();
                                }

			                    //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                if (CData.bUseWheelZAxisAfterMeasureWheel)
                                {
                                    CData.WhlsLog[m_iWy].dWhltL = Math.Round(CData.WheelTipAfterZPos[m_iWy] - CData.WheelTipBeforeZPos[m_iWy], 6);
                                    _SetLog("Z Axis Wheel Loss: " + CData.WhlsLog[m_iWy].dWhltL.ToString(), true);
                                }
                                else
                                {
                                    CData.WhlsLog[m_iWy].dWhltL = CData.WhlBf[m_iWy] - CData.WhlAf[m_iWy];
                                    _SetLog("Wheel Loss: " + CData.WhlsLog[m_iWy].dWhltL.ToString(), true);
                                }
                                //
                                CData.WhlsLog[m_iWy].dWhltipH = CData.WhlAf[m_iWy];
                                if (CData.WhlsLog[m_iWy].iDrsCycleStrip != 0)
                                {
                                    CData.WhlsLog[m_iWy].dOneStripLoss = CData.WhlsLog[m_iWy].dWhltL / CData.WhlsLog[m_iWy].iDrsCycleStrip;
                                }

                                _SetLog("Measure wheel finish(jog).");

                                m_iStep = 10;
                                m_iGStep++;
                            }
                        }
                        else
                        {//스텝 무브 휠 측정 방식
                            if (Cyl_MeaWhl_Step(false) && CSQ_Main.It.m_iStat != EStatus.Error)
                            {
                                //휠 리미트 검사
                                double dDrsTotal = 0.0;
                                if (CData.DrData[m_iWy].bDrsR)
                                {
                                    //211014 pjh : Device Wheel 사용 시 Dressing Parameter 변경								
                                    if (CDataOption.UseDeviceWheel) dDrsTotal = CDev.It.a_tWhl[m_iWy].aNewP[0].dTotalDep + CDev.It.a_tWhl[m_iWy].aNewP[1].dTotalDep;//211011 pjh : Device Dressing Parameter 조건 추가
                                    else                            dDrsTotal = CData.Whls[m_iWy].aNewP[0].dTotalDep + CData.Whls[m_iWy].aNewP[1].dTotalDep;
                                    _SetLog("Replace parameter.  Total depth : " + dDrsTotal + "mm", true);
                                }
                                else
                                {
                                    //211014 pjh : Device Wheel 사용 시 Dressing Parameter 변경								
                                    if (CDataOption.UseDeviceWheel) dDrsTotal = CDev.It.a_tWhl[m_iWy].aUsedP[0].dTotalDep + CDev.It.a_tWhl[m_iWy].aUsedP[1].dTotalDep;//211011 pjh : Device Dressing Parameter 조건 추가
                                    else                            dDrsTotal = CData.Whls[m_iWy].aUsedP[0].dTotalDep + CData.Whls[m_iWy].aUsedP[1].dTotalDep;
                                    _SetLog("Using parameter.  Total depth : " + dDrsTotal + "mm", true);
                                }

                                if (CData.Whls[m_iWy].dWhlLimit > (CData.Whls[m_iWy].dWhlAf - dDrsTotal))
                                {
                                    //200730 jhc : Wheel/Dresser Limit Alaram 보류용 (ASE-Kr VOC)
                                    if((CData.CurCompany != ECompany.ASE_KR) || (CData.bWhlDrsLimitAlarmSkip == false))
                                    {
                                        CSQ_Main.It.m_bWhlLimitArm = true;
                                        frmMain.bShowWhlView = true;
                                        m_Delay.Set_Delay(1000);
                                        _SetLog("Wheel limit.  Set delay : 1000ms");

                                        m_iGStep = 50;
                                        return false;
                                    }
                                }

                                if (CData.Whls[m_iWy].iGdc != 0)
                                {
                                    //드레싱 주기 그라인딩 휠 소모량
                                    CData.Whls[m_iWy].dWhldcL = CData.Whls[m_iWy].dWhlBf - CData.Whls[m_iWy].dWhlAf;
                                    double dPrid = CData.Dev.aData[m_iWy].dDrsPrid;

                                    if (CData.Whls[m_iWy].iGdc >= dPrid)
                                    {
                                        //왼쪽 테이블 자재 한장당 휠 소모량(소수점 4자리까지) (평균 값 로그에 남길 데이터)
                                        CData.Whls[m_iWy].dWhloL = Math.Round((CData.Whls[m_iWy].dWhldcL / CData.Whls[m_iWy].iGdc), 4);
                                    }
                                }

                                //휠 히스토리
                                if (CSQ_Main.It.m_iStat == EStatus.Manual)
                                {
                                    CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.BeforeManual.ToString();
                                }
                                else
                                {
                                    CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.BeforeAuto.ToString();
                                }

			                    //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                if (CData.bUseWheelZAxisAfterMeasureWheel)
                                {
                                    CData.WhlsLog[m_iWy].dWhltL = Math.Round(CData.WheelTipAfterZPos[m_iWy] - CData.WheelTipBeforeZPos[m_iWy], 6);
                                    _SetLog("Z Axis Wheel Loss: " + CData.WhlsLog[m_iWy].dWhltL.ToString(), true);
                                }
                                else
                                {
                                    CData.WhlsLog[m_iWy].dWhltL = CData.WhlBf[m_iWy] - CData.WhlAf[m_iWy];
                                    _SetLog("Wheel Loss: " + CData.WhlsLog[m_iWy].dWhltL.ToString(), true);
                                }
                                //
                                CData.WhlsLog[m_iWy].dWhltipH = CData.WhlAf[m_iWy];
                                if (CData.WhlsLog[m_iWy].iDrsCycleStrip != 0)
                                {
                                    CData.WhlsLog[m_iWy].dOneStripLoss = CData.WhlsLog[m_iWy].dWhltL / CData.WhlsLog[m_iWy].iDrsCycleStrip;
                                }

                                _SetLog("Measure wheel finish.");

                                m_iStep = 10;
                                m_iGStep++;
                            }
                        }

                        return false;
                    }

                case 13:
                    {// 드레셔 높이 측정
                     // 200919 jym : 프로브 체크 flag
                        m_bUsePrbFlag = true;

                        // 200903 jym : Timeout 초기화
                        m_mGTimeout.Set_Delay(TIMEOUT);

                        if (Cyl_MeaDrs() && CSQ_Main.It.m_iStat != EStatus.Error)
                        {
                            //드레셔 리미트 검사
                            double dTempDrsT = 0.0;
                            if (CData.DrData[m_iWy].bDrsR)
                            { 
                                //211014 pjh : Device Wheel 사용 시 Dressing Parameter 변경							
                                if(CDataOption.UseDeviceWheel) dTempDrsT = CDev.It.a_tWhl[m_iWy].aNewP[0].dTotalDep + CDev.It.a_tWhl[m_iWy].aNewP[1].dTotalDep;//211011 pjh : Device Dressing Parameter 조건 추가
                                else                           dTempDrsT = CData.Whls[m_iWy].aNewP[0].dTotalDep + CData.Whls[m_iWy].aNewP[1].dTotalDep;
                            }
                            else
                            { 
                                //211014 pjh : Device Wheel 사용 시 Dressing Parameter 변경							
                                if(CDataOption.UseDeviceWheel) dTempDrsT = CDev.It.a_tWhl[m_iWy].aUsedP[0].dTotalDep + CDev.It.a_tWhl[m_iWy].aUsedP[1].dTotalDep;//211011 pjh : Device Dressing Parameter 조건 추가
                                else                           dTempDrsT = CData.Whls[m_iWy].aUsedP[0].dTotalDep + CData.Whls[m_iWy].aUsedP[1].dTotalDep;
                            }

                            if (CData.Whls[m_iWy].dDrsLimit > (CData.Whls[m_iWy].dDrsAf - dTempDrsT))
                            {
                                //200730 jhc : Wheel/Dresser Limit Alaram 보류용 (ASE-Kr VOC)
                                if((CData.CurCompany != ECompany.ASE_KR) || (CData.bWhlDrsLimitAlarmSkip == false))
                                {
                                    CSQ_Main.It.m_bDrsLimitArm = true;
                                    frmMain.bShowWhlView = true;

                                    // 200919 jym : 프로브 체크 flag
                                    m_bUsePrbFlag = false;

                                    m_Delay.Set_Delay(1000);
                                    _SetLog("Dresser limit.  Set delay : 1000ms");

                                    m_iGStep = 51;
                                    return false;
                                }
                            }
                            //휠 히스토리
							//220106 pjh : Dresser History 저장							
                            if (CDataOption.UseSeperateDresser)
                            {
                                if(CSQ_Main.It.m_iStat == EStatus.Manual) CData.DrsLog[m_iWy].sMeaType = eDrsMeasureType.BeforeManual.ToString();
                                else CData.DrsLog[m_iWy].sMeaType = eDrsMeasureType.BeforeAuto.ToString();

                                CData.WhlsLog[m_iWy].dDrsL = CData.DrsLog[m_iWy].dDrsL = CData.DrsBf[m_iWy] - CData.DrsAf[m_iWy];
                                CData.WhlsLog[m_iWy].dDrsH = CData.DrsLog[m_iWy].dDrsH = CData.DrsAf[m_iWy];

                                CWhl.It.SaveDrsHistory(m_eWy);
                            }
                            else
                            {
                                CData.WhlsLog[m_iWy].dDrsL = CData.DrsBf[m_iWy] - CData.DrsAf[m_iWy];
                                CData.WhlsLog[m_iWy].dDrsH = CData.DrsAf[m_iWy];
                            }
                            CWhl.It.SaveHistory(m_eWy);
                            //

                            // 200919 jym : 프로브 체크 flag
                            m_bUsePrbFlag = false;

                            _SetLog("Measure dresser finish.");

                            m_iStep = 0;
                            m_iGStep++;
                        }

                        return false;
                    }

                case 14:
                    {// 탑 클리너 업 및 체크
                        if (m_eWy == EWay.L) //syc : new cleaner 삭제예정
                        {
                            m_tGrT.eIn1 = eX.GRDL_TopClnDn;
                            m_tGrT.eOt1 = eY.GRDL_TopClnDn;
                        }
                        else
                        {
                            m_tGrT.eIn1 = eX.GRDR_TopClnDn;
                            m_tGrT.eOt1 = eY.GRDR_TopClnDn;
                        }

                        Func_TcDown(false);

                        //syc : new cleaner
                        //if (!CIO.It.Get_X(m_tGrT.eIn1))
                        if (!Chk_CleanerDn(false))
                        {
                            _SetLog("Top cleaner up.");

                            m_iGStep++;
                        }

                        return false;
                    }

                case 15:
                    {// 프로브 업
                        if (m_eWy == EWay.L)    // 왼쪽
                        {
                            m_tGrT.eOt1 = eY.GRDL_ProbeDn;
                            m_tGrT.eIn2 = eX.GRDL_ProbeAMP;
                        }
                        else    // 오른쪽
                        {
                            m_tGrT.eOt1 = eY.GRDR_ProbeDn;
                            m_tGrT.eIn2 = eX.GRDR_ProbeAMP;
                        }

                        Func_PrbUp();
                        _SetLog("Probe up.");

                        m_iGStep++;
                        return false;
                    }

                case 16:
                    {// 프로브 업 체크
                        if (CIO.It.Get_X(m_tGrT.eIn2))
                        {
                            _SetLog("Check probe up.");

                            m_iGStep++;
                        }

                        return false;
                    }

                case 17:
                    {// 테이블 드레싱 스타트 위치로 최초 이동(Run 스피드) 테이블 워터 온
                        ActWater(true);
                        
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_DrsStart[m_iWy]);
                        if (CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_DrsStart[m_iWy]) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("Table water on.  Y axis move dressing start.", CData.SPos.dGRD_Y_DrsStart[m_iWy]);

                        m_iGStep++;
                        return false;
                    }

                case 18:
                    {
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_DrsStart[m_iWy]))
                        { return false; }
                        _SetLog("Check Y axis move.");

                        m_iGStep++;
                        return false;
                    }

                case 19:
                    {// Z축 드레싱 시작 위치 계산 및 카운트 계산
                        // 200424 jym : ASE KR외에는 측정 시간 제외하고 표시
                        if (CData.CurCompany != ECompany.ASE_KR)
                        {
                            // 200326 mjy : 드레싱 시작 시간 저장
                            CData.DrsElp[m_iWy].dtStr = DateTime.Now;
                            //200406 jym : 드레싱 시작 플래그
                            CData.IsDrsStart[m_iWy] = true;
                        }
                        m_dStartZ = Cal_DrsStart();
                        _SetLog("Start position : " + m_dStartZ + "mm", true);
                        double dDrsAirCut = 0.0;

                        //211014 pjh : Device Wheel 사용 시 Air Cut 변경
                        if (CDataOption.UseDeviceWheel)
                        {
                            dDrsAirCut = CDev.It.a_tWhl[m_iWy].dDair;

                            if (CDataOption.IsDrsAirCutReplace && CData.DrData[m_iWy].bDrsR)
                            {
                                dDrsAirCut = CDev.It.a_tWhl[m_iWy].dDairRep;
                            }
                        }
                        //
                        else
                        {
                            // 2020.11.23 JSKim St
                            dDrsAirCut = CData.Whls[m_iWy].dDair;

                            if (CDataOption.IsDrsAirCutReplace && CData.DrData[m_iWy].bDrsR)
                            {
                                dDrsAirCut = CData.Whls[m_iWy].dDairRep;
                            }
                        }
                        // 2020.11.23 JSKim Ed

                        // Dressing Parameter 판단 (Using or New)
                        // 사용할 파라메터 정보 및 진행 카운트 갯수 계산하여 DrData에 입력
                        if (CData.DrData[m_iWy].bDrsR)
                        {
                            //211011 pjh : Device Dressing Parameter 조건 추가
                            if (CDataOption.UseDeviceWheel)
                            {
                                CData.DrData[m_iWy].aParm = CDev.It.a_tWhl[m_iWy].aNewP;
                                CData.DrData[m_iWy].aCnt[0] = Cal_StepCnt(CDev.It.a_tWhl[m_iWy].aNewP[0].dTotalDep + dDrsAirCut, CDev.It.a_tWhl[m_iWy].aNewP[0].dCycleDep);
                                CData.DrData[m_iWy].aCnt[1] = Cal_StepCnt(CDev.It.a_tWhl[m_iWy].aNewP[1].dTotalDep, CDev.It.a_tWhl[m_iWy].aNewP[1].dCycleDep);
                            }
                            else
                            {
                                CData.DrData[m_iWy].aParm = CData.Whls[m_iWy].aNewP;
                                // 2020.11.23 JSKim St
                                //CData.DrData[m_iWy].aCnt[0] = Cal_StepCnt(CData.Whls[m_iWy].aNewP[0].dTotalDep + CData.Whls[m_iWy].dDair, CData.Whls[m_iWy].aNewP[0].dCycleDep);
                                CData.DrData[m_iWy].aCnt[0] = Cal_StepCnt(CData.Whls[m_iWy].aNewP[0].dTotalDep + dDrsAirCut, CData.Whls[m_iWy].aNewP[0].dCycleDep);
                                // 2020.11.23 JSKim Ed
                                CData.DrData[m_iWy].aCnt[1] = Cal_StepCnt(CData.Whls[m_iWy].aNewP[1].dTotalDep, CData.Whls[m_iWy].aNewP[1].dCycleDep);
                            }
                            _SetLog(string.Format("Replace parameter.  Count 1 : {0}  Count 2 : {1}", CData.DrData[m_iWy].aCnt[0], CData.DrData[m_iWy].aCnt[1]), true);
                        }
                        else
                        {
                            //211011 pjh : Device Dressing Parameter 조건 추가
                            if (CDataOption.UseDeviceWheel)
                            {
                                CData.DrData[m_iWy].aParm = CDev.It.a_tWhl[m_iWy].aUsedP;
                                CData.DrData[m_iWy].aCnt[0] = Cal_StepCnt(CDev.It.a_tWhl[m_iWy].aUsedP[0].dTotalDep + dDrsAirCut, CDev.It.a_tWhl[m_iWy].aUsedP[0].dCycleDep);
                                CData.DrData[m_iWy].aCnt[1] = Cal_StepCnt(CDev.It.a_tWhl[m_iWy].aUsedP[1].dTotalDep, CDev.It.a_tWhl[m_iWy].aUsedP[1].dCycleDep);
                            }
                            else
                            {
                                CData.DrData[m_iWy].aParm = CData.Whls[m_iWy].aUsedP;
                                // 2020.11.23 JSKim St
                                //CData.DrData[m_iWy].aCnt[0] = Cal_StepCnt(CData.Whls[m_iWy].aUsedP[0].dTotalDep + CData.Whls[m_iWy].dDair, CData.Whls[m_iWy].aUsedP[0].dCycleDep);
                                CData.DrData[m_iWy].aCnt[0] = Cal_StepCnt(CData.Whls[m_iWy].aUsedP[0].dTotalDep + dDrsAirCut, CData.Whls[m_iWy].aUsedP[0].dCycleDep);
                                // 2020.11.23 JSKim Ed
                                CData.DrData[m_iWy].aCnt[1] = Cal_StepCnt(CData.Whls[m_iWy].aUsedP[1].dTotalDep, CData.Whls[m_iWy].aUsedP[1].dCycleDep);
                                _SetLog(string.Format("Using parameter.  Count 1 : {0}  Count 2 : {1}", CData.DrData[m_iWy].aCnt[0], CData.DrData[m_iWy].aCnt[1]), true);
                            }
                        }

                        m_iGStep++;
                        return false;
                    }

                case 20:
                    {// Z축 드레싱 시작 위치로 이동
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, m_dStartZ);
                        if (CMot.It.Mv_N(m_iZ, m_dStartZ) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("Z axis move position.", m_dStartZ);

                        m_iGStep++;
                        return false;
                    }

                case 21:
                    {// Z축 드레싱 시작위치 이동 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dStartZ))
                        { return false; }
                        _SetLog("Check Z axis move.");

                        m_iGStep++;
                        return false;
                    }

                case 22:
                    {// 그라인딩 워터, 바텀 워터 온
                        if (m_eWy == EWay.L)
                        {
                            m_tGrT.eIn1 = eX.GRDL_SplWater;
                            m_tGrT.eIn2 = eX.GRDL_SplBtmWater;
                            m_tGrT.eOt1 = eY.GRDL_SplWater;
                            m_tGrT.eOt2 = eY.GRDL_SplBtmWater;
                        }
                        else
                        {
                            m_tGrT.eIn1 = eX.GRDR_SplWater;
                            m_tGrT.eIn2 = eX.GRDR_SplBtmWater;
                            m_tGrT.eOt1 = eY.GRDR_SplWater;
                            m_tGrT.eOt2 = eY.GRDR_SplBtmWater;
                        }

                        Func_SplWater(true);
                        Func_BtmWater(true);
                        //200515 myk : Wheel Cleaner Water 추가
                        if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                        { Func_WhlClnWater(true); }
                        _SetLog("Spindle water on.  Bottom water on.");

                        m_iGStep++;
                        return false;
                    }

                case 23:
                    {// 그라인딩 워터, 바텀 워터 온 체크
                        if (CIO.It.Set_Y(m_tGrT.eOt1, true) &&
                            CIO.It.Set_Y(m_tGrT.eOt2, true) &&
                            CIO.It.Get_X(m_tGrT.eIn1) &&
                            CIO.It.Get_X(m_tGrT.eIn2))
                        {
                            _SetLog("Check water.");

                            m_iCnt = 0;
                            m_iGStep++;
                        }
                        return false;
                    }

                case 24: //버퍼 구성 및 실행 ==> 스텝 반복 시작 점
                    {
                        int iDir = CData.Dev.aData[m_iWy].iDrs_YEnd_Dir;
                        if (GV.TEMP_DRS_1STEP && m_iCnt == 1)
                        {
                            if (!CMot.It.Get_Mv(m_iZ, m_dStartZ))
                            { return false; }
                        }

                        if (iDir == 0)
                        { _Bf_Drs(m_iCnt); }
                        else
                        { _Bf_Drs(m_iCnt, iDir); }
                        _SetLog("Set buffer sequence.  Direction : " + iDir, true);

                        m_iGStep++;
                        return false;
                    }

                case 25:
                    {// 테이블 속도, 테이블 타켓 위치, Z축 CycleDepth,카운트(드레싱 스텝 확인)  == 반복 시작 점 ==
                        // 2020.11.23 JSKim St
                        //CData.WhlsLog[m_iWy].dAirCut = CData.Whls[m_iWy].dDair;

                        double dDrsAirCut = 0.0;
                        //211014 pjh : Device Wheel 사용 시 Air Cut 변경
                        if (CDataOption.UseDeviceWheel)
                        {
                            dDrsAirCut = CDev.It.a_tWhl[m_iWy].dDair;
                            if (CDataOption.IsDrsAirCutReplace && CData.DrData[m_iWy].bDrsR)
                            {
                                dDrsAirCut = CDev.It.a_tWhl[m_iWy].dDairRep;
                            }
                        }
                        //
                        else
                        {
                            dDrsAirCut = CData.Whls[m_iWy].dDair;
                            if (CDataOption.IsDrsAirCutReplace && CData.DrData[m_iWy].bDrsR)
                            {
                                dDrsAirCut = CData.Whls[m_iWy].dDairRep;
                            }
                        }
                        CData.WhlsLog[m_iWy].dAirCut = dDrsAirCut;
                        // 2020.11.23 JSKim Ed

                        if (CData.DrData[m_iWy].bDrsR)
                        {
                            //replace parameter 1번 스텝 테이블 속도, Z축 CycleDepth, rpm
                            //211011 pjh : Device Dressing Parameter 조건 추가
                            if (CDataOption.UseDeviceWheel)
                            {
                                m_iRpm = CDev.It.a_tWhl[m_iWy].aNewP[m_iCnt].iSplSpd;

                                CData.WhlsLog[m_iWy].dStep1Total = CDev.It.a_tWhl[m_iWy].aNewP[m_iCnt].dTotalDep;
                                CData.WhlsLog[m_iWy].dStep1Cycle = CDev.It.a_tWhl[m_iWy].aNewP[m_iCnt].dCycleDep;
                                CData.WhlsLog[m_iWy].dStep1TbSpeed = CDev.It.a_tWhl[m_iWy].aNewP[m_iCnt].dTblSpd;
                                CData.WhlsLog[m_iWy].iStep1Rpm = CDev.It.a_tWhl[m_iWy].aNewP[m_iCnt].iSplSpd;
                            }
                            else
                            {
                                m_iRpm = CData.Whls[m_iWy].aNewP[m_iCnt].iSplSpd;

                                CData.WhlsLog[m_iWy].dStep1Total = CData.Whls[m_iWy].aNewP[m_iCnt].dTotalDep;
                                CData.WhlsLog[m_iWy].dStep1Cycle = CData.Whls[m_iWy].aNewP[m_iCnt].dCycleDep;
                                CData.WhlsLog[m_iWy].dStep1TbSpeed = CData.Whls[m_iWy].aNewP[m_iCnt].dTblSpd;
                                CData.WhlsLog[m_iWy].iStep1Rpm = CData.Whls[m_iWy].aNewP[m_iCnt].iSplSpd;
                            }
                        }
                        else
                        {
                            //211011 pjh : Device Dressing Parameter 조건 추가
                            if (CDataOption.UseDeviceWheel)
                            {
                                m_iRpm = CDev.It.a_tWhl[m_iWy].aUsedP[m_iCnt].iSplSpd;

                                CData.WhlsLog[m_iWy].dStep1Total = CDev.It.a_tWhl[m_iWy].aUsedP[m_iCnt].dTotalDep;
                                CData.WhlsLog[m_iWy].dStep1Cycle = CDev.It.a_tWhl[m_iWy].aUsedP[m_iCnt].dCycleDep;
                                CData.WhlsLog[m_iWy].dStep1TbSpeed = CDev.It.a_tWhl[m_iWy].aUsedP[m_iCnt].dTblSpd;
                                CData.WhlsLog[m_iWy].iStep1Rpm = CDev.It.a_tWhl[m_iWy].aUsedP[m_iCnt].iSplSpd;
                            }
                            else
                            {
                                m_iRpm = CData.Whls[m_iWy].aUsedP[m_iCnt].iSplSpd;

                                CData.WhlsLog[m_iWy].dStep1Total = CData.Whls[m_iWy].aUsedP[m_iCnt].dTotalDep;
                                CData.WhlsLog[m_iWy].dStep1Cycle = CData.Whls[m_iWy].aUsedP[m_iCnt].dCycleDep;
                                CData.WhlsLog[m_iWy].dStep1TbSpeed = CData.Whls[m_iWy].aUsedP[m_iCnt].dTblSpd;
                                CData.WhlsLog[m_iWy].iStep1Rpm = CData.Whls[m_iWy].aUsedP[m_iCnt].iSplSpd;
                            }
                        }

                        // 2020.11.23 JSKim St
                        //_SetLog(string.Format("Air-cut thickness : {0}mm  Spindle velocity : {1}rpm", CData.Whls[m_iWy].dDair, m_iRpm), true);
                        _SetLog(string.Format("Air-cut thickness : {0}mm  Spindle velocity : {1}rpm", dDrsAirCut, m_iRpm), true);
                        // 2020.11.23 JSKim Ed

                        m_iGStep++;
                        return false;
                    }

                case 26: //휠 회전
                    {
                        //CSpl.It.Write_Run(m_eWy, m_iRpm);
                        // 2023.03.15 Max
                        bool bExit = false;
                        bool bTimeOutFlag = false;

                        // RPM Setting
                        CSpl_485.It.Write_Rpm(m_eWy, m_iRpm);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRPMSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRPMSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                            return false;
                        }

                        // Spindle RUN
                        bExit = false;
                        bTimeOutFlag = false;
                        CSpl_485.It.Write_Run(m_eWy);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRunSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRunSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            return false;
                        }

                        _SetLog("Spindle run.  Vel : " + m_iRpm + "rpm");

                        //m_mSpl_Chk.Set_Delay(300); // 2023.03.15 Max Spindle RPM Check Delay

                        m_iGStep++;
                        return false;
                    }

                case 27: //휠 회전 확인
                    {
                        
                        //if (!m_mSpl_Chk.Chk_Delay()) { return false; }

                        if (CData.Spls[m_iWy].iRpm > (m_iRpm - 20)) // 2023.03.15 Max Spindle RPM Check
                        {
                            _SetLog("Check spindle run.");

                            m_iGStep++;
                        }

                        //m_mSpl_Chk.Set_Delay(300); // 2023.03.15 Max Spindle RPM Check Delay

                        return false;
                    }

                case 28: //버퍼 시퀀스 시작
                    {
                        _Bf_Start();
                        _SetLog("Buffer start.");

                        m_iGStep++;
                        return false;
                    }

                case 29: //버퍼 시퀀스 시작
                    {
                        _Bf_GetStatus();

                        //200824 jhc : 버퍼모드에서 그라인딩/드레싱 카운트 계산 (드레싱 방향 옵션 별 카운팅)
                        int nMotionStepNum = 2;
                        if (((m_eWy == EWay.L) && (CData.Dev.aData[0].iDrs_YEnd_Dir != 0)) || ((m_eWy == EWay.R) && (CData.Dev.aData[1].iDrs_YEnd_Dir != 0)))
                        { nMotionStepNum = 3; }
                        CData.DrData[m_iWy].aInx[m_iCnt] = CalcBfCount(nMotionStepNum, CData.DrData[m_iWy].aCnt[m_iCnt]);

                        m_iGStep++;
                        return false;
                    }

                case 30: //버퍼 시퀀스 시작
                    {
                        // 200831 jym : 축 상태 검사 추가
                        if (Chk_AxesML())
                        {
                            Bf_Stop();
                            _SetLog(string.Format("Error : X axis  Cmd : {0}mm  Fed : {1}mm", CMot.It.Get_CP(m_iX), CMot.It.Get_FP(m_iX)));
                            _SetLog(string.Format("Error : Y axis  Cmd : {0}mm  Fed : {1}mm", CMot.It.Get_CP(m_iY), CMot.It.Get_FP(m_iY)));
                            _SetLog(string.Format("Error : Z axis  Cmd : {0}mm  Fed : {1}mm", CMot.It.Get_CP(m_iZ), CMot.It.Get_FP(m_iZ)));

                            m_iGStep = 0;
                            return true;
                        }

                        if (!CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_ProbeAMP : eX.GRDR_ProbeAMP))
                        {
                            Bf_Stop();
                            CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET : eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                            _SetLog("Error : Probe down.");

                            m_iGStep = 0;
                            return true;
                        }

                        if (m_mBfStat.State == BufferState.Idle)
                        {   //버퍼 시퀀스 종료
                            _SetLog(string.Format("Buffer end.  Y Pos : {0}mm  Z Pos : {1}mm", CMot.It.Get_FP(m_iY), CMot.It.Get_FP(m_iZ)), true);

                            //200814 jhc : 버퍼 동작 완료 시 최종 카운트 재차 업데이트
                            CData.DrData[m_iWy].aInx[m_iCnt] = CData.DrData[m_iWy].aCnt[m_iCnt];

                            if (m_iCnt == 1)
                            {   //종료
                                _SetLog("Dressing end.");
                                m_iGStep++;
                            }
                            else
                            {   //다음 스텝 이동
                                m_iCnt++;
                                if (GV.TEMP_DRS_1STEP)
                                {
                                    // 200901 jym : 다음 스텝 시 z축 1cycle 하강
                                    m_dStartZ = CMot.It.Get_FP(m_iZ) + CData.DrData[m_iWy].aParm[m_iCnt].dCycleDep;
                                    CMot.It.Mv_N(m_iZ, m_dStartZ);
                                    _SetLog("Next step.  Z axis move position.", m_dStartZ);
                                }
                                else
                                { _SetLog("Next step."); }
                                m_iGStep = 24;
                            }
                        }
                        else
                        {
                            m_iGStep = 29;
                        }
                        
                        return false;
                    }

                case 31:
                    {// 워터 오프
                        //200424 jym : ASE KR 외에는 측정시간 미포함하고 표시
                        if (CData.CurCompany != ECompany.ASE_KR)
                        {
                            // 200326 mjy : 드레싱 종료 시간 등록
                            CData.DrsElp[m_iWy].dtEnd = DateTime.Now;
                            CData.DrsElp[m_iWy].tsEls = CData.DrsElp[m_iWy].dtEnd - CData.DrsElp[m_iWy].dtStr;
                        }
                        _Bf_Clear();

                        Func_SplWater(false);
                        Func_BtmWater(false);
                        //200515 myk : Wheel Cleaner Water 추가
                        if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                        { Func_WhlClnWater(false); }
                        _SetLog("Buffer clear.  Water off.");

                        m_iGStep++;
                        return false;
                    }

                case 32:
                    {// 워터 오프 체크
                        if (CIO.It.Set_Y(m_tGrT.eOt1, false) &&
                            CIO.It.Set_Y(m_tGrT.eOt2, false) &&
                            !CIO.It.Get_X(m_tGrT.eIn1) &&
                            !CIO.It.Get_X(m_tGrT.eIn2))
                        {
                            CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                            _SetLog("Z axis move able.", CData.SPos.dGRD_Z_Able[m_iWy]);

                            m_iGStep++;
                        }

                        return false;
                    }

                case 33:
                    {// 스핀들 스탑
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }
                        //CSpl.It.Write_Stop(m_eWy);
                        // 2023.03.15 Max
                        CSpl_485.It.Write_Stop(m_eWy);

                        _SetLog("Spindle stop.");

                        m_iGStep++;
                        return false;
                    }

                case 34:
                    {// 스핀들 스탑 확인
                        if (CData.Spls[m_iWy].iRpm == 0)
                        {
                            m_iStep = 10;
                            _SetLog("Check spindle stop.");

                            m_iGStep++;
                        }

                        return false;
                    }

                case 35:
                    {// 드레셔 높이 측정
                     // 200919 jym : 프로브 체크 flag
                        m_bUsePrbFlag = true;

                        // 200903 jym : Timeout 초기화
                        m_mGTimeout.Set_Delay(TIMEOUT);

                        if (Cyl_MeaDrs()) //190929 ksg :
                        {
                            if (m_bSubErr)
                            {
                                // 200919 jym : 프로브 체크 flag
                                m_bUsePrbFlag = false;

                                _SetLog("Error : Measure dresser.");

                                m_iGStep = 0;
                                return true;
                            }
                            //
                            //휠 히스토리
							//220106 pjh : Dresser History 저장
                            if (CDataOption.UseSeperateDresser)
                            {
                                if(CSQ_Main.It.m_iStat == EStatus.Manual) CData.DrsLog[m_iWy].sMeaType = eDrsMeasureType.AfterManual.ToString();
                                else CData.DrsLog[m_iWy].sMeaType = eDrsMeasureType.AfterAuto.ToString();

                                CData.WhlsLog[m_iWy].dDrsL = CData.DrsLog[m_iWy].dDrsL = CData.DrsBf[m_iWy] - CData.DrsAf[m_iWy];
                                CData.WhlsLog[m_iWy].dDrsH = CData.DrsLog[m_iWy].dDrsH = CData.DrsAf[m_iWy];

                                CWhl.It.SaveDrsHistory(m_eWy);
                            }
                            else
                            {
                                CData.WhlsLog[m_iWy].dDrsL = CData.DrsBf[m_iWy] - CData.DrsAf[m_iWy];
                                CData.WhlsLog[m_iWy].dDrsH = CData.DrsAf[m_iWy];
                            }

                            // 200919 jym : 프로브 체크 flag
                            m_bUsePrbFlag = false;

                            m_iStep = 10;
                            _SetLog(string.Format("Measure dresser finish.  {0}mm -> {1}mm  Loss : {2}mm", CData.DrsBf[m_iWy], CData.DrsAf[m_iWy], CData.WhlsLog[m_iWy].dDrsL), true);

                            m_iGStep++;
                        }

                        return false;
                    }

                case 36:
                    {// 휠 높이 측정
                        // 200903 jym : Timeout 초기화
                        m_mGTimeout.Set_Delay(TIMEOUT);

                        if (CDataOption.MeasureType == eMeasureType.Jog)
                        {//조그 무브 휠 측정 방식
                            if (Cyl_MeaWhl())
                            {
                                if (m_bSubErr)
                                {
                                    _SetLog("Error : Measure wheel(jog).");

                                    m_iGStep = 0;
                                    return true;
                                }
                                //휠 히스토리
                                if (CSQ_Main.It.m_iStat == EStatus.Manual)
                                {
                                    CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.AfterManual.ToString();
                                }
                                else
                                {
                                    CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.AfterAuto.ToString();
                                }

			                    //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                if (CData.bUseWheelZAxisAfterMeasureWheel)
                                {
                                    CData.WhlsLog[m_iWy].dWhltL = Math.Round(CData.WheelTipAfterZPos[m_iWy] - CData.WheelTipBeforeZPos[m_iWy], 6);
                                    _SetLog("Z Axis Wheel Loss: " + CData.WhlsLog[m_iWy].dWhltL.ToString(), true);
                                }
                                else
                                {
                                    CData.WhlsLog[m_iWy].dWhltL = CData.WhlBf[m_iWy] - CData.WhlAf[m_iWy];
                                    _SetLog("Wheel Loss: " + CData.WhlsLog[m_iWy].dWhltL.ToString(), true);
                                }
                                //
                                CData.WhlsLog[m_iWy].dWhltipH = CData.WhlAf[m_iWy];
                                CData.WhlsLog[m_iWy].iDrsC++;
                                CData.WhlsLog[m_iWy].iDrsCycleStrip = 0;

                                CWhl.It.SaveHistory(m_eWy);
                                //
                                
                                CData.Whls[m_iWy].dWhldoL = CData.WhlsLog[m_iWy].dWhltL;
                                _SetLog(string.Format("Measure wheel finish(jog).  {0}mm -> {1}mm  Loss : {2}mm", CData.WhlBf[m_iWy], CData.WhlAf[m_iWy], CData.WhlsLog[m_iWy].dWhltL), true);

                                m_iGStep++;
                            }
                        }
                        else
                        {//스텝 무브 휠 측정 방식
                            if (Cyl_MeaWhl_Step())
                            {
                                if (m_bSubErr)
                                {
                                    _SetLog("Error : Measure wheel(jog).");

                                    m_iGStep = 0;
                                    return true;
                                }
                                //휠 히스토리
                                if (CSQ_Main.It.m_iStat == EStatus.Manual)
                                {
                                    CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.AfterManual.ToString();
                                }
                                else
                                {
                                    CData.WhlsLog[m_iWy].sMeaType = eWhlMeasureType.AfterAuto.ToString();
                                }

			                    //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                                if (CData.bUseWheelZAxisAfterMeasureWheel)
                                {
                                    CData.WhlsLog[m_iWy].dWhltL = Math.Round(CData.WheelTipAfterZPos[m_iWy] - CData.WheelTipBeforeZPos[m_iWy], 6);
                                    _SetLog("Z Axis Wheel Loss: " + CData.WhlsLog[m_iWy].dWhltL.ToString(), true);
                                }
                                else
                                {
                                    CData.WhlsLog[m_iWy].dWhltL = CData.WhlBf[m_iWy] - CData.WhlAf[m_iWy];
                                    _SetLog("Wheel Loss: " + CData.WhlsLog[m_iWy].dWhltL.ToString(), true);
                                }
                                //
                                CData.WhlsLog[m_iWy].dWhltipH = CData.WhlAf[m_iWy];
                                CData.WhlsLog[m_iWy].iDrsC++;
                                CData.WhlsLog[m_iWy].iDrsCycleStrip = 0;

                                CWhl.It.SaveHistory(m_eWy);
                                //
                                
                                CData.Whls[m_iWy].dWhldoL = CData.WhlsLog[m_iWy].dWhltL;
                                _SetLog(string.Format("Measure wheel finish.  {0}mm -> {1}mm  Loss : {2}mm", CData.WhlBf[m_iWy], CData.WhlAf[m_iWy], CData.WhlsLog[m_iWy].dWhltL), true);

                                m_iGStep++;
                            }
                        }

                        return false;
                    }

                case 37:
                    {//테이블 대기 위치 이동

                        //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                        if (CData.CurCompany == ECompany.ASE_KR)
                        {
                            m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                            if (0 != m_iPickerVacErr)
                            {
                                //200429 jym : 메뉴얼 동작 일때도 테이블 워터 종료
                                if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                                { ActWater(false); }

                                //20200427 lks
                                m_bManualStop = false;

                                _SetLog("ERROR : Picker Vacuum (Step 37)");

                                m_iGStep = 200; //Y축 이동하지 않고 종료 => Error 표시, 드레싱은 완료된 것으로!
                                return false;
                            }
                        }
                        ///////////////////////////////////////////////////////////////////////////////////////

                        // 210106 myk : Dressing 후 휠 높이 측정 시 드레싱 후 휠 두께가 드레싱 전 휠 두께보다 두꺼우면 에러 발생
                        if (CData.CurCompany == ECompany.SkyWorks)
                        {
                            if (CData.WhlBf[m_iWy] < CData.WhlAf[m_iWy])
                            {
                                if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                                { ActWater(false); }

                                m_bManualStop = false;

                                _SetLog("ERROR : Before Wheel Thickness < After Wheel Thickness (Step 37)");

                                m_iGStep = 400;
                                return false;
                            }
                        }

                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]);
                        _SetLog("Y axis move wait.", CData.SPos.dGRD_Y_Wait[m_iWy]);

                        m_iGStep++;
                        return false;
                    }
                case 38:
                    {//테이블 대기 위치 이동 확인, 종료

                        //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                        if (CData.CurCompany == ECompany.ASE_KR)
                        {
                            m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                            if (0 != m_iPickerVacErr)
                            {
                                CMot.It.EStop(m_iY); //Table Y축 즉시 Stop

                                //200429 jym : 메뉴얼 동작 일때도 테이블 워터 종료
                                if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                                { ActWater(false); }

                                //20200427 lks
                                m_bManualStop = false;

                                _SetLog("ERROR : Picker Vacuum (Step 38) : " + m_siY + " STOP : " + CMot.It.Get_FP(m_iY).ToString());

                                m_iGStep = 200; //Y축 즉시 정지 후 종료 => Error 표시, 드레싱은 완료된 것으로!
                                return false;
                            }
                        }
                        ///////////////////////////////////////////////////////////////////////////////////////

                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]))
                        { return false; }

                        //200429 jym : 메뉴얼 동작에서 테이블 워터 오프
                        if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                        { ActWater(false); }
                        _SetLog("Check Y axis move.");

                        m_iGStep++;
                        return false;
                    }

                case 39:
                    {
                        //200429 jym : 메뉴얼 동작에서 테이블 워터 오프
                        if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                        {
                            if (m_eWy == EWay.L)
                            {
                                if (CIO.It.Get_X(eX.GRDL_TbFlow))
                                { return false; }
                            }
                            else
                            {
                                if (CIO.It.Get_X(eX.GRDR_TbFlow))
                                { return false; }
                            }
                        }

                        //200424 jym : ASE KR는 측정시간 포함하고 표시
                        if (CData.CurCompany == ECompany.ASE_KR)
                        {
                            // 200326 mjy : 드레싱 종료 시간 등록
                            CData.DrsElp[m_iWy].dtEnd = DateTime.Now;
                            CData.DrsElp[m_iWy].tsEls = CData.DrsElp[m_iWy].dtEnd - CData.DrsElp[m_iWy].dtStr;
                        }

                        if (m_eWy == EWay.L)
                        {
                            //200402 jym : 드레싱 이후 테이블 크리닝
                            CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_Table_Clean;
                        }
                        else
                        {
                            //200402 jym : 드레싱 이후 테이블 크리닝
                            CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_Table_Clean;
                        }

                        CData.Whls[m_iWy].iGdc = 0;
                        if (CData.Whls[m_iWy].dWhlFtH != 0.0)
                        {
                            //휠 총 소모량
                            CData.Whls[m_iWy].dWhltL = CData.Whls[m_iWy].dWhlFtH - CData.Whls[m_iWy].dWhlAf;
                        }
                        CData.Whls[m_iWy].iDrsC++;
                        
                        CWhl.It.Save(m_eWy, CData.Whls[m_iWy]);

                        //20191028 ghk_auto_tool_offset
                        if (CDataOption.AutoOffset == eAutoToolOffset.Use)
                        {
                            double dTotalDepth = 0.0;
                            double dDrsLos     = 0.0;
                            double dWhlLos     = 0.0;
                            double dGap        = 0.0;
                            double dPre = CData.MPos[m_iWy].dTOOL_SETTER_GAP;

                            if (CData.DrData[m_iWy].bDrsR)
                            {
                                //211014 pjh : Device Wheel 사용 시 Dressing Parameter 변경							
                                if (CDataOption.UseDeviceWheel) dTotalDepth = CDev.It.a_tWhl[m_iWy].aNewP[0].dTotalDep + CDev.It.a_tWhl[m_iWy].aNewP[1].dTotalDep;
                                else                            dTotalDepth = CData.Whls[m_iWy].aNewP[0].dTotalDep + CData.Whls[m_iWy].aNewP[1].dTotalDep;
                            }
                            else
                            {
                                //211014 pjh : Device Wheel 사용 시 Dressing Parameter 변경							
                                if (CDataOption.UseDeviceWheel) dTotalDepth = CDev.It.a_tWhl[m_iWy].aUsedP[0].dTotalDep + CDev.It.a_tWhl[m_iWy].aUsedP[1].dTotalDep;
                                else                            dTotalDepth = CData.Whls[m_iWy].aUsedP[0].dTotalDep + CData.Whls[m_iWy].aUsedP[1].dTotalDep;
                            }

                            dDrsLos = CData.WhlsLog[m_iWy].dDrsL;
                            dWhlLos = CData.Whls[m_iWy].dWhldoL;

                            dGap = dTotalDepth - (dDrsLos + dWhlLos);

                            //210727 pjh : Tool Setter Gap 변화량이 최대 설정치 이상일 때 Error 발생 및 Tool setter gap값 Update 하지 않음
                            if (CDataOption.UseAutoToolSetterGapLimit && (CData.Opt.dToolMax != 0) && (Math.Abs(dGap) > CData.Opt.dToolMax))
                            {
                                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_AUTO_OFFSET_RANGEOVER : eErr.RIGHT_AUTO_OFFSET_RANGEOVER);
                                _SetLog("Error : Auto offset rangeover. Gap : " + dGap + "mm" + "Tool Setter Gap changed over than Maximum Limit");

                                m_iStep = 0;
                                m_iGStep = 0;
                                return true;
                            }
                            //

                            // 201110 jym : 소수점 자리수 보완
                            //CData.MPos[m_iWy].dTOOL_SETTER_GAP -= dGap;
                            CData.MPos[m_iWy].dTOOL_SETTER_GAP = Math.Round(dPre - dGap, 8);

                            CSetup.It.Save_Offset();
                            CSetup.It.Load_Offset();

                            // 201030 jym : 에러 검사 전에 로그 저장으로 위치 이동
                            //201202 jhc : 로그 보강
                            //_SetLog(string.Format("Tool setter gap : {0} -> {1}mm ", dPre, CData.MPos[m_iWy].dTOOL_SETTER_GAP, true));
                            _SetLog(string.Format("Tool setter gap : {0} -> {1}mm : dGap [{2}] = dTotalDepth [{3}]- (dDrsLos [{4}] + dWhlLos [{5}])",
                                                  dPre, CData.MPos[m_iWy].dTOOL_SETTER_GAP, dGap, dTotalDepth, dDrsLos, dWhlLos), true);

                            // 201022 jym : Auto offset limit 확인 기능 추가
#if true //201202 jhc : Auto offset limit 확인 기능 라이선스 옵션으로 적용
                            if (CDataOption.UseAutoToolSetterGapLimit && //라이선스 체크
                                (CData.Opt.aAtoLimit[m_iWy] != 0) &&     //설정값 0 아님 체크
                                (dGap >= CData.Opt.aAtoLimit[m_iWy]))    //설정 Limit 체크
#else
                            if (CData.CurCompany == ECompany.SkyWorks && CData.Opt.aAtoLimit[m_iWy] != 0 &&
                                dGap >= CData.Opt.aAtoLimit[m_iWy])
#endif
                            {
                                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_AUTO_OFFSET_RANGEOVER : eErr.RIGHT_AUTO_OFFSET_RANGEOVER);
                                _SetLog("Error : Auto offset rangeover.  Gap : " + dGap + "mm");

                                m_iStep = 0;
                                m_iGStep = 0;
                                return true;
                            } 
                        }

                        // 휠 리그라인딩 옵셋
                        CData.Whls[m_iWy].dReGrdOffset = 0;

                        // 휠 파라미터 선택
                        CData.DrData[m_iWy].bDrsR = false;
                        CData.DrData[m_iWy].bDrs = false;

                        // 2021-10-25, jhLee, For SkyWorks Dressing Sync VOC
                        // Manual Dressing인 경우에만 동기화 플랙을 지정한다.
                        if (CSQ_Main.It.m_iStat == EStatus.Manual)
                        {
                            CData.DrData[m_iWy].bDrsPerformed = true;      // Dressing 작업을 수행했는가 ? Auto-Run 진행시 check한다.
                            _SetLog($"[Dressing Sync] : Set side {m_iWy} (ML) Dressing Perform flag");
                        }


                        m_iCnt = 0;
                        _SetLog("Finish.");

                        m_iStep = 0;
                        m_iGStep = 0;
                        return true;
                    }

                case 50: //190714 ksg :Auto Run 중 화면 변환 후 Error 표시로 변경
                    {
                        if (m_Delay.Chk_Delay()) return false;

                        if (m_eWy == EWay.L)
                        { CErr.Show(eErr.LEFT_GRIND_OVER_WHEEL_THICKNESS); }
                        else
                        { CErr.Show(eErr.RIGHT_GRIND_OVER_WHEEL_THICKNESS); }
                        m_iGStep = 0;

                        return true;
                    }
                case 51: //190714 ksg :Auto Run 중 화면 변환 후 Error 표시로 변경
                    {
                        if (m_Delay.Chk_Delay()) return false;

                        if (m_eWy == EWay.L)
                        { CErr.Show(eErr.LEFT_GRIND_OVER_DRESSER_THICKNESS); }
                        else
                        { CErr.Show(eErr.RIGHT_GRIND_OVER_DRESSER_THICKNESS); }
                        m_iGStep = 0;

                        return true;
                    }
                case 60:
                    {//200616 pjh : Grinding Water Check 60~64
                        if (!m_Delay.Chk_Delay())
                        { return false; }
                        CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                        //CSpl.It.Write_Stop(m_eWy);
                        // 2023.03.15 Max 
                        CSpl_485.It.Write_Stop(m_eWy);


                        m_iGStep++;

                        return false;
                    }
                case 61:
                    {
                        if (CData.Spls[m_iWy].iRpm != 0 || !CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        if (m_eWy == EWay.L)
                        {
                            CIO.It.Set_Y(eY.GRDL_ProbeDn, false);
                            CIO.It.Set_Y(eY.GRDL_ProbeAir, false);
                        }
                        else
                        {
                            CIO.It.Set_Y(eY.GRDR_ProbeDn, false);
                            CIO.It.Set_Y(eY.GRDR_ProbeAir, false);
                        }
                        //210907 pjh : Probe Up Log 추가
                        _SetLog("Probe up. Probe air off");
                        //
                        m_iGStep++;

                        return false;
                    }
                case 62:
                    {
#if true //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        bool   bProbeUp  = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값
                        if (!bProbeUp || (dProbeVal < GV.dProbeUpHeight))
                        { return false; }
#else
                        if (m_eWy == EWay.L)
                        {
                            if (!CIO.It.Get_X(eX.GRDL_ProbeAMP))
                            { return false; }
                        }
                        else
                        {
                            if (!CIO.It.Get_X(eX.GRDR_ProbeAMP))
                            { return false; }
                        }
#endif

                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);

                        m_iGStep++;

                        return false;
                    }
                case 63:
                    {
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }

                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]);
                        m_iGStep++;

                        return false;
                    }
                case 64:
                    {
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]))
                        { return false; }

                        //201003 pjh : Chk DI Error
                        Func_BtmWater(false);
                        Func_SplWater(false);

                        _SetLog("Error : Check DI Error");
                        CErr.Show(eWater);

                        m_iGStep = 0;
                        return true;
                        //
                    }

                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스
                case 100:
                    {//Z축 대기 위치 이동
                        //200429 jym : 메뉴얼 동작 일때도 테이블 워터 종료
                        if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                        { ActWater(false); }

                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        { m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy]; }
                        else
                        { m_dPosZ = CData.SPos.dGRD_Z_Wait[m_iWy]; }
                        CMot.It.Stop(m_iZ);
                        CMot.It.Mv_N(m_iZ, m_dPosZ);

                        _SetLog("ERROR : Picker Vacuum (Step 100) : " + m_siZ + " UP : " + m_dPosZ.ToString());

                        m_iGStep++;
                        return false;
                    }

                case 101:
                    {//Z축 대기 위치 이동 확인
                        //200429 jym : 메뉴얼 동작 일때도 테이블 워터 종료
                        if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                        {
                            if (CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_TbFlow : eX.GRDR_TbFlow))
                            { return false; }
                        }

                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }

                        if (m_iPickerVacErr == 1)
                        { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else
                        { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        _SetLog("ERROR : Picker Vacuum (Step 101) : " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        m_iGStep = 0;
                        return true;
                    }

                case 200:
                    {
                        //200429 jym : 메뉴얼 동작 일때도 테이블 워터 종료
                        if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                        {
                            if (CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_TbFlow : eX.GRDR_TbFlow))
                            { return false; }
                        }

                        //200424 jym : ASE KR는 측정시간 포함하고 표시
                        if (CData.CurCompany == ECompany.ASE_KR)
                        {
                            // 200326 mjy : 드레싱 종료 시간 등록
                            CData.DrsElp[m_iWy].dtEnd = DateTime.Now;
                            CData.DrsElp[m_iWy].tsEls = CData.DrsElp[m_iWy].dtEnd - CData.DrsElp[m_iWy].dtStr;
                        }

                        //200402 jym : 드레싱 이후 테이블 크리닝
                        CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_Table_Clean : ESeq.GRR_Table_Clean;

                        CData.Whls[m_iWy].iGdc = 0;
                        if (CData.Whls[m_iWy].dWhlFtH != 0.0)
                        {
                            //휠 총 소모량
                            CData.Whls[m_iWy].dWhltL = CData.Whls[m_iWy].dWhlFtH - CData.Whls[m_iWy].dWhlAf;
                        }
                        CData.Whls[m_iWy].iDrsC++;
                        CWhl.It.Save(m_eWy, CData.Whls[m_iWy]);

                        _SetLog("ERROR : Picker Vacuum (Step 200) : " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        //20191028 ghk_auto_tool_offset
                        if (CDataOption.AutoOffset == eAutoToolOffset.Use)
                        {
                            double dTotalDepth = 0.0;
                            double dDrsLos     = 0.0;
                            double dWhlLos     = 0.0;
                            double dGap        = 0.0;

                            if (CData.DrData[m_iWy].bDrsR)
                            {
                                //211014 pjh : Device Wheel 사용 시 Dressing Parameter 변경							
                                if (CDataOption.UseDeviceWheel) dTotalDepth = CDev.It.a_tWhl[m_iWy].aNewP[0].dTotalDep + CDev.It.a_tWhl[m_iWy].aNewP[1].dTotalDep;
                                else                            dTotalDepth = CData.Whls[m_iWy].aNewP[0].dTotalDep + CData.Whls[m_iWy].aNewP[1].dTotalDep;
                            }
                            else
                            {
                                //211014 pjh : Device Wheel 사용 시 Dressing Parameter 변경							
                                if (CDataOption.UseDeviceWheel) dTotalDepth = CDev.It.a_tWhl[m_iWy].aUsedP[0].dTotalDep + CDev.It.a_tWhl[m_iWy].aUsedP[1].dTotalDep;
                                else                            dTotalDepth = CData.Whls[m_iWy].aUsedP[0].dTotalDep + CData.Whls[m_iWy].aUsedP[1].dTotalDep;
                            }

                            dDrsLos = CData.WhlsLog[m_iWy].dDrsL  ;
                            dWhlLos = CData.Whls   [m_iWy].dWhldoL;

                            dGap = dTotalDepth - (dDrsLos + dWhlLos);
                            CData.MPos[m_iWy].dTOOL_SETTER_GAP -= dGap;
                            CSetup.It.Save_Offset();
                            CSetup.It.Load_Offset();
                        }
                        //

                        //20190421 ghk_휠 리그라인딩 옵셋
                        CData.Whls[m_iWy].dReGrdOffset = 0;

                        //20190421 ghk_휠 파라미터 선택
                        CData.DrData[m_iWy].bDrsR = false;
                        CData.DrData[m_iWy].bDrs  = false;
                        m_iCnt        = 0;
                        m_iStep       = 0;
                        m_iGStep      = 0;


                        // 2021-10-25, jhLee, For SkyWorks Dressing Sync VOC
                        // Manual Dressing인 경우에만 동기화 플랙을 지정한다.
                        if (CSQ_Main.It.m_iStat == EStatus.Manual)
                        {
                            CData.DrData[m_iWy].bDrsPerformed = true;      // Dressing 작업을 수행했는가 ? Auto-Run 진행시 check한다.
                            _SetLog($"[Dressing Sync] : Set side {m_iWy} (ML) Dressing Perform flag");
                        }



                        if (m_iPickerVacErr == 1)
                        { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else
                        { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        return true;
                    }
                ///////////////////////////////////////////////////////////////////////////////////

                //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
                case 300:
                    {
                        //버퍼 스탑 후 모터 레디 대기 시간
                        if (!m_Delay.Chk_Delay())
                        { return false; }

                        m_iGStep = 0;
                        m_iStep = 0;

                        //프로브 업
                        Func_PrbUp();
                        //스핀들 정지
                        //CSpl.It.Write_Stop(m_eWy);
                        // 2023.03.15 Max 
                        CSpl_485.It.Write_Stop(m_eWy);

                        //그라인딩 워터(스핀들 워터) 끄기
                        Func_SplWater(false);
                        //그라인딩 바텀 워터(스핀들 바텀 워터) 끄기
                        Func_BtmWater(false);
                        //휠 클리너 워터 끄기
                        if (CDataOption.IsWhlCleaner)
                        { Func_WhlClnWater(false); }
                        //테이블 워터 끄기
                        if (!CDataOption.IsTblWater)
                        { ActWater(false); }
                        //Z축 UP
                        CMot.It.Mv_N(m_iZ, 0);

                        CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_SPINDLE_CURRENT_HIGH : eErr.RIGHT_GRIND_SPINDLE_CURRENT_HIGH);
                        _SetLog("Error : Spindle overload(Current Limit).  Load : " + CData.GrData[m_iWy].dSplMaxLoad + "%  Current : "
                                        + CData.GrData[m_iWy].nSpindleCurrentMax.ToString() + "mA / Current Limit : "
                                        + CData.Dev.aData[m_iWy].nSpindleCurrentDressHigh.ToString() + "mA");

                        ClearAdvancedGrindConditionError(); //Limit Over 상태 초기화 (Spindle Current Low/High, Table Vacuum Low Limit)

                        return true;
                    }
                //..

                // 210106 myk : Dressing 후 휠 높이 측정 시 드레싱 후 휠 두께가 드레싱 전 휠 두께보다 두꺼우면 에러 발생
                case 400:
                    {
                        if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                        {
                            if (CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_TbFlow : eX.GRDR_TbFlow))
                            { return false; }
                        }

                        CData.DrData[m_iWy].bDrs = true;

                        CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_DRESSING_FAIL :
                                                      eErr.RIGHT_GRIND_DRESSING_FAIL);

                        _SetLog("ERROR : Dressing Fail (Step 400). Bf : " + CData.WhlBf[m_iWy] + " Af : " + CData.WhlAf[m_iWy]);

                        m_iCnt = 0;
                        m_iStep = 0;
                        m_iGStep = 0;
                        return true;
                    }
            }
        }

        public bool Cyl_BfTest()
        {
            // Timeout check
            if (m_iGPreStep != m_iGStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay() == true)
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_DRESSING_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_DRESSING_TIMEOUT); }

                    m_iCnt = 0;
                    m_iGStep = 0;

                    return true;
                }
            }

            m_iGPreStep = m_iGStep;

            if (m_eWy == EWay.L) m_LogVal.sStatus = "GRL_Dressing";
            else m_LogVal.sStatus = "GRR_Dressing";

            switch (m_iGStep)
            {
                default:
                    {
                        m_iGStep = 0;
                        return true;
                    }

                case 10:
                    {// 1. 축 상태 체크                
                        if (Chk_Axes())
                        {
                            m_iGStep = 0;
                            return true;
                        }

                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        m_LogVal.iStep = m_iGStep;
                        SaveLog();
                        m_iGStep++;
                        return false;
                    }

                case 11:
                    {// 2. 초기화
                        _InitCycle();
                        m_tGrT = new tTempData();
                        m_iStep = 10;
                        m_iCnt = 0;
                        CData.DrData[m_iWy].aInx[0] = 0;
                        CData.DrData[m_iWy].aInx[1] = 0;

                        m_LogVal.iStep = m_iGStep;
                        SaveLog();

                        m_iGStep++;
                        return false;
                    }

                case 12:
                    {// 탑 클리너 업 및 체크
                        if (m_eWy == EWay.L)
                        { m_tGrT.eIn1 = eX.GRDL_TopClnDn; m_tGrT.eOt1 = eY.GRDL_TopClnDn; }//syc : new cleaner 삭제예정
                        else
                        { m_tGrT.eIn1 = eX.GRDR_TopClnDn; m_tGrT.eOt1 = eY.GRDR_TopClnDn; }

                        //syc : new cleaner
                        //CIO.It.Set_Y(m_tGrT.eOt1, false);
                        ActTcDown(false);

                        //syc : new cleaner
                        //if (!CIO.It.Get_X(m_tGrT.eIn1))
                        if (!Chk_CleanerDn())
                        {
                            m_LogVal.iStep = m_iGStep;
                            m_LogVal.sMsg = "TopclnDn : false";
                            SaveLog();

                            m_iGStep++;
                        }

                        return false;
                    }

                case 13:
                    {// 프로브 업
                        if (m_eWy == EWay.L)    // 왼쪽
                        {
                            m_tGrT.eOt1 = eY.GRDL_ProbeDn;
                            m_tGrT.eIn2 = eX.GRDL_ProbeAMP;
                        }
                        else    // 오른쪽
                        {
                            m_tGrT.eOt1 = eY.GRDR_ProbeDn;
                            m_tGrT.eIn2 = eX.GRDR_ProbeAMP;
                        }

                        CIO.It.Set_Y(m_tGrT.eOt1, false);

                        m_LogVal.iStep = m_iGStep;
                        m_LogVal.sMsg = "Probe : false";
                        SaveLog();

                        m_iGStep++;
                        return false;
                    }

                case 14:
                    {// 프로브 업 체크
                        if (CIO.It.Get_X(m_tGrT.eIn2))
                        {
                            m_LogVal.iStep = m_iGStep;
                            m_LogVal.sMsg = "Probe Up Check";
                            SaveLog();

                            m_iGStep++;
                        }

                        return false;
                    }

                case 15: // 테이블 드레싱 스타트 위치로 최초 이동(Run 스피드) 테이블 워터 온
                    {
                        CMot.It.Mv_N(m_iZ, 0);

                        m_LogVal.iStep = m_iGStep;
                        m_LogVal.sAsix1 = m_siZ;
                        m_LogVal.dPos1 = m_dStartZ;
                        SaveLog();

                        m_iGStep++;
                        return false;
                    }

                case 16:
                    {
                        if (!CMot.It.Get_Mv(m_iZ, 0))
                        { return false; }

                        m_LogVal.iStep = m_iGStep;
                        SaveLog();

                        m_iGStep++;
                        return false;
                    }

                case 17:
                    {// Z축 드레싱 시작 위치로 이동
                        CMot.It.Mv_N(m_iY, CData.Dev.aGrd_Y_Start[m_iWy]);

                        m_LogVal.iStep = m_iGStep;
                        m_LogVal.sAsix1 = m_siY;
                        m_LogVal.dPos1 = CData.Dev.aGrd_Y_Start[m_iWy];
                        SaveLog();

                        m_iGStep++;
                        return false;
                    }

                case 18:
                    {// Z축 드레싱 시작위치 이동 확인
                        if (!CMot.It.Get_Mv(m_iY, CData.Dev.aGrd_Y_Start[m_iWy]))
                        { return false; }

                        m_LogVal.iStep = m_iGStep;
                        SaveLog();

                        m_iGStep++;
                        return false;
                    }

                case 19: //버퍼 구성 및 실행 ==> 스텝 반복 시작 점
                    {
                        _Bf_Test();

                        m_LogVal.iStep = m_iGStep;
                        SaveLog();

                        m_iGStep++;
                        return false;
                    }

                case 20: //버퍼 시퀀스 시작
                    {
                        _Bf_Start();

                        m_LogVal.iStep = m_iGStep;
                        m_LogVal.sMsg = "Buffer start";
                        SaveLog();

                        m_iGStep++;
                        return false;
                    }

                case 21: //버퍼 시퀀스 시작
                    {
                        _Bf_GetStatus();

                        m_LogVal.iStep = m_iGStep;
                        m_LogVal.sMsg = "Get Status";
                        SaveLog();

                        m_iGStep++;
                        return false;
                    }

                case 22: //버퍼 시퀀스 시작
                    {
                        // 200831 jym : 축 상태 검사 추가
                        if (Chk_AxesML())
                        {
                            Bf_Stop();
                            _SetLog(string.Format("Error : X axis  Cmd : {0}mm  Fed : {1}mm", CMot.It.Get_CP(m_iX), CMot.It.Get_FP(m_iX)));
                            _SetLog(string.Format("Error : Y axis  Cmd : {0}mm  Fed : {1}mm", CMot.It.Get_CP(m_iY), CMot.It.Get_FP(m_iY)));
                            _SetLog(string.Format("Error : Z axis  Cmd : {0}mm  Fed : {1}mm", CMot.It.Get_CP(m_iZ), CMot.It.Get_FP(m_iZ)));

                            m_iGStep = 0;
                            return true;
                        }

                        if (!CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_ProbeAMP : eX.GRDR_ProbeAMP))
                        {
                            Bf_Stop();
                            CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET : eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                            _SetLog("Error : Probe down.");

                            m_iGStep = 0;
                            return true;
                        }

                        if (m_mBfStat.State == BufferState.Idle)
                        {   //버퍼 시퀀스 종료
                            m_iGStep++;
                        }
                        else
                        {
                            m_iGStep = 21;
                        }

                        m_LogVal.iStep = m_iGStep;
                        m_LogVal.sMsg = "Get Status";
                        SaveLog();

                        return false;
                    }

                case 23:
                    {// 워터 오프
                        // 200326 mjy : 드레싱 종료 시간 등록

                        m_LogVal.iStep = m_iGStep;
                        SaveLog();

                        m_iGStep = 0;
                        return true;
                    }
            }
        }

        /// <summary>
        /// Table Grinding
        /// 테이블 그라인딩 함수
        /// </summary>
        /// <returns></returns>
        public bool Cyl_GrdTbl()
        {
            // Probe down check
            if (!Chk_PrbUpAmp())
            {
                m_iGStep = 0;
                m_iStep = 0;

                Func_SplWater(false);
                Func_BtmWater(false);
                if (CDataOption.IsWhlCleaner)
                { Func_WhlClnWater(false); }
                //CSpl.It.Write_Stop(m_eWy);
                // 2023.03.15 Max
                CSpl_485.It.Write_Stop(m_eWy);

                CMot.It.Mv_N(m_iZ, 0);

                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET : eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                _SetLog("Error : Probe down during table grinding.");

                return true;
            }

            // Timeout check
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_TABLE_GRINDING_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_TABLE_GRINDING_TIMEOUT); }
                    _SetLog("Error : Timeout.");

                    m_iCnt = 0;
                    m_iStep = 0;
                    return true;
                }
            }

            if (m_eWy == EWay.L) m_LogVal.sStatus = "GRL_Table_Grinding_Work";
            else                 m_LogVal.sStatus = "GRR_Table_Grinding_Work";

            m_iPreStep = m_iStep;
            //if(CDataOption.SplType == eSpindleType.EtherCat)
            //{
            //    CData.Spls[0].iRpm =  Convert.ToInt32(CSpl.It.GetFrpm(true));
            //    CData.Spls[1].iRpm =  Convert.ToInt32(CSpl.It.GetFrpm(false));
            //}
            // 2023.03.15 Max
            CData.Spls[(int)EWay.L].iRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.L));
            CData.Spls[(int)EWay.R].iRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.R));

            // 201006 jym st : Delay add
            if (CDataOption.IsChkDI && (m_iStep > 20 && m_iStep < 24))
            {   //200616 pjh : Grinding Water Check
                if (!Chk_GrdWater(m_eWy))
                {
                    if (CData.Opt.iChkDiTime != 0 && !m_tmChkDI.Chk_Delay())
                    { return false; }

                    if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                    { Func_WhlClnWater(false); }
                    m_iStep = 80;

                    return false;
                }
                else
                { m_tmChkDI.Set_Delay(CData.Opt.iChkDiTime); }
            }
            // 201006 jym ed

            if(m_iStep > 17 && m_iStep < 26)
            {   //200616 pjh : Grinding Water Check
                if (m_eWy == EWay.L)
                {
                    if (!CIO.It.Get_X(eX.GRDL_TbFlow))
                    {
                        if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                        { CIO.It.Set_Y(eY.GRDL_WhlCleaner, false); }
                        m_iStep = 80;

                        return false;
                    }
                }
                else
                {
                    if (!CIO.It.Get_X(eX.GRDR_TbFlow))
                    {
                        if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                        { CIO.It.Set_Y(eY.GRDR_WhlCleaner, false); }
                        m_iStep = 80;

                        return false;
                    }
                }
                
            }

            switch (m_iStep)
            {
                default:
                    {
                        m_iCnt = 0;
                        m_iStep = 0;
                        return true;
                    }

                case 10:
                    {//축 상태 체크
                        m_iCnt = 0;

                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }
                        _SetLog("Check axes.");

                        m_iStep++;
                        return false;
                    }

                case 11:
                    {//IO 초기화
                        _InitCycle();
                        _SetLog("Init cycle.");

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {//테이블 안전상태 체크
                        SafeTbl(true, true, false);
                        _SetLog("Check safty table.");

                        m_iStep++;
                        return false;
                    }

                case 13:
                    {//Z축 시작 위치 계산, 카운트 계산, X축 대기위치, Y축 그라인딩 시작 위치, Z축 ABLE 위치, 그라인딩 워터, 바텀워터
                        m_dStartZ = Cal_GrdTbStart();

                        //if (iStepMaxCnt == 12)
                        if (CDataOption.StepCnt == (int)EStepCnt.DEFAULT_STEP)      // 2020.10.09 SungTae : Modify
                        {
                            m_aGrd[0] = Cal_StepCnt((CData.Opt.aTbGrd[0].dTotalDep + CData.Opt.dTbGrdAir), CData.Opt.aTbGrd[0].dCycleDep);
                            m_aGrd[1] = Cal_StepCnt(CData.Opt.aTbGrd[1].dTotalDep, CData.Opt.aTbGrd[1].dCycleDep);
                        }
                        else
                        {
                            m_aGrd_3[0] = Cal_StepCnt((CData.Opt.aTbGrd[0].dTotalDep + CData.Opt.dTbGrdAir), CData.Opt.aTbGrd[0].dCycleDep);
                            m_aGrd_3[1] = Cal_StepCnt(CData.Opt.aTbGrd[1].dTotalDep, CData.Opt.aTbGrd[1].dCycleDep);
                        }

                        m_dPosX = CData.SPos.dGRD_X_Wait[m_iWy];
                        m_dPosY = CData.Dev.aGrd_Y_Start[m_iWy];
                        m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy];

                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_SplWater;
                            m_eOt2 = eY.GRDL_SplBtmWater;
                            m_eIn1 = eX.GRDL_SplWater;
                            m_eIn2 = eX.GRDL_SplBtmWater;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_SplWater;
                            m_eOt2 = eY.GRDR_SplBtmWater;
                            m_eIn1 = eX.GRDL_SplBtmWater;
                            m_eIn2 = eX.GRDR_SplBtmWater;
                        }

                        //if (iStepMaxCnt == 12)
                        if (CDataOption.StepCnt == (int)EStepCnt.DEFAULT_STEP)      // 2020.10.09 SungTae : Modify
                        {
                            _SetLog(string.Format("Start position : {0}mm  Count 1 : {1}  Count 2 : {2}", m_dStartZ, m_aGrd[0], m_aGrd[1]));
                        }
                        else
                        {
                            _SetLog(string.Format("Start position : {0}mm  Count 1 : {1}  Count 2 : {2}", m_dStartZ, m_aGrd_3[0], m_aGrd_3[1]));
                        }

                        m_iStep++;
                        return false;
                    }

                case 14:
                    {//Z축 able 포지션 이동
                        CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                        _SetLog("Z axis move able.", CData.SPos.dGRD_Z_Able[m_iWy]);
                        
                        m_iStep++;
                        return false;
                    }

                case 15:
                    {// Z축 able 포지션 이동 확인, X축 0 이동
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                        _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 16:
                    {// X축 0 이동 확인, Y테이블 그라인딩 시작위치 이동, 테이블 워터 온
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }

                        // 2022.04.08 SungTae Start : [수정] ASE-KH도 추가
                        // 2021.04.13 SungTae Start : Table Grinding 시 조작 실수 방지 위해 추가
                        //if (CData.CurCompany == ECompany.ASE_KR)    { m_dPosY = CData.SPos.dGRD_Y_TblGrdSt[m_iWy]; }
                        if (CData.CurCompany == ECompany.ASE_KR || CData.CurCompany == ECompany.ASE_K12)
                        {
                            m_dPosY = CData.SPos.dGRD_Y_TblGrdSt[m_iWy];
                        }
                        // 2022.04.08 SungTae End
                        else
                        {
                            m_dPosY = CData.Dev.aGrd_Y_Start[m_iWy];
                        }

                        CMot.It.Mv_N(m_iY, m_dPosY);
                        //200406 jym : Water flow 함수 사용
                        ActWater(true);

                        _SetLog("Table water on.  Y axis move start.", m_dPosY /*CData.Dev.aGrd_Y_Start[m_iWy]*/);
                        // 2021.04.13 SungTae End

                        m_iStep++;
                        return false;
                    }

                case 17:
                    {// Y축 테이블 그라인딩 시작위치로 이동 확인, 스핀들 회전
                        if(m_eWy == EWay.L)
                        {
                            if (!CIO.It.Get_X(eX.GRDL_TbFlow))
                            { return false; }
                        }
                        else
                        {
                            if (!CIO.It.Get_X(eX.GRDR_TbFlow))
                            { return false; }
                        }

                        // 2022.04.08 SungTae Start : [수정] ASE-KH도 추가
                        // 2021.04.13 SungTae Start : Table Grinding 시 조작 실수 방지 위해 추가
                        //if (CData.CurCompany == ECompany.ASE_KR)    { m_dPosY = CData.SPos.dGRD_Y_TblGrdSt[m_iWy]; }
                        if (CData.CurCompany == ECompany.ASE_KR || CData.CurCompany == ECompany.ASE_K12)
                        {
                            m_dPosY = CData.SPos.dGRD_Y_TblGrdSt[m_iWy];
                        }
                        // 2022.04.08 SungTae End
                        else
                        {
                            m_dPosY = CData.Dev.aGrd_Y_Start[m_iWy];
                        }

                        if (!CMot.It.Get_Mv(m_iY, m_dPosY /*CData.Dev.aGrd_Y_Start[m_iWy])*/))
                        { return false; }
                        // 2021.04.13 SungTae End

                        //CSpl.It.Write_Run(m_eWy, CData.Opt.aTbGrd[0].iSplSpd);
                        // 2023.03.15 Max
                        bool bExit = false;
                        bool bTimeOutFlag = false;

                        // RPM Setting
                        CSpl_485.It.Write_Rpm(m_eWy, CData.Opt.aTbGrd[0].iSplSpd);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRPMSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRPMSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                            return false;
                        }

                        // Spindle RUN
                        bExit = false;
                        bTimeOutFlag = false;
                        CSpl_485.It.Write_Run(m_eWy);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRunSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRunSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            return false;
                        }

                        _SetLog("Spindle run : " + CData.Opt.aTbGrd[0].iSplSpd + "rpm");

                        m_iStep++;
                        return false;
                    }

                case 18:
                    {// 스핀들 RPM 확인, Z축 시작위치 이동, 스핀들 회전 확인
                        if ((CData.Spls[m_iWy].iRpm + 10) < CData.Opt.aTbGrd[0].iSplSpd)
                        {
                            return false;
                        }

                        CMot.It.Mv_N(m_iZ, m_dStartZ);
                        _SetLog("Z axis move position.", m_dStartZ);

                        m_iStep++;
                        return false;
                    }

                case 19:
                    {// Z축 시작위치 이동 확인, 그라인딩 워터 온, 바텀 워터 온
                        if (!CMot.It.Get_Mv(m_iZ, m_dStartZ))   { return false; }

                        CIO.It.Set_Y(m_eOt1, true);
                        CIO.It.Set_Y(m_eOt2, true);

                        //200515 myk : Wheel Cleaner Water 추가
                        if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                        {
                            Func_WhlClnWater(true);
                        }

                        _SetLog("Spindle water on.  Bottom water on.");
                        
                        m_iStep++;
                        return false;
                    }

                case 20:
                    {//카운트 확인(스텝 전환용), 해당 스텝 값으로 갱신, 스핀들 회전    == 반복 시작 ==
                        if (m_eWy == EWay.L)
                        {
                            if (!CIO.It.Get_X(eX.GRDL_SplWater) || !CIO.It.Get_X(eX.GRDL_SplBtmWater))
                            { return false; }
                        }
                        else
                        {
                            if (!CIO.It.Get_X(eX.GRDR_SplWater) || !CIO.It.Get_X(eX.GRDR_SplBtmWater))
                            { return false; }
                        }

                        // 2022.04.08 SungTae Start : [수정] ASE-KH도 추가
                        // 2021.04.13 SungTae Start : Table Grinding 시 조작 실수 방지 위해 추가
                        if (m_iCnt % 2 == 0)
                        {
                            //if (CData.CurCompany == ECompany.ASE_KR)    { m_dPosY = CData.SPos.dGRD_Y_TblGrdEd[m_iWy]; }
                            if (CData.CurCompany == ECompany.ASE_KR || CData.CurCompany == ECompany.ASE_K12)
                            { m_dPosY = CData.SPos.dGRD_Y_TblGrdEd[m_iWy]; }
                            else
                            { m_dPosY = CData.Dev.aGrd_Y_End[m_iWy]; }
                        }
                        else
                        {
                            //if (CData.CurCompany == ECompany.ASE_KR)    { m_dPosY = CData.SPos.dGRD_Y_TblGrdSt[m_iWy]; }
                            if (CData.CurCompany == ECompany.ASE_KR || CData.CurCompany == ECompany.ASE_K12)
                            { m_dPosY = CData.SPos.dGRD_Y_TblGrdSt[m_iWy]; }
                            else
                            { m_dPosY = CData.Dev.aGrd_Y_Start[m_iWy]; }
                        }
                        // 2021.04.13 SungTae End
                        // 2022.04.08 SungTae End

                        if (CDataOption.StepCnt == (int)EStepCnt.DEFAULT_STEP)      // 2020.10.09 SungTae : Modify
                        {
                            if (m_iCnt <= m_aGrd[0])
                            {
                                m_iRpm  = CData.Opt.aTbGrd[0].iSplSpd;
                                m_dVelY = CData.Opt.aTbGrd[0].dTblSpd;
                                m_dCylZ = CData.Opt.aTbGrd[0].dCycleDep;
                            }
                            else
                            {
                                m_iRpm  = CData.Opt.aTbGrd[1].iSplSpd;
                                m_dVelY = CData.Opt.aTbGrd[1].dTblSpd;
                                m_dCylZ = CData.Opt.aTbGrd[1].dCycleDep;
                            }
                        }
                        else
                        {
                            if (m_iCnt <= m_aGrd_3[0])
                            {
                                m_iRpm  = CData.Opt.aTbGrd[0].iSplSpd  ;
                                m_dVelY = CData.Opt.aTbGrd[0].dTblSpd  ;
                                m_dCylZ = CData.Opt.aTbGrd[0].dCycleDep;
                            }
                            else
                            {
                                m_iRpm  = CData.Opt.aTbGrd[1].iSplSpd  ;
                                m_dVelY = CData.Opt.aTbGrd[1].dTblSpd  ;
                                m_dCylZ = CData.Opt.aTbGrd[1].dCycleDep;
                            }
                        }
                        
                        //CSpl.It.Write_Run(m_eWy, m_iRpm);
                        // 2023.03.15 Max
                        bool bExit = false;
                        bool bTimeOutFlag = false;

                        // RPM Setting
                        CSpl_485.It.Write_Rpm(m_eWy, m_iRpm);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRPMSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRPMSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_SET_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_SET_RPM_ERROR);
                            return false;
                        }

                        // Spindle RUN
                        bExit = false;
                        bTimeOutFlag = false;
                        CSpl_485.It.Write_Run(m_eWy);
                        m_Timout_485.Set_Delay(300);
                        do
                        {
                            Application.DoEvents();
                            if (m_Timout_485.Chk_Delay()) { bTimeOutFlag = true; bExit = true; }
                            bExit = CSpl_485.It.GetAcceptRunSpindle(m_eWy);
                        } while (bExit != true);
                        CSpl_485.It.SetAcceptRunSpindle(m_eWy);

                        if (bTimeOutFlag)
                        {
                            if (m_eWy == EWay.L) CErr.Show(eErr.LEFT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            if (m_eWy == EWay.R) CErr.Show(eErr.RIGHT_GRIND_SPINDLE_RUN_RPM_ERROR);
                            return false;
                        }

                        _SetLog(string.Format("Spindle vel : {0}rpm  Table vel : {1}mm/s  Cycle depth : {2}mm", m_iRpm, m_dVelY, m_dCylZ));

                        m_iStep++;
                        return false;
                    }

                case 21:
                    {// 스핀들 RPM 확인, 테이블 이동
                        if ((CData.Spls[m_iWy].iRpm + 10) < m_iRpm)
                        { return false; }

                        CMot.It.Mv_V(m_iY, m_dPosY, m_dVelY);
                        _SetLog("Y axis move position.", m_dPosY);

                        m_iStep++;
                        return false;
                    }

                case 22:
                    {// 테이블 이동 확인 카운트 계산 종료 여부 판단  == 반복 종료 여부 확인 ==
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY, GV.INPOS_TBL))
                        { return false; }

                        m_iCnt++;

                        //if (iStepMaxCnt == 12)
                        if (CDataOption.StepCnt == (int)EStepCnt.DEFAULT_STEP)      // 2020.10.09 SungTae : Modify
                        {
                            if (m_iCnt >= (m_aGrd[0] + m_aGrd[1]))
                            {
                                _SetLog("Loop end.  Count : " + m_iCnt);
                                m_iStep = 24;
                            }
                            else
                            {
                                m_dCurZ = CMot.It.Get_CP(m_iZ) + m_dCylZ;
                                //CMot.It.Mv_N(m_iZ, m_dCurZ);
                                //200407 jym : 사이클 이동시 슬로우
                                CMot.It.Mv_S(m_iZ, m_dCurZ);
                                _SetLog("Z axis move position(slow).  Count : " + m_iCnt, m_dCurZ);

                                m_iStep++;
                            }
                        }
                        else
                        {
                            if (m_iCnt >= (m_aGrd_3[0] + m_aGrd_3[1]))
                            {
                                _SetLog("Loop end.  Count : " + m_iCnt);
                                m_iStep = 24;
                            }
                            else
                            {
                                m_dCurZ = CMot.It.Get_CP(m_iZ) + m_dCylZ;
                                //CMot.It.Mv_N(m_iZ, m_dCurZ);
                                //200407 jym : 사이클 이동시 슬로우
                                CMot.It.Mv_S(m_iZ, m_dCurZ);
                                _SetLog("Z axis move position(slow).  Count : " + m_iCnt, m_dCurZ);

                                m_iStep++;
                            }
                        }
                        
                        return false;
                    }

                case 23:
                    {// Z축 사이클 뎁스 이동 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dCurZ, GV.INPOS_GRD_CYCLE))
                        {
                            return false;
                        }

                        m_iStep = 20;
                        return false;
                    }

                case 24:
                    {//그라인딩 워터 오프, 바텀 워터 오프, 스핀들 정지
                        CIO.It.Set_Y(m_eOt1, false);
                        CIO.It.Set_Y(m_eOt2, false);

                        //200515 myk : Wheel Cleaner Water 추가
                        if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                        {
                            Func_WhlClnWater(false);
                        }

                        //CSpl.It.Write_Stop(m_eWy);
                        // 2023.03.15 Max
                        CSpl_485.It.Write_Stop(m_eWy);

                        _SetLog("Spindle stop.");
                        
                        m_iStep++;
                        return false;
                    }

                case 25:
                    {//그라인딩 워터 오프 확인, 바텀 워터 오프 확인, 스핀들 정지 확인, Z축 Able 이동
                        if (!CIO.It.Get_X(m_eIn1) && !CIO.It.Get_X(m_eIn2))
                        {
                            if (CData.Spls[m_iWy].iRpm != 0)
                            {
                                return false;
                            }

                            CMot.It.Mv_N(m_iZ, m_dPosZ);
                            _SetLog("Z axis move position.", m_dPosZ);

                            m_iStep++;
                        }

                        return false;
                    }

                case 26:
                    {//Z축 Able 이동 확인, 테이블 워터 오프
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            return false;
                        }

                        //200406 jym : Water flow 함수 사용
                        ActWater(false);

                        _SetLog("Table water off.");

                        m_iStep++;
                        return false;
                    }

                case 27:
                    {//테이블 워터 오프 확인, 종료
                        if (CIO.It.Get_Y(m_eOt1))
                        { return false; }

                        //200406 jym : 그라인딩 이후 After 측정으로 플래그 변경
                        CData.TblMea = EMeaStep.After;
                        //200406 jym : 마지막 테이블 그라인딩 날짜 저장

                        if (m_eWy == EWay.L)    { CData.Opt.dtLast_L = DateTime.Now; }
                        else                    { CData.Opt.dtLast_R = DateTime.Now; }

                        m_iCnt = 0;
                        _SetLog("Finish.");

                        m_iStep = 0;
                        return true;
                    }

                case 80:
                    {
                        CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                        //CSpl.It.Write_Stop(m_eWy);
                        // 2023.03.15 Max
                        CSpl_485.It.Write_Stop(m_eWy);

                        m_iStep++;
                        return false;
                    }

                case 81:
                    {
                        if (CData.Spls[m_iWy].iRpm != 0 || !CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        {
                            return false;
                        }

                        if (m_eWy == EWay.L)
                        {
                            CIO.It.Set_Y(eY.GRDL_ProbeDn, false);
                            CIO.It.Set_Y(eY.GRDL_ProbeAir, false);
                        }
                        else
                        {
                            CIO.It.Set_Y(eY.GRDR_ProbeDn, false);
                            CIO.It.Set_Y(eY.GRDR_ProbeAir, false);
                        }

                        //210907 pjh : Probe Up Log 추가
                        _SetLog("Probe up. Probe air off");
                        //
                        m_iStep++;

                        return false;
                    }

                case 82:
                    {
                        if (m_eWy == EWay.L)
                        {
                            if (!CIO.It.Get_X(eX.GRDL_ProbeAMP))
                            { return false; }
                        }
                        else
                        {
                            if (!CIO.It.Get_X(eX.GRDR_ProbeAMP))
                            { return false; }
                        }

                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 83:
                    {
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        {
                            return false;
                        }

                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]);
                        m_iStep++;

                        return false;
                    }

                case 84:
                    {
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]))
                        {
                            return false;
                        }

                        //201003 pjh : Chk DI Error
                        Func_BtmWater(false);
                        Func_SplWater(false);

                        _SetLog("Error : Check DI Error");
                        CErr.Show(eWater);

                        m_iGStep = 0;
                        return true;
                        //
                    }
            }
        }

        /// <summary>
        /// Calculate Grinding Step or Dressing Count
        /// 그라인딩 스텝 및 드레싱 카운트 계산
        /// </summary>
        /// <param name="dTotalDep"></param>
        /// <param name="dCycleDep"></param>
        /// <returns></returns>
        public int Cal_StepCnt(double dTotalDep, double dCycleDep)
        {
            int iRet = 0;

            // 2022.09.20 lhs : 소수점 4자리까지 유효하게
            dTotalDep = Math.Round(dTotalDep, 4);
            dCycleDep = Math.Round(dCycleDep, 4);

            iRet = (int)(dTotalDep / dCycleDep);            

            _SetLog(string.Format("Total thickness : {0}mm  Cycle thickness : {1}mm", dTotalDep, dCycleDep), true);

            return iRet;
        }

        // 2022.09.26 lhs Start
        /// <summary>
        /// 리그라인딩 카운트 계산.... 나머지 적용
        /// </summary>
        /// <param name="dTotalDep"></param>
        /// <param name="dCycleDep"></param>
        /// <returns></returns>
        public int Cal_ReCnt(double dTotalDep, double dCycleDep)
        {
            int nReCnt = 0;

            // 2022.09.20 lhs : 소수점 4자리까지 유효하게
            dTotalDep = Math.Round(dTotalDep, 4);
            dCycleDep = Math.Round(dCycleDep, 4);

            nReCnt = (int)(dTotalDep / dCycleDep);

            double dRemainder = dTotalDep % dCycleDep;
			dRemainder = Math.Round(dRemainder, 4);

            // 나머지가 리그라인딩 판정 조건보다 크면 카운트 증가, 나머지 ReGrnd Flag = TRUE (맨 마지막의 Cycle Depth는 나머지 두께)
            if(dRemainder > m_ReGrdDep)
            {
                nReCnt++;
                m_bRemainder = true;  // nReCnt 인 경우에서만 dRemainder를 Cycle Depth로...
            }
            else
            {
                m_bRemainder = false;
            }
            m_dRemainder = dRemainder;
			
            _SetLog(string.Format($"Cal_ReCnt() : Total Depth = {dTotalDep}mm, Cycle Depth : {dCycleDep}mm, Remainder = {m_dRemainder}mm, nReCnt = {nReCnt}"), true);

            return nReCnt;
        }
        // 2022.09.26 lhs End

        /// <summary>
        /// Calculate Grinding Step Start Position
        /// 그라인딩 스텝 시작 위치 계산
        /// </summary>
        /// <returns></returns>
        public double Cal_GrdStart()
        {
            double dTotalDepthOriginal = 0.0; //201125 jhc : Grinding Step별 Correct 기능

            //201203 jhc : 드레싱 후 N 번째 그라인딩 시 휠 소모량 보정 기능
            m_TotalWheelLossLimitOver = false; //누적 Wheel Loss 제한량 초과 여부 플래그 리셋 (Z축 과도 DOWN 방지용)

            int nCountAfterDressing = 0;       //드레싱 후 그라인딩 완료 횟수
            double dWheelLossTotal = 0.0;      //드레싱 후 N 번째 그라인딩 시까지의 누적 휠 소모량
            int idx = 0;                       //Wheel Loss 보정값 배열 인덱스
            //

            double dTotalDepth  = 0.0;
            double dGrdPos      = 0.0;
            double dMax         = 0.0;
            double dMin         = 999.999; //190502 ksg :
            double dAvg         = 0.0; //190502 ksg :
            double dMean        = 0.0; //190502 ksg :
            double dStripHeight = 0.0;
            bool bAir = false;

            bool bMeasure = false; //200712 jhc : 18 포인트 측정 (ASE-KR VOC)

#if true //201021 jhc : ASE-Kr TOP 그라인딩 결과 두께 > SECS/GEM > BTM 그라인딩
            bool bBtmMoldGrindByTopData = false; //ASE-Kr Bottom Mold 기준 그라인딩 시 옵션/상태 여부
            double dStripHeight1st = 0.0;        //Befor Measure 또는 Shift된 자재 두께 값 저장용
            double dStripHeight1stMax = 0.0;     //Rough 1 에서 그라인딩 량(카운트) 계산을 위한 두께 값 저장용
            double dPcbTh = 0.0;                 //SECS/GEM Host에서 내려 받은 TOP 두께 값 저장용
            double dDeviceTotalTh = 0.0;         //Device(Recipe)에 설정된 Total Thickness 값

            //ASE-Kr Bottom Mold 기준 그라인딩 시 옵션
            if ((CData.Dev.bDynamicSkip) &&                                         //DF기능 비활성(ASE-Kr)
                ((CDataOption.SecsUse == eSecsGem.Use) && CData.Opt.bSecsUse) &&    //SECS/GEM 사용(TOP 두께 수신)
                (CData.Dev.eMoldSide == ESide.Btm) &&                               //BTM 그라인딩
                (CSQ_Main.It.m_iStat != EStatus.Manual))                            //AUTO-RUNNING
            { bBtmMoldGrindByTopData = true; }

            // 2021.05.28 SungTae Start :
            //if(CData.CurCompany == ECompany.Qorvo_NC)            
            if(CDataOption.UseDFDataServer)//210818 pjh : D/F Data server 기능 License로 구분
            {
                if (CData.Dev.bDynamicSkip && // 210602 pjh : bottom doesn't measure D/F
                    //CDataOption.SecsUse == eSecsGem.NotUse && !CData.Opt.bSecsUse &&
                    !CData.Opt.bSecsUse && //211214 pjh : SECS/GEM License 조건 제거
                    CData.Dev.eMoldSide == ESide.Btm &&
                    CSQ_Main.It.m_iStat != EStatus.Manual)
                {
                    bBtmMoldGrindByTopData = true;
                }
            }
            // 2021.05.28 SungTae End

            if ((m_eWy == EWay.R) && (CData.Dev.bDual != eDual.Dual))
            {
                //Normal 모드, R-Table인 경우 Left 설정값 사용
                dDeviceTotalTh = CData.Dev.aData[(int)EWay.L].dTotalTh;
            } 
            else
            {
                //L-Table 또는 R-Table Step 모드인 경우 각자 설정값 사용
                dDeviceTotalTh = CData.Dev.aData[m_iWy].dTotalTh;
            }
#endif
            _SetLog(string.Format(">>>>> dDeviceTotalTh : {0}mm", dDeviceTotalTh), true);

            // 200317 mjy : 조건 추가함
            if (CDataOption.Package == ePkg.Strip)
            {
                //200325 ksg : Data Shift Probe Skip
                if(m_eWy == EWay.R && CData.Dev.bDual == eDual.Dual && CData.Dev.bDShiftPSkip && CData.Parts[(int)EPart.GRDR].dShiftT > 0)
                {
                    dMax  = CData.Parts[(int)EPart.GRDR].dShiftT;
                    dMin  = CData.Parts[(int)EPart.GRDR].dShiftT;

                    _SetLog(string.Format("Shift data.  Max : {0}mm  Min : {1}mm", dMax, dMin), true);
                }
                else
                {
                    //190816 ksg : 계산 오류로 수정함.
                    for (int i = 0; i < CData.Dev.iCol; i++)
                    {
                        //측정한 자재 높이 중 가장 높은 자재 높이 구하기
                        for (int j = 0; j < (CData.Dev.iRow * CData.Dev.iWinCnt); j++)
                        {
                            if (CData.Parts[m_iPart].b18PMeasure)   { bMeasure = CData.Dev.aData[m_iWy].aPosBf[j, i].bUse18P;   } //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                            else                                    { bMeasure = CData.Dev.aData[m_iWy].aPosBf[j, i].bUse;      }
                            
                            if (bMeasure)
                            {
                                if(m_aInspBf[j, i] == 0) continue;

                                dMax  = Math.Max(dMax, m_aInspBf[j, i]);
                                dMin  = Math.Min(dMin, m_aInspBf[j, i]);
                            }
                        }
                    }

                    _SetLog(string.Format("Max : {0}mm  Min : {1}mm", dMax, dMin), true);
                }
            }
            else
            {   // Unit에서 검사
                for (int i = 0; i < CData.Dev.iCol; i++)
                {
                    //측정한 자재 높이 중 가장 높은 자재 높이 구하기
                    for (int j = 0; j < CData.Dev.iRow; j++)
                    {
                        if (CData.Dev.aData[m_iWy].aPosBf[j, i].bUse)
                        {
                            for (int iU = 0; iU < CData.Dev.iUnitCnt; iU++)
                            {
                                double dVal = CData.GrData[m_iWy].aUnit[iU].aMeaBf[j, i];

                                if (dVal == 0) continue;

                                dMax = Math.Max(dMax, dVal);
                                dMin = Math.Min(dMin, dVal);
                            }
                        }
                    }
                }

                _SetLog(string.Format("Max : {0}mm  Min : {1}mm", dMax, dMin), true);
            }

#if true //201021 jhc : ASE-Kr TOP 그라인딩 결과 두께 > SECS/GEM > BTM 그라인딩
            dStripHeight1st = dStripHeight1stMax = dMax; //실제 측정(또는 Shift된) 자재 두께 (Total 또는 Mold)

            // 2021.05.28 SungTae Start: [수정] Qorvo_NC 조건 추가
            //if ((CData.CurCompany == ECompany.ASE_KR) && bBtmMoldGrindByTopData)
            //if ((CData.CurCompany == ECompany.ASE_KR || CData.CurCompany == ECompany.Qorvo_NC) && bBtmMoldGrindByTopData)
            //if ((CData.CurCompany == ECompany.ASE_KR || CDataOption.UseDFDataServer) && bBtmMoldGrindByTopData)//210818 pjh : D/F Data server 기능 License로 구분
            if ((CData.CurCompany == ECompany.ASE_KR || (CData.CurCompany == ECompany.ASE_K12 && CData.Opt.bSecsUse) || 
                (CDataOption.UseDFDataServer && !CData.Opt.bSecsUse)) && bBtmMoldGrindByTopData) //220504 pjh : ASE KH 조건 추가
            {
                // 1. Host에서 전달 받은 PCB 두께
                //if(CData.CurCompany == ECompany.ASE_KR)
                if (CData.CurCompany == ECompany.ASE_KR || (CData.CurCompany == ECompany.ASE_K12 && CData.Opt.bSecsUse))//220504 pjh : ASE KH SECS/GEM 사용 시 조건 추가
                {
                    dPcbTh = (CData.Dynamic.iHeightType == 0) ? CData.Parts[m_iPart].dPcbMax : CData.Parts[m_iPart].dPcbMean;
                    _SetLog("SECS/GEM Use. PCB Thickness = " + dPcbTh.ToString(), true);//220516 pjh : Data 확인용 Log
                }
                else
                {
                    //dPcbTh = (CData.Dynamic.iHeightType == 0) ? CData.Parts[m_iPart].dPcbMax + CSq_OnP.It.m_tTarget.dAfMax : CData.Parts[m_iPart].dPcbMean + CSq_OnP.It.m_tTarget.dAfAvg;
                    dPcbTh = (CData.Dynamic.iHeightType == 0) ? CData.Parts[m_iPart].dPcbMax + CData.Parts[m_iPart].dTopMoldMax : CData.Parts[m_iPart].dPcbMean + CData.Parts[m_iPart].dTopMoldAvg;//220111 pjh : DF Server 사용 시 Top Mold Thickness 저장 변수 변경
                    //220509 pjh : Data 확인용 Log
                    if (CData.Dynamic.iHeightType == 0)
                    {
                        _SetLog("PCB Thickness : " + CData.Parts[m_iPart].dPcbMax.ToString() + "Top Mold Thickness : " + CData.Parts[m_iPart].dTopMoldMax.ToString(), true);
                    }
                    else
                    {
                        _SetLog("PCB Thickness : " + CData.Parts[m_iPart].dPcbMean.ToString() + "Top Mold Thickness : " + CData.Parts[m_iPart].dTopMoldAvg.ToString(), true);
                    }
                    //
                    _SetLog($">>>>> PCB Thickness(from HOST) : {dPcbTh} mm. HeightType : {CData.Dynamic.iHeightType}", true);
                }
                if (dPcbTh <= 0)
                {
                    m_WrongCalFlag = true;

                    //_SetLog("Wrong calculate flag on. SECS/GEM use. PCB Thickness : " + dPcbTh + "mm");
                    if (CData.CurCompany == ECompany.ASE_KR)    _SetLog("Wrong calculate flag on. SECS/GEM use. PCB Thickness : " + dPcbTh + "mm");
                    //if (CData.CurCompany == ECompany.Qorvo_NC)  _SetLog("Wrong calculate flag on. DF Server use. PCB Thickness : " + dPcbTh + "mm");
                    if (CDataOption.UseDFDataServer && !CData.Opt.bSecsUse) _SetLog("Wrong calculate flag on. DF Server use. PCB Thickness : " + dPcbTh + "mm");//210818 pjh : D/F Data server 기능 License로 구분
                }

                // 2021.09.30 SungTae Start : [수정] Hard Coding 한 것을 수정
                // - Device에 설정한 PCB 두께가 "0"이 아닌 경우에만 Bottom Grinding 시 Host에서 Top Grinding 한 Data(PCB 두께)를 받아서 사용.
                // 2021.07.30 SungTae Start : [추가] ASE-KR VOC로 Grinding이 완료된 자재가 재투입 시 Over Grinding 되는 Issue 관련 조건 추가
                //if (dPcbTh < 0.6)
                //if (CData.Dev.aData[0].dPcbTh != 0.0)
                if (CData.Dev.aData[0].dPcbTh != 0.0 && CData.Dynamic.dPcbRange != 0.0)//220318 pjh : PCB Range가 0이면 해당 기능 사용하지 않도록 수정
                {
                    // Host에서 받은 PCB 두께가 Device에 설정한 PCB 두께 - PCB Range 설정값 보다 더 작으면 Alarm
                    if (dPcbTh < CData.Dev.aData[0].dPcbTh - CData.Dynamic.dPcbRange)
                    {
                        m_WrongPCBThicknessFlag = true;
                        _SetLog("Wrong PCB Thickness flag on. SECS/GEM use. PCB Thickness : " + dPcbTh + "mm");
                    }
                }
                // 2021.07.30 SungTae End
                // 2021.09.30 SungTae End

                // 2. 자재 측정(또는 Shift) 두께 와 디바이스(Recipe) 입력 두께 중 큰 값 선택
                //    <== 그라인딩 시작 높이(dGrdPos) 계산 시 실재 자재 측정(또는 Shift) 두께와,
                //        디바이스(Recipe) 설정 두께 중 더 큰 값 기준으로 계산하므로,
                //        Rough 1 에서 그라인딩 량(카운트) 계산 시에도 이를 공통 적용해야 함!!!
                if ((dStripHeight1st + dPcbTh) < dDeviceTotalTh)
                {
                    dStripHeight1stMax = (dDeviceTotalTh - dPcbTh); //Device 설정 값 기준 자재 두께 (Mold)
                    _SetLog($">>>>> dStripHeight1stMax({dStripHeight1stMax}) = dDeviceTotalTh({dDeviceTotalTh}) - dPcbTh({dPcbTh})", true);
                }

                _SetLog($">>>>> Data 비교 : dDeviceTotalTh = {dDeviceTotalTh}  / dStripHeight1st({dStripHeight1st}) + dPcbTh({dPcbTh}) = {dStripHeight1st + dPcbTh}", true);
            }
            // 2021.05.28 SungTae End
#endif

            if (dMax <= 0)
            {
                m_WrongCalFlag = true;
                _SetLog("Wrong calculate flag on.  Max : " + dMax + "mm");
            }

            //200325 ksg : Data Shift Probe Skip
            if(m_eWy == EWay.R && CData.Dev.bDual == eDual.Dual && CData.Dev.bDShiftPSkip && CData.Parts[(int)EPart.GRDR].dShiftT > 0)
            {
                dAvg  = CData.Parts[(int)EPart.GRDR].dShiftT;
                dMean = CData.Parts[(int)EPart.GRDR].dShiftT;

                CData.PbResultVal[m_iWy].dBMax  = dMax;
                CData.PbResultVal[m_iWy].dBMin  = dMax;
                CData.PbResultVal[m_iWy].dBAvg  = dMax;
                
                _SetLog(string.Format("Shift data.  Avg : {0}mm  Mean : {1}mm", dAvg, dMean), true);
            }
            else
            {
                dAvg  = Math.Round(CData.PbResultVal[m_iWy].dBAvg , 4);
                dMean = Math.Round(CData.PbResultVal[m_iWy].dBMean, 4);

                _SetLog(string.Format("Avg : {0}mm  Mean : {1}mm", dAvg, dMean), true);
            }

            if (CData.Dev.aData[m_iWy].eGrdMod != eGrdMode.TopDown)
            {//타켓 모드
                if (m_eWy == EWay.L)
                {
                    if(CData.Dev.bDynamicSkip)
                    {
                        _SetLog($">>>>> dMax = {dMax} mm / CData.Dev.aData[{m_iWy}].dTotalTh = {CData.Dev.aData[m_iWy].dTotalTh}", true);

                        if (dMax < CData.Dev.aData[m_iWy].dTotalTh)
                        {//가장 높은 자재 측정 높이가 유저 입력한 자재 높이보다 클 경우 => 차이값 옵셋 변수에 저장
                            dMax = CData.Dev.aData[m_iWy].dTotalTh;                            
                        }
#if true //201021 jhc : ASE-Kr TOP 그라인딩 결과 두께 > SECS/GEM > BTM 그라인딩

                        // 2021.05.28 SungTae Start: [수정] Qorvo_NC 조건 추가
                        //if ((CData.CurCompany == ECompany.ASE_KR) && bBtmMoldGrindByTopData)
                        //if ((CData.CurCompany == ECompany.ASE_KR || CData.CurCompany == ECompany.Qorvo_NC) && bBtmMoldGrindByTopData)
                        //if ((CData.CurCompany == ECompany.ASE_KR || CDataOption.UseDFDataServer) && bBtmMoldGrindByTopData)//210818 pjh : D/F Data server 기능 License로 구분
                        if ((CData.CurCompany == ECompany.ASE_KR || (CData.CurCompany == ECompany.ASE_K12 && CData.Opt.bSecsUse) ||
                            (CDataOption.UseDFDataServer && !CData.Opt.bSecsUse)) && bBtmMoldGrindByTopData) //220504 pjh : ASE KH 조건 추가
                        {
                            dMax = dStripHeight1stMax + dPcbTh; //(Max(측정(Shift)두께,설정두께) + PCB두께(from HOST))
                            _SetLog($">>>>> dMax({dMax}) = dStripHeight1stMax({dStripHeight1stMax}) + dPcbTh({dPcbTh})", true);
                        }
#endif
                    }
                    else
                    {
                        _SetLog($">>>>> dMax = {dMax} mm / CData.Dev.aData[{m_iWy}].dMoldTh = {CData.Dev.aData[m_iWy].dMoldTh}", true);

                        if (dMax < CData.Dev.aData[m_iWy].dMoldTh)
                        {//가장 높은 자재 측정 높이가 유저 입력한 자재 높이보다 클 경우 => 차이값 옵셋 변수에 저장
                            dMax = CData.Dev.aData[m_iWy].dMoldTh;
                        }
                    }

                    _SetLog(string.Format("Table thickness : {0}mm  Max : {1}mm  Wheel tip : {2}mm", CData.Tbl_Af[m_iWy, 0], dMax, CData.WhlAf[m_iWy]), true);
                    
                    //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                    if (CData.bUseWheelZAxisAfterMeasureWheel)
                    {
                        dGrdPos = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - dMax - CData.Dev.aData[m_iWy].dAir
                                + Math.Round((CData.WheelTipAfterZPos[m_iWy] - CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER) - CData.MPos[m_iWy].dTOOL_SETTER_GAP, 6); //프로브와 휠팁의 높이차(휠팁 Z축 위치 적용)
                        
                        _SetLog("Wheel Tip Z Axis: " + CData.WheelTipAfterZPos[m_iWy].ToString() + "  PRB_TOOL_SETTER: " + CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER.ToString() + "  TOOL_SETTER_GAP: " + CData.MPos[m_iWy].dTOOL_SETTER_GAP.ToString(), true);
                    }
                    else
                    {
                        dGrdPos = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - dMax - CData.Dev.aData[m_iWy].dAir + CData.MPos[m_iWy].dPRB_TO_WHL_BASE - CData.WhlAf[m_iWy];
                    }
                    //
                    _SetLog("[Target Mode]  Start position : " + dGrdPos + "mm", true);
                }
                else
                {
                    if (CData.Dev.bDual == eDual.Dual)
                    {//듀얼 모드 사용
                        if(CData.Dev.bDynamicSkip)
                        {
                            _SetLog($">>>>> dMax = {dMax} mm / CData.Dev.aData[{m_iWy}].dTotalTh = {CData.Dev.aData[m_iWy].dTotalTh}");

                            if (dMax < CData.Dev.aData[m_iWy].dTotalTh)
                            {//가장 높은 자재 측정 높이가 유저 입력한 자재 높이보다 클 경우 => 차이값 옵셋 변수에 저장
                                dMax = CData.Dev.aData[m_iWy].dTotalTh;
                            }
#if true //201021 jhc : ASE-Kr TOP 그라인딩 결과 두께 > SECS/GEM > BTM 그라인딩                            
                            // 2021.05.28 SungTae Start: [수정] Qorvo_NC 조건 추가
                            //if ((CData.CurCompany == ECompany.ASE_KR) && bBtmMoldGrindByTopData)
                            //if ((CData.CurCompany == ECompany.ASE_KR || CData.CurCompany == ECompany.Qorvo_NC) && bBtmMoldGrindByTopData)
                            //if ((CData.CurCompany == ECompany.ASE_KR || CDataOption.UseDFDataServer) && bBtmMoldGrindByTopData)//210818 pjh : D/F Data server 기능 License로 구분
                            if ((CData.CurCompany == ECompany.ASE_KR || (CData.CurCompany == ECompany.ASE_K12 && CData.Opt.bSecsUse) ||
                                (CDataOption.UseDFDataServer && !CData.Opt.bSecsUse)) && bBtmMoldGrindByTopData) //220504 pjh : ASE KH 조건 추가
                            {
                                dMax = dStripHeight1stMax + dPcbTh; //(Max(측정(Shift)두께,설정두께) + PCB두께(from HOST))
                                
                                _SetLog($">>>>> dMax({dMax}) = dStripHeight1stMax({dStripHeight1stMax}) + dPcbTh({dPcbTh})", true);
                            }
#endif
                        }
                        else
                        {
                            _SetLog($">>>>> dMax = {dMax} mm / CData.Dev.aData[{m_iWy}].dMoldTh = {CData.Dev.aData[m_iWy].dMoldTh}", true);

                            if (dMax < CData.Dev.aData[m_iWy].dMoldTh)
                            {//가장 높은 자재 측정 높이가 유저 입력한 자재 높이보다 클 경우 => 차이값 옵셋 변수에 저장
                                dMax = CData.Dev.aData[m_iWy].dMoldTh;
                            }
                        }

                        _SetLog(string.Format("Table thickness : {0}mm  Max : {1}mm  Wheel tip : {2}mm", CData.Tbl_Af[m_iWy, 0], dMax, CData.WhlAf[m_iWy]), true);
                        
                        //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                        if (CData.bUseWheelZAxisAfterMeasureWheel)
                        {
                            dGrdPos = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - dMax - CData.Dev.aData[m_iWy].dAir
                                    + Math.Round((CData.WheelTipAfterZPos[m_iWy] - CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER) - CData.MPos[m_iWy].dTOOL_SETTER_GAP, 6); //프로브와 휠팁의 높이차(휠팁 Z축 위치 적용)
                            
                            _SetLog("Wheel Tip Z Axis: " + CData.WheelTipAfterZPos[m_iWy].ToString() + "  PRB_TOOL_SETTER: " + CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER.ToString() + "  TOOL_SETTER_GAP: " + CData.MPos[m_iWy].dTOOL_SETTER_GAP.ToString(), true);
                        }
                        else
                        {
                            dGrdPos = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - dMax - CData.Dev.aData[m_iWy].dAir + CData.MPos[m_iWy].dPRB_TO_WHL_BASE - CData.WhlAf[m_iWy];
                        }
                        //
                        _SetLog("[Target Mode][DUAL]  Start position : " + dGrdPos + "mm", true);
                    }
                    else
                    {//듀얼 모드 사용 안함
                        if(CData.Dev.bDynamicSkip)
                        {
                            if (dMax < CData.Dev.aData[(int)EWay.L].dTotalTh)
                            {//가장 높은 자재 측정 높이가 유저 입력한 자재 높이보다 클 경우 => 차이값 옵셋 변수에 저장
                                dMax = CData.Dev.aData[(int)EWay.L].dTotalTh;
                            }
#if true //201021 jhc : ASE-Kr TOP 그라인딩 결과 두께 > SECS/GEM > BTM 그라인딩
                            // 2021.05.28 SungTae Start: [수정] Qorvo_NC 조건 추가
                            //if ((CData.CurCompany == ECompany.ASE_KR) && bBtmMoldGrindByTopData)
                            //if ((CData.CurCompany == ECompany.ASE_KR || CData.CurCompany == ECompany.Qorvo_NC) && bBtmMoldGrindByTopData)
                            //if ((CData.CurCompany == ECompany.ASE_KR || CDataOption.UseDFDataServer) && bBtmMoldGrindByTopData)//210818 pjh : D/F Data server 기능 License로 구분
                            if ((CData.CurCompany == ECompany.ASE_KR || (CData.CurCompany == ECompany.ASE_K12 && CData.Opt.bSecsUse) ||
                                (CDataOption.UseDFDataServer && !CData.Opt.bSecsUse)) && bBtmMoldGrindByTopData) //220504 pjh : ASE KH 조건 추가
                            {
                                dMax = dStripHeight1stMax + dPcbTh; //(Max(측정(Shift)두께,설정두께) + PCB두께(from HOST))
                            }
#endif
                        }
                        else
                        {
                            if (dMax < CData.Dev.aData[(int)EWay.L].dMoldTh)
                            {//가장 높은 자재 측정 높이가 유저 입력한 자재 높이보다 클 경우 => 차이값 옵셋 변수에 저장
                                dMax = CData.Dev.aData[(int)EWay.L].dMoldTh;
                            }
                        }

                        _SetLog(string.Format("Table thickness : {0}mm  Max : {1}mm  Wheel tip : {2}mm", CData.Tbl_Af[m_iWy, 0], dMax, CData.WhlAf[m_iWy]), true);
                        
                        //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                        if (CData.bUseWheelZAxisAfterMeasureWheel)
                        {
                            dGrdPos = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - dMax - CData.Dev.aData[(int)EWay.L].dAir
                                    + Math.Round((CData.WheelTipAfterZPos[m_iWy] - CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER) - CData.MPos[m_iWy].dTOOL_SETTER_GAP, 6); //프로브와 휠팁의 높이차(휠팁 Z축 위치 적용)
                            
                            _SetLog("Wheel Tip Z Axis: " + CData.WheelTipAfterZPos[m_iWy].ToString() + "  PRB_TOOL_SETTER: " + CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER.ToString() + "  TOOL_SETTER_GAP: " + CData.MPos[m_iWy].dTOOL_SETTER_GAP.ToString(), true);
                        }
                        else
                        {
                            dGrdPos = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - dMax - CData.Dev.aData[(int)EWay.L].dAir + CData.MPos[m_iWy].dPRB_TO_WHL_BASE - CData.WhlAf[m_iWy];
                        }
                        //
                        _SetLog("[Target Mode]  Start position : " + dGrdPos + "mm", true);
                    }
                }
            }
            else
            {//탑다운 모드
                if (m_eWy == EWay.L)
                {
                    _SetLog(string.Format("Table thickness : {0}mm  Max : {1}mm  Wheel tip : {2}mm", CData.Tbl_Af[m_iWy, 0], dMax, CData.WhlAf[m_iWy]), true);
                    
                    //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                    if (CData.bUseWheelZAxisAfterMeasureWheel)
                    {
                        dGrdPos = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - dMax - CData.Dev.aData[m_iWy].dAir
                                + Math.Round((CData.WheelTipAfterZPos[m_iWy] - CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER) - CData.MPos[m_iWy].dTOOL_SETTER_GAP, 6); //프로브와 휠팁의 높이차(휠팁 Z축 위치 적용)
                        _SetLog("Wheel Tip Z Axis: " + CData.WheelTipAfterZPos[m_iWy].ToString() + "  PRB_TOOL_SETTER: " + CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER.ToString() + "  TOOL_SETTER_GAP: " + CData.MPos[m_iWy].dTOOL_SETTER_GAP.ToString(), true );
                    }
                    else
                    {
                        dGrdPos = CData.MPos[0].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - dMax - CData.Dev.aData[m_iWy].dAir + CData.MPos[0].dPRB_TO_WHL_BASE - CData.WhlAf[m_iWy];
                    }
                    //
                    _SetLog("[Top-Down Mode]  Start position : " + dGrdPos + "mm", true);
                }
                else  // Right
                {
                    if (CData.Dev.bDual == eDual.Dual)
                    {//듀얼 모드 사용
                        _SetLog(string.Format("Table thickness : {0}mm  Max : {1}mm  Wheel tip : {2}mm", CData.Tbl_Af[m_iWy, 0], dMax, CData.WhlAf[m_iWy]), true);
                        //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                        if (CData.bUseWheelZAxisAfterMeasureWheel)
                        {
                            dGrdPos = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - dMax - CData.Dev.aData[m_iWy].dAir
                                    + Math.Round((CData.WheelTipAfterZPos[m_iWy] - CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER) - CData.MPos[m_iWy].dTOOL_SETTER_GAP, 6); //프로브와 휠팁의 높이차(휠팁 Z축 위치 적용)
                            _SetLog("Wheel Tip Z Axis: " + CData.WheelTipAfterZPos[m_iWy].ToString() + "  PRB_TOOL_SETTER: " + CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER.ToString() + "  TOOL_SETTER_GAP: " + CData.MPos[m_iWy].dTOOL_SETTER_GAP.ToString(), true);
                        }
                        else
                        {
                            dGrdPos = CData.MPos[1].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - dMax - CData.Dev.aData[m_iWy].dAir + CData.MPos[1].dPRB_TO_WHL_BASE - CData.WhlAf[m_iWy];
                        }
                        //
                        _SetLog("[Top-Down Mode][DUAL]  Start position : " + dGrdPos + "mm", true);
                    }
                    else
                    {//듀얼 모드 사용 안함
                        _SetLog(string.Format("Table thickness : {0}mm  Max : {1}mm  Wheel tip : {2}mm", CData.Tbl_Af[m_iWy, 0], dMax, CData.WhlAf[m_iWy]), true);
                        //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
                        if (CData.bUseWheelZAxisAfterMeasureWheel)
                        {
                            dGrdPos = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - dMax - CData.Dev.aData[(int)EWay.L].dAir
                                    + Math.Round((CData.WheelTipAfterZPos[m_iWy] - CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER) - CData.MPos[m_iWy].dTOOL_SETTER_GAP, 6); //프로브와 휠팁의 높이차(휠팁 Z축 위치 적용)
                            _SetLog("Wheel Tip Z Axis: " + CData.WheelTipAfterZPos[m_iWy].ToString() + "  PRB_TOOL_SETTER: " + CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER.ToString() + "  TOOL_SETTER_GAP: " + CData.MPos[m_iWy].dTOOL_SETTER_GAP.ToString(), true );
                        }
                        else
                        {
                            dGrdPos = CData.MPos[1].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - dMax - CData.Dev.aData[(int)EWay.L].dAir + CData.MPos[1].dPRB_TO_WHL_BASE - CData.WhlAf[m_iWy];
                        }
                        //
                        _SetLog("[Top-Down Mode]  Start position : " + dGrdPos + "mm", true);
                    }
                }
            }

            //20190421 ghk_휠 리그라인딩 옵셋
            m_dStartHeight = dMax;
            dStripHeight   = dMax;

#if true //201021 jhc : ASE-Kr TOP 그라인딩 결과 두께 > SECS/GEM > BTM 그라인딩
            //if ((CData.CurCompany == ECompany.ASE_KR || CData.CurCompany == ECompany.Qorvo_NC) && bBtmMoldGrindByTopData )
            //if ((CData.CurCompany == ECompany.ASE_KR || CDataOption.UseDFDataServer) && bBtmMoldGrindByTopData)//210818 pjh : D/F Data server 기능 License로 구분
            if ((CData.CurCompany == ECompany.ASE_KR || (CData.CurCompany == ECompany.ASE_K12 && CData.Opt.bSecsUse) ||
                (CDataOption.UseDFDataServer && !CData.Opt.bSecsUse)) && bBtmMoldGrindByTopData) //220504 pjh : ASE KH 조건 추가
            {                       
                // 자재 측정(또는 Shift) 두께 와 디바이스(Recipe) 입력 두께 중 큰 값 선택
                // <== 그라인딩 시작 높이(dGrdPos) 계산 시 실재 자재 측정(또는 Shift) 두께와,
                //     디바이스(Recipe) 설정 두께 중 더 큰 값 기준으로 계산하므로,
                //     Rough 1 에서 그라인딩 량(카운트) 계산 시에도 이를 공통 적용해야 함!!!                     
                dStripHeight = dStripHeight1stMax; //PCB 두께를 제외한 Mold두께 기준 : Bottom && SECS/GEM 사용 => Mold 두께 기준의 Recipe 적용되므로!!!
            }
#endif

            //190529 ksg :
            //190604 ksg : JSCK 옵션 처리 하라고 함
            //190610 ksg : 옵션 처리 
            if(CData.Dev.bDataShift)
            {
                if (m_eWy == EWay.R && CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown && CData.Dev.bDual == eDual.Dual)
                {
                    if (CData.Parts[(int)EPart.GRDR].dShiftT != 0)
                    {
                        m_dStartHeight = CData.Parts[(int)EPart.GRDR].dShiftT;
                        dStripHeight   = CData.Parts[(int)EPart.GRDR].dShiftT;
                    }
                }
            }

            m_dGrdUpOffset = 0;

            int iWy = 0;
            for (int i = 0; i < m_iStepMaxCnt; i++)     // 2020.09.08 SungTae : Modify
            {
                if ((m_eWy == EWay.R) && (CData.Dev.bDual == eDual.Normal))
                { iWy = (int)EWay.L; }
                else
                { iWy = m_iWy; }

                if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                {//해당 스텝 사용 할때 그라인딩 카운트 계산
                 //해당 스텝 그라인딩 양
                    if(CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.Target)
                    {
                        dTotalDepth = Math.Round((dStripHeight - CData.Dev.aData[iWy].aSteps[i].dTotalDep), 4);
                    }
                    else
                    {
                        dTotalDepth = CData.Dev.aData[iWy].aSteps[i].dTotalDep;
                        //190502 ksg :
                        if(i == 0)
                        {
                                 if(CData.Dev.aData[iWy].eStartMode == eTDStartMode.Max ) dTotalDepth = dTotalDepth + 0;
                            else if(CData.Dev.aData[iWy].eStartMode == eTDStartMode.Avg ) dTotalDepth = dTotalDepth + (dMax - dAvg );
                            else if(CData.Dev.aData[iWy].eStartMode == eTDStartMode.Mean) dTotalDepth = dTotalDepth + (dMax - dMean);
                            else if(CData.Dev.aData[iWy].eStartMode == eTDStartMode.Min ) dTotalDepth = dTotalDepth + (dMax - dMin );
                        }
                    }

					if (!bAir && (i < m_iStepMaxCnt - 1))       // 2020.09.08 SungTae : Modify
					{   //Fine그라인딩이 아니고 사용 선택 한 첫번째 스텝에 에어컷 양 넣기
						dTotalDepth += CData.Dev.aData[iWy].dAir;
						bAir = true;
					}

					//201125 jhc : Grinding Step별 Correct 기능 : 각 스텝별 입력 값 만큼 단위 스텝의 총 그라인딩량 보정 (Fine Step 제외)
					if (CDataOption.UseGrindingStepCorrect && (i < (m_iStepMaxCnt - 1)))
					{
						dTotalDepthOriginal = dTotalDepth;
						dTotalDepth += CData.Dev.aData[iWy].aSteps[i].dCorrectDepth;
						_SetLog(string.Format("Total Depth Correct (Step {0} : {1})  {2} ===> {3}",
												(i + 1),
												CData.Dev.aData[iWy].aSteps[i].dCorrectDepth.ToString("0.0000"),
												dTotalDepthOriginal.ToString("0.0000"),
												dTotalDepth.ToString("0.0000")));
					}
					//

					if (i != 0 && i != m_iStepMaxCnt - 1)       // 2020.09.08 SungTae : Modify
					{   //첫번째 스텝과 Fine Grinding 스텝 제외 한 나머지 스텝 20um 에어컷 적용
						CData.GrData[m_iWy].aCnt[i] = Cal_StepCnt(dTotalDepth + m_ZPosUpOffset, CData.Dev.aData[iWy].aSteps[i].dCycleDep); //10 추가 옵셋... //190419 ksg :
					}
					else
					{
						CData.GrData[m_iWy].aCnt[i] = Cal_StepCnt(dTotalDepth, CData.Dev.aData[iWy].aSteps[i].dCycleDep);   // Grd

                        if (i == 0) // Rough 01
                        {
                            if (CData.Dev.aData[m_iWy].bAppCylDepOnFirst) { } // 2022.09.26 lhs : R1, Count 그대로... Z축은 바로 Cycle Depth 적용
                            else { CData.GrData[m_iWy].aCnt[0]++; }  //200824 jhc : 1st Step Grinding - Z축 1회 더 Down하여 그라인딩 필요
                        }
                    }

					if (i == m_iStepMaxCnt - 1)     // 2020.09.08 SungTae : Modify
					{ CData.GrData[m_iWy].aCnt[i] = 1; }
					else // 200923 jym : Up offset 추출
					{
						m_dGrdUpOffset = Math.Max(m_dGrdUpOffset, CData.Dev.aData[m_iWy].aSteps[i].dCycleDep);
					}

					dStripHeight = CData.Dev.aData[iWy].aSteps[i].dTotalDep;

					_SetLog(string.Format("Step {0} -> Total depth : {1}mm  Z up offset : {2}mm  Grind count : {3}", (i + 1), dTotalDepth, m_ZPosUpOffset, CData.GrData[m_iWy].aCnt[i]), true);
				}
				else
				{//해당 스텝 사용 안할때 그라인딩 카운트 0입력
					CData.GrData[m_iWy].aCnt[i] = 0;
					_SetLog(string.Format("Step {0} -> Not use.", (i + 1)));
				}
			}

            //if ((!CData.Dev.bDynamicSkip) || (CData.Opt.bSecsUse))
            if (((!CData.Dev.bDynamicSkip) || (CData.Opt.bSecsUse)) && !bBtmMoldGrindByTopData)//220516 pjh : ASE KH Bottom Grinding 시 시작위치 Issue로 조건 처리
            {
				// SECS/GEM 사용시에 Host 에서 Down 받은 값을 "-" 진행 함 20200401 LCY
				// 다이나믹 펑션 사용 시 측정 값을 "-" 진행 함 20200401 LCY
				if (m_eWy == EWay.L)
				{
					//20191029 ghk_dfserver_notuse_df
					if (CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
					{//DF 사용시 DF 측정 안할 경우 Max값으로 적용
						CData.Dynamic.iHeightType = 0;
					}

					if (CData.Dynamic.iHeightType == 0)
					{//PCB 측정 값 중 Max 사용
					 //20190618 ghk_dfserver
						if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
						{//[GL2, GL3]
							dGrdPos -= CData.Parts[(int)EPart.GRDL].dDfMax;
							_SetLog(string.Format("PCB Max.  GL2,3.  DF Max : {0}mm  Start position : {1}mm", CData.Parts[(int)EPart.GRDL].dDfMax, dGrdPos), true);
						}
						else
						{//[GL1]
						 //20191029 ghk_dfserver_notuse_df
							if (CDataOption.MeasureDf == eDfServerType.MeasureDf)
							{//DF 사용시 DF 측정 사용할경우 PCB값 계산포함
								dGrdPos -= CData.Parts[(int)EPart.GRDL].dPcbMax;
								_SetLog(string.Format("PCB Max.  GL1.  PCB Max : {0}mm  Start position : {1}mm", CData.Parts[(int)EPart.GRDL].dPcbMax, dGrdPos), true);
							}
						}
					}
					else
					{//PCB 측정 값 중 Mean 사용
					 //20190618 ghk_dfserver
						if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
						{
							dGrdPos -= CData.Parts[(int)EPart.GRDL].dDfAvg;
							_SetLog(string.Format("PCB Mean.  GL2,3.  DF Max : {0}mm  Start position : {1}mm", CData.Parts[(int)EPart.GRDL].dDfAvg, dGrdPos), true);
						}
						else
						{
							dGrdPos -= CData.Parts[(int)EPart.GRDL].dPcbMean;
							_SetLog(string.Format("PCB Mean.  GL1.  PCB Max : {0}mm  Start position : {1}mm", CData.Parts[(int)EPart.GRDL].dPcbMean, dGrdPos), true);
						}
					}
				}
				else  // Right
				{
					//20191029 ghk_dfserver_notuse_df
					if (CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
					{//DF 사용시 DF 측정 안할 경우 Max값으로 적용
						CData.Dynamic.iHeightType = 0;
					}

					if (CData.Dynamic.iHeightType == 0)
					{//PCB 측정 값 중 Max 사용
					 //20190618 ghk_dfserver
						if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
						{//[GL2, GL3]
							dGrdPos -= CData.Parts[(int)EPart.GRDR].dDfMax;
							_SetLog(string.Format("PCB Max.  GL2,3.  DF Max : {0}mm  Start position : {1}mm", CData.Parts[(int)EPart.GRDR].dDfMax, dGrdPos), true);
						}
						else
						{//[GL1]
						 //20191029 ghk_dfserver_notuse_df
							if (CDataOption.MeasureDf == eDfServerType.MeasureDf)
							{//DF 사용시 DF 측정 사용할경우 PCB값 계산포함
								dGrdPos -= CData.Parts[(int)EPart.GRDR].dPcbMax;
								_SetLog(string.Format("PCB Max.  GL1.  PCB Max : {0}mm  Start position : {1}mm", CData.Parts[(int)EPart.GRDR].dPcbMax, dGrdPos), true);
							}
						}
					}
					else
					{//PCB 측정 값 중 Mean 사용
					 //20190618 ghk_dfserver
						if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
						{
							dGrdPos -= CData.Parts[(int)EPart.GRDR].dDfAvg;
							_SetLog(string.Format("PCB Mean.  GL2,3.  DF Max : {0}mm  Start position : {1}mm", CData.Parts[(int)EPart.GRDR].dDfAvg, dGrdPos), true);
						}
						else
						{
							dGrdPos -= CData.Parts[(int)EPart.GRDR].dPcbMean;
							_SetLog(string.Format("PCB Mean.  GL1.  PCB Max : {0}mm  Start position : {1}mm", CData.Parts[(int)EPart.GRDR].dPcbMean, dGrdPos), true);
						}
					}
				}
			}

            //201014 jhc : ASE-Kr 적용 안 함(ASE-Kr에서 결정) //그라인딩 시 오버그라인딩 방지를 위한 시작 위치 상승 옵셋 200923 jym
            if (CData.CurCompany == ECompany.ASE_KR)
            { m_dGrdUpOffset = 0; }
            //

            // 200923 jym : Grd up offset 추가
            dGrdPos = dGrdPos - CData.Dev.aData[m_iWy].dPrbOffset - m_dGrdUpOffset;

            //201203 jhc : 드레싱 후 N번째 그라인딩 시 휠 소모량 보정 기능
            if (CDataOption.UseDeviceAdvancedOption && CDataOption.UseWheelLossCorrect) //(DEVICE > PARAM > ADVANCED 메뉴 표시) + (드레싱 후 N번째 그라인딩 시 휠 소모량 보정 기능 사용)
            {
                nCountAfterDressing = CData.Whls[m_iWy].iGdc;
                if (nCountAfterDressing < 0)
                {
                    nCountAfterDressing = 0; //카운트 비정상 경우 대비
                }
                dWheelLossTotal = 0.0;

                if (0 == nCountAfterDressing) //DEVICE > ADVANCED 메뉴 옵션에서는 "1st"로 표시됨
                {
                    //드레싱 후 첫번째 그라인딩은 Wheel Loss 보정 불필요
                    _SetLog("Probe RNR : " + CData.Dev.aData[m_iWy].dPrbOffset + "mm  Grd up offset : " + m_dGrdUpOffset + "mm  Wheel Loss[0:" + CData.Whls[m_iWy].iGdc.ToString() + "] : None", true);
                }
                else
                {
                    for (int i=1; i <= nCountAfterDressing; i++)
                    {
                        idx = i;
                        if (GV.WHEEL_LOSS_CORRECT_STRIP_MAX <= idx)
                        {
                            idx = (GV.WHEEL_LOSS_CORRECT_STRIP_MAX - 1); //드레싱 후 그라인딩 횟수가 Wheel Loss 보정 설정 최대 수량 초과 시 ==> 마지막 회차의 보정 설정 값 적용
                            if (idx < 0) { break; } //인덱스(카운트) 비정상 경우 대비
                        }
                        dWheelLossTotal += CData.Dev.aData[m_iWy].dWheelLoss[idx]; //드레싱 후 N 번째까지의 Wheel Loss 누적 => Z축 추가 DOWN
                    }

                    //////////////////////////////////////////////////////
                    // HERE : Wheel Loss 누적 값의 제한 범위 고려 필요!!! //
                    //////////////////////////////////////////////////////
                    if (dWheelLossTotal <= CData.Dev.aData[m_iWy].dTotalWheelLossLimit)
                    {
                        ////////////////////////////
                        dGrdPos += dWheelLossTotal;
                        ////////////////////////////
                        _SetLog("Probe RNR : " + CData.Dev.aData[m_iWy].dPrbOffset + "mm  Grd up offset : " + m_dGrdUpOffset +
                                "mm  After Dress : " + CData.Whls[m_iWy].iGdc + "  Total Wheel Loss[" + nCountAfterDressing + "] : " + dWheelLossTotal, true);
                    }
                    else
                    {
                        //Error 처리
                        m_TotalWheelLossLimitOver = true; //누적 Wheel Loss 제한량 초과 여부 (Z축 과도 DOWN 제한 필요)

                        _SetLog("Probe RNR : " + CData.Dev.aData[m_iWy].dPrbOffset + "mm  Grd up offset : " + m_dGrdUpOffset +
                                "mm  After Dress : " + CData.Whls[m_iWy].iGdc + "  Total Wheel Loss [" + nCountAfterDressing + "] : " + dWheelLossTotal +
                                " ==> Limit[" + CData.Dev.aData[m_iWy].dTotalWheelLossLimit + "] Over!!!", true);
                    }
                }
            }
            else
            {
                _SetLog("Probe RNR : " + CData.Dev.aData[m_iWy].dPrbOffset + "mm  Grd up offset : " + m_dGrdUpOffset + "mm", true);
            }
            //

            //200416 pjh : Grinding Strip Start Limit
            if (CData.Dev.bStripStartLimit)
            {
                if (m_eWy == EWay.L)
                {
                    if (!CData.Dev.bDynamicSkip)
                    {
                        if (dGrdPos > CData.MPos[0].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - CData.Parts[(int)EPart.GRDL].dPcbMax + CData.MPos[0].dPRB_TO_WHL_BASE - CData.WhlAf[m_iWy] - CData.Dev.dStripStartLimit)
                        {
                            m_WrongCalFlag = true;
                        }
                    }
                    else
                    {
                        if (dGrdPos > CData.MPos[0].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] + CData.MPos[0].dPRB_TO_WHL_BASE - CData.WhlAf[m_iWy] - CData.Dev.dStripStartLimit)
                        {
                            m_WrongCalFlag = true;
                        }
                    }
                }
                else
                {
                    if (!CData.Dev.bDynamicSkip)
                    {
                        if (dGrdPos > CData.MPos[1].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - CData.Parts[(int)EPart.GRDL].dPcbMax + CData.MPos[0].dPRB_TO_WHL_BASE - CData.WhlAf[m_iWy] - CData.Dev.dStripStartLimit)
                        {
                            m_WrongCalFlag = true;
                        }
                    }
                    else
                    {
                        if (dGrdPos > CData.MPos[1].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] + CData.MPos[0].dPRB_TO_WHL_BASE - CData.WhlAf[m_iWy] - CData.Dev.dStripStartLimit)
                        {
                            m_WrongCalFlag = true;
                        }
                    }
                }
            }

            _SetLog("Final start position : " + dGrdPos + "mm", true);
            return dGrdPos;
        }

        // 2021.07.31 lhs Start : UseNewSckGrindProc용 (SCK 전용)
        /// <summary>
        /// Calculate Grinding Step Start Position
        /// 그라인딩 스텝 시작 위치 계산 (SCK 전용)
        /// </summary>
        /// <returns></returns>
        public double Cal_GrdStart_NewSck()
        {
            double dTotalDepthOriginal = 0.0;      //201125 jhc : Grinding Step별 Correct 기능

            //201203 jhc : 드레싱 후 N 번째 그라인딩 시 휠 소모량 보정 기능
            m_TotalWheelLossLimitOver   = false;    //누적 Wheel Loss 제한량 초과 여부 플래그 리셋 (Z축 과도 DOWN 방지용)

            int     nCountAfterDressing = 0;        //드레싱 후 그라인딩 완료 횟수
            double  dWheelLossTotal     = 0.0;      //드레싱 후 N 번째 그라인딩 시까지의 누적 휠 소모량
            int     idx = 0;                        //Wheel Loss 보정값 배열 인덱스
            //

            double dTotalDepth  = 0.0;
            double dGrdPos      = 0.0;
            double dMax         = 0.0;
            double dMin         = 999.999;  //190502 ksg :
            double dAvg         = 0.0;      //190502 ksg :
            double dMean        = 0.0;      //190502 ksg :
            double dStripHeight = 0.0;
            bool bAir           = false;
            bool bMeasure       = false;    //200712 jhc : 18 포인트 측정 (ASE-KR VOC)

            double dDeviceTotalTh   = 0.0;  //Device(Recipe)에 설정된 Total Thickness 값

            if ((m_eWy == EWay.R) && (CData.Dev.bDual == eDual.Normal)) { dDeviceTotalTh = CData.Dev.aData[(int)EWay.L].dTotalTh;   } //Normal 모드, R-Table인 경우 Left 설정값 사용
            else                                                        { dDeviceTotalTh = CData.Dev.aData[m_iWy].dTotalTh;         } //L-Table 또는 R-Table Step 모드인 경우 각자 설정값 사용

            // 200317 mjy : 조건 추가함
            if (CDataOption.Package == ePkg.Strip)
            {
                //200325 ksg : Data Shift Probe Skip
                if (m_eWy == EWay.R && CData.Dev.bDual == eDual.Dual && CData.Dev.bDShiftPSkip && CData.Parts[(int)EPart.GRDR].dShiftT > 0)
                {
                    dMax = CData.Parts[(int)EPart.GRDR].dShiftT;
                    dMin = CData.Parts[(int)EPart.GRDR].dShiftT;
                    _SetLog(string.Format("Shift data.  Max : {0}mm  Min : {1}mm", dMax, dMin), true);
                }
                else
                {
                    for (int i = 0; i < CData.Dev.iCol; i++)
                    {   //측정한 자재 높이 중 가장 높은 자재 높이 구하기
                        for (int j = 0; j < (CData.Dev.iRow * CData.Dev.iWinCnt); j++)
                        {
                            if (CData.Parts[m_iPart].b18PMeasure)   { bMeasure = CData.Dev.aData[m_iWy].aPosBf[j, i].bUse18P;   } //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                            else                                    { bMeasure = CData.Dev.aData[m_iWy].aPosBf[j, i].bUse;      }
                            
                            if (bMeasure)
                            {
                                if (m_aInspBf[j, i] == 0) continue;
                                dMax = Math.Max(dMax, m_aInspBf[j, i]);
                                dMin = Math.Min(dMin, m_aInspBf[j, i]);
                            }
                        }
                    }
                    _SetLog(string.Format("Max : {0}mm  Min : {1}mm", dMax, dMin), true);
                }
            }
            else // Unit에서 검사
            {
                for (int i = 0; i < CData.Dev.iCol; i++)
                {//측정한 자재 높이 중 가장 높은 자재 높이 구하기
                    for (int j = 0; j < CData.Dev.iRow; j++)
                    {
                        if (CData.Dev.aData[m_iWy].aPosBf[j, i].bUse)
                        {
                            for (int iU = 0; iU < CData.Dev.iUnitCnt; iU++)
                            {
                                double dVal = CData.GrData[m_iWy].aUnit[iU].aMeaBf[j, i];
                                if (dVal == 0) continue;
                                dMax = Math.Max(dMax, dVal);
                                dMin = Math.Min(dMin, dVal);
                            }
                        }
                    }
                }
                _SetLog(string.Format("Max : {0}mm  Min : {1}mm", dMax, dMin), true);
            }

            if (dMax <= 0)
            {
                m_WrongCalFlag = true;
                _SetLog("Wrong calculate flag on.  Max : " + dMax + "mm");
            }
            // <-- dMax는 실제 측정(또는 Shift된) 자재 두께 (Total 또는 Mold)

            //200325 ksg : Data Shift Probe Skip
            if (m_eWy == EWay.R && CData.Dev.bDual == eDual.Dual && CData.Dev.bDShiftPSkip && CData.Parts[(int)EPart.GRDR].dShiftT > 0)
            {
                dAvg  = CData.Parts[(int)EPart.GRDR].dShiftT;
                dMean = CData.Parts[(int)EPart.GRDR].dShiftT;
                CData.PbResultVal[m_iWy].dBMax = dMax;
                CData.PbResultVal[m_iWy].dBMin = dMax;
                CData.PbResultVal[m_iWy].dBAvg = dMax;
                _SetLog(string.Format("Shift data.  Avg : {0}mm  Mean : {1}mm", dAvg, dMean), true);
            }
            else
            {
                dAvg  = Math.Round(CData.PbResultVal[m_iWy].dBAvg,  4);
                dMean = Math.Round(CData.PbResultVal[m_iWy].dBMean, 4);
                _SetLog(string.Format("Avg : {0}mm  Mean : {1}mm", dAvg, dMean), true);
            }            

            // Target 모드 TopDown 모드 상관없이 모두 적용됨
            int iWy = 0;
			if ((m_eWy == EWay.R) && (CData.Dev.bDual == eDual.Normal))     {   iWy = (int)EWay.L;    }
			else                                                            {   iWy = m_iWy;          }

			if (CData.Dev.aData[m_iWy].eBaseOnThick == EBaseOnThick.Total)  {   if (dMax < CData.Dev.aData[iWy].dTotalTh)   dMax = CData.Dev.aData[iWy].dTotalTh;   }
			else			                                                {   if (dMax < CData.Dev.aData[iWy].dMoldTh)    dMax = CData.Dev.aData[iWy].dMoldTh;    }

            double dTmpAir = CData.Dev.aData[iWy].dAir;
			 

			_SetLog(string.Format("Table thickness : {0}mm  Max : {1}mm  Wheel tip : {2}mm", CData.Tbl_Af[m_iWy, 0], dMax, CData.WhlAf[m_iWy]), true);

			if (CData.bUseWheelZAxisAfterMeasureWheel)
			{
				dGrdPos = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - dMax - dTmpAir
						+ Math.Round((CData.WheelTipAfterZPos[m_iWy] - CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER) - CData.MPos[m_iWy].dTOOL_SETTER_GAP, 6); //프로브와 휠팁의 높이차(휠팁 Z축 위치 적용)

				_SetLog("Wheel Tip Z Axis: " + CData.WheelTipAfterZPos[m_iWy].ToString() + "  PRB_TOOL_SETTER: " + CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER.ToString() + "  TOOL_SETTER_GAP: " + CData.MPos[m_iWy].dTOOL_SETTER_GAP.ToString(), true);
			}
			else
			{
				dGrdPos = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] - dMax - dTmpAir
						+ CData.MPos[m_iWy].dPRB_TO_WHL_BASE - CData.WhlAf[m_iWy];
			}

            string sLogMsg = "";
            sLogMsg += (CData.Dev.bDual == eDual.Normal)                            ? "eDual.Normal. "          : "eDual.Dual. ";
            sLogMsg += (m_eWy           == EWay.L)                                  ? "Left Table. "            : "Right Table. ";
            sLogMsg += (CData.Dev.aData[m_iWy].eGrdMod      == eGrdMode.TopDown)    ? "TopDown mode. "          : "Target mode. ";
            sLogMsg += (CData.Dev.aData[m_iWy].eBaseOnThick == EBaseOnThick.Total)  ? "Base on Total thick. "   : "Base on Mold thick. ";
			_SetLog(sLogMsg);
			
            _SetLog("Grinding Start position : " + dGrdPos + "mm", true);

            //20190421 ghk_휠 리그라인딩 옵셋
            m_dStartHeight  = dMax;
            dStripHeight    = dMax;

            if (CData.Dev.bDataShift)
            {
                if (m_eWy == EWay.R && CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown && CData.Dev.bDual == eDual.Dual)
                {
                    if (CData.Parts[(int)EPart.GRDR].dShiftT != 0)
                    {
                        m_dStartHeight  = CData.Parts[(int)EPart.GRDR].dShiftT;
                        dStripHeight    = CData.Parts[(int)EPart.GRDR].dShiftT;
                    }
                }
            }

            m_dGrdUpOffset = 0;

            for (int i = 0; i < m_iStepMaxCnt; i++)  
            {
                if ((m_eWy == EWay.R) && (CData.Dev.bDual == eDual.Normal)) { iWy = (int)EWay.L;    }
                else                                                        { iWy = m_iWy;          }

                if (CData.Dev.aData[m_iWy].aSteps[i].bUse)
                {//해당 스텝 사용 할때 그라인딩 카운트 계산
                 //해당 스텝 그라인딩 양
                    if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.Target)
                    {
                        dTotalDepth = Math.Round((dStripHeight - CData.Dev.aData[iWy].aSteps[i].dTotalDep), 4);
                    }
                    else  // TopDown
                    {
                        dTotalDepth = CData.Dev.aData[iWy].aSteps[i].dTotalDep;
                        if (i == 0)
                        {
                            if      (CData.Dev.aData[iWy].eStartMode == eTDStartMode.Max)   dTotalDepth += 0;
                            else if (CData.Dev.aData[iWy].eStartMode == eTDStartMode.Avg)   dTotalDepth += (dMax - dAvg);
                            else if (CData.Dev.aData[iWy].eStartMode == eTDStartMode.Mean)  dTotalDepth += (dMax - dMean);
                            else if (CData.Dev.aData[iWy].eStartMode == eTDStartMode.Min)   dTotalDepth += (dMax - dMin);
                        }
                    }

                    if (!bAir && (i < m_iStepMaxCnt - 1)) 
                    {   //Fine그라인딩이 아니고 사용 선택 한 첫번째 스텝에 에어컷 양 넣기
                        dTotalDepth += CData.Dev.aData[iWy].dAir;
                        bAir = true;
                    }

                    //201125 jhc : Grinding Step별 Correct 기능 : 각 스텝별 입력 값 만큼 단위 스텝의 총 그라인딩량 보정 (Fine Step 제외)
                    if (CDataOption.UseGrindingStepCorrect && (i < (m_iStepMaxCnt - 1)))
                    {
                        dTotalDepthOriginal = dTotalDepth;
                        dTotalDepth += CData.Dev.aData[iWy].aSteps[i].dCorrectDepth;
                        _SetLog(string.Format("Total Depth Correct (Step {0} : {1})  {2} ===> {3}",
                                                (i + 1),
                                                CData.Dev.aData[iWy].aSteps[i].dCorrectDepth.ToString("0.0000"),
                                                dTotalDepthOriginal.ToString("0.0000"),
                                                dTotalDepth.ToString("0.0000")));
                    }
                    //

                    if (i != 0 && i != m_iStepMaxCnt - 1)  
                    {   //첫번째 스텝과 Fine Grinding 스텝 제외 한 나머지 스텝 20um 에어컷 적용
                        CData.GrData[m_iWy].aCnt[i] = Cal_StepCnt(dTotalDepth + m_ZPosUpOffset, CData.Dev.aData[iWy].aSteps[i].dCycleDep); //10 추가 옵셋... //190419 ksg :
                    }
                    else
                    {
                        CData.GrData[m_iWy].aCnt[i] = Cal_StepCnt(dTotalDepth, CData.Dev.aData[iWy].aSteps[i].dCycleDep); // Grd

                        if (i == 0) // Rough 01
                        {
                            if (CData.Dev.aData[m_iWy].bAppCylDepOnFirst)   { }                                 // 2022.09.26 lhs : R1, Count 그대로... Z축은 바로 Cycle Depth 적용
                            else                                            { CData.GrData[m_iWy].aCnt[0]++; }  //200824 jhc : 1st Step Grinding - Z축 1회 더 Down하여 그라인딩 필요
                        }
                    }

                    if (i == m_iStepMaxCnt - 1) 
                    { 
                        CData.GrData[m_iWy].aCnt[i] = 1; 
                    }
                    else // 200923 jym : Up offset 추출
                    {
                        m_dGrdUpOffset = Math.Max(m_dGrdUpOffset, CData.Dev.aData[m_iWy].aSteps[i].dCycleDep);
                    }

                    dStripHeight = CData.Dev.aData[iWy].aSteps[i].dTotalDep; // Target Mode

                    _SetLog(string.Format("Step {0} -> Total depth : {1}mm  Z up offset : {2}mm  Grind count : {3}", (i + 1), dTotalDepth, m_ZPosUpOffset, CData.GrData[m_iWy].aCnt[i]), true);
                }
                else
                {//해당 스텝 사용 안할때 그라인딩 카운트 0입력
                    CData.GrData[m_iWy].aCnt[i] = 0;
                    _SetLog(string.Format("Step {0} -> Not use.", (i + 1)));
                }
            }

            double dPcbTh = 0.0;    // Pcb값
            if (CData.Opt.bSecsUse)             { _SetLog("SECS/GEM Use. "); }
            
            string sPcbMsg = "";
            if (CData.Dynamic.iHeightType == 0) { dPcbTh = CData.Parts[m_iPart].dPcbMax;    sPcbMsg += "PCB Max = "; }
            else                                { dPcbTh = CData.Parts[m_iPart].dPcbMean;   sPcbMsg += "PCB Mean = "; }

            double dTopMold = CData.Parts[m_iPart].dTopMoldMax;
            double dBtmMold = CData.Parts[m_iPart].dBtmMoldMax;
            
            if (CData.Dev.aData[m_iWy].eBaseOnThick == EBaseOnThick.Mold)
            {
                if      (CData.Dev.eMoldSide == ESide.Top)  {   dGrdPos -= dPcbTh;                          }  // Top Single
                else if (CData.Dev.eMoldSide == ESide.BtmS) {   dGrdPos -= dPcbTh;                          } // Btm Single
                else if (CData.Dev.eMoldSide == ESide.TopD) {   dGrdPos -= dPcbTh;  dGrdPos -= dBtmMold;    } // Top Double
                else if (CData.Dev.eMoldSide == ESide.Btm)  {   dGrdPos -= dPcbTh;  dGrdPos -= dTopMold;    }  // Btm Double
            }
            else    // Total
            {
                //dGrdPos -= 0;
            }
            sLogMsg = string.Format(sPcbMsg + "{0}mm, Top Mold Max = {1}mm, Btm Mold Max = {2}mm, Grinding Start Position = {3}mm", dPcbTh, dTopMold, dBtmMold, dGrdPos);
            _SetLog(sLogMsg);


            // 200923 jym : Grd up offset 추가
            dGrdPos -= (CData.Dev.aData[m_iWy].dPrbOffset + m_dGrdUpOffset);

            //201203 jhc : 드레싱 후 N번째 그라인딩 시 휠 소모량 보정 기능
            if (CDataOption.UseDeviceAdvancedOption && CDataOption.UseWheelLossCorrect) //(DEVICE > PARAM > ADVANCED 메뉴 표시) + (드레싱 후 N번째 그라인딩 시 휠 소모량 보정 기능 사용)
            {
                nCountAfterDressing = CData.Whls[m_iWy].iGdc;
                if (nCountAfterDressing < 0)
                {
                    nCountAfterDressing = 0; //카운트 비정상 경우 대비
                }
                dWheelLossTotal = 0.0;

                if (0 == nCountAfterDressing) //DEVICE > ADVANCED 메뉴 옵션에서는 "1st"로 표시됨
                {
                    //드레싱 후 첫번째 그라인딩은 Wheel Loss 보정 불필요
                    _SetLog("Probe RNR : " + CData.Dev.aData[m_iWy].dPrbOffset + "mm  Grd up offset : " + m_dGrdUpOffset + "mm  Wheel Loss[0:" + CData.Whls[m_iWy].iGdc.ToString() + "] : None", true);
                }
                else
                {
                    for (int i = 1; i <= nCountAfterDressing; i++)
                    {
                        idx = i;
                        if (GV.WHEEL_LOSS_CORRECT_STRIP_MAX <= idx)
                        {
                            idx = (GV.WHEEL_LOSS_CORRECT_STRIP_MAX - 1); //드레싱 후 그라인딩 횟수가 Wheel Loss 보정 설정 최대 수량 초과 시 ==> 마지막 회차의 보정 설정 값 적용
                            if (idx < 0) { break; } //인덱스(카운트) 비정상 경우 대비
                        }
                        dWheelLossTotal += CData.Dev.aData[m_iWy].dWheelLoss[idx]; //드레싱 후 N 번째까지의 Wheel Loss 누적 => Z축 추가 DOWN
                    }

                    //////////////////////////////////////////////////////
                    // HERE : Wheel Loss 누적 값의 제한 범위 고려 필요!!! //
                    //////////////////////////////////////////////////////
                    if (dWheelLossTotal <= CData.Dev.aData[m_iWy].dTotalWheelLossLimit)
                    {
                        ////////////////////////////
                        dGrdPos += dWheelLossTotal;
                        ////////////////////////////
                        _SetLog("Probe RNR : " + CData.Dev.aData[m_iWy].dPrbOffset + "mm  Grd up offset : " + m_dGrdUpOffset +
                                "mm  After Dress : " + CData.Whls[m_iWy].iGdc + "  Total Wheel Loss[" + nCountAfterDressing + "] : " + dWheelLossTotal, true);
                    }
                    else
                    {
                        //Error 처리
                        m_TotalWheelLossLimitOver = true; //누적 Wheel Loss 제한량 초과 여부 (Z축 과도 DOWN 제한 필요)

                        _SetLog("Probe RNR : " + CData.Dev.aData[m_iWy].dPrbOffset + "mm  Grd up offset : " + m_dGrdUpOffset +
                                "mm  After Dress : " + CData.Whls[m_iWy].iGdc + "  Total Wheel Loss [" + nCountAfterDressing + "] : " + dWheelLossTotal +
                                " ==> Limit[" + CData.Dev.aData[m_iWy].dTotalWheelLossLimit + "] Over!!!", true);
                    }
                }
            }
            else
            {
                _SetLog("Probe RNR : " + CData.Dev.aData[m_iWy].dPrbOffset + "mm  Grd up offset : " + m_dGrdUpOffset + "mm", true);
            }
            //

            //200416 pjh : Grinding Strip Start Limit
            if (CData.Dev.bStripStartLimit)
            {
                double dGrdPosTmp = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0] + CData.MPos[m_iWy].dPRB_TO_WHL_BASE - CData.WhlAf[m_iWy] - CData.Dev.dStripStartLimit;
                
                if (CData.Dev.aData[m_iWy].eBaseOnThick == EBaseOnThick.Mold)
                {
                    if      (CData.Dev.eMoldSide == ESide.Top)  {   dGrdPosTmp -= dPcbTh;   }   // Top Single
                    else if (CData.Dev.eMoldSide == ESide.BtmS) {   dGrdPosTmp -= dPcbTh;   }   // Btm Single
                    else if (CData.Dev.eMoldSide == ESide.TopD) {   dGrdPosTmp -= dPcbTh;   dGrdPosTmp -= dBtmMold; } // Top Double
                    else if (CData.Dev.eMoldSide == ESide.Btm)  {   dGrdPosTmp -= dPcbTh;   dGrdPosTmp -= dTopMold; } // Btm Double
                }

				if (dGrdPos > dGrdPosTmp)
				{
					m_WrongCalFlag = true;
                    _SetLog(string.Format("Wrong calculate flag on.  dGrdPos(={0}) > dGrdPosTmp (={1})", dGrdPos, dGrdPosTmp));
                }
			}

			_SetLog("Final start position : " + dGrdPos + "mm", true);
            return dGrdPos;
        }
        // 2021.07.31 lhs End : UseNewSckGrindProc용 (SCK 전용)

        /// <summary>
        /// Calculate Grinding Step Target Position
        /// 그라인딩 스텝 별 타겟 위치 계산
        /// </summary>
        public void Cal_GrdTarget()
        {
            double dMax         = 0.0;
            double dMin         = 999.999; //190502 ksg :
            double dAvg         = 0.0; //190502 ksg :
            double dMean        = 0.0; //190502 ksg :
            double dAdd         = 0.0;
            double dStripHeight = 0.0;

            bool bMeasure = false; //200712 jhc : 18 포인트 측정 (ASE-KR VOC)

            // 200317 mjy : 조건 추가함
            if (CDataOption.Package == ePkg.Strip)
            {
                //200325 ksg : Data Shift Probe Skip
                if(m_eWy == EWay.R && CData.Dev.bDual == eDual.Dual && CData.Dev.bDShiftPSkip && CData.Parts[(int)EPart.GRDR].dShiftT > 0)
                {
                    dMax = CData.Parts[(int)EPart.GRDR].dShiftT;
                    dMin = CData.Parts[(int)EPart.GRDR].dShiftT;
                    _SetLog(string.Format("Shift data.  Max : {0}mm  Min : {1}mm", dMax, dMin), true);
                }
                else
                {
                    for (int i = 0; i < CData.Dev.iCol; i++)    //측정한 높이 중 가장 높은 자재 높이 구하기
                    {
                        for (int j = 0; j < (CData.Dev.iRow * CData.Dev.iWinCnt); j++)
                        {
                            if (CData.Parts[m_iPart].b18PMeasure)   { bMeasure = CData.Dev.aData[m_iWy].aPosBf[j, i].bUse18P;   } //200712 jhc : 18 포인트 측정 (ASE-KR VOC)
                            else                                    { bMeasure = CData.Dev.aData[m_iWy].aPosBf[j, i].bUse;      }
                            if (bMeasure)
                            {
                                if(m_aInspBf[j, i] == 0) continue;
                                dMax = Math.Max(dMax, m_aInspBf[j, i]);
                                dMin = Math.Min(dMin, m_aInspBf[j, i]);
                            }
                        }
                    }
                    _SetLog(string.Format("Max : {0}mm  Min : {1}mm", dMax, dMin), true);
                }
            }
            else // Unit에서 검사
            {   
                for (int i = 0; i < CData.Dev.iCol; i++)//측정한 자재 높이 중 가장 높은 자재 높이 구하기
                {
                    for (int j = 0; j < (CData.Dev.iRow); j++)
                    {
                        if (CData.Dev.aData[m_iWy].aPosBf[j, i].bUse)
                        {
                            for (int iU = 0; iU < CData.Dev.iUnitCnt; iU++)
                            {
                                double dVal = CData.GrData[m_iWy].aUnit[iU].aMeaBf[j, i];
                                if (dVal == 0) continue;
                                dMax = Math.Max(dMax, dVal);
                                dMin = Math.Min(dMin, dVal);
                            }
                        }
                    }
                }
                _SetLog(string.Format("Max : {0}mm  Min : {1}mm", dMax, dMin), true);
            }

            //200325 ksg : Data Shift Probe Skip
            if(m_eWy == EWay.R && CData.Dev.bDual == eDual.Dual && CData.Dev.bDShiftPSkip && CData.Parts[(int)EPart.GRDR].dShiftT > 0)
            {
                dAvg  = CData.Parts[(int)EPart.GRDR].dShiftT;
                dMean = CData.Parts[(int)EPart.GRDR].dShiftT;
                _SetLog(string.Format("Shift data.  Avg : {0}mm  Mean : {1}mm", dAvg, dMean), true);
            }
            else
            {
                dAvg  = CData.PbResultVal[(int)m_eWy].dBAvg ;
                dMean = CData.PbResultVal[(int)m_eWy].dBMean;
                _SetLog(string.Format("Avg : {0}mm  Mean : {1}mm", dAvg, dMean), true);
            }

            dStripHeight = dMax;
            
            if(CData.Dev.bDataShift)
            {
                if (m_eWy == EWay.R && CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown && CData.Dev.bDual == eDual.Dual)
                {
                    if (CData.Parts[(int)EPart.GRDR].dShiftT != 0)
                    {
                        dStripHeight = CData.Parts[(int)EPart.GRDR].dShiftT;
                        CData.Parts[(int)EPart.GRDR].dShiftT = 0;
                    }
                }
            }
            //200428 myk : 평균, 중간값 소수 4번째 자리까지 사용
            dAvg    = Math.Round(dAvg,  4);
            dMean   = Math.Round(dMean, 4);
            dMax    = Math.Round(dMax,  4); //191125 ksg :
            //190813 ksg :
            if (dMax <= 0 || dMax < dAvg || dMax < dMean)
            {
                m_WrongCalFlag = true;
                _SetLog("Wrong calculate flag on.  Max = " + dMax + "mm");
            }

            for (int i = 0; i < m_iStepMaxCnt; i++)     //각 스텝 타켓값 입력
            {
                if (CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown)  //탑다운 모드 일때
                {
                    if (CData.Dev.aData[m_iWy].aSteps[i].bUse)  //해당 스텝 사용 할때
                    {
                        if(i == 0)
                        {
                            if(CData.Dev.bDataShift)
                            {
                                if (m_eWy == EWay.R && CData.Dev.aData[m_iWy].eGrdMod == eGrdMode.TopDown && CData.Dev.bDual == eDual.Dual && CData.Parts[(int)EPart.GRDR].dShiftT != 0)
                                {
                                    dAdd = 0;
                                }
                                else
                                {
                                         if (CData.Dev.aData[m_iWy].eStartMode == eTDStartMode.Max ) dAdd = 0;
                                    else if (CData.Dev.aData[m_iWy].eStartMode == eTDStartMode.Avg ) dAdd = dMax - dAvg;
                                    else if (CData.Dev.aData[m_iWy].eStartMode == eTDStartMode.Mean) dAdd = dMax - dMean;
                                    else if (CData.Dev.aData[m_iWy].eStartMode == eTDStartMode.Min ) dAdd = dMax - dMin;
                                }
                            }
                            else
                            {
                                     if (CData.Dev.aData[m_iWy].eStartMode == eTDStartMode.Max ) dAdd = 0;
                                else if (CData.Dev.aData[m_iWy].eStartMode == eTDStartMode.Avg ) dAdd = dMax - dAvg;
                                else if (CData.Dev.aData[m_iWy].eStartMode == eTDStartMode.Mean) dAdd = dMax - dMean;
                                else if (CData.Dev.aData[m_iWy].eStartMode == eTDStartMode.Min ) dAdd = dMax - dMin;
                            }

                            CData.GrData[m_iWy].aTar[i] = dStripHeight - (CData.Dev.aData[m_iWy].aSteps[i].dTotalDep + dAdd);
                            dStripHeight = CData.GrData[m_iWy].aTar[i];
                        }
                        else
                        {
                            CData.GrData[m_iWy].aTar[i] = dStripHeight - CData.Dev.aData[m_iWy].aSteps[i].dTotalDep;
                            dStripHeight = CData.GrData[m_iWy].aTar[i];
                        }
                    }
                    else
                    {//해당 스텝 사용 안할때
                        CData.GrData[m_iWy].aTar[i] = dStripHeight;
                    }
                }
                else //타켓 모드 일때
                {
                    if (CData.Dev.bDual == eDual.Dual) //듀얼 모드 일때(왼쪽 오른쪽 파라미터 각각 사용)
                    {
                        if (CData.Dev.aData[m_iWy].aSteps[i].bUse)  {   CData.GrData[m_iWy].aTar[i] = CData.Dev.aData[m_iWy].aSteps[i].dTotalDep;   }//해당 스텝 사용 할때 
                        else                                        {   CData.GrData[m_iWy].aTar[i] = 0.0;                                          }//해당 스텝 사용 안할때
                    }
                    else    //노멀 모드(왼쪽 파라미터만 사용)
                    {
                        if (CData.Dev.aData[(int)EWay.L].aSteps[i].bUse)    {   CData.GrData[m_iWy].aTar[i] = CData.Dev.aData[(int)EWay.L].aSteps[i].dTotalDep; }//해당 스텝 사용 할때
                        else                                                {   CData.GrData[m_iWy].aTar[i] = 0.0;                                              }
                        CData.GrData[(int)EWay.L].aTar[i] = CData.GrData[m_iWy].aTar[i];
                    }
                }

                _SetLog(string.Format("Step {0} -> Target thickness : {1}mm", (i + 1), CData.GrData[m_iWy].aTar[i]), true);
            }
        }     

        /// <summary>
        /// Calculate Dressing Start Position
        /// 드레싱 스텝 시작 위치 계산
        /// </summary>
        /// <returns></returns>
        public double Cal_DrsStart()
        {
            double dDrsPos = 0.0;
            double dDrsAirCut = 0.0;

            //211014 pjh : Device Wheel 사용 시 Air Cut 변경
            if (CDataOption.UseDeviceWheel)
            {
                 dDrsAirCut = CDev.It.a_tWhl[m_iWy].dDair;

                if (CDataOption.IsDrsAirCutReplace && CData.DrData[m_iWy].bDrsR)
                {
                    dDrsAirCut = CDev.It.a_tWhl[m_iWy].dDairRep;
                }
            }
            //
            else
            {
                // 2020.11.23 JSKim St
                dDrsAirCut = CData.Whls[m_iWy].dDair;

                if (CDataOption.IsDrsAirCutReplace && CData.DrData[m_iWy].bDrsR)
                {
                    dDrsAirCut = CData.Whls[m_iWy].dDairRep;
                }
            }
            // 2020.11.23 JSKim Ed

            //201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
            if (CData.bUseWheelZAxisAfterMeasureWheel)
            {
                dDrsPos = CData.MPos[m_iWy].dZ_DRS_MEA_POS     // 드레셔측정 높이
                        - CData.DrsAf[m_iWy]                   // - 드레셔 높이
                        + Math.Round((CData.WheelTipAfterZPos[m_iWy] - CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER) - CData.MPos[m_iWy].dTOOL_SETTER_GAP, 6) //프로브와 휠팁의 높이차(휠팁 Z축 위치 적용)
                        // 2020.11.23 JSKim St
                        //- CData.Whls [m_iWy].dDair;          // - 드레싱 에어컷
                        - dDrsAirCut;                          // - 드레싱 에어컷
                        // 2020.11.23 JSKim Ed
                _SetLog("Wheel Tip Z Axis: " + CData.WheelTipAfterZPos[m_iWy].ToString() + "  PRB_TOOL_SETTER: " + CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER.ToString() + "  TOOL_SETTER_GAP: " + CData.MPos[m_iWy].dTOOL_SETTER_GAP.ToString(), true);
            }
            else
            {
                dDrsPos = CData.MPos[m_iWy].dZ_DRS_MEA_POS     // 드레셔측정 높이
                        - CData.DrsAf[m_iWy]                   // - 드레셔 높이
                        + CData.MPos[m_iWy].dPRB_TO_WHL_BASE   // + 프로브와 휠베이스의 높이차
                        - CData.WhlAf[m_iWy]                   // - 휠 팁의 높이
                        // 2020.11.23 JSKim St
                        //- CData.Whls [m_iWy].dDair;          // - 드레싱 에어컷
                        - dDrsAirCut;                          // - 드레싱 에어컷
                        // 2020.11.23 JSKim Ed
            }
            //

            return dDrsPos;
        }

        /// <summary>
        /// Calculate Table Grinding Step Start Postion
        /// 테이블 그라인딩 스텝 시작 위치 계산
        /// </summary>
        /// <returns></returns>
        public double Cal_GrdTbStart()
        {
            double dGrdPos = 0.0;
            double dTbHeightMax = 0.0;

            dTbHeightMax = Math.Max(CData.Tbl_Bf[m_iWy, 0], CData.Tbl_Bf[m_iWy, 1]);
			//201104 jhc : Grinding 시작 높이 계산 시 (휠팁 두께 값) 대신 (휠 측정 시 Z축 높이 값) 이용
            if (CData.bUseWheelZAxisAfterMeasureWheel)
            {
                dGrdPos = CData.MPos[m_iWy].dZ_TBL_BASE - dTbHeightMax - CData.Opt.dTbGrdAir
                        + Math.Round((CData.WheelTipAfterZPos[m_iWy] - CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER) - CData.MPos[m_iWy].dTOOL_SETTER_GAP, 6); //프로브와 휠팁의 높이차(휠팁 Z축 위치 적용)
                _SetLog("Wheel Tip Z Axis: " + CData.WheelTipAfterZPos[m_iWy].ToString() + "  PRB_TOOL_SETTER: " + CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER.ToString() + "  TOOL_SETTER_GAP: " + CData.MPos[m_iWy].dTOOL_SETTER_GAP.ToString(), true);
            }
            else
            {
                dGrdPos = CData.MPos[m_iWy].dZ_TBL_BASE - dTbHeightMax + CData.MPos[m_iWy].dPRB_TO_WHL_BASE - CData.WhlAf[m_iWy] - CData.Opt.dTbGrdAir;
            }

            return dGrdPos;
        }

        /// <summary>
        /// 현재 존재하는 유닛 중 마지막 인덱스 찾아 반환
        /// </summary>
        /// <returns></returns>
        public int Cal_LastU()
        {
            int iRet = -1;
            for (int iU = CData.Dev.iUnitCnt - 1; iU >= 0; iU--)
            {
                if (CData.GrData[m_iWy].aUnitEx[iU])
                {
                    iRet = iU;
                    break;
                }
            }

            return iRet;
        }

        /// <summary>
        /// 현재 존재하는 유닛 중 첫번째 인덱스 찾아 반환
        /// </summary>
        /// <returns></returns>
        public int Cal_FirstU()
        {
            int iRet = -1;
            for (int iU = 0; iU < CData.Dev.iUnitCnt; iU++)
            {
                if (CData.GrData[m_iWy].aUnitEx[iU])
                {
                    iRet = iU;
                    break;
                }
            }

            return iRet;
        }

        /// <summary>
        /// 배열에서 min, max, average 추출하여 반환
        /// </summary>
        /// <param name="aVal"></param>
        /// <param name="dMin"></param>
        /// <param name="dMax"></param>
        /// <param name="dAvg"></param>
        private void _Cal_MMA(double[,] aVal, out double dMin, out double dMax, out double dAvg)
        {
            int iCnt = 0;
            int iRCnt = aVal.GetLength(0);
            int iCCnt = aVal.GetLength(1);
            double dTot = 0.0;
            
            dMax = 0.0;
            dMin = 999.999;
            dAvg = 0.0;

            for (int iRow = 0; iRow < iRCnt; iRow++)
            {
                for (int iCol = 0; iCol < iCCnt; iCol++)
                {
                    double dVal = aVal[iRow, iCol];
                    if (dVal != 0)
                    {
                        dMax = Math.Max(dMax, dVal);
                        dMin = Math.Min(dMin, dVal);
                        dTot += dVal;
                        iCnt++;
                    }
                }
            }

            if (iCnt != 0) dAvg = Math.Round((dTot / iCnt), 4);
            else dAvg = 0;

            _SetLog(string.Format("Min : {0}mm  Max : {1}mm  Avg : {2}mm", dMin, dMax, dAvg));
        }

        #region 워터 나이프
        /// <summary>
        /// 스폰지 제거 상태에서만 사용
        /// 0. New Clenaer Type 시 Side 클리닝
        /// 1. 버블 워터 클리닝
        /// 2. 에어 클리닝
        /// 3. wait 포지션 이동
        /// </summary>
        /// <returns></returns>
        public bool Cyl_WKnife_Before()
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_WATERKNIFE_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_WATERKNIFE_TIMEOUT); }
                    _SetLog("Error : Timeout.");

                    m_iCnt = 0;
                    m_iStep = 0;
                    return true;
                }
            }

            m_iPreStep = m_iStep;

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if ((CData.CurCompany == ECompany.ASE_KR) && 
                (15 <= m_iStep && m_iStep <= 25))
            {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                if (0 != m_iPickerVacErr)
                {
                    CMot.It.EStop(m_iY); //Table Y축 즉시 Stop

                    _SetLog("ERROR : Picker Vacuum : " + m_siY + " STOP : " + CMot.It.Get_FP(m_iY).ToString());

                    m_iStep = 100; //정리 스텝으로
                    return false;
                }
            }

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10:
                    {//축 상태 체크
                     // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max 
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }

                        m_iCnt = 0;
                        _SetLog("Check axes.");

                        m_iStep++;
                        return false;
                    }

                case 11:
                    {//IO 초기화
                        _InitCycle();
                        _SetLog("Init cycle.");

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {//데이터 저장 변수 초기화
                        m_dVelY = CData.Dev.aData[m_iWy].dTpBubSpd;
                        _SetLog("Set position.  Velocity : " + m_dVelY + "mm/s");

                        // 2020.11.05 JSKim St
                        //m_iStep++;
                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running && CData.Dev.bMeasureMode)
                        {
                            m_iStep = 23;
                        }
                        else
                        {
                            m_iStep++;
                        }
                        // 2020.11.05 JSKim Ed

                        return false;
                    }

                case 13:
                    {//Z축 Able 포지션 이동
                        m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy];
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move able.", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 14:
                    {//Z축 Able 포지션 이동 확인, X축 대기 위치 이동
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        m_dPosX = CData.SPos.dGRD_X_Wait[m_iWy];
                        CMot.It.Mv_N(m_iX, m_dPosX);
                        _SetLog("X axis move wait.", m_dPosX);

                        m_iStep++;
                        return false;
                    }
                case 15:
                    {//X축 대기 위치 이동 확인, Y축 클리닝 시작 위치로 이동

                        if (CData.Dev.aData[m_iWy].iTpBubCnt == 0 &&
                            CData.Dev.aData[m_iWy].iTpAirCnt == 0 &&
                            CData.Dev.aData[m_iWy].iTpSpnCnt == 0)
                        {
                            Func_TcDown(false);
                            _SetLog("Top cleaner up.");

                            m_iStep = 24;
                            // 201012 jym : 리턴 빠져있어서 추가
                            return false;
                        }

                        if (!CMot.It.Get_Mv(m_iX, m_dPosX))
                        { return false; }

                        m_dPosY = CData.SPos.dGRD_Y_ClnStart[m_iWy];
                        CMot.It.Mv_N(m_iY, m_dPosY);
                        _SetLog("Y axis move clean start.", m_dPosY);

                        m_iStep++;
                        return false;
                    }

                case 16:
                    {//Y축 시작 위치로 이동 확인, 탑클리너 다운
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }
                        _SetLog("Check Y axis move.");

                        m_iStep++;
                        return false;
                    }

                case 17:
                    {//탑클리너 다운 확인, 워터 나이프 버블 워터 온
                        Func_TcWknife(true);
                        _SetLog("Top cleaner water-knife on.");

                        m_iStep++;
                        return false;
                    }

                case 18:
                    {//== 버블 워터 반복 시작지점 == 워터 나이프 버블 워터 온 확인, 버블 워터 클린 종료 여부 판단, 테이블 이동
                        if (Chk_TcFlow())
                        {
                            if (m_iCnt < CData.Dev.aData[m_iWy].iTpBubCnt)
                            {
                                if (m_iCnt % 2 == 0)
                                { m_dPosY = CData.SPos.dGRD_Y_ClnEnd[m_iWy]; }
                                else
                                { m_dPosY = CData.SPos.dGRD_Y_ClnStart[m_iWy]; }

                                CMot.It.Mv_V(m_iY, m_dPosY, m_dVelY);
                                _SetLog("Y axis move position.  Vel : " + m_dVelY + "mm/s", m_dPosY);

                                m_iStep++;
                            }
                            else
                            {//버블 워터 종료, 테이블 에어나이프 시작 위치 이동, 에어나이프 테이블 속도 설정
                                m_dPosY = CData.SPos.dGRD_Y_ClnStart[m_iWy];
                                CMot.It.Mv_N(m_iY, m_dPosY);
                                _SetLog("Y axis move position.", m_dPosY);

                                m_iCnt = 0;
                                m_iStep = 20;
                            }
                        }

                        return false;
                    }

                case 19:
                    {//테이블 이동 확인, 카운터 증가, 버블 워터 반복 시작 점으로 이동
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { 
                            CMot.It.Mv_V(m_iY, m_dPosY, m_dVelY);
                            return false; 
                        }

                        m_iCnt++;
                        _SetLog("Loop.  Count : " + m_iCnt);

                        m_iStep = 18;
                        return false;
                    }

                case 20:
                    {//테이블 이동 확인, 버블 워터 오프, 에어 온
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        Func_TcWknife(false);
                        Func_TcAknife(true);
                        _SetLog("Top cleaner water-knife off, air-knife on.");

                        m_iStep++;
                        return false;
                    }

                case 21:
                    {//== 에어 나이프 반복 시작 지점 == 버블 워터 오프 확인, 에어 온 확인, 테이블 이동
                        if (!Chk_TcFlow() && Func_TcAknife(true))
                        {
                            if (m_iCnt < CData.Dev.aData[m_iWy].iTpAirCnt)
                            {
                                if (m_iCnt % 2 == 0)
                                { m_dPosY = CData.SPos.dGRD_Y_ClnEnd[m_iWy]; }
                                else
                                { m_dPosY = CData.SPos.dGRD_Y_ClnStart[m_iWy]; }

                                CMot.It.Mv_V(m_iY, m_dPosY, m_dVelY);
                                _SetLog("Y axis move postion.", m_dPosY);

                                m_iStep++;
                            }
                            else
                            {//에어나이프 종료, 에어오프
                                Func_TcAknife(false);
                                _SetLog("Top cleaner air-knife off.");

                                m_iCnt = 0;
                                m_iStep = 23;
                            }
                        }

                        return false;
                    }

                case 22:
                    {//테이블 이동 확인, 카운터 증가,에어나이프 반복 시작 이동
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        m_iCnt++;
                        _SetLog("Loop.  Count : " + m_iCnt);
                        
                        m_iStep = 21;
                        return false;
                    }

                case 23:
                    {//에어 오프 확인, 탑클리너 업
                        if (Func_TcAknife(false))
                        {
                            Func_TcDown(false);
                            _SetLog("Top cleaner up.");

                            m_iStep++;
                        }

                        return false;
                    }

                case 24:
                    {//탑클리너 업 확인, 테이블 대기 위치 이동
                        if (Func_TcDown(false))
                        {
                            m_dPosY = CData.SPos.dGRD_Y_Wait[m_iWy];
                            CMot.It.Mv_N(m_iY, m_dPosY);

                            _SetLog("Y axis move wait.", m_dPosY);

                            // 2020.11.24 JSKim St
                            if (CData.CurCompany == ECompany.JCET && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                            {
                                if (m_eWy == EWay.L)    {   CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_WaitPick; }
                                else                    {   CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_WaitPick; }
                                _SetLog("Finish.  Status : " + CData.Parts[m_iPart].iStat);

                                m_iStep = 0;
                                return true;
                            }
                            // 2020.11.24 JSKim Ed

                            m_iStep++;
                        }

                        return false;
                    }

                case 25:
                    {//테이블 대기 위치 확인
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        if (m_eWy == EWay.L)    { CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_WaitPick; }
                        else                    { CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_WaitPick; }

                        _SetLog("Finish.  Status : " + CData.Parts[m_iPart].iStat);

                        m_iStep = 0;
                        return true;
                    }

                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스
                case 100:
                    {//X축 대기 위치 이동 확인, 버블워터 오프, 에어 오프
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Wait[m_iWy]))
                        {
                            CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Wait[m_iWy]);
                            return false;
                        }

                        Func_TcWknife(false);
                        Func_TcAknife(false);

                        _SetLog("ERROR : Picker Vacuum : TopWaterKnife OFF, TopCleanAir OFF");

                        m_iStep++;
                        return false;
                    }

                case 101:
                    {//버블 워터 오프 확인, 에어 오프 확인, 탑클리너 업,
                        if (Chk_TcFlow() || !Func_TcAknife(false))
                        { return false; }

                        Func_TcDown(false);//탑클리너 업
                        _SetLog("Error : Picker Vacuum : Top Cleaner UP");

                        m_iStep++;
                        return false;
                    }

                case 102:
                    {//탑클리너 업 확인
                        if (!Func_TcDown(false))
                        { return false; }

                        if (m_iPickerVacErr == 1)
                        { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else
                        { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        _SetLog("Picker Vacuum ERROR " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        m_iStep = 0;
                        return true;
                    }
                ///////////////////////////////////////////////////////////////////////////////////
            }
        }
        public bool Cyl_WKnife()
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_WATERKNIFE_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_WATERKNIFE_TIMEOUT); }
                    _SetLog("Error : Timeout.");

                    m_iCnt = 0;
                    m_iStep = 0;
                    return true;
                }
            }

            m_iPreStep = m_iStep;

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if ((CData.CurCompany == ECompany.ASE_KR) &&
                (15 <= m_iStep && m_iStep <= 25))
            {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                if (0 != m_iPickerVacErr)
                {
                    CMot.It.EStop(m_iY); //Table Y축 즉시 Stop

                    _SetLog("ERROR : Picker Vacuum : " + m_siY + " STOP : " + CMot.It.Get_FP(m_iY).ToString());

                    m_iStep = 100; //정리 스텝으로
                    return false;
                }
            }

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10:
                    {//축 상태 체크
                     // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }

                        m_iCnt = 0;
                        _SetLog("Check axes.");

                        m_iStep++;
                        return false;
                    }

                case 11:
                    {//IO 초기화
                        _InitCycle();
                        _SetLog("Init cycle.");

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {
                        // 2020.11.05 JSKim St
                        //m_iStep++;
                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running && CData.Dev.bMeasureMode)
                        {
                            //m_iStep = 23;
                            m_iStep = 26;
                        }
                        else
                        {
                            m_iStep++;
                        }
                        // 2020.11.05 JSKim Ed

                        return false;
                    }

                case 13:
                    {//Z축 Able 포지션 이동
                        m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy];
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move able.", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 14:
                    {//Z축 Able 포지션 이동 확인, X축 대기 위치 이동
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        m_dPosX = CData.SPos.dGRD_X_Wait[m_iWy];
                        CMot.It.Mv_N(m_iX, m_dPosX);
                        _SetLog("X axis move wait.", m_dPosX);

                        m_iStep++;
                        return false;
                    }
                case 15:
                    {//X축 대기 위치 이동 확인, Y축 클리닝 시작 위치로 이동

                        if (CData.Dev.aData[m_iWy].iTpBubCnt == 0 &&
                            CData.Dev.aData[m_iWy].iTpAirCnt == 0 &&
                            CData.Dev.aData[m_iWy].iTpSpnCnt == 0)
                        {
                            Func_TcDown(false);
                            _SetLog("Top cleaner up.");

                            m_iStep = 24;
                            // 201012 jym : 리턴 빠져있어서 추가
                            return false;
                        }

                        if (!CMot.It.Get_Mv(m_iX, m_dPosX))
                        { return false; }

                        m_dPosY = CData.SPos.dGRD_Y_ClnStart[m_iWy];
                        CMot.It.Mv_N(m_iY, m_dPosY);
                        _SetLog("Y axis move clean start.", m_dPosY);

                        m_iStep++;
                        return false;
                    }

                case 16:
                    {//Y축 시작 위치로 이동 확인
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }
                        _SetLog("Check Y axis move.");

                        m_iStep++;
                        return false;
                    }

                case 17:
                    {//Point Water On, Table 속도 설정

                        //New   Cleaner : Side Clean 역할 수행
                        //Nomal Cleaner : Wknife     역할 수행 
                        Func_TcWknife(true);

                        m_dVelY = CData.Dev.aData[m_iWy].dTpSpnSpd;
                        _SetLog("Set position.  Velocity : " + m_dVelY + "mm/s");

                        if (CDataOption.UseNewClenaer)//New Clenaer 사용시 
                        {
                            _SetLog("Top cleaner Point water on.");
                            m_iStep++;
                        }
                        else
                        {
                            _SetLog("Top cleaner water-knife on.");
                            m_iStep = 21;
                        }
                        return false;
                    }

                case 18:
                    {//== Point Clean 반복 시작 지점 ==
                     //Point Water On 확인, 버블 워터 클린 종료 여부 판단, 테이블 이동
                        if (Chk_TcFlow())
                        {
                            if (m_iCnt < CData.Dev.aData[m_iWy].iTpSpnCnt)
                            {
                                if (m_iCnt % 2 == 0)
                                { m_dPosY = CData.SPos.dGRD_Y_ClnEnd[m_iWy]; }
                                else
                                { m_dPosY = CData.SPos.dGRD_Y_ClnStart[m_iWy]; }

                                CMot.It.Mv_V(m_iY, m_dPosY, m_dVelY);
                                _SetLog("Y axis move position.  Vel : " + m_dVelY + "mm/s", m_dPosY);

                                m_iStep++;
                            }
                            else
                            {//Point Clean 종료, 테이블 Wknife 시작 위치 이동,
                                m_dPosY = CData.SPos.dGRD_Y_ClnStart[m_iWy];
                                Func_TcWknife(false);

                                CMot.It.Mv_N(m_iY, m_dPosY);
                                _SetLog("Y axis move position.", m_dPosY);

                                m_iCnt = 0;
                                m_iStep = 20;
                            }
                        }
                        return false;
                    }

                case 19:
                    {//테이블 이동 확인, 카운터 증가, 버블 워터 반복 시작 점으로 이동
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        {
                            CMot.It.Mv_V(m_iY, m_dPosY, m_dVelY);
                            return false;
                        }

                        m_iCnt++;
                        _SetLog("Loop.  Count : " + m_iCnt);

                        m_iStep = 18;
                        return false;
                    }

                case 20:
                    {//테이블 이동 확인
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        Func_TcWater(true); //New Cleaner : WKnife 역할 수행
                        Func_TcWknife(true); //New Clenaer : Point Nozzle

                        _SetLog("Point Water Off, ");

                        m_iStep++;
                        return false;
                    }
                //////////////////////////////////////////////////////////////////////////////////////////////////////

                case 21: //18
                    {//== 버블 워터 반복 시작지점 == 워터 나이프 버블 워터 온 확인, 버블 워터 클린 종료 여부 판단, 테이블 이동
                        if (Chk_TcFlow())
                        {
                            m_dVelY = CData.Dev.aData[m_iWy].dTpBubSpd; //테이블 속도 재설정

                            if (m_iCnt < CData.Dev.aData[m_iWy].iTpBubCnt)
                            {
                                if (m_iCnt % 2 == 0)
                                { m_dPosY = CData.SPos.dGRD_Y_ClnEnd[m_iWy]; }
                                else
                                { m_dPosY = CData.SPos.dGRD_Y_ClnStart[m_iWy]; }

                                CMot.It.Mv_V(m_iY, m_dPosY, m_dVelY);
                                _SetLog("Y axis move position.  Vel : " + m_dVelY + "mm/s", m_dPosY);

                                m_iStep++;
                            }
                            else
                            {//버블 워터 종료, 테이블 에어나이프 시작 위치 이동, 에어나이프 테이블 속도 설정

                                Func_TcWknife(false);
                                Func_TcWater(false);

                                m_dPosY = CData.SPos.dGRD_Y_ClnStart[m_iWy];
                                CMot.It.Mv_N(m_iY, m_dPosY);
                                _SetLog("Y axis move position.", m_dPosY);

                                m_iCnt = 0;
                                m_iStep = 23;
                            }
                        }

                        return false;
                    }

                case 22: //19
                    {//테이블 이동 확인, 카운터 증가, 버블 워터 반복 시작 점으로 이동
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        {
                            CMot.It.Mv_V(m_iY, m_dPosY, m_dVelY);
                            return false;
                        }

                        m_iCnt++;
                        _SetLog("Loop.  Count : " + m_iCnt);

                        m_iStep = 21;
                        return false;
                    }

                case 23: //20
                    {//테이블 이동 확인, 버블 워터 오프, 에어 온
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        Func_TcAknife(true);

                        _SetLog("Top water-knife off, air-knife on.");

                        m_iStep++;
                        return false;
                    }

                case 24: //21
                    {//== 에어 나이프 반복 시작 지점 == 버블 워터 오프 확인, 에어 온 확인, 테이블 이동

                        m_dVelY = CData.Dev.aData[m_iWy].dTpAirSpd; //테이블 속도 재설정

                        if (!Chk_TcFlow() && Func_TcAknife(true))
                        {
                            if (m_iCnt < CData.Dev.aData[m_iWy].iTpAirCnt)
                            {
                                if (m_iCnt % 2 == 0)
                                { m_dPosY = CData.SPos.dGRD_Y_ClnEnd[m_iWy]; }
                                else
                                { m_dPosY = CData.SPos.dGRD_Y_ClnStart[m_iWy]; }

                                CMot.It.Mv_V(m_iY, m_dPosY, m_dVelY);
                                _SetLog("Y axis move postion.", m_dPosY);

                                m_iStep++;
                            }
                            else
                            {//에어나이프 종료, 에어오프
                                Func_TcAknife(false);
                                _SetLog("Top cleaner air-knife off.");

                                m_iCnt = 0;
                                m_iStep = 26;
                            }
                        }

                        return false;
                    }

                case 25: //22
                    {//테이블 이동 확인, 카운터 증가,에어나이프 반복 시작 이동
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        m_iCnt++;
                        _SetLog("Loop.  Count : " + m_iCnt);

                        m_iStep = 24;
                        return false;
                    }

                case 26: //23
                    {//에어 오프 확인, 탑클리너 업
                        if (Func_TcAknife(false))
                        {
                            Func_TcDown(false);
                            _SetLog("Top cleaner up.");

                            m_iStep++;
                        }

                        return false;
                    }

                case 27: //24
                    {//탑클리너 업 확인, 테이블 대기 위치 이동
                        if (Func_TcDown(false))
                        {
                            m_dPosY = CData.SPos.dGRD_Y_Wait[m_iWy];
                            CMot.It.Mv_N(m_iY, m_dPosY);

                            _SetLog("Y axis move wait.", m_dPosY);

                            // 2020.11.24 JSKim St
                            if (CData.CurCompany == ECompany.JCET && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                            {
                                if (m_eWy == EWay.L)    {   CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_WaitPick; }
                                else                    {   CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_WaitPick; }
                                _SetLog("Finish.  Status : " + CData.Parts[m_iPart].iStat);

                                m_iStep = 0;
                                return true;
                            }
                            // 2020.11.24 JSKim Ed

                            m_iStep++;
                        }

                        return false;
                    }

                case 28: //25
                    {//테이블 대기 위치 확인
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        if (m_eWy == EWay.L)    { CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_WaitPick; }
                        else                    { CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_WaitPick; }
                        _SetLog("Finish.  Status : " + CData.Parts[m_iPart].iStat);

                        m_iStep = 0;
                        return true;
                    }

                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스
                case 100:
                    {//X축 대기 위치 이동 확인, 버블워터 오프, 에어 오프
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Wait[m_iWy]))
                        {
                            CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Wait[m_iWy]);
                            return false;
                        }

                        Func_TcWknife(false);
                        Func_TcAknife(false);

                        _SetLog("ERROR : Picker Vacuum : TopWaterKnife OFF, TopCleanAir OFF");

                        m_iStep++;
                        return false;
                    }

                case 101:
                    {//버블 워터 오프 확인, 에어 오프 확인, 탑클리너 업,
                        if (Chk_TcFlow() || !Func_TcAknife(false))
                        { return false; }

                        Func_TcDown(false);//탑클리너 업
                        _SetLog("Error : Picker Vacuum : Top Cleaner UP");

                        m_iStep++;
                        return false;
                    }

                case 102:
                    {//탑클리너 업 확인
                        if (!Func_TcDown(false))
                        { return false; }

                        if (m_iPickerVacErr == 1)
                        { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else
                        { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        _SetLog("Picker Vacuum ERROR " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        m_iStep = 0;
                        return true;
                    }
                    ///////////////////////////////////////////////////////////////////////////////////
            }
        }
        #endregion

        #region 테이블 클리닝
        /// <summary>
        /// 1. 스폰지 이용 하여 테이블 클리닝
        /// 2. wait 포지션 이동
        /// </summary>
        /// <returns></returns>
        public bool Cyl_TblClean()
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_TABLECLEAN_TIMEOUT :
                                                  eErr.RIGHT_GRIND_TABLECLEAN_TIMEOUT);
                    _SetLog("Error : Timeout.");

                    m_iCnt = 0;
                    m_iStep = 0;
                    return true;
                }
            }

            if (Chk_Strip())
            {//자재가 감지 되었을 경우 에러
                CErr.Show((m_eWy == EWay.L) ? eErr.LEFT_GRIND_DETECTED_STRIP :
                                              eErr.RIGHT_GRIND_DETECTED_STRIP);
                _SetLog("Error : Detect strip.");

                m_iStep = 0;
                return true;
            }

            m_iPreStep = m_iStep;

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if ((CData.CurCompany == ECompany.ASE_KR) && 
                (m_iStep == 14 || m_iStep == 15 || m_iStep == 18 || m_iStep == 19 || m_iStep == 20 || m_iStep == 31 || m_iStep == 32))
            {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                if (0 != m_iPickerVacErr)
                {
                    //200807 jhc : 버퍼 모드 동작 정지
                    if (m_iStep == 18 || m_iStep == 19 || m_iStep == 20)
                    {
                        Bf_Stop();
                    }

                    CMot.It.EStop(m_iY); //Table Y축 즉시 Stop

                    _SetLog("ERROR : Picker Vacuum : " + m_siY + " STOP : " + CMot.It.Get_FP(m_iY).ToString());

                    m_iStep = 100; //정리 스텝으로
                    return false;
                }
            }
            //

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10:
                    {//축 상태 체크
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }
                        _SetLog("Check axes.");

                        _SetLog("Clean count : " + CData.Opt.aTC_Cnt[m_iWy] + "  Skip : " + CData.Opt.aTblSkip[m_iWy]);
                        if (CData.Opt.aTC_Cnt[m_iWy] == 0 || CData.Opt.aTblSkip[m_iWy])
                        {   //종료                           
                            m_iStep = 30;
                            return false;
                        }

                        m_iStep++;
                        return false;
                    }

                case 11:
                    {//IO 초기화
                        _InitCycle();
                        _SetLog("Init cycle.");

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {//Z축 Able 포지션 이동
                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                        if (CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("Z axis move able.", CData.SPos.dGRD_Z_Able[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 13:
                    {//Z축 Able 포지션 이동 확인, X축 대기 위치 이동
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Wait[m_iWy]);
                        if (CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Wait[m_iWy]) != 0)
                        {
                            return false;
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("X axis move wait.", CData.SPos.dGRD_X_Wait[m_iWy]);

                        m_iStep++;
                        return false;
                    }
                case 14:
                    {//X축 대기 위치 이동 확인, Y축 클리닝 시작 위치로 이동
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Wait[m_iWy]))
                        { return false; }

                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_ClnStart[m_iWy]);
                        if(CData.CurCompany == ECompany.ASE_KR)
                        {
                            if (CMot.It.Mv_Speed(m_iY, CData.SPos.dGRD_Y_ClnStart[m_iWy], CData.Dev.aTblCleanVel[m_iWy]) != 0) { return false; }
                        }
                        else
                        {
                            if (CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_ClnStart[m_iWy]) != 0) { return false; }
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("Y axis move clean start.", CData.SPos.dGRD_Y_ClnStart[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 15:
                    {//Y축 시작 위치로 이동 확인, 탑클리너 다운
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_ClnStart[m_iWy]))
                        { return false; }

                        ActTcDown(true);
                        _SetLog("Top cleaner down.");

                        m_iStep++;
                        return false;
                    }

                case 16:
                    {//탑클리너 다운 확인, 탑클리너 워터 온, 테이블 워터 온
                        //syc : new cleaner
                        //if (!CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_TopClnDn : eX.GRDR_TopClnDn))
                        if (!Chk_CleanerDn())
                        { return false; }
                        Func_TcWater(true);
                        ActWater(true);
                        //200402 jym : Waterknife, Airknife 추가
                        Func_TcWknife(true);
                        Func_TcAknife(true);
                        _SetLog("Table water on.  Top cleaner water on, Wknife on, Aknife on.");

                        m_iStep++;
                        return false;
                    }

                case 17: //버퍼 시퀀스 구성
                    {                        
                        _Bf_TblClean();
                        _SetLog("Buffer create.");

                        m_iStep++;
                        return false;
                    }

                case 18: //버퍼 시퀀스 시작
                    {
                        _Bf_Start();
                        _SetLog("Buffer start.");

                        m_iStep++;
                        return false;
                    }

                case 19:
                    {//버퍼 완료 확인
                        _Bf_GetStatus();

                        if (m_mBfStat.State == BufferState.Active)
                        {
                            m_iStep++;
                        }
                        else
                        {//테이블 클린 종료, 탑클리너 워터 오프, 테이블 워터 오프
                            Func_TcWater(false);
                            Func_TcWknife(false);
                            Func_TcAknife(false);

                            //200429 jym : 메뉴얼 동작에서 테이블 워터 오프
                            if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                            { ActWater(false); }
                            _SetLog("Buffer end.  Top cleaner water off.");

                            // 2021.07.21 lhs Start : PM Count OffP Sponge Current Count,  루프 종료시 저장, SCK VOC
                            if (CData.CurCompany == ECompany.SCK || CData.CurCompany == ECompany.JSCK || CData.CurCompany == ECompany.ASE_K12)
                            {
                                if (m_iWy == 0)
                                {
                                    CData.tPM.nLT_Sponge_Check_CurrCnt  += CData.Opt.aTC_Cnt[m_iWy];
                                    CData.tPM.nLT_Sponge_Change_CurrCnt += CData.Opt.aTC_Cnt[m_iWy];
                                    _SetLog("Left Table Sponge Current Count : Check Count = "  + CData.tPM.nLT_Sponge_Check_CurrCnt.ToString() +
                                                                            ", Change Count = " + CData.tPM.nLT_Sponge_Change_CurrCnt.ToString());
                                }
                                else
                                {
                                    CData.tPM.nRT_Sponge_Check_CurrCnt  += CData.Opt.aTC_Cnt[m_iWy];
                                    CData.tPM.nRT_Sponge_Change_CurrCnt += CData.Opt.aTC_Cnt[m_iWy];
                                    _SetLog("Right Table Sponge Current Count : Check Count = "  + CData.tPM.nRT_Sponge_Check_CurrCnt.ToString() +
                                                                             ", Change Count = " + CData.tPM.nRT_Sponge_Change_CurrCnt.ToString());
                                }

                                CMnt.It.Save();
                                _SetLog("Maintenance.cfg Save !!!");
                            }
                            // 2021.07.21 lhs End

                            m_iStep = 30;
                        }

                        return false;
                    }

                case 20:
                    {//테이블 이동 확인, 카운터 증가, 버블 워터 반복 시작 점으로 이동
                        m_iStep = 19;
                        return false;
                    }

                case 30:
                    {//탑클리너 워터 오프 확인, 테이블 워터 오프 확인, 탑 클리너 업
                        if (m_eWy == EWay.L)
                        {
                            //200429 jym : 메뉴얼 동작에서 테이블 워터 오프
                            if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                            {
                                if (CIO.It.Get_X(eX.GRDL_TopClnFlow) && CIO.It.Get_X(eX.GRDL_TbFlow))
                                { return false; }
                            }
                            else
                            {
                                if (CIO.It.Get_X(eX.GRDL_TopClnFlow))
                                { return false; }
                            }
                            //syc : new cleaner
                            //CIO.It.Set_Y(eY.GRDL_TopClnDn, false);
                            ActTcDown(false);
                        }
                        else
                        {
                            //200429 jym : 메뉴얼 동작에서 테이블 워터 오프
                            if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                            {
                                if (CIO.It.Get_X(eX.GRDR_TopClnFlow) && CIO.It.Get_X(eX.GRDR_TbFlow))
                                { return false; }
                            }
                            else
                            {
                                if (CIO.It.Get_X(eX.GRDR_TopClnFlow))
                                { return false; }
                            }
                            //syc : new cleaner
                            //CIO.It.Set_Y(eY.GRDR_TopClnDn, false);
                            ActTcDown(false);
                        }
                        _SetLog("Top cleaner up.");

                        m_iStep++;
                        return false;
                    }

                case 31:
                    {//탑클리너 업 확인, 테이블 대기 위치 이동
                         //syc : new cleaner
                         //if (CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_TopClnDn : eX.GRDR_TopClnDn))
                        if (Chk_CleanerDn(false))
                        { return false; }

                        // 2021.04.06 SungTae Start
                        //CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]);
                        if (CData.CurCompany == ECompany.ASE_KR)
                        {
                            if (CMot.It.Mv_Speed(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy], CData.Dev.aTblCleanVel[m_iWy]) != 0) { return false; }
                        }
                        else
                        {
                            if (CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]) != 0) { return false; }
                        }
                        // 2021.04.06 SungTae End

                        _SetLog("Y axis move wait.", CData.SPos.dGRD_Y_Wait[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 32:
                    {//테이블 대기 위치 확인
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]))
                        { return false; }

                        CData.Parts[m_iPart].iStat = (m_eWy == EWay.L) ? ESeq.GRL_Ready : ESeq.GRR_Ready;
                        _SetLog("Finish.  Status : " + CData.Parts[m_iPart].iStat);

                        m_iProcessCnt = 0;      // 2020-11-17, jhLee : 처리 제품수 초기화, Table Clean을 수행하게되면 제품 처리 수량을 초기화해준다.
                        m_iStep = 0;
                        return true;
                    }

                //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
                // 이 하 : Error 발생 시 추가 시퀀스
                case 100:
                    {//탑클리너 워터 오프, 테이블 워터 오프
                        Func_TcWater(false);
                        Func_TcWknife(false);
                        Func_TcAknife(false);

                        //200429 jym : 메뉴얼 동작에서 테이블 워터 오프
                        if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                        { ActWater(false); }

                        _SetLog("ERROR : Picker Vacuum : Water OFF");

                        m_iStep++;
                        return false;
                    }

                case 101:
                    {//탑클리너 워터 오프 확인, 테이블 워터 오프 확인, 탑 클리너 업
                        if (m_eWy == EWay.L)
                        {
                            //200429 jym : 메뉴얼 동작에서 테이블 워터 오프
                            if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                            {
                                if (CIO.It.Get_X(eX.GRDL_TopClnFlow) && CIO.It.Get_X(eX.GRDL_TbFlow))
                                { return false; }
                            }
                            else
                            {
                                if (CIO.It.Get_X(eX.GRDL_TopClnFlow))
                                { return false; }
                            }
                        }
                        else
                        {
                            //200429 jym : 메뉴얼 동작에서 테이블 워터 오프
                            if (!CDataOption.IsTblWater || CSQ_Main.It.m_iStat == EStatus.Manual)
                            {
                                if (CIO.It.Get_X(eX.GRDR_TopClnFlow) && CIO.It.Get_X(eX.GRDR_TbFlow))
                                { return false; }
                            }
                            else
                            {
                                if (CIO.It.Get_X(eX.GRDR_TopClnFlow))
                                { return false; }
                            }
                        }

                        ActTcDown(false); //탑클리너 업

                        _SetLog("ERROR : Picker Vacuum : Top Cleaner UP");

                        m_iStep++;
                        return false;
                    }

                case 102:
                    {//탑클리너 업 확인
                        if (CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_TopClnDn : eX.GRDR_TopClnDn))
                        { return false; }

                        if (m_iPickerVacErr == 1)
                        { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                        else
                        { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }

                        m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                        _SetLog("Picker Vacuum ERROR " + m_siY + " : " + CMot.It.Get_FP(m_iY).ToString());

                        m_iStep = 0;
                        return true;
                    }
                ///////////////////////////////////////////////////////////////////////////////////
            }
        }
        #endregion

        #region Check
        /// <summary>
        /// Grind Part X, Y, Z Axes Check
        /// 그라인딩 파트의 X, Y, Z축 상태 체크
        /// </summary>
        /// <param name="bHD"></param>
        /// <returns></returns>
        public bool Chk_Axes(bool bHD = true)
        {
            int iRet = 0;

            iRet = CMot.It.Chk_Rdy(m_iX, bHD);
            if (iRet != 0)
            {
                if (m_eWy == EWay.L)
                {
                    CErr.Show(eErr.LEFT_GRIND_PROBE_NOT_READY);
                    _SetLog("Error : X axis not ready.");

                    return true;
                }
                else
                {
                    CErr.Show(eErr.RIGHT_GRIND_PROBE_NOT_READY);
                    _SetLog("Error : X axis not ready.");

                    return true;
                }
            }

            iRet = CMot.It.Chk_Rdy(m_iY, bHD);
            if (iRet != 0)
            {
                if (m_eWy == EWay.L)
                {
                    CErr.Show(eErr.LEFT_GRIND_TABLE_NOT_READY);
                    _SetLog("Error : Y axis not ready.");

                    return true;
                }
                else
                {
                    CErr.Show(eErr.RIGHT_GRIND_TABLE_NOT_READY);
                    _SetLog("Error : Y axis not ready.");

                    return true;
                }
            }

            iRet = CMot.It.Chk_Rdy(m_iZ, bHD);
            if (iRet != 0)
            {
                if (m_eWy == EWay.L)
                {
                    CErr.Show(eErr.LEFT_GRIND_ZAXIS_NOT_READY);
                    _SetLog("Error : Z axis not ready.");

                    return true;
                }
                else
                {
                    CErr.Show(eErr.RIGHT_GRIND_ZAXIS_NOT_READY);
                    _SetLog("Error : Z axis not ready.");

                    return true;
                }
            }

            return false;
        }

        public bool Chk_AxesML()
        {
            // X axis
            if (!CMot.It.Chk_Srv(m_iX))
            {
                if (m_eWy == EWay.L)
                {
                    CErr.Show(eErr.LEFT_GRIND_PROBE_NOT_READY);
                    _SetLog("Error : X axis servo off.");

                    return true;
                }
                else
                {
                    CErr.Show(eErr.RIGHT_GRIND_PROBE_NOT_READY);
                    _SetLog("Error : X axis servo off.");

                    return true;
                }
            }

            if (CMot.It.Chk_Alr(m_iX))
            {
                if (m_eWy == EWay.L)
                {
                    CErr.Show(eErr.LEFT_GRIND_X_AXIS_MOTOR_ALRAM);
                    _SetLog("Error : X axis alarm.");

                    return true;
                }
                else
                {
                    CErr.Show(eErr.RIGHT_GRIND_X_AXIS_MOTOR_ALRAM);
                    _SetLog("Error : X axis alarm.");

                    return true;
                }
            }

            // Y axis
            if (!CMot.It.Chk_Srv(m_iY))
            {
                if (m_eWy == EWay.L)
                {
                    CErr.Show(eErr.LEFT_GRIND_TABLE_NOT_READY);
                    _SetLog("Error : Y axis servo off.");

                    return true;
                }
                else
                {
                    CErr.Show(eErr.RIGHT_GRIND_TABLE_NOT_READY);
                    _SetLog("Error : Y axis servo off.");

                    return true;
                }
            }

            if (CMot.It.Chk_Alr(m_iY))
            {
                if (m_eWy == EWay.L)
                {
                    CErr.Show(eErr.LEFT_GRIND_Y_AXIS_MOTOR_ALRAM);
                    _SetLog("Error : Y axis alarm.");

                    return true;
                }
                else
                {
                    CErr.Show(eErr.RIGHT_GRIND_Y_AXIS_MOTOR_ALRAM);
                    _SetLog("Error : Y axis alarm.");

                    return true;
                }
            }

            // Z axis 
            if (!CMot.It.Chk_Srv(m_iZ))
            {
                if (m_eWy == EWay.L)
                {
                    CErr.Show(eErr.LEFT_GRIND_ZAXIS_NOT_READY);
                    _SetLog("Error : Z axis servo off.");

                    return true;
                }
                else
                {
                    CErr.Show(eErr.RIGHT_GRIND_ZAXIS_NOT_READY);
                    _SetLog("Error : Z axis servo off.");

                    return true;
                }
            }

            if (CMot.It.Chk_Alr(m_iZ))
            {
                if (m_eWy == EWay.L)
                {
                    CErr.Show(eErr.LEFT_GRIND_Z_AXIS_MOTOR_ALRAM);
                    _SetLog("Error : Z axis alarm.");

                    return true;
                }
                else
                {
                    CErr.Show(eErr.RIGHT_GRIND_Z_AXIS_MOTOR_ALRAM);
                    _SetLog("Error : Z axis alarm.");

                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// 스핀들 정지 상태 체크
        /// </summary>
        /// <returns></returns>
        public bool Chk_Spl()
        {
            // 200720 jym : Spindle 검사 추가
            //if (CSpl.It.GetFrpm((m_eWy == EWay.L) ? true : false) != 0)
            //{
            //    CSpl.It.Write_Stop(m_eWy);                
            //    return false;
            //}
                       

            if (CSpl_485.It.GetFrpm(m_eWy) != 0)
            {
                // 2023.03.15 Max - Spildle Stop Check
                //CSpl_485.It.Write_Stop(m_eWy);
                return false;
            }

            return true;
        }

        public bool Chk_Vac()
        {
            bool bRet = CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_TbVaccum : eX.GRDR_TbVaccum);
            return bRet;
        }

        /// <summary>
        /// [B] Tool Setter Check
        /// 툴세터 감지 체크 false : 감지, true : 미감지
        /// </summary>
        /// <returns></returns>
        public bool Chk_TSetter()
        {
            if (!CData.VIRTUAL)
            {
                if (m_eWy == EWay.L)
                {
                    return Convert.ToBoolean(CIO.It.Get_X(10, 7));
                }
                else
                {
                    /*
                    if (CDataOption.SplType == eSpindleType.Rs232)
                    { return Convert.ToBoolean(CIO.It.Get_X(85, 7)); }
                    else
                    { return Convert.ToBoolean(CIO.It.Get_X(97, 7)); }
                    */
                    // 2023.03.15 Max
                    return Convert.ToBoolean(CIO.It.Get_X(97, 7));
                }
            }
            else
            { return true; }
        }

        /// <summary>
        /// [B] Wheel Zig Check
        /// 휠 지그 감지 체크 false : 감지, true : 미감지
        /// </summary>
        /// <returns></returns>
        public bool Chk_WhlZig()
        {
            eX eIn;

            if (m_eWy == EWay.L)
            { eIn = eX.X3C; }
            else
            { eIn = eX.X54; }

            return (CIO.It.Get_X(eIn));
        }

        public bool Chk_GrdWater(EWay Way)
        {//200616 pjh : Grinding Water Check
            bool ret = true;

            if(Way == EWay.L)
            {
                if (!CIO.It.Get_X(eX.GRDL_SplWater))
                {
                    eWater = eErr.LEFT_GRIND_SPINDLE_WATER_ERROR;
                    ret = false;
                }
                if (!CIO.It.Get_X(eX.GRDL_SplBtmWater))
                {
                    eWater = eErr.LEFT_GRIND_SPINDLE_BOTTOM_WATER_ERROR;
                    ret = false;
                }
                if (!CIO.It.Get_X(eX.GRDL_SplPCW))
                {
                    eWater = eErr.LEFT_GRIND_SPINDLE_COOLANT_OFF;
                    ret = false;
                }
                if (CDataOption.IsBtmAir == true)
                {
                    if (CDataOption.IsBtmAir && !CIO.It.Get_X(eX.GRDL_SplBtmAir))
                    {
                        eWater = eErr.LEFT_GRIND_SPINDLE_BOTTOM_AIR_ERROR;
                        ret = false;
                    }
                }
            }
            else
            {
                if (!CIO.It.Get_X(eX.GRDR_SplWater))
                {
                    eWater = eErr.RIGHT_GRIND_SPINDLE_WATER_ERROR;
                    ret = false;
                }
                if (!CIO.It.Get_X(eX.GRDR_SplBtmWater))
                {
                    eWater = eErr.RIGHT_GRIND_SPINDLE_BOTTOM_WATER_ERROR;
                    ret = false;
                }
                if (!CIO.It.Get_X(eX.GRDR_SplPCW))
                {
                    eWater = eErr.RIGHT_GRIND_SPINDLE_COOLANT_OFF;
                    ret = false;
                }
                if (CDataOption.IsBtmAir == true)
                {
                    if (CDataOption.IsBtmAir && !CIO.It.Get_X(eX.GRDR_SplBtmAir))
                    {
                        eWater = eErr.RIGHT_GRIND_SPINDLE_BOTTOM_AIR_ERROR;
                        ret = false;
                    }
                }
            }
            return ret;
        }

        public bool Chk_TcFlow()
        {
            if (m_eWy == EWay.L)
            { return CIO.It.Get_X(eX.GRDL_TopClnFlow); }
            else
            { return CIO.It.Get_X(eX.GRDR_TopClnFlow); }
        }

        public bool Chk_PrbUp()
        {
            bool bXPrbUp = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
            bool bYPrbDn = (m_eWy == EWay.L) ? CIO.It.Get_Y(eY.GRDL_ProbeDn) : CIO.It.Get_Y(eY.GRDR_ProbeDn); //프로브 업 센서
            double dVal = CPrb.It.Read_Val(m_eWy); //프로브 값
            if (bXPrbUp && !bYPrbDn && (dVal >= GV.dProbeUpHeight))
            { return true; }
            else
            { return false; }
        }

        public bool Chk_PrbUpAmp()
        {
            bool bXPrbUp = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
            bool bYPrbDn = (m_eWy == EWay.L) ? CIO.It.Get_Y(eY.GRDL_ProbeDn) : CIO.It.Get_Y(eY.GRDR_ProbeDn); //프로브 업 센서
            if (bXPrbUp && !bYPrbDn)
            { return true; }
            else
            { return false; }
        }
        
        //2021.08.06 syc : Up상태일때 Probe 값 정상 범위 인지 확인
        //- Qorvo 프로브 앰프값 자동으로 바뀌는 이슈에 대한 방지책
        //- Probe 값이 18.9xxx ~ 19.0xxx 범위 이탈시 알람
        public bool Chk_ProbeUpVal()
        {
            bool bRet = false;
            double dVal = CPrb.It.Read_Val(m_eWy);
            string slog = "";

            // 2022.04.19 SungTae Start : [수정] Log 상에 불일치로 변경
            if (m_eWy == EWay.L/*EWay.INR*/)    slog = "Left Probe Up Val : ";
            else                                slog = "Right Probe Up Val : ";
            // 2022.04.19 SungTae End

            if (!(18.9000 < dVal && dVal < 19.1000))
            {
                if (m_eWy == EWay.L)
                {
                    CErr.Show(eErr.LEFT_PROBE_AMP_VALUE_WRONG);
                    _SetLog("Error : LEFT_PROBE_AMP_VALUE_WRONG.");
                }
                else
                {
                    CErr.Show(eErr.RIGHT_PROBE_AMP_VALUE_WRONG);
                    _SetLog("Error : RIGHT_PROBE_AMP_VALUE_WRONG.");
                }

                bRet = true;
            }

            _SetLog(slog + dVal);              
            return bRet; 
        }

        #endregion

        private void _InitCycle()
        {
            if (m_eWy == EWay.L)
            {
                CIO.It.Set_Y(eY.GRDL_TopClnDn     , false);
                CIO.It.Set_Y(eY.GRDL_TopClnAir    , false);
                CIO.It.Set_Y(eY.GRDL_TopClnFlow   , false);
                CIO.It.Set_Y(eY.GRDL_TopWaterKnife, false);

                CIO.It.Set_Y(eY.GRDL_ProbeDn ,      false);
                CIO.It.Set_Y(eY.GRDL_ProbeAir,      false);

                CIO.It.Set_Y(eY.GRDL_SplCDA,        true);
                CIO.It.Set_Y(eY.GRDL_SplPCW,        true);

                CIO.It.Set_Y(eY.GRDL_SplWater   ,   false);
                CIO.It.Set_Y(eY.GRDL_SplBtmWater,   false);
                //200515 myk : Wheel Cleaner Water 추가
                if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                { CIO.It.Set_Y(eY.GRDL_WhlCleaner,  false); }
            }
            else
            {
                CIO.It.Set_Y(eY.GRDR_TopClnDn     , false);
                CIO.It.Set_Y(eY.GRDR_TopClnAir    , false);
                CIO.It.Set_Y(eY.GRDR_TopClnFlow   , false);
                CIO.It.Set_Y(eY.GRDR_TopWaterKnife, false);

                CIO.It.Set_Y(eY.GRDR_ProbeDn ,      false);
                CIO.It.Set_Y(eY.GRDR_ProbeAir,      false);

                CIO.It.Set_Y(eY.GRDR_SplCDA,        true);
                CIO.It.Set_Y(eY.GRDR_SplPCW,        true);

                CIO.It.Set_Y(eY.GRDR_SplWater   ,   false);
                CIO.It.Set_Y(eY.GRDR_SplBtmWater,   false);
                //200515 myk : Wheel Cleaner Water 추가
                if (CDataOption.IsWhlCleaner && !CData.Opt.bWhlClnSkip)
                { CIO.It.Set_Y(eY.GRDR_WhlCleaner,  false); }
            }
        }

        public int Chk_IO()
        {//해당 함수 사용 하는 곳이 없네요. 확인 후 삭제 할게요.
            //20190227 ghk_err
            //int iRet = (int)eErr.NONE;
            int iRet = 0;

            // 1. 툴세터 센서 체크 (항시 온 정상)
            if (Chk_TSetter() == false)
            {
                if (m_eWy == EWay.L)
                { return 1; }
                else
                { return 1; }

            }

            _SetLog("Tool setter check ok");

            // 2. 프로브 상승 명령
            CIO.It.Set_Y(eY.GRDL_ProbeDn, false);
            CIO.It.Set_Y(eY.GRDR_ProbeDn, false);
            _SetLog("Probe down check ok");

            // 3. 휠 지그 체크
            if (Chk_WhlZig() == false)
            {
                if (m_eWy == EWay.L)
                { return 1; }
                else
                { return 1; }
            }

            _SetLog("Wheel zig check ok");

            // 4. 탑 클리너 상승 명령
            CIO.It.Set_Y(eY.GRDL_TopClnDn, false);
            CIO.It.Set_Y(eY.GRDR_TopClnDn, false);

            return iRet;
        }

        /// <summary>
        /// 테이블 위에 자재 유무 확인
        /// </summary>
        /// <returns></returns>
        public bool Chk_Strip()
        {
            bool bval = false;
            //210826 syc : 2004U는 기존 테이블과 Vac이 다름 -> 케리어와 유닛이 서로 다른 아웃풋
            //return CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_TbVaccum : eX.GRDR_TbVaccum);
            if (CDataOption.Use2004U == true)
            {
                if (m_eWy == EWay.L)
                {
                    bval = CIO.It.Get_X(eX.GRDL_Carrier_Vacuum_4U) 
                        && CIO.It.Get_X(eX.GRDL_Unit_Vacuum_4U);
                    return bval;
                }
                else
                {
                    bval = CIO.It.Get_X(eX.GRDR_Carrier_Vacuum_4U)
                        && CIO.It.Get_X(eX.GRDR_Unit_Vacuum_4U);
                    return bval;
                }
            }
            else
            {
                return CIO.It.Get_X((m_eWy == EWay.L) ? eX.GRDL_TbVaccum : eX.GRDR_TbVaccum);
            }
            //210826 syc : 2004U end
        }


        // 2021-05-28, jhLee, SPIL SG-2001U/2003U 설비에서 오류발생, Logic부분을 수정하였다.
        //  Carrier 유무만 Check 하는 루틴 추가, Dressing 할떄는 굳이 각 Unit 의 유무는 불필요한다.
        //
        /// <summary>
        /// 테이블 위에 유닛 유무 확인
        /// </summary>
        /// <returns></returns>
        public bool Chk_Unit(bool bOnlyCarrier=false)
        {
            bool bRet = false;                      // 제품이 없다고 가정

            if (m_eWy == EWay.L)
            {//테이블 왼쪽
                bRet = CIO.It.Get_X(eX.GRDL_TbVaccum);          // Carrier유무

                if (bOnlyCarrier) return bRet;                  // Carrier 유무만을 Check하는 경우

                // Carrier가 있다면 각 Unit별로 제품이 있는지 Check한다.
                if (bRet == true)
                {
                    if (CData.Dev.iUnitCnt == 4)            // Unit이 4개짜리라면
                    {
                        // 각 위치의 Unit이 있다고 지정되어있다면 각 Unit의 Vaccum을 확인한다.
                        // 이 중에 한 곳이라도 제품이 있는데, 진공이 잡히지 않았다면, 제품은 없는것이다.
                        if (CData.GrData[m_iWy].aUnitEx[0] == true) bRet = bRet && CIO.It.Get_X(eX.GRDL_Unit_1_Vacuum);
                        if (CData.GrData[m_iWy].aUnitEx[1] == true) bRet = bRet && CIO.It.Get_X(eX.GRDL_Unit_2_Vacuum);
                        if (CData.GrData[m_iWy].aUnitEx[2] == true) bRet = bRet && CIO.It.Get_X(eX.GRDL_Unit_3_Vacuum);
                        if (CData.GrData[m_iWy].aUnitEx[3] == true) bRet = bRet && CIO.It.Get_X(eX.GRDL_Unit_4_Vacuum);

                        // Old 
                        //bRet = CIO.It.Get_X(eX.GRDL_Unit_1_Vacuum) == CData.GrData[m_iWy].aUnitEx[0];
                        //bRet = CIO.It.Get_X(eX.GRDL_Unit_2_Vacuum) == CData.GrData[m_iWy].aUnitEx[1];
                        //bRet = CIO.It.Get_X(eX.GRDL_Unit_3_Vacuum) == CData.GrData[m_iWy].aUnitEx[2];
                        //bRet = CIO.It.Get_X(eX.GRDL_Unit_4_Vacuum) == CData.GrData[m_iWy].aUnitEx[3];
                    }
                    else
                    {
                        // 2개의 Unit이 존재하는 경우,
                        // 2개씩 1개의 Unit를 감지한다.

                        if (CData.GrData[m_iWy].aUnitEx[0] == true)
                        { 
                            bRet = bRet && CIO.It.Get_X(eX.GRDL_Unit_1_Vacuum) && CIO.It.Get_X(eX.GRDL_Unit_2_Vacuum);
                        }


                        if (CData.GrData[m_iWy].aUnitEx[1] == true)
                        {
                            bRet = bRet && CIO.It.Get_X(eX.GRDL_Unit_3_Vacuum) && CIO.It.Get_X(eX.GRDL_Unit_4_Vacuum);
                        }

                        // old
                        //bool b1 = CIO.It.Get_X(eX.GRDL_Unit_1_Vacuum) == CData.GrData[m_iWy].aUnitEx[0];
                        //bool b2 = CIO.It.Get_X(eX.GRDL_Unit_2_Vacuum) == CData.GrData[m_iWy].aUnitEx[0];
                        //bool b3 = CIO.It.Get_X(eX.GRDL_Unit_3_Vacuum) == CData.GrData[m_iWy].aUnitEx[1];
                        //bool b4 = CIO.It.Get_X(eX.GRDL_Unit_4_Vacuum) == CData.GrData[m_iWy].aUnitEx[1];
                        //bRet = b1 == b2;
                        //bRet = b3 == b4;
                    }
                }
            }
            else
            {//테이블 오른쪽
                bRet = CIO.It.Get_X(eX.GRDR_TbVaccum);

                if (bOnlyCarrier) return bRet;                  // Carrier 유무만을 Check하는 경우

                if (CData.Dev.iUnitCnt == 4)
                {
                    if (CData.GrData[m_iWy].aUnitEx[0] == true) bRet = bRet && CIO.It.Get_X(eX.GRDR_Unit_1_Vacuum);
                    if (CData.GrData[m_iWy].aUnitEx[1] == true) bRet = bRet && CIO.It.Get_X(eX.GRDR_Unit_2_Vacuum);
                    if (CData.GrData[m_iWy].aUnitEx[2] == true) bRet = bRet && CIO.It.Get_X(eX.GRDR_Unit_3_Vacuum);
                    if (CData.GrData[m_iWy].aUnitEx[3] == true) bRet = bRet && CIO.It.Get_X(eX.GRDR_Unit_4_Vacuum);

                    //bRet = CIO.It.Get_X(eX.GRDR_Unit_1_Vacuum) == CData.GrData[m_iWy].aUnitEx[0];
                    //bRet = CIO.It.Get_X(eX.GRDR_Unit_2_Vacuum) == CData.GrData[m_iWy].aUnitEx[1];
                    //bRet = CIO.It.Get_X(eX.GRDR_Unit_3_Vacuum) == CData.GrData[m_iWy].aUnitEx[2];
                    //bRet = CIO.It.Get_X(eX.GRDR_Unit_4_Vacuum) == CData.GrData[m_iWy].aUnitEx[3];
                }
                else
                {
                    if (CData.GrData[m_iWy].aUnitEx[0] == true)
                    {
                        bRet = bRet && CIO.It.Get_X(eX.GRDR_Unit_1_Vacuum) && CIO.It.Get_X(eX.GRDR_Unit_2_Vacuum);
                    }


                    if (CData.GrData[m_iWy].aUnitEx[1] == true)
                    {
                        bRet = bRet && CIO.It.Get_X(eX.GRDR_Unit_3_Vacuum) && CIO.It.Get_X(eX.GRDR_Unit_4_Vacuum);
                    }

                    //bool b1 = CIO.It.Get_X(eX.GRDR_Unit_1_Vacuum) == CData.GrData[m_iWy].aUnitEx[0];
                    //bool b2 = CIO.It.Get_X(eX.GRDR_Unit_2_Vacuum) == CData.GrData[m_iWy].aUnitEx[0];
                    //bool b3 = CIO.It.Get_X(eX.GRDR_Unit_3_Vacuum) == CData.GrData[m_iWy].aUnitEx[1];
                    //bool b4 = CIO.It.Get_X(eX.GRDR_Unit_4_Vacuum) == CData.GrData[m_iWy].aUnitEx[1];
                    //bRet = b1 == b2;
                    //bRet = b3 == b4;
                }
            }

            return bRet;
        }

        public int SafePrb(bool bUp = true)
        {
            int iRet = 0;

            // 1. 프로브 업 체크
            if (bUp == true)
            {
#if true //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                bool   bProbeUp  = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값
                if ((!bProbeUp) || (dProbeVal < GV.dProbeUpHeight))
                { return -1; }
#else
                eY eOt;
                if (m_eWy == EWay.L)
                { eOt = eY.GRDL_ProbeDn; }
                else
                { eOt = eY.GRDR_ProbeDn; }

                if (CIO.It.Get_Y(eOt))
                { return -1; }    //josh 이해안가는부분
#endif
                //GU.Delay(100);
            }

            return iRet;
        }

        public int SafeTbl(bool bTc = true, bool bZ = true, bool bPrb = true)
        {
            int iRet = 0;
            

            // 1. 온 피커, 오프 피커가 테이블 위에 위치 했을 때 Z축 확인
            //josh 확인필요

            // 2. 탑 클리너 상승 인지 (탑클리너 사용 시 상태 확인 안함)
            if (bTc == true)
            {
                eX eIn = (m_eWy == EWay.L) ? eX.GRDL_TopClnDn : eX.GRDR_TopClnDn; //syc : new cleaner 삭제예정

                //syc : new cleaner
                //if (CIO.It.Get_X(eIn))
                if (Chk_CleanerDn(false))
                { return -1; }
                //GU.Delay(100);
            }

            // 3. Z축이 허용위치보다 높은지
            if (bZ == true)
            {//josh

            }

            // 4. 프로브가 업이며, 대기위치 인지
            if (bPrb == true)
            {
                // 4-1 프로브 업
                eY eOt = (m_eWy == EWay.L) ? eY.GRDL_ProbeDn : eY.GRDR_ProbeDn;
                CIO.It.Set_Y(eOt, false);
            }

            return iRet;
        }

        public int SafeZ(bool bPrb = true)
        {
            int iRet = 0;

            // 1. 프로브 대기위치 인지, 프로브 업
            if (bPrb == true)
            {
                eY eOt = (m_eWy == EWay.L) ? eY.GRDL_ProbeDn : eY.GRDR_ProbeDn;

                if (CIO.It.Get_Y(eOt))
                { return -1; }
            }

            return iRet;
        }
        /// <summary>
        /// Log 구조체 초기화
        /// </summary>
        //190218 ksg :
        public void LogclearVal()
        {
            m_LogVal.iStep  =  0; 
            m_LogVal.sAsix1 = "";
            m_LogVal.dPos1  = -1;
            m_LogVal.sAsix2 = "";
            m_LogVal.dPos2  = -1;
            m_LogVal.sMsg   = "";    
        }

        #region Grinding 부분 시퀸스 로고
        public void SeqLog()
        {
            string sLine;
            string sStep, sPos1,sPos2;

            sStep = m_LogVal.iStep.ToString();
            
            sPos1 = m_LogVal.dPos1.ToString();
            sPos2 = m_LogVal.dPos2.ToString();

            if (m_eWy == EWay.L) { sLine = "[L]" ; }
            else { sLine = "[R]"; }
            sLine += "[" + m_LogVal.sStatus + ":" + m_LogVal.sMsg + ":" + m_iStep.ToString() + ":" + m_iGStep.ToString() + ":" + CData.iErrNo+"]";
            
            //sLine += []
            sLine += "[" + m_LogVal.sAsix1 + "," + sPos1 + "]";
            sLine += "[" + m_LogVal.sAsix2 + "," + sPos2 + "]";
            //프로브 값
            sLine += "[" + CPrb.It.GetBufValProbe((int)EWay.L).ToString() + "," + CPrb.It.GetBufValProbe((int)EWay.R).ToString() + "]";
            //스핀들
            sLine += "[" + CData.Spls[0].iRpm.ToString() + "," + CData.Spls[0].dLoad.ToString() + "," + CData.Spls[1].iRpm.ToString() + "," + CData.Spls[1].dLoad.ToString() + "]";

            CLog.mLogGnd(sLine);
        }
        #endregion
        /// <summary>
        /// Log 저장 함수
        /// </summary>
        //190218 ksg :
        public void SaveLog()
        {
            string sLine;
            string sDir, sPath, sDay, sHour, sStep,  sPos1, sPos2;

            DateTime Now  = DateTime.Now;

            sDir = GV.PATH_LOG+ Now.Year .ToString("0000") + "\\" + Now.Month.ToString("00") + "\\" + Now.Day  .ToString("00") + "\\GRD\\";

            if (!Directory.Exists(sDir.ToString()))
            {
                Directory.CreateDirectory(sDir.ToString());
            }

            sDay   = DateTime.Now.ToString("[yyyyMMdd-HHmmss fff]");
            sHour  = DateTime.Now.ToString("yyyyMMddHH"           );
            sStep  = m_LogVal.iStep .ToString();
            sPos1  = m_LogVal.dPos1 .ToString();
            sPos2  = m_LogVal.dPos2 .ToString();
         
            sLine = sDay             + "\t";
            sLine += m_LogVal.sStatus + "\t";
            sLine += sStep            + "\t";
            sLine += m_LogVal.sAsix1  + "\t";
            sLine += sPos1            + "\t";
            sLine += m_LogVal.sAsix2  + "\t";
            sLine += sPos2            + "\t";

            sLine += m_LogVal.sMsg;
            
            if(m_eWy == EWay.L)
            {
                sPath = sDir + "LEFT";
            }
            else
            {
                sPath = sDir + "RIGHT";
            }
            
            CLogManager Log = new CLogManager(sPath, null, null);
            Log.WriteLine(sLine);   

            LogclearVal();
        }

        public void SaveLog_Encode(int GStep, int iStep)
        {            
            string sLine = "";
            string sDir, sPath, sDay, sHour, sStep, sPos1, sPos2;

            DateTime Now  = DateTime.Now;

            sDir = GV.PATH_LOG+ Now.Year .ToString("0000") + "\\" + Now.Month.ToString("00") + "\\" + Now.Day  .ToString("00") + "\\ Encode \\";

            if (!Directory.Exists(sDir.ToString()))
            {
                Directory.CreateDirectory(sDir.ToString());
            }

            sPath = sDir;

            sDay   = DateTime.Now.ToString("[yyyyMMdd-HHmmss fff]");
            sHour  = DateTime.Now.ToString("yyyyMMddHH"           );
            sStep  = m_LogVal.iStep .ToString();
            sPos1  = m_LogVal.dPos1 .ToString();
            sPos2  = m_LogVal.dPos2 .ToString();

            //sLine  = sDay             + "\t";
            //sLine += m_LogVal.sStatus + "\t";
            sLine  = sDay             ;
            sLine += m_LogVal.sStatus ;
            sLine += "[" + GStep.ToString() +", "+iStep.ToString()+ "][";
            //모터 엔코더
            for(int i = CMot.It.AxS; i < CMot.It.AxL+1; i++)
            {
                sLine += Convert.ToString(CMot.It.GetBufEnc(i))+",";
            }
            //프로브 값
            sLine += CPrb.It.GetBufValProbe((int)EWay.L).ToString() + "," + CPrb.It.GetBufValProbe((int)EWay.R).ToString() + ",";
            //스핀들
            sLine += CData.Spls[0].iRpm.ToString() + "," + CData.Spls[0].dLoad.ToString() + "," + CData.Spls[1].iRpm.ToString() + "," + CData.Spls[1].dLoad.ToString()+ "]";
            
            CLogManager Log = new CLogManager(sPath, null, null);
            Log.WriteLine(sLine);   

            LogclearVal();
            m_SaveDelay.Set_Delay(50);            
        }

        public bool Cyl_ProbeTest()
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_PROBETEST_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_PROBETEST_TIMEOUT); }
                    _SetLog("Error : Timeout.");
                    m_iProbeTestCnt = 0;
                    m_bProbeTestDir = false;

                    m_iStep = 0;
                    return true;
                }
            }

            m_iPreStep = m_iStep;

            switch (m_iStep)
            {
                default:
                    {
                        m_iProbeTestCnt = 0;
                        m_bProbeTestDir = false;
						
                        m_iStep = 0;
                        return true;
                    }

                case 10:
                    {// 축 상태 체크 및 데이터 저장 배열 초기화(999)
                        for (int i = 0; i < 10; i++)
                        {
                            CData.ProbeTest[m_iWy].dBase[i] = 999;
                            CData.ProbeTest[m_iWy].dCenter[i] = 999;
                            CData.ProbeTest[m_iWy].dBlock[i] = 999;
                        }
                        m_iProbeTestCnt = 0;
                        m_bProbeTestDir = false;

                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }

                        _SetLog("Check axes.");

                        m_iStep++; 
                        return false;
                    }

                case 11:
                    {// IO 초기화
                        _InitCycle();
                        _SetLog("Init cycle.");

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {// 테이블 안전상태 체크
                        SafeTbl(true, true, false);
                        _SetLog("Check table safe.");

                        m_iStep++;
                        return false;
                    }

                case 13:
                    {// Z축 ABLE 위치 이동
                        CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                        _SetLog("Z axis move able.", CData.SPos.dGRD_Z_Able[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 14:
                    {//프로브 업
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }

                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_ProbeDn;
                            m_eOt2 = eY.GRDL_ProbeAir;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_ProbeDn;
                            m_eOt2 = eY.GRDR_ProbeAir;
                        }

                        CIO.It.Set_Y(m_eOt1, false);

                        _SetLog("Probe up.");

                        m_iStep++;
                        return false;
                    }

                case 15:
                    {//프로브 업 확인 후 프로브 X축 0으로 이동

                        //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        //if (!CIO.It.Get_Y(m_eOt1))
                        bool   bProbeUp  = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값
                        if (bProbeUp && (dProbeVal >= GV.dProbeUpHeight))
                        {
                            CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
                            _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

                            m_iStep++;
                        }

                        return false;
                    }

                case 16:
                    {//프로브 X축 0으로 이동 확인 후 테이블 측정 위치로 이동 == 반복 시작 점 ==
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }

                        if (m_bProbeTestDir == false)
                        {// 상단 측정 위치
                            m_dPosY = CData.SPos.dGRD_Y_TblInsp[m_iWy];
                        }
                        else
                        {// 테이블 센터 측정 위치
                            m_dPosY = CData.MPos[m_iWy].dY_PRB_TBL_CENTER;
                        }

                        CMot.It.Mv_N(m_iY, m_dPosY);
                        _SetLog("Y axis move position.", m_dPosY);

                        m_iStep++;
                        return false;
                    }

                case 17:
                    {//테이블 측정 위치로 이동 확인 후 프로브 다운, 프로브 에어 온
                        if (!CMot.It.Get_Mv(m_iY, m_dPosY))
                        { return false; }

                        CIO.It.Set_Y(m_eOt1, true);
                        CIO.It.Set_Y(m_eOt2, true);
                        _SetLog("Probe air on.  Probe down.");

                        m_iStep++;
                        return false;
                    }

                case 18:
                    {//프로브 다운, 프로브 에어 온 확인, Z축 측정 위치로 이동
                        if (CIO.It.Get_Y(m_eOt1) && CIO.It.Get_Y(m_eOt2))
                        {
                            m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS;
                            CMot.It.Mv_N(m_iZ, m_dPosZ);
                            _SetLog("Z axis move position.", m_dPosZ);

                            m_iStep++;
                        }

                        return false;
                    }

                case 19:
                    {//Z축 측정 위치 이동 확인, 프로브 에어 오프
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        CIO.It.Set_Y(m_eOt2, false);
                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        _SetLog("Set delay : " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }

                case 20:
                    {//BASE or CENTER 값 측정
                        if (m_tmPrb.Chk_Delay())
                        {
                            if (m_bProbeTestDir == false)
                            {
                                CData.ProbeTest[m_iWy].dBase[m_iProbeTestCnt] = CPrb.It.Read_Val(m_eWy);
                                _SetLog("Table base : " + CData.ProbeTest[m_iWy].dBase[m_iProbeTestCnt] + "mm  Count : " + m_iProbeTestCnt);
                            }
                            else
                            {
                                CData.ProbeTest[m_iWy].dCenter[m_iProbeTestCnt] = CPrb.It.Read_Val(m_eWy);
                                _SetLog("Table center : " + CData.ProbeTest[m_iWy].dCenter[m_iProbeTestCnt] + "mm  Count : " + m_iProbeTestCnt);
                            }

                            m_iStep++;
                        }

                        return false;
                    }

                case 21:
                    {//테이블 높이 값 확인(999 인지 아닌지 확인), Z축 Able 포지션 이동
                        if (!m_bProbeTestDir && CData.ProbeTest[m_iWy].dBase[m_iProbeTestCnt] == 999)
                        {
                            if (m_eWy == EWay.L)
                            { CErr.Show(eErr.LEFT_GRIND_PROBETEST_FAIL); }
                            else
                            { CErr.Show(eErr.RIGHT_GRIND_PROBETEST_FAIL); }
                            _SetLog("Error : Table base 999.");
                            m_bProbeTestDir = false;
                            m_iProbeTestCnt = 0;

                            m_iStep = 0;
                            return true;
                        }

                        CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]);
                        _SetLog("Z axis move able.", CData.SPos.dGRD_Z_Able[m_iWy]);

                        m_iStep++;
                        return false;
                    }

                case 22:
                    {//Z축 Able 포지션 이동 확인    == 반복 종료 여부 확인 ==
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Able[m_iWy]))
                        { return false; }
                        
                        if (m_bProbeTestDir)
                        { m_iProbeTestCnt++; }

                        if (m_iProbeTestCnt > 9)
                        {
                            _SetLog("Loop end.  Count : " + m_iProbeTestCnt);

                            m_iStep++; 
                        }
                        else
                        {
                            m_bProbeTestDir = !m_bProbeTestDir;
                            CIO.It.Set_Y(m_eOt1, false);
                            _SetLog("Loop.  Probe up.");

                            m_iStep = 15;
                        }

                        return false;
                    }

                case 23:
                    {//프로브 업
                        CIO.It.Set_Y(m_eOt1, false);

                        _SetLog("Probe up.");
                        
                        m_iStep++;
                        return false;
                    }

                case 24:
                    {//측정 종료, 프로브 업 확인

                        //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        //if (CIO.It.Get_Y(m_eOt1))
                        bool   bProbeUp  = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값
                        if (!bProbeUp || (dProbeVal < GV.dProbeUpHeight))
                        { return false; }

                        m_bProbeTestDir = false;
                        m_iProbeTestCnt = 0;

                        _SetLog("Finish.");

                        m_iStep = 0;
                        return true;
                    }
            }
        }

        public bool Cyl_DrsReplace()
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    CErr.Show(eErr.GRIND_DRESSER_REPLACE_TIMEOUT);
                    _SetLog("Error : Timeout.");

                    m_iStep = 0;
                    return true;
                }
            }

            m_iPreStep = m_iStep;

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;
                        return true;
                    }

                case 10:
                    {// 축 상태 체크
                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }
                        _SetLog("Check axes.");

                        m_iStep++; 
                        return false;
                    }

                case 11:
                    {// IO 초기화
                        _InitCycle();
                        _SetLog("Init cycle.");

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {// 테이블 안전상태 체크
                        SafeTbl(true, true, false);
                        _SetLog("Check safe table.");

                        m_iStep++;
                        return false;
                    }

                case 13:
                    {// Z축 대기 위치 이동
                        CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Wait[m_iWy]);
                        _SetLog("Z axsi move wait.", CData.SPos.dGRD_Z_Wait[m_iWy]);

                        m_iStep++;
                        return false;
                    }
                case 14:
                    {// Z축 대기 위치 이동 확인, 프로브 업, 프로브 에어 오프
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Wait[m_iWy]))
                        { return false; }

                        //211227 pjh : Qorvo 요청 사항 : Probe Up 시에만 Ejector 사용
                        if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                        {
                            Func_PrbEjectorOn(true);
                        }
                        Func_PrbDown(false);
                        Func_PrbAir(false);
                        _SetLog("Probe up.  Probe air off.");

                        m_iStep++;
                        return false;
                    }

                case 15:
                    {//프로브 업 확인 후 Y축 드레셔 교체 위치 이동

                        //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
                        //if (!CIO.It.Get_Y(m_eOt1))
                        bool   bProbeUp  = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값
                        if (bProbeUp && (dProbeVal >= GV.dProbeUpHeight))
                        {
                            //211227 pjh : Ejector off
                            if ((CData.CurCompany == ECompany.Qorvo_DZ || CData.CurCompany == ECompany.Qorvo) && CDataOption.IsPrbEjector)
                            {
                                Func_PrbEjectorOn(false);
                            }
                            //

                            CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_DrsChange[m_iWy]);
                            _SetLog("Y axis move dresser change.", CData.SPos.dGRD_Y_DrsChange[m_iWy]);

                            m_iStep++;
                        }

                        return false;
                    }

                case 16:
                    {//Y축 드레셔 교체 위치 이동 확인, 종료
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_DrsChange[m_iWy]))
                        { return false; }

                        _SetLog("Finish.");

                        m_iStep = 0;
                        return true;
                    }
            }
        }

        //20190703 ghk_automeasure
        /// <summary>
        /// 그라인딩 스킵후 자재 측정 후 대기 위치 이동
        /// </summary>
        /// <returns></returns>
        public bool Cyl_AfterMeaStrip()
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            {
                m_mTimeout.Set_Delay(TIMEOUT);
            }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (m_eWy == EWay.L)    {   CErr.Show(eErr.LEFT_GRIND_WAIT_POSITION_TIMEOUT);   }
                    else                    {   CErr.Show(eErr.RIGHT_GRIND_WAIT_POSITION_TIMEOUT);  }

                    m_iStep = 0;
                    return true;
                }
            }

            //20191121 ghk_display_strip
            if (!Chk_Strip())
            {
                if (m_eWy == EWay.L)    { CErr.Show(eErr.LEFT_GRIND_VACUUM_ERROR); }
                else                    { CErr.Show(eErr.RIGHT_GRIND_VACUUM_ERROR); }

                m_iStep = 0;
                return true;
            }
            //

            m_iPreStep = m_iStep;

            if (m_eWy == EWay.L)    m_LogVal.sStatus = "GRL_AfMeaStrip";
            else                    m_LogVal.sStatus = "GRR_AfMeaStrip";

            //200731 jhc : Table Y축 이동 전 On/Off Picker 자재 Vacuum 이상 체크 (ASE-KR VOC #03)
            if ((CData.CurCompany == ECompany.ASE_KR) && 
                (m_iStep == 20 || m_iStep == 21))
            {//Table Y축 대기 위치로 Moving 전 또는 Moving 중
                m_iPickerVacErr = Chk_PickerStripVacOk(m_eWy); //Picker 자재 Vacuum 체크
                if (0 != m_iPickerVacErr)
                {
                    CMot.It.EStop(m_iY); //Table Y축 즉시 Stop

                    if (m_iPickerVacErr == 1)
                    { CErr.Show(eErr.ONLOADERPICKER_VACUUM_ERROR); }
                    else
                    { CErr.Show(eErr.OFFLOADERPICKER_VACUUM_CHECK_ERROR); }                    

                    m_iPickerVacErr = 0; //Picker 자재 Vacuum Error 상태 초기화

                    _SetLog("ERROR : Picker Vacuum : " + m_siY + " STOP : " + CMot.It.Get_FP(m_iY).ToString());

                    m_iStep = 0;
                    return true;
                }
            }
            ///////////////////////////////////////////////////////////////////////////////////////

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;

                        return true;
                    }

                case 10:
                    {// 축 상태 체크
                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }

                        // 200722 jym : 스핀들 정지 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }
                        
                        m_LogVal.iStep = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 11:
                    {// IO 초기화
                        _InitCycle();

                        m_LogVal.iStep = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {// Z축 대기 위치 이동
                        if (CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        { m_dPosZ = CData.SPos.dGRD_Z_Able[m_iWy]; }
                        else
                        { m_dPosZ = CData.SPos.dGRD_Z_Wait[m_iWy]; }
                        CMot.It.Mv_N(m_iZ, m_dPosZ);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sAsix1 = m_siZ;
                        m_LogVal.dPos1 = m_dPosZ;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 13:
                    {// Z축 대기 위치 이동 확인
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        m_LogVal.iStep = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 14:
                    {// 9. 프로브 업
                        if (m_eWy == EWay.L)
                        {
                            m_eIn1 = eX.GRDL_ProbeAMP;
                            m_eOt1 = eY.GRDL_ProbeDn;
                        }
                        else
                        {
                            m_eIn1 = eX.GRDR_ProbeAMP;
                            m_eOt1 = eY.GRDR_ProbeDn;
                        }

                        CIO.It.Set_Y(m_eOt1, false);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sMsg = m_eOt1.ToString();
                        SaveLog();

                        m_iStep++;

                        return false;
                    }

                case 15:
                    {// 10. 프로브 업 체크

                        //20200710    josh    프로브업체크 입력신호&프로브값 같이 비교
                        //if (!CIO.It.Get_X(m_eIn1))
                        dtmp = CPrb.It.Read_Val(m_eWy);
                        if (!CIO.It.Get_X(m_eIn1) || (dtmp < GV.dProbeUpHeight))
                        { return false; }

                        m_LogVal.iStep = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 16:
                    {// 탑클리너 업
                        if (m_eWy == EWay.L)
                        {
                            m_eIn1 = eX.GRDL_TopClnDn;
                            m_eOt1 = eY.GRDL_TopClnDn;
                        }
                        else
                        {
                            m_eIn1 = eX.GRDR_TopClnDn;
                            m_eOt1 = eY.GRDR_TopClnDn;
                        }

                        //syc : new cleaner
                        //CIO.It.Set_Y(m_eOt1, false);
                        ActTcDown(false);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sMsg = m_eOt1.ToString() + "false";
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 17:
                    {//탑클리너 업 체크
                        //syc : new cleaner
                        //if (CIO.It.Get_X(m_eIn1))
                        if (Chk_CleanerDn(false))
                        { return false; }

                        m_LogVal.iStep = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 18:
                    {// 프로브 축 표지션 0으로 위치 이동
                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sAsix1 = m_iX.ToString();
                        m_LogVal.dPos1 = CData.SPos.dGRD_X_Zero[m_iWy];
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 19:
                    {// 프로브 축 포지션 0으로 이동 확인
                        if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
                        { return false; }

                        m_LogVal.iStep = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 20:    // 테이블 축 대기 위치 이동
                    {
                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]);

                        m_LogVal.iStep = m_iStep;
                        m_LogVal.sAsix1 = m_iY.ToString();
                        m_LogVal.dPos1 = CData.SPos.dGRD_Y_Wait[m_iWy];
                        SaveLog();

                        // 2020.11.24 JSKim St
                        if (CData.CurCompany == ECompany.JCET && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
                        {
                            if (m_eWy == EWay.L)    {   CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_WaitPick; }
                            else                    {   CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_WaitPick; }

                            m_iStep = 0;
                            return true;
                        }
                        // 2020.11.24 JSKim Ed

                        m_iStep++;
                        return false;
                    }

                case 21:    // 테이블 축 대기 위치 이동 확인
                    {
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]))
                        { return false; }

                        m_LogVal.iStep = m_iStep;
                        SaveLog();

                        m_iStep++;
                        return false;
                    }

                case 22:    // 종료
                    {
                        if (m_eWy == EWay.L)    { CData.Parts[(int)EPart.GRDL].iStat = ESeq.GRL_WaitPick; }
                        else                    { CData.Parts[(int)EPart.GRDR].iStat = ESeq.GRR_WaitPick; }
                       
                        m_LogVal.iStep = m_iStep;
                        SaveLog();

                        m_iStep = 0;
                        return true;
                    }
            }
        }

        //200810 myk : Probe Calibration Check
        //syc : Probe Calibration Check 수정 - 기존 Table base 이용하여 테이블 컨텍 지점 찾는 방법 -> Z축 0 위치부터 테이블 컨텍 지점 찾는 방법 으로 수정
        /// <summary>
        /// Probe Calibration Check
        /// 프로브 센서 켈리브레이션 후 확인하는 함수
        /// </summary>
        /// <returns></returns>
        public bool Cyl_ProbeCalCheck()
        {
            // Timeout check
            if (m_iGPreStep != m_iGStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay() == true)
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_PROBE_CALIBRATION_CHECK_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_PROBE_CALIBRATION_CHECK_TIMEOUT); }

                    m_iGStep = 0;

                    return true;
                }
            }

            m_iPreStep = m_iGStep;

            if (m_eWy == EWay.L) m_LogVal.sStatus = "GRL_Cyl_ProbeCalCheck";
            else m_LogVal.sStatus = "GRR_Cyl_ProbeCalCheck";

            switch (m_iGStep)
            {
                default:
                    {
                        m_iGStep = 0;
                        return true;
                    }

                case 10: // 축 상태 체크
                    {
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max 
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iGStep = 0;
                            return true;
                        }

                        sProbe = "";
                        bCalCheck = true;

                        _SetLog("Check axes.");
                        m_iGStep++;

                        return false;
                    }

                case 11: // 테이블 안전상태 체크
                    {
                        SafeTbl(true, true, false);
                        _SetLog("SafeTbl(true, true, false)");


                        m_iStep = 10;
                        m_iPreStep = 0;

                        m_iGStep++;
                        return false;
                    }

                case 12: // IO 초기화
                    {
                        _InitCycle();
                        _SetLog("Init cycle.");

                        m_iStep = 10;
                        m_iPreStep = 0;
                        m_iGStep++;

                        return false;
                    }

                case 13: // 프로브와 테이블의 접촉지점 찾기
                    {
                        if (Cyl_ProbeContactTable())
                        {
                            _SetLog("Cyl_ProbeContactTable end");
                            m_iGStep++;
                        }
                        return false;
                    }

                case 14:
                    {
                        m_iGStep++;
                        return false;
                    }

                case 15: //Z축 1mm 다운 및 프로브 딜레이
                    {
                        m_dPosZ = CMot.It.Get_FP(m_iZ) + 1;

                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        _SetLog("Z axis move 1mm Down.  Set delay : " + GV.PRB_DELAY + "ms", m_dPosZ);

                        m_iGStep++;
                        return false;
                    }

                case 16: // Z축 1mm 다운 및 딜레이 확인, 프로브 딜레이 및 프로브 값 획득
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ) || !m_tmPrb.Chk_Delay())
                        { return false; }

                        sProbe += (Math.Round(CPrb.It.Read_Val(m_eWy), 5)).ToString() + "\n";
                        _SetLog("Probe Height : " + (Math.Round(CPrb.It.Read_Val(m_eWy), 5)).ToString());

                        m_iGStep++;
                        return false;
                    }

                case 17: // 프로브 에어 온
                    {
                        CIO.It.Set_Y(m_eOt2, true);
                        _SetLog("Probe Air On.");

                        m_iGStep++;
                        return false;
                    }

                case 18: // 프로브 에어 온 확인, Z축 타겟 위치 + 1mm 다운 
                    {
                        if (!CIO.It.Get_Y(m_eOt2))
                        { return false; }

                        m_dPosZ += 1;
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move 1mm Down.", m_dPosZ);

                        m_iGStep++;
                        return false;

                    }

                case 19: // Z축 타겟 위치 확인, 프로브 에어 오프 및 프로브 딜레이
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        CIO.It.Set_Y(m_eOt2, false);
                        _SetLog("Probe Air Off.  Set delay : " + GV.PRB_DELAY + "ms");

                        m_iGStep++;
                        return false;
                    }

                case 20: // 프로브 에어 오프 및 딜레이 확인, 프로브 값 획득
                    {
                        if (CIO.It.Get_Y(m_eOt2) || !m_tmPrb.Chk_Delay())
                        { return false; }

                        sProbe += (Math.Round(CPrb.It.Read_Val(m_eWy), 5)).ToString() + "\n";
                        _SetLog("Probe Height : " + (Math.Round(CPrb.It.Read_Val(m_eWy), 5)).ToString());

                        m_iGStep++;
                        return false;
                    }

                case 21: // 프로브 에어 온
                    {
                        CIO.It.Set_Y(m_eOt2, true);
                        _SetLog("Probe Air On.");

                        m_iGStep++;
                        return false;
                    }

                case 22: // 프로브 에어 온 확인, Z축 타겟 위치 + 1mm 다운 
                    {
                        if (!CIO.It.Get_Y(m_eOt2))
                        { return false; }

                        m_dPosZ += 1;
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move 1mm Down.", m_dPosZ);

                        m_iGStep++;
                        return false;

                    }

                case 23: // Z축 타겟 위치 확인, 프로브 에어 오프 및 프로브 딜레이
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        CIO.It.Set_Y(m_eOt2, false);
                        _SetLog("Probe Air Off.  Set delay : " + GV.PRB_DELAY + "ms");

                        m_iGStep++;
                        return false;
                    }

                case 24: // 프로브 에어 오프 및 딜레이 확인, 프로브 값 획득
                    {
                        if (CIO.It.Get_Y(m_eOt2) || !m_tmPrb.Chk_Delay())
                        { return false; }

                        sProbe += (Math.Round(CPrb.It.Read_Val(m_eWy), 5)).ToString() + "\n";
                        _SetLog("Probe Height : " + (Math.Round(CPrb.It.Read_Val(m_eWy), 5)).ToString());

                        m_iGStep++;
                        return false;
                    }

                case 25: // 프로브 에어 온
                    {
                        CIO.It.Set_Y(m_eOt2, true);
                        _SetLog("Probe Air On.");

                        m_iGStep++;
                        return false;
                    }

                case 26: // 프로브 에어 온 확인, Z축 타겟 위치 + 1mm 다운 
                    {
                        if (!CIO.It.Get_Y(m_eOt2))
                        { return false; }

                        m_dPosZ += 1;
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move 1mm Down.", m_dPosZ);

                        m_iGStep++;
                        return false;

                    }

                case 27: // Z축 타겟 위치 확인, 프로브 에어 오프 및 프로브 딜레이
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        CIO.It.Set_Y(m_eOt2, false);
                        _SetLog("Probe Air Off.  Set delay : " + GV.PRB_DELAY + "ms");

                        m_iGStep++;
                        return false;
                    }

                case 28: // 프로브 에어 오프 및 딜레이 확인, 프로브 값 획득
                    {
                        if (CIO.It.Get_Y(m_eOt2) || !m_tmPrb.Chk_Delay())
                        { return false; }

                        sProbe += (Math.Round(CPrb.It.Read_Val(m_eWy), 5)).ToString() + "\n";
                        _SetLog("Probe Height : " + (Math.Round(CPrb.It.Read_Val(m_eWy), 5)).ToString());

                        m_iGStep++;
                        return false;
                    }

                case 29: // 프로브 에어 온
                    {
                        CIO.It.Set_Y(m_eOt2, true);
                        _SetLog("Probe Air On.");

                        m_iGStep++;
                        return false;
                    }

                case 30: // 프로브 에어 온 확인, Z축 타겟 위치 + 1mm 다운 
                    {
                        if (!CIO.It.Get_Y(m_eOt2))
                        { return false; }

                        m_dPosZ += 1;
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move 1mm Down.", m_dPosZ);

                        m_iGStep++;
                        return false;

                    }

                case 31: // Z축 타겟 위치 확인, 프로브 에어 오프 및 프로브 딜레이
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        CIO.It.Set_Y(m_eOt2, false);
                        _SetLog("Probe Air Off.  Set delay : " + GV.PRB_DELAY + "ms");

                        m_iGStep++;
                        return false;
                    }

                case 32: // 프로브 에어 오프 및 딜레이 확인, 프로브 값 획득
                    {
                        if (CIO.It.Get_Y(m_eOt2) || !m_tmPrb.Chk_Delay())
                        { return false; }

                        sProbe += (Math.Round(CPrb.It.Read_Val(m_eWy), 5)).ToString() + "\n";
                        _SetLog("Probe Height : " + (Math.Round(CPrb.It.Read_Val(m_eWy), 5)).ToString());

                        m_iGStep++;
                        return false;
                    }

                case 33: // 프로브 에어 온
                    {
                        CIO.It.Set_Y(m_eOt2, true);
                        _SetLog("Probe Air On.");

                        m_iGStep++;
                        return false;
                    }

                case 34: // 프로브 에어 온 확인, Z축 타겟 위치 + 1mm 다운 
                    {
                        if (!CIO.It.Get_Y(m_eOt2))
                        { return false; }

                        m_dPosZ += 1;
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move 1mm Down.", m_dPosZ);

                        m_iGStep++;
                        return false;

                    }

                case 35: // Z축 타겟 위치 확인, 프로브 에어 오프 및 프로브 딜레이
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        CIO.It.Set_Y(m_eOt2, false);
                        _SetLog("Probe Air Off.  Set delay : " + GV.PRB_DELAY + "ms");

                        m_iGStep++;
                        return false;
                    }

                case 36: // 프로브 에어 오프 및 딜레이 확인, 프로브 값 획득
                    {
                        if (CIO.It.Get_Y(m_eOt2) || !m_tmPrb.Chk_Delay())
                        { return false; }

                        sProbe += (Math.Round(CPrb.It.Read_Val(m_eWy), 5)).ToString() + "\n";
                        _SetLog("Probe Height : " + (Math.Round(CPrb.It.Read_Val(m_eWy), 5)).ToString());

                        m_iGStep++;
                        return false;
                    }

                case 37: //프로브 업
                    {
                        CIO.It.Set_Y(m_eOt1, false);
                        _SetLog("Probe Up.");

                        m_iGStep++;
                        return false;
                    }
                case 38: // 프로브 업 확인, Z축 Wait 위치 이동
                    {
                        if (!CIO.It.Get_X(m_eIn1))
                        { return false; }

                        bool bProbeUp = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값

                        if ((!bProbeUp || (dProbeVal < GV.dProbeUpHeight)) && m_Delay.Chk_Delay())
                        {
                            CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET :
                                                               eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                            _SetLog("Error : Probe Up Not Complete");

                            m_iGStep = 0;
                            return true;
                        }

                        CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Wait[m_iWy]);
                        _SetLog("Z axis move Wait Position.", CData.SPos.dGRD_Z_Wait[m_iWy]);

                        m_iGStep++;
                        return false;
                    }

                case 39: // Z축 Wait 위치 이동 확인, 테이블 Wait 위치 이동
                    {
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Wait[m_iWy]))
                        { return false; }

                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]);
                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);//syc : Auto cal para

                        _SetLog("Y axis move Wait Position.", CData.SPos.dGRD_Y_Wait[m_iWy]);

                        m_iGStep++;
                        return false;
                    }

                case 40: // 테이블 Wait 위치 이동 확인
                    {
                        if(!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]) || !CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy])) //syc : Auto cal para
                        { return false; }

                        _SetLog("Probe Calibration Check End");
                        bCalCheck = false;

                        m_iGStep = 0;
                        return true;
                    }
            }
        }

        //200818 myk : Probe Calibration Check
        //syc : Probe Calibration Check 수정 - 기존 Table base 이용하여 테이블 컨텍 지점 찾는 방법 -> Z축 0 위치부터 테이블 컨텍 지점 찾는 방법 으로 수정
        /// <summary>
        /// Probe Auto Calibration
        /// 프로브 센서 자동 Calibration 함수
        /// </summary>
        /// <returns></returns>
        public bool Cyl_AutoCalibration()
        {
            // Timeout check
            if (m_iGPreStep != m_iGStep)
            { m_mTimeout.Set_Delay(TIMEOUT); }
            else
            {
                if (m_mTimeout.Chk_Delay() == true)
                {
                    if (m_eWy == EWay.L)
                    { CErr.Show(eErr.LEFT_GRIND_PROBE_AUTO_CALIBRATION_TIMEOUT); }
                    else
                    { CErr.Show(eErr.RIGHT_GRIND_PROBE_AUTO_CALIBRATION_TIMEOUT); }

                    m_iGStep = 0;
                    m_iStep = 0;

                    return true;
                }
            }

            m_iPreStep = m_iGStep;

            if (m_eWy == EWay.L) m_LogVal.sStatus = "GRL_Cyl_AutoCalibration";
            else m_LogVal.sStatus = "GRR_Cyl_AutoCalibration";

            switch (m_iGStep)
            {
                default:
                    {
                        m_iGStep = 0;
                        m_iStep = 0;
                        return true;
                    }

                case 10: // 축 상태 체크
                    {
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iGStep = 0;
                            return true;
                        }

                        _SetLog("Check axes.");

                        m_iGStep++;
                        return false;
                    }

                case 11: // 테이블 안전상태 체크
                    {
                        SafeTbl(true, true, false);
                        _SetLog("SafeTbl(true, true, false)");

                        m_iGStep++;
                        return false;
                    }

                case 12: // IO 초기화 및 프로브 설정
                    {
                        _InitCycle();
                        _SetLog("Init cycle.");

                        if (m_eWy == EWay.L)
                        {
                            m_eOt1 = eY.GRDL_ProbeDn;
                            m_eOt2 = eY.GRDL_ProbeAir;
                            m_eIn1 = eX.GRDL_ProbeAMP;
                        }
                        else
                        {
                            m_eOt1 = eY.GRDR_ProbeDn;
                            m_eOt2 = eY.GRDR_ProbeAir;
                            m_eIn1 = eX.GRDR_ProbeAMP;
                        }

                        m_iStep = 10;
                        m_iPreStep = 0;
                        m_iGStep++;
                        return false;
                    }

                case 13: //프로브와 테이블의 접촉지점
                    {
                        if (Cyl_ProbeContactTable())
                        {
                            _SetLog("Cyl_ProbeContactTable end");

                            if (m_eWy == EWay.L)
                            {
                                m_eOt1 = eY.GRDL_ProbeDn;
                                m_eOt2 = eY.GRDL_ProbeAir;
                                m_eIn1 = eX.GRDL_ProbeAMP;
                            }
                            else
                            {
                                m_eOt1 = eY.GRDR_ProbeDn;
                                m_eOt2 = eY.GRDR_ProbeAir;
                                m_eIn1 = eX.GRDR_ProbeAMP;
                            }

                            if (CDataOption.Use10PointAutoCal) { m_iGStep = 100; }
                            else { m_iGStep = 14; }
                        }
                        return false;
                    }
                #region 5 point Calibration
                case 14: //프로브 캘리브레이션 기능 활성화
                    {
                        _SetLog("5Point Cal start");

                        if (m_eWy == EWay.L)
                        {
                            CPrb.It.WriteCal(m_eWy, "MASTERSETON");
                            _SetLog("Left Probe Calibration Function activation");
                        }

                        else
                        {
                            CPrb.It.WriteCal(m_eWy, "MASTERSETON");
                            _SetLog("Right Probe Calibration Function activation");
                        }

                        if (m_eWy == EWay.L)
                        {
                            CPrb.It.WriteCal(m_eWy, "CALMASTER+120000+090000+060000+030000+000000");
                        }

                        else
                        {
                            CPrb.It.WriteCal(m_eWy, "CALMASTER+120000+090000+060000+030000+000000");
                        }


                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        _SetLog("Set delay : " + GV.PRB_DELAY + "ms");

                        m_iGStep++;
                        return false;
                    }

                case 15: // 프로브 캘리브레이션 값 획득
                    {
                        if (!m_tmPrb.Chk_Delay())
                        { return false; }

                        if (m_eWy == EWay.L)
                        {
                            CPrb.It.WriteCal(m_eWy, "CALLo");
                            _SetLog("Left Probe Low Value Calibration Setting Complete");
                        }

                        else
                        {
                            CPrb.It.WriteCal(m_eWy, "CALLo");
                            _SetLog("Right Probe Low Value Calibration Setting Complete");
                        }

                        m_iGStep++;
                        return false;
                    }

                case 16: // 프로브 에어 온
                    {
                        CIO.It.Set_Y(m_eOt2, true);
                        _SetLog("Probe Air On.");

                        m_iGStep++;
                        return false;
                    }

                case 17: // 프로브 에어 온 확인, Z축 타겟 위치 + 3mm 다운 
                    {
                        if (!CIO.It.Get_Y(m_eOt2))
                        { return false; }

                        m_dPosZ += 3;
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move 3mm Down.", m_dPosZ);

                        m_iGStep++;
                        return false;
                    }

                case 18: // Z축 타겟 위치 이동 확인, 프로브 에어 오프
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        CIO.It.Set_Y(m_eOt2, false);
                        _SetLog("Probe Air Off.  Set delay : " + GV.PRB_DELAY + "ms");

                        m_iGStep++;
                        return false;
                    }

                case 19: // 프로브 에어 오프 및 딜레이 확인, 프로브 캘리브레이션 값 획득
                    {
                        if (CIO.It.Get_Y(m_eOt2) || !m_tmPrb.Chk_Delay())
                        { return false; }

                        if (m_eWy == EWay.L)
                        {
                            CPrb.It.WriteCal(m_eWy, "CALM3");
                            _SetLog("Left Probe Middle3 Value Calibration Setting Complete");
                        }

                        else
                        {
                            CPrb.It.WriteCal(m_eWy, "CALM3");
                            _SetLog("Right Probe Middle3 Value Calibration Setting Complete");
                        }

                        m_iGStep++;
                        return false;
                    }

                case 20: // 프로브 에어 온
                    {
                        CIO.It.Set_Y(m_eOt2, true);
                        _SetLog("Probe Air On.");

                        m_iGStep++;
                        return false;
                    }

                case 21: // 프로브 에어 온 확인, Z축 타겟 위치 + 3mm 다운 
                    {
                        if (!CIO.It.Get_Y(m_eOt2))
                        { return false; }

                        m_dPosZ += 3;
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move 3mm Down.", m_dPosZ);

                        m_iGStep++;
                        return false;
                    }

                case 22: // Z축 타겟 위치 이동 확인, 프로브 에어 오프
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        CIO.It.Set_Y(m_eOt2, false);
                        _SetLog("Probe Air Off.  Set delay : " + GV.PRB_DELAY + "ms");

                        m_iGStep++;
                        return false;
                    }

                case 23: // 프로브 에어 오프 및 딜레이 확인, 프로브 캘리브레이션 값 획득
                    {
                        if (CIO.It.Get_Y(m_eOt2) || !m_tmPrb.Chk_Delay())
                        { return false; }

                        if (m_eWy == EWay.L)
                        {
                            CPrb.It.WriteCal(m_eWy, "CALM2");
                            _SetLog("Left Probe Middle2 Value Calibration Setting Complete");
                        }

                        else
                        {
                            CPrb.It.WriteCal(m_eWy, "CALM2");
                            _SetLog("Right Probe Middle2 Value Calibration Setting Complete");
                        }

                        m_iGStep++;
                        return false;
                    }

                case 24: // 프로브 에어 온
                    {
                        CIO.It.Set_Y(m_eOt2, true);
                        _SetLog("Probe Air On.");

                        m_iGStep++;
                        return false;
                    }

                case 25: // 프로브 에어 온 확인, Z축 타겟 위치 + 3mm 다운 
                    {
                        if (!CIO.It.Get_Y(m_eOt2))
                        { return false; }

                        m_dPosZ += 3;
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move 3mm Down.", m_dPosZ);

                        m_iGStep++;
                        return false;
                    }

                case 26: // Z축 타겟 위치 이동 확인, 프로브 에어 오프
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        CIO.It.Set_Y(m_eOt2, false);
                        _SetLog("Probe Air Off.  Set delay : " + GV.PRB_DELAY + "ms");

                        m_iGStep++;
                        return false;
                    }

                case 27: // 프로브 에어 오프 및 딜레이 확인, 프로브 캘리브레이션 값 획득
                    {
                        if (CIO.It.Get_Y(m_eOt2) || !m_tmPrb.Chk_Delay())
                        { return false; }

                        if (m_eWy == EWay.L)
                        {
                            CPrb.It.WriteCal(m_eWy, "CALM1");
                            _SetLog("Left Probe Middle1 Value Calibration Setting Complete");
                        }

                        else
                        {
                            CPrb.It.WriteCal(m_eWy, "CALM1");
                            _SetLog("Right Probe Middle1 Value Calibration Setting Complete");
                        }

                        m_iGStep++;
                        return false;
                    }

                case 28: // 프로브 에어 온
                    {
                        CIO.It.Set_Y(m_eOt2, true);
                        _SetLog("Probe Air On.");

                        m_iGStep++;
                        return false;
                    }

                case 29: // 프로브 에어 온 확인, Z축 타겟 위치 + 3mm 다운 
                    {
                        if (!CIO.It.Get_Y(m_eOt2))
                        { return false; }

                        m_dPosZ += 3;
                        CMot.It.Mv_N(m_iZ, m_dPosZ);
                        _SetLog("Z axis move 3mm Down.", m_dPosZ);

                        m_iGStep++;
                        return false;
                    }

                case 30: // Z축 타겟 위치 이동 확인, 프로브 에어 오프
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        { return false; }

                        m_tmPrb.Set_Delay(GV.PRB_DELAY);
                        CIO.It.Set_Y(m_eOt2, false);
                        _SetLog("Probe Air Off.  Set delay : " + GV.PRB_DELAY + "ms");

                        m_iGStep++;
                        return false;
                    }

                case 31: // 프로브 에어 오프 및 딜레이 확인, 프로브 캘리브레이션 값 획득
                    {
                        if (CIO.It.Get_Y(m_eOt2) || !(m_tmPrb.Chk_Delay()))
                        { return false; }

                        if (m_eWy == EWay.L)
                        {
                            CPrb.It.WriteCal(m_eWy, "CALHi");
                            _SetLog("Left Probe High Value Calibration Setting Complete");
                        }

                        else
                        {
                            CPrb.It.WriteCal(m_eWy, "CALHi");
                            _SetLog("Right Probe High Value Calibration Setting Complete");
                        }

                        m_tmPrb.Set_Delay(GV.PRB_DELAY);

                        m_iGStep = 1000; // 종료 지점
                        return false;
                    }
                #endregion

                #region 10 point Calibration
                // 211223 syc : 10point auto cal 
                // 측정 위치 -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5
                case 100: // Master 값 설정
                    {
                        _SetLog("10Point Cal start");
                        CPrb.It.WriteCal(m_eWy, "MASTERSETON"); // Master 설정 On
                        CPrb.It.WriteCal(m_eWy, "CALMASTER+045000+040000+035000+030000+025000+020000+015000+010000+005000+000000"); // 각 Point별 값 Setting

                        _SetLog(m_eWy + "Probe Calibration Function activation");

                        m_iGStep++;
                        return false;
                    }

                // 반복시작 위치-------------------------------------------------                
                case 101: // count 확인 종료 반복 유무 판단
                    {
                        itenpointAutocalCount++; // 반복 count 증가 

                        if (itenpointAutocalCount > 10)
                        {
                            m_iGStep = 1000; // 종료 지점 
                        }
                        else
                        {
                            m_iGStep++; // count 증가
                            _SetLog("Auto Cal Count : " + itenpointAutocalCount);
                        }
                        
                        return false;
                    }

                case 102:  // 각 point 별 명령어 설정
                    {
                        if      (itenpointAutocalCount ==  1) sAutocal = "CALLo";
                        else if (itenpointAutocalCount ==  2) sAutocal = "CALM8";
                        else if (itenpointAutocalCount ==  3) sAutocal = "CALM7";
                        else if (itenpointAutocalCount ==  4) sAutocal = "CALM6";
                        else if (itenpointAutocalCount ==  5) sAutocal = "CALM5";
                        else if (itenpointAutocalCount ==  6) sAutocal = "CALM4";
                        else if (itenpointAutocalCount ==  7) sAutocal = "CALM3";
                        else if (itenpointAutocalCount ==  8) sAutocal = "CALM2";
                        else if (itenpointAutocalCount ==  9) sAutocal = "CALM1";
                        else if (itenpointAutocalCount == 10) sAutocal = "CALHi";
                        else // 예외상황 에러 처리
                        {
                            if (m_eWy == EWay.L) { CErr.Show(eErr.LEFT_GRIND_PROBE_AUTO_CALIBRATION_TIMEOUT); }
                            else { CErr.Show(eErr.RIGHT_GRIND_PROBE_AUTO_CALIBRATION_TIMEOUT); }
                            _SetLog(m_eWy + " Probe calibration point value is wrong");

                            m_iGStep = 0;
                            m_iStep = 0;

                            return true;
                        }
                        _SetLog(m_eWy + " Probe calibration point value setting complete");
                        m_iGStep = 110;
                        return false;
                    }

                case 110: // Probe Air on
                    {
                        if (ActPrbAir(true))
                        {
                            _SetLog("Probe Air On.");
                            m_iGStep++;
                        }
                        return false;
                    }

                case 111: // Z축 0.5mm Down
                    {
                        if (itenpointAutocalCount != 1) // 첫번째 설정 위치는 Probe값 0, 위에서 이미 프로브 값이 0인 위치로 Z축 이동되어있기 때문에 Z축이동 불필요
                        {
                            m_dPosZ = CMot.It.Get_FP(m_iZ) + 0.5; //Z축 위치 설정 : 현재 위치 + 0.5
                            CMot.It.Mv_N(m_iZ, m_dPosZ);          // Z축 이동
                            _SetLog("Z axis move 0.5mm Down.", m_dPosZ);
                        }
                        m_iGStep++;
                        return false;
                    }

                case 112: // Z축 0.5mm Down 확인, Probe Air off
                    {
                        if (itenpointAutocalCount != 1) // Z축 0.5mm Down 확인
                        {
                            if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                            { return false; }
                        }

                        if (ActPrbAir(false) == false) // Probe Air off
                        {
                            _SetLog("Probe Air Off.  Set delay : " + GV.PRB_DELAY + "ms");
                            m_tmPrb.Set_Delay(GV.PRB_DELAY); // 딜레이 설정

                            m_iGStep++; // 다음 스텝 이동
                            return false;
                        }
                        return false;
                    }

                case 113: // 딜레이 확인, Calibration 값 획득
                    {
                        if (!m_tmPrb.Chk_Delay()) { return false; } // 딜레이 확인

                        CPrb.It.WriteCal(m_eWy, sAutocal); // Calibration 값 획득
                        _SetLog(m_eWy + " Probe " + sAutocal + " Value Calibration Setting Complete");

                        m_iGStep = 101;
                        return false;
                    }
                // 반복 종료 위치 ------------------------------------------------------
                #endregion

                #region 종료 지점
                case 1000: // 프로브 다운 딜레이 확인, Z축 Wait 위치 이동
                    {
                        if (!m_tmPrb.Chk_Delay())
                        { return false; }

                        itenpointAutocalCount = 0; // 10 Point Auto Cal Count 초기화

                        CMot.It.Mv_N(m_iZ, CData.SPos.dGRD_Z_Wait[m_iWy]);
                        _SetLog("Z axis move Wait Position.", CData.SPos.dGRD_Z_Wait[m_iWy]);

                        m_iGStep++;
                        return false;
                    }

                case 1001: // Z축 Wait 위치 이동 확인, 프로브 다운 초기화
                    {
                        if (!CMot.It.Get_Mv(m_iZ, CData.SPos.dGRD_Z_Wait[m_iWy]))
                        { return false; }

                        if (CDataOption.Use10PointAutoCal)
                        {
                            CPrb.It.WriteCal(m_eWy, "ZERO");
                            _SetLog(m_eWy + " Probe Down Value reset Complete");
                        }
                        else
                        {
                            if (m_eWy == EWay.L)
                            {
                                CPrb.It.WriteCal(m_eWy, "Z011");
                                _SetLog("Left Probe Down Value reset Complete");
                            }

                            else
                            {
                                CPrb.It.WriteCal(m_eWy, "Z011");
                                _SetLog("Right Probe Down Value reset Complete");
                            }
                        }
                        m_tmPrb.Set_Delay(GV.PRB_DELAY);

                        m_iGStep++;
                        return false;
                    }

                case 1002: // 프로브 다운 딜레이 확인, 프로브 업
                    {
                        if (!m_tmPrb.Chk_Delay())
                        { return false; }

                        CIO.It.Set_Y(m_eOt1, false);
                        _SetLog("Probe Up.");

                        m_iGStep++;
                        return false;
                    }

                case 1003: // 프로브 업 확인, 테이블 Wait 위치 이동
                    {
                        if (!CIO.It.Get_X(m_eIn1))
                        { return false; }

                        bool bProbeUp = (m_eWy == EWay.L) ? CIO.It.Get_X(eX.GRDL_ProbeAMP) : CIO.It.Get_X(eX.GRDR_ProbeAMP); //프로브 업 센서
                        double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값

                        if ((!bProbeUp || (dProbeVal < GV.dProbeUpHeight)) && m_Delay.Chk_Delay())
                        {
                            CErr.Show((m_iWy == (int)EWay.L) ? eErr.LEFT_PROBE_UP_NOT_COMPLET :
                                                               eErr.RIGHT_PROBE_UP_NOT_COMPLET);
                            _SetLog("Error : Probe Up Not Complete");

                            m_iGStep = 0;
                            return true;
                        }

                        CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]);
                        CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);

                        _SetLog("Y axis move Wait Position.", CData.SPos.dGRD_Y_Wait[m_iWy]);
                        _SetLog("X axis move Zero Position.", CData.SPos.dGRD_X_Zero[m_iWy]);//syc : Auto cal para

                        m_iGStep++;
                        return false;
                    }

                case 1004: // 테이블 Wait 위치 이동 확인
                    {
                        if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_Wait[m_iWy]) || !CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))//syc : Auto cal para
                        { return false; }

                        _SetLog("Probe Auto Calibration End");

                        m_iGStep = 0;
                        return true;
                    }
                    #endregion
            }
        }

        //syc : Probe contact table
        /// <summary>
        /// 베이스 set up 이전 Probe와 Table이 만나는 지점, Amp 값 -1 인 지점
        /// Table inspection 포지션은 확인 필요
        /// </summary>
        /// <returns></returns>
        public bool Cyl_ProbeContactTable()
        {
            // Timeout check
            if (m_iPreStep != m_iStep)
            {
                m_mTimeout.Set_Delay(TIMEOUT);
            }
            else
            {
                if (m_mTimeout.Chk_Delay())
                {
                    if (m_eWy == EWay.L)
                    {
                        CErr.Show(eErr.LEFT_GRIND_PROBE_CALIBRATION_TIMEOUT);
                    }
                    else
                    {
                        CErr.Show(eErr.RIGHT_GRIND_PROBE_CALIBRATION_TIMEOUT);
                    }
                    _SetLog("Error : Timeout.");

                    m_iStep = 0;
                    return true;
                }
            }

            m_iPreStep = m_iStep;

            if (SafeTbl(true, true, false) != 0)
            {// 테이블 축 안전상태 체크
                if (m_eWy == EWay.L)
                { CErr.Show(eErr.LEFT_GRIND_TABLE_SAFTY_ERROR); _SetLog("Error : LEFT_GRIND_TABLE_SAFTY_ERROR"); }
                else
                { CErr.Show(eErr.RIGHT_GRIND_TABLE_SAFTY_ERROR); _SetLog("Error : RIGHT_GRIND_TABLE_SAFTY_ERROR"); }


                m_iStep = 0;

                return true;
            }

            if (SafeZ(false) != 0)
            {// Z축 안전상태 체크
                if (m_eWy == EWay.L)
                { CErr.Show(eErr.LEFT_GRIND_ZAXIS_SAFTY_ERROR); }
                else
                { CErr.Show(eErr.RIGHT_GRIND_ZAXIS_SAFTY_ERROR); }

                _SetLog("Error : Z axis sfaty error");

                m_iStep = 0;

                return true;
            }

            switch (m_iStep)
            {
                default:
                    {
                        m_iStep = 0;

                        return true;
                    }

                case 10:
                    {// 축 상태 체크
                        if (!Chk_Spl())
                        {
                            //CSpl.It.Write_Stop(m_eWy);
                            // 2023.03.15 Max 
                            CSpl_485.It.Write_Stop(m_eWy);

                            // 2023.03.15 Max - Spildle Stop Check
                            bool bExit = false;
                            m_mSpl_Chk.Set_Delay(100);
                            do
                            {
                                Application.DoEvents();
                                if (m_mSpl_Chk.Chk_Delay()) { bExit = true; }
                            } while (bExit != true);

                            return false;
                        }

                        if (Chk_Axes())
                        {
                            m_iStep = 0;
                            return true;
                        }
                        else
                        {
                            _SetLog("Check axes.");

                            m_iStep++;
                        }

                        return false;
                    }

                case 11:
                    {// IO 초기화
                        _InitCycle();
                        _SetLog("Init cycle.");

                        m_iStep++;
                        return false;
                    }

                case 12:
                    {// 변수 초기화
                        if (m_eWy == EWay.L)    {   m_eOt1 = eY.GRDL_ProbeDn;   }
                        else                    {   m_eOt1 = eY.GRDR_ProbeDn;   }

                        _SetLog("");

                        m_iStep++;
                        return false;

                    }

                case 13:
                    {// Z축 0 position 이동
                        CMot.It.Mv_N(m_iZ, 0);
                        CIO.It.Set_Y(m_eOt1, false);

                        _SetLog("Z axis move 0 position start");

                        m_iStep++;
                        return false;
                    }

                case 14:
                    {// Z축 0 position 이동 확인
                        if (!CMot.It.Get_Mv(m_iZ, 0))
                        { return false; }

                        _SetLog("Z axis move end");

                        m_iStep++;
                        return false;
                    }

                case 15:
                    {// X축,Y축 0 position 이동
                        CMot.It.Mv_N(m_iX, 0);
                        CMot.It.Mv_N(m_iY, 0);

                        _SetLog("X, Y axis move 0 position start");

                        m_iStep++;
                        return false;
                    }

                case 16:
                    {// X축, Y축 0 position 이동 확인
                        if (!CMot.It.Get_Mv(m_iX, 0) || !CMot.It.Get_Mv(m_iY, 0))
                        { return false; }

                        _SetLog("X, Y axis move end");

                        m_iStep++;
                        return false;
                    }
                case 17:
                    {// Table 설정 Position 이동
                     // Wheel Move Aable Position 이동                        
                        CMot.It.Mv_N(m_iY, CData.Prbs[m_iWy].dY); 
                        CMot.It.Mv_N(m_iZ, 30);
                        CMot.It.Mv_N(m_iX, CData.Prbs[m_iWy].dX); //포지션 설정 추가

                        _SetLog("Y axis move measure table.", CData.Prbs[m_iWy].dY);                        
                        _SetLog("Z axis move 30 position", 30);
                        _SetLog("Z axis move measure table,", CData.Prbs[m_iWy].dX);

                        m_iStep++;
                        return false;
                    }
                case 18:
                    {// Table 설정 Position 이동 확인
                     // Wheel Move Able Position 이동 확인
                        if ((!CMot.It.Get_Mv(m_iY, CData.Prbs[m_iWy].dY)) || (!CMot.It.Get_Mv(m_iZ, 30)) || (!CMot.It.Get_Mv(m_iX, CData.Prbs[m_iWy].dX)))

                        { return false; }

                        _SetLog("move ok");

                        m_iStep++;
                        return false;
                    }

                case 19:
                    {// Probe 다운
                        CIO.It.Set_Y(m_eOt1, true);
                        m_tmPrb.Set_Delay(GV.PRB_DELAY);

                        _SetLog("Probe down. Set delay " + GV.PRB_DELAY + "ms");

                        m_iStep++;
                        return false;
                    }
                case 20:
                    {// Probe 다운 확인
                        if (!CIO.It.Get_Y(m_eOt1) || !m_tmPrb.Chk_Delay()) //Probe OutPut, Delay 확인
                        {
                            return false;
                        }

                        _SetLog("Probe down complete");
                        m_tmPrb.Set_Delay(m_iPbTb_Dly);

                        m_iStep++;
                        return false;
                    }
                case 21: // 테이블 접촉 반복 시작 ~ case :24
                    {// Probe 값 획득 //
                        if (!m_tmPrb.Chk_Delay()) return false;

                        m_dProVal = CPrb.It.Read_Val(m_eWy); //현재값 저장

                        _SetLog("Probe val : " + m_dProVal + "mm");

                        m_iStep++;
                        return false;
                    }
                case 22:
                    {// Probe 값이 Table과 접촉 유무 확인
                     // 종료 확인 지점
                        if (m_dProVal > 0)
                        {
                            _SetLog("probe and table contact");
                            m_tmPrb.Set_Delay(m_iPbTb_Dly);

                            m_iStep = 30; //접촉 확인 후 다음 스텝 이동
                            return false;
                        }
                        m_dPosZ = CMot.It.Get_FP(m_iZ) + 5; // 현재 Z축 +5 저장 // 1~5까지 확인 결과 5사용해도 이상 없음

                        _SetLog("probe and table did not contact");

                        m_iStep++;
                        return false;
                    }
                case 23:
                    {// Z축 5mm 다운
                        CMot.It.Mv_N(m_iZ, m_dPosZ);

                        _SetLog("Z axis 5mm down", m_dPosZ);

                        m_iStep++;
                        return false;
                    }

                case 24: // Z축 5mm 다운 확인 // Probe 값이 Table과 접촉 유무 확인 반복 끝 부분
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }

                        _SetLog("");
                        m_tmPrb.Set_Delay(m_iPbTb_Dly);

                        m_iStep = 21;
                        return false;
                    }
                case 30: //프로브 0지점 맞추기 반복 시작 ~ case 32:
                    {
                        if (!m_tmPrb.Chk_Delay()) return false;

                        m_dProVal = CPrb.It.Read_Val(m_eWy); //현재값 저장

                        if (m_dProVal == -0.9999)
                        {

                            _SetLog("Probe and table contact 0 point");

                            m_iStep = 40;
                            return false;
                        }
                        m_dPosZ = CMot.It.Get_FP(m_iZ);
                        m_dPosZ = m_dPosZ - (m_dProVal + 0.9999);

                        m_iStep++;
                        return false;
                    }
                case 31: //Z축 이동
                    {
                        CMot.It.Mv_N(m_iZ, m_dPosZ);

                        _SetLog("Z axis move position.", m_dPosZ);

                        m_iStep++;
                        return false;
                    }
                case 32: //프로브 0지점 맞추기 반복 끝 부분
                    {
                        if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
                        {
                            CMot.It.Mv_N(m_iZ, m_dPosZ);
                            return false;
                        }
                        m_tmPrb.Set_Delay(m_iPbTb_Dly);

                        _SetLog("");

                        m_iStep = 30;
                        return false;
                    }
                case 40: //종료
                    {
                        _SetLog("Finish. Probe and table contact");

                        m_iStep = 0;
                        return true;
                    }
            }
        }

        #region Active method
        /// <summary>
        /// 테이블 버큠 동작   true:버큠 온 false:버큠 오프
        /// </summary>
        /// <param name="bVal"></param>
        public void ActVacuum(bool bVal)
        {
            //210902 syc : 2004U
            if (CDataOption.Use2004U)
            {
                if (m_eWy == EWay.L)
                {
                    CIO.It.Set_Y(eY.GRDL_Carrier_Vacuum_4U, bVal);
                    CIO.It.Set_Y(eY.GRDL_Unit_Vacuum_4U   , bVal);
                }
                else
                {
                    CIO.It.Set_Y(eY.GRDR_Carrier_Vacuum_4U, bVal);
                    CIO.It.Set_Y(eY.GRDR_Unit_Vacuum_4U   , bVal);
                }
            }
            else
            {
                CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_TbVacuum : eY.GRDR_TbVacuum, bVal);
                if (CDataOption.Package == ePkg.Unit)
                {
                    CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_CarrierVacuum : eY.GRDR_CarrierVacuum, bVal);
                    if (bVal)
                    {
                        if (CData.Dev.iUnitCnt == 4)
                        {
                            CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_1_Vacuum : eY.GRDR_Unit_1_Vacuum, CData.Parts[(int)EPart.GRDL].aUnitEx[0]);
                            CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_2_Vacuum : eY.GRDR_Unit_2_Vacuum, CData.Parts[(int)EPart.GRDL].aUnitEx[1]);
                            CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_3_Vacuum : eY.GRDR_Unit_3_Vacuum, CData.Parts[(int)EPart.GRDL].aUnitEx[2]);
                            CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_4_Vacuum : eY.GRDR_Unit_4_Vacuum, CData.Parts[(int)EPart.GRDL].aUnitEx[3]);
                        }
                        else
                        {
                            CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_1_Vacuum : eY.GRDR_Unit_1_Vacuum, CData.Parts[(int)EPart.GRDL].aUnitEx[0]);
                            CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_2_Vacuum : eY.GRDR_Unit_2_Vacuum, CData.Parts[(int)EPart.GRDL].aUnitEx[0]);
                            CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_3_Vacuum : eY.GRDR_Unit_3_Vacuum, CData.Parts[(int)EPart.GRDL].aUnitEx[1]);
                            CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_4_Vacuum : eY.GRDR_Unit_4_Vacuum, CData.Parts[(int)EPart.GRDL].aUnitEx[1]);
                        }
                    }
                    else
                    {
                        CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_1_Vacuum : eY.GRDR_Unit_1_Vacuum, false);
                        CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_2_Vacuum : eY.GRDR_Unit_2_Vacuum, false);
                        CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_3_Vacuum : eY.GRDR_Unit_3_Vacuum, false);
                        CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_4_Vacuum : eY.GRDR_Unit_4_Vacuum, false);
                    }
                }
            }            
        }

        public bool Func_TblVacuum(bool bOn)
        {
            bool bRet = false;

            bRet = CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_TbVacuum : eY.GRDR_TbVacuum, bOn);
            if (CDataOption.Package == ePkg.Unit)
            {
                CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_CarrierVacuum : eY.GRDR_CarrierVacuum, bOn);
                if (bOn)
                {
                    if (CData.Dev.iUnitCnt == 4)
                    {
                        CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_1_Vacuum : eY.GRDR_Unit_1_Vacuum, CData.Parts[(int)EPart.GRDL].aUnitEx[0]);
                        CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_2_Vacuum : eY.GRDR_Unit_2_Vacuum, CData.Parts[(int)EPart.GRDL].aUnitEx[1]);
                        CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_3_Vacuum : eY.GRDR_Unit_3_Vacuum, CData.Parts[(int)EPart.GRDL].aUnitEx[2]);
                        CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_4_Vacuum : eY.GRDR_Unit_4_Vacuum, CData.Parts[(int)EPart.GRDL].aUnitEx[3]);
                    }
                    else
                    {
                        CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_1_Vacuum : eY.GRDR_Unit_1_Vacuum, CData.Parts[(int)EPart.GRDL].aUnitEx[0]);
                        CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_2_Vacuum : eY.GRDR_Unit_2_Vacuum, CData.Parts[(int)EPart.GRDL].aUnitEx[0]);
                        CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_3_Vacuum : eY.GRDR_Unit_3_Vacuum, CData.Parts[(int)EPart.GRDL].aUnitEx[1]);
                        CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_4_Vacuum : eY.GRDR_Unit_4_Vacuum, CData.Parts[(int)EPart.GRDL].aUnitEx[1]);
                    }
                }
                else
                {
                    CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_1_Vacuum : eY.GRDR_Unit_1_Vacuum, false);
                    CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_2_Vacuum : eY.GRDR_Unit_2_Vacuum, false);
                    CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_3_Vacuum : eY.GRDR_Unit_3_Vacuum, false);
                    CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_Unit_4_Vacuum : eY.GRDR_Unit_4_Vacuum, false);
                }
            }

            return bRet;
        }

        /// <summary>
        /// 테이블 이젝트 동작   true:이젝트 온 false:이젝트 오프
        /// </summary>
        /// <param name="bVal"></param>
        public void ActEject(bool bVal)
        {
            if (m_eWy == EWay.L)
            {
                CIO.It.Set_Y(eY.GRDL_TbEjector, bVal);

                if (CDataOption.Package == ePkg.Unit)
                {
                    CIO.It.Set_Y(eY.GRDL_CarrierVacuum, bVal);
                    CIO.It.Set_Y(eY.GRDL_Unit_1_Vacuum, bVal);
                    CIO.It.Set_Y(eY.GRDL_Unit_2_Vacuum, bVal);
                    CIO.It.Set_Y(eY.GRDL_Unit_3_Vacuum, bVal);
                    CIO.It.Set_Y(eY.GRDL_Unit_4_Vacuum, bVal);
                }
            }
            else
            {
                CIO.It.Set_Y(eY.GRDR_TbEjector, bVal);
                if (CDataOption.Package == ePkg.Unit)
                {
                    CIO.It.Set_Y(eY.GRDR_CarrierVacuum, bVal);
                    CIO.It.Set_Y(eY.GRDR_Unit_1_Vacuum, bVal);
                    CIO.It.Set_Y(eY.GRDR_Unit_2_Vacuum, bVal);
                    CIO.It.Set_Y(eY.GRDR_Unit_3_Vacuum, bVal);
                    CIO.It.Set_Y(eY.GRDR_Unit_4_Vacuum, bVal);
                }
            }
        }

        public bool Func_TblEject(bool bOn)
        {
            bool bRet = false;

            if (m_eWy == EWay.L)
            {
                bRet = CIO.It.Set_Y(eY.GRDL_TbEjector, bOn);
                if (CDataOption.Package == ePkg.Unit)
                {
                    CIO.It.Set_Y(eY.GRDL_CarrierVacuum, bOn);
                    CIO.It.Set_Y(eY.GRDL_Unit_1_Vacuum, bOn);
                    CIO.It.Set_Y(eY.GRDL_Unit_2_Vacuum, bOn);
                    CIO.It.Set_Y(eY.GRDL_Unit_3_Vacuum, bOn);
                    CIO.It.Set_Y(eY.GRDL_Unit_4_Vacuum, bOn);
                }
            }
            else
            {
                bRet = CIO.It.Set_Y(eY.GRDR_TbEjector, bOn);
                if (CDataOption.Package == ePkg.Unit)
                {
                    CIO.It.Set_Y(eY.GRDR_CarrierVacuum, bOn);
                    CIO.It.Set_Y(eY.GRDR_Unit_1_Vacuum, bOn);
                    CIO.It.Set_Y(eY.GRDR_Unit_2_Vacuum, bOn);
                    CIO.It.Set_Y(eY.GRDR_Unit_3_Vacuum, bOn);
                    CIO.It.Set_Y(eY.GRDR_Unit_4_Vacuum, bOn);
                }
            }

            return bRet;
        }

        /// <summary>
        /// 테이블 워터 동작   true:워터 온 false:워터 오프
        /// </summary>
        /// <param name="bVal"></param>
        public void ActWater(bool bVal)
        {
            if (m_eWy == EWay.L)
            {
                CIO.It.Set_Y(eY.GRDL_TbFlow, bVal);
                if (CDataOption.Package == ePkg.Unit)
                {
                    CIO.It.Set_Y(eY.GRDL_CarrierVacuum, bVal);
                    CIO.It.Set_Y(eY.GRDL_Unit_1_Vacuum, bVal);
                    CIO.It.Set_Y(eY.GRDL_Unit_2_Vacuum, bVal);
                    CIO.It.Set_Y(eY.GRDL_Unit_3_Vacuum, bVal);
                    CIO.It.Set_Y(eY.GRDL_Unit_4_Vacuum, bVal);
                }
            }
            else
            {
                CIO.It.Set_Y(eY.GRDR_TbFlow, bVal);
                if (CDataOption.Package == ePkg.Unit)
                {
                    CIO.It.Set_Y(eY.GRDR_CarrierVacuum, bVal);
                    CIO.It.Set_Y(eY.GRDR_Unit_1_Vacuum, bVal);
                    CIO.It.Set_Y(eY.GRDR_Unit_2_Vacuum, bVal);
                    CIO.It.Set_Y(eY.GRDR_Unit_3_Vacuum, bVal);
                    CIO.It.Set_Y(eY.GRDR_Unit_4_Vacuum, bVal);
                }
            }
        }

        public bool Func_TblWater(bool bOn)
        {
            bool bRet = false;

            if (m_eWy == EWay.L)
            {
                bRet = CIO.It.Set_Y(eY.GRDL_TbFlow, bOn);
                if (CDataOption.Package == ePkg.Unit)
                {
                    CIO.It.Set_Y(eY.GRDL_CarrierVacuum, bOn);
                    CIO.It.Set_Y(eY.GRDL_Unit_1_Vacuum, bOn);
                    CIO.It.Set_Y(eY.GRDL_Unit_2_Vacuum, bOn);
                    CIO.It.Set_Y(eY.GRDL_Unit_3_Vacuum, bOn);
                    CIO.It.Set_Y(eY.GRDL_Unit_4_Vacuum, bOn);
                }

                return bRet && (CIO.It.Get_X(eX.GRDL_TbFlow) == bOn);
            }
            else
            {
                bRet = CIO.It.Set_Y(eY.GRDR_TbFlow, bOn);
                if (CDataOption.Package == ePkg.Unit)
                {
                    CIO.It.Set_Y(eY.GRDR_CarrierVacuum, bOn);
                    CIO.It.Set_Y(eY.GRDR_Unit_1_Vacuum, bOn);
                    CIO.It.Set_Y(eY.GRDR_Unit_2_Vacuum, bOn);
                    CIO.It.Set_Y(eY.GRDR_Unit_3_Vacuum, bOn);
                    CIO.It.Set_Y(eY.GRDR_Unit_4_Vacuum, bOn);
                }

                return bRet && (CIO.It.Get_X(eX.GRDR_TbFlow) == bOn);
            }
        }

        /// <summary>
        /// 그라인딩 워터 동작    true:워터 온 false:워터 오프
        /// </summary>
        /// <param name="bOn"></param>
        /// <returns></returns>
        public bool Func_SplWater(bool bOn)
        {
            bool bRet = false;

            if (m_eWy == EWay.L)
            {
                bRet = CIO.It.Set_Y(eY.GRDL_SplWater, bOn);
                bRet = bOn == CIO.It.Get_X(eX.GRDL_SplWater);
            }
            else
            {
                CIO.It.Set_Y(eY.GRDR_SplWater, bOn);
                bRet = bOn == CIO.It.Get_X(eX.GRDR_SplWater);
            }

            return bRet;
        }

        /// <summary>
        /// 그라인딩 바텀 워터 동작    true:워터 온 false:워터 오프
        /// </summary>
        /// <param name="bOn"></param>
        /// <returns></returns>
        public bool Func_BtmWater(bool bOn)
        {
            bool bRet = false;

            if (m_eWy == EWay.L)
            {
                CIO.It.Set_Y(eY.GRDL_SplBtmWater, bOn);
                bRet = bOn == CIO.It.Get_X(eX.GRDL_SplBtmWater);
            }
            else
            {
                CIO.It.Set_Y(eY.GRDR_SplBtmWater, bOn);
                bRet = bOn == CIO.It.Get_X(eX.GRDR_SplBtmWater);
            }

            return bRet;
        }

        /// <summary>
        /// 그라인딩 휠 클리너 워터 동작    true:워터 온 false:워터 오프
        /// </summary>
        /// <param name="bOn"></param>
        /// <returns></returns>
        public bool Func_WhlClnWater(bool bOn)
        {
            bool bRet = false;

            bRet = CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_WhlCleaner : eY.GRDR_WhlCleaner, bOn);

            return bRet;
        }

        /// <summary>
        /// 탑클리너 다운 동작    true:다운 false:업
        /// </summary>
        /// <param name="bVal"></param>
        /// <returns></returns>
        public bool ActTcDown(bool bVal)
        {
            if (!CDataOption.UseNewClenaer)// syc : new cleaner
            {
                bool bRet = false;
                if (m_eWy == EWay.L)
                {
                    CIO.It.Set_Y(eY.GRDL_TopClnDn, bVal);
                    bRet = bVal && CIO.It.Get_X(eX.GRDL_TopClnDn);
                }
                else
                {
                    CIO.It.Set_Y(eY.GRDR_TopClnDn, bVal);
                    bRet = bVal && CIO.It.Get_X(eX.GRDR_TopClnDn);
                }

                return bRet;
            }
            return true;// syc : new cleaner
        }

        public bool Func_TcUp()
        {
            if (!CDataOption.UseNewClenaer)// syc : new cleaner
            {
                bool bRet = false;

                if (m_eWy == EWay.L)
                {
                    CIO.It.Set_Y(eY.GRDL_TopClnDn, false);
                    bRet = !CIO.It.Get_X(eX.GRDL_TopClnDn);
                }
                else
                {
                    CIO.It.Set_Y(eY.GRDR_TopClnDn, false);
                    bRet = !CIO.It.Get_X(eX.GRDR_TopClnDn);
                }

                return bRet;
            }
            return true; //syc : new clenaer
        }

        public bool Func_TcDown()
        {
            if (!CDataOption.UseNewClenaer)// syc : new cleaner
            {
                bool bRet = false;

                if (m_eWy == EWay.L)
                {
                    CIO.It.Set_Y(eY.GRDL_TopClnDn, true);
                    bRet = CIO.It.Get_X(eX.GRDL_TopClnDn);
                }
                else
                {
                    CIO.It.Set_Y(eY.GRDR_TopClnDn, true);
                    bRet = CIO.It.Get_X(eX.GRDR_TopClnDn);
                }

                return bRet;
            }
            return true; //syc : new cleaner
        }

        /// <summary>
        /// 탑클리너 다운 동작    true:다운 false:업
        /// </summary>
        /// <param name="bDn"></param>
        /// <returns></returns>
        public bool Func_TcDown(bool bDn)
        {
            if (!CDataOption.UseNewClenaer)// syc : new cleaner
            {
                bool bRet = false;
                if (m_eWy == EWay.L)
                {
                    CIO.It.Set_Y(eY.GRDL_TopClnDn, bDn);
                    bRet = bDn == CIO.It.Get_X(eX.GRDL_TopClnDn);
                }
                else
                {
                    CIO.It.Set_Y(eY.GRDR_TopClnDn, bDn);
                    bRet = bDn == CIO.It.Get_X(eX.GRDR_TopClnDn);
                }

                return bRet;
            }
            return true; //syc new cleaner
        }

        //syc : new cleaner
        /// <summary>
        /// Cleaner 타입 변경으로 인한 탑클리너 다운 확인 분기
        /// </summary>
        /// <param name="eWy"></param>
        /// <param name="bdown"></param>
        /// <returns></returns>
        public bool Chk_CleanerDn(bool bret = true)// 새로운 클리너 사용시 구문에 따라 Return값 지정할것
        {
            if (CDataOption.UseNewClenaer)
            {
                return bret; //새로운 클리너 사용시 확인 해야함
            }
            else
            {
                if (m_eWy == EWay.L)
                {
                    return CIO.It.Get_X(eX.GRDL_TopClnDn);
                }
                else
                {
                    return CIO.It.Get_X(eX.GRDR_TopClnDn);
                }
            }
        }

        /// <summary>
        /// 탑클리너 워터 동작    true:워터 온 false:워터 오프
        /// </summary>
        /// <param name="bOn"></param>
        /// <returns></returns>
        public bool Func_TcWater(bool bOn)
        {
            bool bRet = false;

            if (m_eWy == EWay.L)
            {
                CIO.It.Set_Y(eY.GRDL_TopClnFlow, bOn);
                bRet = bOn == CIO.It.Get_X(eX.GRDL_TopClnFlow);
            }
            else
            {
                CIO.It.Set_Y(eY.GRDR_TopClnFlow, bOn);
                bRet = bOn == CIO.It.Get_X(eX.GRDR_TopClnFlow);
            }

            return bRet;
        }

        /// <summary>
        /// 탑클리너 워터 나이프 동작    true:워터 온 false:워터 오프
        /// </summary>
        /// <param name="bOn"></param>
        /// <returns></returns>
        public bool Func_TcWknife(bool bOn)
        {
            return CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_TopWaterKnife : eY.GRDR_TopWaterKnife, bOn);
        }

        /// <summary>
        /// 탑클리너 에어 나이프 동작    true:에어 온 false:에어 오프
        /// </summary>
        /// <param name="bOn"></param>
        /// <returns></returns>
        public bool Func_TcAknife(bool bOn)
        {
            return CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_TopClnAir : eY.GRDR_TopClnAir, bOn);
        }

        /// <summary>
        /// 프로브 다운    true:다운 false:업
        /// </summary>
        /// <param name="bVal"></param>
        /// <returns></returns>
        public bool ActPrbDown(bool bVal)
        {
            if (m_eWy == EWay.L)
            {
                CIO.It.Set_Y(eY.GRDL_ProbeDn, bVal);
                return CIO.It.Get_Y(eY.GRDL_ProbeDn);
            }
            else
            {
                CIO.It.Set_Y(eY.GRDR_ProbeDn, bVal);
                return CIO.It.Get_Y(eY.GRDR_ProbeDn);
            }
        }

        public bool Func_PrbUp()
        {
            if (m_eWy == EWay.L)
            {
                CIO.It.Set_Y(eY.GRDL_ProbeDn, false);
                return !CIO.It.Get_Y(eY.GRDL_ProbeDn) && CIO.It.Get_X(eX.GRDL_ProbeAMP);
            }
            else
            {
                CIO.It.Set_Y(eY.GRDR_ProbeDn, false);
                return !CIO.It.Get_Y(eY.GRDR_ProbeDn) && CIO.It.Get_X(eX.GRDR_ProbeAMP);
            }
        }

        public bool Func_PrbDown()
        {
            if (m_eWy == EWay.L)
            {
                CIO.It.Set_Y(eY.GRDL_ProbeDn, true);
                return CIO.It.Get_Y(eY.GRDL_ProbeDn) && !CIO.It.Get_X(eX.GRDL_ProbeAMP);
            }
            else
            {
                CIO.It.Set_Y(eY.GRDR_ProbeDn, true);
                return CIO.It.Get_Y(eY.GRDR_ProbeDn) && !CIO.It.Get_X(eX.GRDR_ProbeAMP);
            }
        }

        /// <summary>
        /// 프로브 다운    true:다운 false:업
        /// </summary>
        /// <param name="bDn"></param>
        /// <returns>동작 완료 시 true</returns>
        public bool Func_PrbDown(bool bDn)
        {
            if (m_eWy == EWay.L)
            {
                CIO.It.Set_Y(eY.GRDL_ProbeDn, bDn);
                return (CIO.It.Get_Y(eY.GRDL_ProbeDn) == bDn) && (!CIO.It.Get_X(eX.GRDL_ProbeAMP) == bDn);
            }
            else
            {
                CIO.It.Set_Y(eY.GRDR_ProbeDn, bDn);
                return (CIO.It.Get_Y(eY.GRDR_ProbeDn) == bDn) && (!CIO.It.Get_X(eX.GRDR_ProbeAMP) == bDn);
            }
        }

        /// <summary>
        /// 프로브 에어    true:에어 온 false:에어 오프
        /// </summary>
        /// <param name="bVal"></param>
        /// <returns></returns>
        public bool ActPrbAir(bool bVal)
        {
            if (m_eWy == EWay.L)
            {
                CIO.It.Set_Y(eY.GRDL_ProbeAir, bVal);
                return CIO.It.Get_Y(eY.GRDL_ProbeAir);
            }
            else
            {
                CIO.It.Set_Y(eY.GRDR_ProbeAir, bVal);
                return CIO.It.Get_Y(eY.GRDR_ProbeAir);
            }
        }

        /// <summary>
        /// 프로브 이젝터 On/Off  true : 이젝터 온 false : 이젝터 오프
        /// </summary>
        /// <param name="bOn"></param>
        /// <returns></returns>
        public bool Func_PrbEjectorOn(bool bOn)
        {
            return CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_ProbeEjector : eY.GRDR_ProbeEjector, bOn);
        }

        public bool Func_PrbAir(bool bOn)
        {
            return CIO.It.Set_Y((m_eWy == EWay.L) ? eY.GRDL_ProbeAir : eY.GRDR_ProbeAir, bOn);
        }
        #endregion

        //190319 ksg :
        public void ProbeClearVal(int iBfAf)
        {
            if(iBfAf == 0)
            {
                CData.PbResultVal[m_iWy].dBMax  = 0;
                CData.PbResultVal[m_iWy].dBMin  = 0;
                CData.PbResultVal[m_iWy].dBAvg  = 0;
                CData.PbResultVal[m_iWy].dBMean = 0;
            }
            else 
            { 
                CData.PbResultVal[m_iWy].dAMax  = 0;
                CData.PbResultVal[m_iWy].dAMin  = 0;
                CData.PbResultVal[m_iWy].dAAvg  = 0;
                CData.PbResultVal[m_iWy].dAMean = 0;
            }
        }

        public void InitReGrd(int iWay)
        {
            for (int iStep = 0; iStep < m_iStepMaxCnt - 1; iStep++)     // 2020.09.08 SungTae : Modify
            {
                if(CDataOption.StepCnt == (int)EStepCnt.DEFAULT_STEP)
                {
                    CData.RedGrdCnt[iWay, iStep].m_lRedCnt = new List<int>();
                }
                else
                {
                    CData.RedGrdCnt3[iWay, iStep].m_lRedCnt = new List<int>();
                }
            }
        }
        //191120 ksg :
        public void InitPbValue(int iWay, int iBfAf)
        {
            if(iBfAf == 0) CData.m_dPbVal[iWay].m_BFVal = new List<double>();
            else           CData.m_dPbVal[iWay].m_AFVal = new List<double>();
        }

        #region Buffer motion
        /// <summary>
        /// 버퍼 시퀀스 시작
        /// </summary>
        private void _Bf_Start()
        { CWmx.It.WLib.basicBuffer.Execute(m_nCh); }

        /// <summary>
        /// 버퍼 시퀀스 중지 및 클리어
        /// </summary>
        public void Bf_Stop()
        {
            CWmx.It.WLib.basicBuffer.AbortAndStop(m_nCh);

            _Bf_Clear();
        }
        /// <summary>
        /// 버퍼 시퀀스 클리어(삭제)
        /// </summary>
        private void _Bf_Clear()
        { CWmx.It.WLib.basicBuffer.Clear(m_nCh); }

        /// <summary>
        /// 버퍼 상태 가져오기
        /// </summary>
        private void _Bf_GetStatus()
        {   CWmx.It.WLib.basicBuffer.GetStatus(m_nCh, ref m_mBfStat);     }

        /// <summary>
        /// 버퍼 시퀀스 - 테이블 크리닝
        /// </summary>
        private void _Bf_TblClean()
        {
            int iCnt = CData.Opt.aTC_Cnt[m_iWy]; ;
            //Y축 파라메터
            double dPP1 = CData.Axes[m_iY].dPP1;
            double dPos = 0;
            double dVel = CData.Axes[m_iY].tRN.iVel * dPP1;
            double dAcc = CData.Axes[m_iY].tRN.iAcc * dPP1;
            double dDec = CData.Axes[m_iY].tRN.iDec * dPP1;
            
            _Bf_Clear();

            for (int i = 0; i < iCnt; i++)
            {
                dPos = (i % 2 == 0) ? CData.SPos.dGRD_Y_ClnEnd[m_iWy] : CData.SPos.dGRD_Y_ClnStart[m_iWy];

                dPos *= dPP1;
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iY, dPos, dVel, dAcc, dDec);
            }
        }

        /// <summary>
        /// 버퍼 시퀀스 - Wheel measure Z'axis Up 하여 ToolSetter 감지 벗어나기
        /// 20201123 Wheel Measure Test
        /// </summary>
        /// <param name="iStep"></param>
        /// 
        private void _Bf_Wheel_measure_Toolsetter_Escape_Up2(double fCurr_Pos)
        {
            // Event 번호 정의
            uint nByteAddress = 10;
            byte nBitOffset = 7;

            //Z축 파라메터
            double dPP1Z = CData.Axes[m_iZ].dPP1;
            double dPosZ = 0;
            double dVelZ = CData.Axes[m_iZ].tRN.iVel * dPP1Z;
            double dVelZ2 = CData.Axes[m_iZ].tRS.iVel * dPP1Z;
            double dAccZ = CData.Axes[m_iZ].tRS.iAcc * dPP1Z * 10;
            double dDecZ = CData.Axes[m_iZ].tRS.iDec * dPP1Z * 10;

            BufferCondition buffCon = new BufferCondition();
            CWmx.It.WLib.eventControl.ClearAllEvent();
            if (m_eWy == EWay.R)
            {
                // Buffer 내용 clear
                nByteAddress = 35;
                nBitOffset = 7;
            }
            else
            {
                // Buffer 내용 clear
                nByteAddress = 10;
                nBitOffset = 7;
            }
            // IO 입력 신호를 받는 버퍼의 조건 설정 (위쪽의 Event와 같은 IO입력 주소를 선택해야함)
            buffCon.BufferConditionType = BufferConditionType.IOInput;
            buffCon.IOAddress.ByteAddress = (int)nByteAddress;
            buffCon.IOAddress.BitOffset = nBitOffset;
            buffCon.IOAddress.Size = 1;
            buffCon.Logic = 1;  // Off -> On 일때 정지

            _Bf_Clear();
            dPosZ = (fCurr_Pos - (3.0)) * dPP1Z;// 현 위치에서 0.003mm Up
            dVelZ = 0.2 * dPP1Z;// 1mm/s
            CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);
            CWmx.It.WLib.basicBuffer.Wait(m_nCh, buffCon); //1) NCS 감지 Escape 시 정지
            CWmx.It.WLib.basicBuffer.Stop(m_nCh, BufferFinishType.Immediate, (short)m_iZ);

        }

        /// <summary>
        /// 버퍼 시퀀스 - Wheel measure Z'axis Up 하여 ToolSetter 감지 벗어나기
        /// 20201123 Wheel Measure Test
        /// </summary>
        /// <param name="iStep"></param>
        /// 
        private void _Bf_Wheel_measure_Toolsetter_Escape_Up(double fCurr_Pos)
        {
            // Event 번호 정의
            uint nByteAddress = 10;
            byte nBitOffset = 7;

            //Z축 파라메터
            double dPP1Z = CData.Axes[m_iZ].dPP1;
            double dPosZ = 0;
            double dVelZ = CData.Axes[m_iZ].tRN.iVel * dPP1Z;
            double dVelZ2 = CData.Axes[m_iZ].tRS.iVel * dPP1Z;
            double dAccZ = CData.Axes[m_iZ].tRS.iAcc * dPP1Z;
            double dDecZ = CData.Axes[m_iZ].tRS.iDec * dPP1Z;

            int nCnt = 0;
            BufferCondition buffCon = new BufferCondition();
            CWmx.It.WLib.eventControl.ClearAllEvent();
            if (m_eWy == EWay.R)
            {
                // Buffer 내용 clear
                nByteAddress = 35;
                nBitOffset = 7;
            }
            else
            {
                // Buffer 내용 clear
                nByteAddress = 10;
                nBitOffset = 7;
            }
            // IO 입력 신호를 받는 버퍼의 조건 설정 (위쪽의 Event와 같은 IO입력 주소를 선택해야함)
            buffCon.BufferConditionType = BufferConditionType.IOInput;
            buffCon.IOAddress.ByteAddress = (int)nByteAddress;
            buffCon.IOAddress.BitOffset = nBitOffset;
            buffCon.IOAddress.Size = 1;
            buffCon.Logic = 1;  // Off -> On 일때 정지

            _Bf_Clear();
            for (nCnt = 0; nCnt < 50; nCnt++)// 512 * 1024
            {
                dPosZ = (fCurr_Pos - (0.003 * nCnt)) * dPP1Z;       // 현 위치에서 0.003mm Up
                CWmx.It.WLib.basicBuffer.FlowIf(m_nCh, buffCon);    //1) Toolsetter 미감지 시 정지
                CWmx.It.WLib.basicBuffer.Stop(m_nCh, BufferFinishType.Immediate, (short)m_iZ);
                CWmx.It.WLib.basicBuffer.FlowElse(m_nCh);           //2) Toolsetter 감지 시 Up
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);
                CWmx.It.WLib.basicBuffer.FlowEndIf(m_nCh);
            }
        }

        /// <summary>
        /// 20201123 Wheel Measure Test
        /// </summary>
        /// <param name="fCurr_Pos"></param>
        private void _Bf_Wheel_measure_Toolsetter_Check_Down(double fCurr_Pos)
        {
            // Event 번호 정의
            uint nByteAddress = 10;
            byte nBitOffset = 7;
            //Z축 파라메터
            double dPP1Z = CData.Axes[m_iZ].dPP1;
            double dPosZ = fCurr_Pos * dPP1Z;
            double dVelZ = CData.Axes[m_iZ].tRN.iVel * dPP1Z;
            double dVelZ2 = CData.Axes[m_iZ].tRS.iVel * dPP1Z;
            double dAccZ = CData.Axes[m_iZ].tRN.iAcc * dPP1Z;
            double dDecZ = CData.Axes[m_iZ].tRN.iDec * dPP1Z;

            double dInterval = 1.0;

            int nCnt = 0;
            int nCnt1 = 0;
            int nCnt2 = 0;
            double dRoughPos = dPosZ;
            BufferCondition buffCon = new BufferCondition();
            CWmx.It.WLib.eventControl.ClearAllEvent();
            if (m_eWy == EWay.R)
            {
                // Buffer 내용 clear
                nByteAddress = 35;
                nBitOffset = 7;
            }
            else
            {
                // Buffer 내용 clear
                nByteAddress = 10;
                nBitOffset = 7;
            }
            // IO 입력 신호를 받는 버퍼의 조건 설정 (위쪽의 Event와 같은 IO입력 주소를 선택해야함)
            buffCon.BufferConditionType = BufferConditionType.IOInput;
            buffCon.IOAddress.ByteAddress = (int)nByteAddress;
            buffCon.IOAddress.BitOffset = nBitOffset;
            buffCon.IOAddress.Size = 1;
            buffCon.Logic = 0;  // Off -> On 일때 정지

            _Bf_Clear();
            for (nCnt = 1; nCnt < 50; nCnt++)// 512 * 1024
            {
                //1) Z-axis 현 위치에서 2.0mm down 후 이전 Wheel 높이 보다 1.5 큰 위치일 경우 1.5 mm Down
                if (dPosZ < ((CData.WheelTipBeforeZPos[m_iWy] - 1.6) * dPP1Z))
                {
                    nCnt1 = nCnt2 = 0;
                    dInterval = 1.3;
                    dPosZ = (fCurr_Pos + (dInterval * nCnt)) * dPP1Z;// 현 위치에서 1.3mm Down
                }
                else if (dPosZ < ((CData.WheelTipBeforeZPos[m_iWy] - 0.2) * dPP1Z))
                {
                    nCnt1++;
                    dInterval = 0.1;
                    dPosZ = ((dRoughPos / dPP1Z) + (dInterval * nCnt1)) * dPP1Z;// 현 위치에서 0.1mm Down
                }
                else
                {
                    nCnt2++;
                    dInterval = 0.05;
                    dVelZ = CData.Axes[m_iZ].tRS.iVel * dPP1Z;
                    dAccZ = CData.Axes[m_iZ].tRS.iAcc * dPP1Z;
                    dDecZ = CData.Axes[m_iZ].tRS.iDec * dPP1Z;
                    dPosZ = ((dRoughPos / dPP1Z) + (dInterval * nCnt2)) * dPP1Z;// 현 위치에서 0.05mm Down
                }
                dRoughPos = dPosZ;
                CWmx.It.WLib.basicBuffer.FlowIf(m_nCh, buffCon);    //1) Toolsetter 감지 시 정지
                CWmx.It.WLib.basicBuffer.Stop(m_nCh, BufferFinishType.Immediate, (short)m_iZ);
                CWmx.It.WLib.basicBuffer.FlowElse(m_nCh);           // 2) Toolsetter 미감지 시 Down
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);
                CWmx.It.WLib.basicBuffer.FlowEndIf(m_nCh);
            }
            _SetLog(" Target Pos : " + dPosZ);
        }

        /// <summary>
        /// 버퍼 시퀀스 - NCS Down 후 Encoder 1'st 읽기
        /// </summary>
        /// <param name="iStep"></param>
        private void _Bf_NCS_Probe_Down1(double fCurrPos)
        {
            // Event 번호 정의
            uint evtID = 0;
            uint posEvtID = 0;
            uint nByteAddress = 10;
            byte nBitOffset = 7;

            //Y축 파라메터
            double dPP1X = CData.Axes[m_iX].dPP1 ;
            double dVelX = (double)CData.Axes[m_iX].tRN.iVel * dPP1X;
            double dAccX = (double)CData.Axes[m_iX].tRN.iAcc * dPP1X;
            double dDecX = (double)CData.Axes[m_iX].tRN.iDec * dPP1X;
            //Y축 파라메터
            double dPP1Y = CData.Axes[m_iY].dPP1;
            double dVelY = 200 * dPP1Y;
            double dAccY = CData.Axes[m_iY].iAccR * dVelY;
            double dDecY = CData.Axes[m_iY].iDecR * dVelY;
            //Z축 파라메터
            double dPosZ = 0;
            double dPP1Z = CData.Axes[m_iZ].dPP1;
            double dVelZ = CData.Axes[m_iZ].tRN.iVel  * dPP1Z;
            double dVelZ2 = CData.Axes[m_iZ].tRS.iVel * dPP1Z;
            double dAccZ = CData.Axes[m_iZ].tRS.iAcc  * dPP1Z;
            double dDecZ = CData.Axes[m_iZ].tRS.iDec  * dPP1Z;

            PosBlock PosBlk = new PosBlock();
             PosBlk.AxisCount = 2;
            BufferCondition buffCon = new BufferCondition();
            if (m_eWy == EWay.L)
            {
                // Event 번호 정의
                evtID = 0;
                posEvtID = 0;
                nByteAddress = 10;
                nBitOffset = 7;

                // 이벤트 초기화
                CWmx.It.WLib.eventControl.ClearAllEvent();
                // Event등록(IO 입력 신호 받는 이벤트)
                wmxCLRLibrary.common.Event evt = new wmxCLRLibrary.common.Event();
                evt.InputFunction = wmxCLRLibrary.common.EventInputFunction.IOBit;
                evt.InputUseOutput = 0;                 // 0 : Input , 1: Output
                evt.InputByteAddress = nByteAddress;
                evt.InputBitAddress = nBitOffset;
                evt.InputInvert = 1;                    // 0: A 접점 , 1: B 접점
                evt.Enabled = 1;                        // Event 활성화
                CWmx.It.WLib.eventControl.SetEvent(ref evtID, evt);

                // 모션Event등록(IO 입력 신호 받는 이벤트가 활성화되면, 축 정지 이벤트)
                wmxCLRLibrary.common.jerkRatioMotionEvent.PosBlockEvent posEvt = new wmxCLRLibrary.common.jerkRatioMotionEvent.PosBlockEvent();
                posEvt.InputEventID = evtID;
                posEvt.OutputFunction = wmxCLRLibrary.common.jerkRatioMotionEvent.OutputFunc.StopSingleAxis;
                posEvt.OutputBlock.Axis = (short)m_iZ;
                posEvt.OutputBlock.Dec = dDecZ;
                posEvt.Enabled = 1;                     // Event 활성화
                CWmx.It.WLib.eventControl.SetEvent(ref posEvtID, posEvt);

                // IO 입력 신호를 받는 버퍼의 조건 설정 (위쪽의 Event와 같은 IO입력 주소를 선택해야함)
                buffCon.BufferConditionType = BufferConditionType.IOInput;
                buffCon.IOAddress.ByteAddress = (int)nByteAddress;
                buffCon.IOAddress.BitOffset = nBitOffset;
                buffCon.Logic = 0;  // A 접점 설정 -> FlowIf 신호가 1일때 정지 위한 조건
                
                _Bf_Clear();        // Buffer 내용 clear
                ///
                /// Probe Cylinder Up 위치 이동 -> Z-axis "0" 이동 -> X,Y-axis 측정 위치 이동 -> Probe Down /Z-axis Down -> 센서 감지 Stop
                /// 
                //1) Probe Cylinder Up 위치 이동
                CWmx.It.WLib.basicBuffer.SetOutBit(m_nCh,(short)((int)eY.GRDL_ProbeDn/8 + 2),(short)eY.GRDL_ProbeDn%8,Convert.ToByte(false));
                CWmx.It.WLib.basicBuffer.Sleep(m_nCh, 2 * 1000);
                //2) Z-axis "0" 이동
                dPosZ = 0.0 * dPP1Z;
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);                
                //3) X,Y 측정 위치 이동
                PosBlk.Block[0].Axis    = (short)m_iX;
                PosBlk.Block[0].Target  = CData.SPos.dGRD_X_Zero[m_iWy] * dPP1X;
                PosBlk.Block[0].Velocity= dVelX;
                PosBlk.Block[0].Acc     = dAccX;
                PosBlk.Block[0].Dec     = dDecX;
 
                PosBlk.Block[1].Axis    = (short)m_iY;
                PosBlk.Block[1].Target  = (CData.MPos[m_iWy].dY_PRB_TBL_CENTER - GV.EQP_TABLE_CENTER_TO_TOOLSETTER) * dPP1Y;
                PosBlk.Block[1].Velocity= dVelY;
                PosBlk.Block[1].Acc     = dAccY;
                PosBlk.Block[1].Dec     = dDecY; 
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, PosBlk);              
                //4) Probe Down
                CWmx.It.WLib.basicBuffer.SetOutBit(m_nCh,(short)((int)eY.GRDL_ProbeDn/8 + 2),(short)eY.GRDL_ProbeDn%8, Convert.ToByte(true));
                //5) Z-axis 측정 위치 이동 (파라메터 위치 + 1.0mm)
                dPosZ = (CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER + 1.0) * dPP1Z;
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);
                //6) NCS 감지시 정지
                CWmx.It.WLib.basicBuffer.FlowIf(m_nCh, buffCon);   
                    CWmx.It.WLib.basicBuffer.AbortAndStop(m_nCh);                
                CWmx.It.WLib.basicBuffer.FlowEndIf(m_nCh);
            }
        }
        /// <summary>
        /// 버퍼 시퀀스 - NCS Up 하여 Encoder 2'nd 읽기
        /// </summary>
        /// <param name="iStep"></param>
        private void _Bf_NCS_Probe_Up1(double fCurrPos)
        {
            //Y축 파라메터
            double dPP1Y = CData.Axes[m_iY].dPP1;
            double dVelY = 20 * dPP1Y;
            double dAccY = CData.Axes[m_iY].iAccR * dVelY;
            double dDecY = CData.Axes[m_iY].iDecR * dVelY;
            //Z축 파라메터
            double dPP1Z = CData.Axes[m_iZ].dPP1;
            double dPosZ = 0;
            double dVelZ  = CData.Axes[m_iZ].tRN.iVel * dPP1Z;
            double dVelZ2 = CData.Axes[m_iZ].tRS.iVel * dPP1Z;
            double dAccZ = CData.Axes[m_iZ].tRS.iAcc * dPP1Z;
            double dDecZ = CData.Axes[m_iZ].tRS.iDec * dPP1Z;

            BufferCondition buffCon = new BufferCondition();
            CWmx.It.WLib.eventControl.ClearAllEvent();
            if (m_eWy == EWay.L)
            {               
                // Buffer 내용 clear
                _Bf_Clear();
                ///
                /// Z-axis Up -> 센서 감지 Stop -> 0.1mm Up
                /// 
                //1) Z-axis 현 위치에서 0.1mm Up
                dPosZ = (fCurrPos) * dPP1Z;// 현 위치에서 1.0mm Up
                dVelZ  = 0.6 * dPP1Z;                
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);
            }
        }   
                /// <summary>
        /// 버퍼 시퀀스 - NCS Down 후 Encoder 1'st 읽기
        /// </summary>
        /// <param name="iStep"></param>
        private void _Bf_NCS_Probe_Down2(double fCurrPos)
        {
            // Event 번호 정의
            uint evtID = 0;
            uint posEvtID = 0;
            uint nByteAddress = 10;
            byte nBitOffset = 7;

            //Y축 파라메터
            double dPP1X = CData.Axes[m_iX].dPP1 ;
            double dVelX = (double)CData.Axes[m_iX].tRN.iVel * dPP1X;
            double dAccX = (double)CData.Axes[m_iX].tRN.iAcc * dPP1X;
            double dDecX = (double)CData.Axes[m_iX].tRN.iDec * dPP1X;
            //Y축 파라메터
            double dPP1Y = CData.Axes[m_iY].dPP1;
            double dVelY = 20 * dPP1Y;
            double dAccY = CData.Axes[m_iY].iAccR * dVelY;
            double dDecY = CData.Axes[m_iY].iDecR * dVelY;
            //Z축 파라메터
            double dPosZ = 0;
            double dPP1Z = CData.Axes[m_iZ].dPP1;
            double dVelZ = CData.Axes[m_iZ].tRN.iVel  * dPP1Z;
            double dVelZ2 = CData.Axes[m_iZ].tRS.iVel * dPP1Z;
            double dAccZ = CData.Axes[m_iZ].tRS.iAcc  * dPP1Z;
            double dDecZ = CData.Axes[m_iZ].tRS.iDec  * dPP1Z;

            PosBlock PosBlk = new PosBlock();
            PosBlk.AxisCount = 2;
            BufferCondition buffCon = new BufferCondition();
            if (m_eWy == EWay.L)
            {
                // Event 번호 정의
                evtID = 0;
                posEvtID = 0;
                nByteAddress = 10;
                nBitOffset = 7;

                // 이벤트 초기화
                CWmx.It.WLib.eventControl.ClearAllEvent();
                // Event등록(IO 입력 신호 받는 이벤트)
                wmxCLRLibrary.common.Event evt = new wmxCLRLibrary.common.Event();
                evt.InputFunction = wmxCLRLibrary.common.EventInputFunction.IOBit;
                evt.InputUseOutput = 0;                 // 0 : Input , 1: Output
                evt.InputByteAddress = nByteAddress;
                evt.InputBitAddress = nBitOffset;
                evt.InputInvert = 1;                    // 0: A 접점 , 1: B 접점
                evt.Enabled = 1;                        // Event 활성화
                CWmx.It.WLib.eventControl.SetEvent(ref evtID, evt);

                // 모션Event등록(IO 입력 신호 받는 이벤트가 활성화되면, 축 정지 이벤트)
                wmxCLRLibrary.common.jerkRatioMotionEvent.PosBlockEvent posEvt = new wmxCLRLibrary.common.jerkRatioMotionEvent.PosBlockEvent();
                posEvt.InputEventID = evtID;
                posEvt.OutputFunction = wmxCLRLibrary.common.jerkRatioMotionEvent.OutputFunc.StopSingleAxis;
                posEvt.OutputBlock.Axis = (short)m_iZ;
                posEvt.OutputBlock.Dec = dDecZ;
                posEvt.Enabled = 1;                     // Event 활성화
                CWmx.It.WLib.eventControl.SetEvent(ref posEvtID, posEvt);

                // IO 입력 신호를 받는 버퍼의 조건 설정 (위쪽의 Event와 같은 IO입력 주소를 선택해야함)
                buffCon.BufferConditionType = BufferConditionType.IOInput;
                buffCon.IOAddress.ByteAddress = (int)nByteAddress;
                buffCon.IOAddress.BitOffset = nBitOffset;
                buffCon.Logic = 0;  // A 접점 설정 -> FlowIf 신호가 1일때 정지 위한 조건
                
                _Bf_Clear();        // Buffer 내용 clear
                ///
                /// Probe Cylinder Down 위치 이동 ->  Probe Down /Z-axis Down -> 센서 감지 Stop
                /// 
                //1) Probe Down
                CWmx.It.WLib.basicBuffer.SetOutBit(m_nCh,(short)((int)eY.GRDL_ProbeDn/8 + 2),(short)eY.GRDL_ProbeDn%8, Convert.ToByte(true));
                //2) Z-axis 측정 위치 이동 (파라메터 위치 + 1.0mm)
                dPosZ = (CData.MPos[m_iWy].dZ_PRB_TOOL_SETTER + 1.0) * dPP1Z;
                dVelZ  = 0.6 * dPP1Z;
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);
                //3) NCS 감지시 정지
                CWmx.It.WLib.basicBuffer.FlowIf(m_nCh, buffCon);   
                    CWmx.It.WLib.basicBuffer.AbortAndStop(m_nCh);
                CWmx.It.WLib.basicBuffer.FlowEndIf(m_nCh);
            }
        }
                /// <summary>
        /// 버퍼 시퀀스 - NCS Up 하여 Encoder 2'nd 읽기
        /// </summary>
        /// <param name="iStep"></param>
        private void _Bf_Zaxis_Up(double fCurrPos,int nsel)
        {
            //Y축 파라메터
            double dPosY = 0;
            double dPP1Y = CData.Axes[m_iY].dPP1;
            double dVelY = 200 * dPP1Y;
            double dAccY = CData.Axes[m_iY].iAccR * dVelY;
            double dDecY = CData.Axes[m_iY].iDecR * dVelY;
            //Z축 파라메터
            double dPP1Z = CData.Axes[m_iZ].dPP1;
            double dPosZ = 0;
            double dVelZ  = CData.Axes[m_iZ].tRN.iVel * dPP1Z;
            double dVelZ2 = CData.Axes[m_iZ].tRS.iVel * dPP1Z;
            double dAccZ = CData.Axes[m_iZ].tRS.iAcc * dPP1Z;
            double dDecZ = CData.Axes[m_iZ].tRS.iDec * dPP1Z;

            BufferCondition buffCon = new BufferCondition();
            if (m_eWy == EWay.L)
            {
                // 이벤트 초기화
                CWmx.It.WLib.eventControl.ClearAllEvent();
                // Buffer 내용 clear
                _Bf_Clear();
                ///
                /// Z-axis Up -> 센서 감지 Stop -> 0.1mm Up
                /// 
                //1) Probe Up
                CWmx.It.WLib.basicBuffer.SetOutBit(m_nCh,(short)((int)eY.GRDL_ProbeDn/8 + 2),(short)eY.GRDL_ProbeDn%8, Convert.ToByte(false));
                //2) Z-axis 현 위치에서 5mm Up
                dPosZ = (0.0) * dPP1Z;// 현 위치에서 0mm 이동
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);
                if(nsel == 1) {
                    dPosY = 0.0 * dPP1Y;
                    CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iY, dPosY, dVelY, dAccY, dDecY);
                }
            }
        }
        /// <summary>
        /// 버퍼 시퀀스 - NCS Down 후 Encoder 1'st 읽기
        /// </summary>
        /// <param name="iStep"></param>
        private void _Bf_NCS_Wheel_Down1(double fCurrPos)
        {
            uint evtID = 0;
            uint posEvtID = 0;
            uint nByteAddress = 10;
            byte nBitOffset = 7;
            //Y축 파라메터
            double dPP1Y = CData.Axes[m_iY].dPP1;
            double dPosY = 0;
            double dVelY = 200.0 * dPP1Y;;
            double dAccY = dVelY * CData.Axes[m_iY].iAccR;
            double dDecY = dVelY * CData.Axes[m_iY].iDecR;
            //Z축 파라메터
            double dPP1Z = CData.Axes[m_iZ].dPP1;
            double dPosZ = 0;
            double dVelZ = CData.Axes[m_iZ].tRN.iVel * dPP1Z;
            double dVelZ2 = CData.Axes[m_iZ].tRS.iVel * dPP1Z;
            double dAccZ = CData.Axes[m_iZ].tRS.iAcc * dPP1Z;
            double dDecZ = CData.Axes[m_iZ].tRS.iDec * dPP1Z;

            BufferCondition buffCon = new BufferCondition();
            // 이벤트 초기화
            CWmx.It.WLib.eventControl.ClearAllEvent();
            // Event등록(IO 입력 신호 받는 이벤트)
            wmxCLRLibrary.common.Event evt = new wmxCLRLibrary.common.Event();
            evt.InputFunction = wmxCLRLibrary.common.EventInputFunction.IOBit;
            evt.InputUseOutput = 0;// 0 : Input , 1: Output
            evt.InputByteAddress = nByteAddress;
            evt.InputBitAddress = nBitOffset;
            evt.InputInvert = 1;// 0: A 접점 , 1: B 접점
            evt.Enabled = 1;// Event 활성화
            CWmx.It.WLib.eventControl.SetEvent(ref evtID, evt);

            // 모션Event등록(IO 입력 신호 받는 이벤트가 활성화되면, 축 정지 이벤트)
            wmxCLRLibrary.common.jerkRatioMotionEvent.PosBlockEvent posEvt = new wmxCLRLibrary.common.jerkRatioMotionEvent.PosBlockEvent();
            posEvt.InputEventID = evtID;
            posEvt.OutputFunction = wmxCLRLibrary.common.jerkRatioMotionEvent.OutputFunc.StopSingleAxis;
            posEvt.OutputBlock.Axis = (short)m_iZ;
            posEvt.OutputBlock.Dec = dDecZ;
            posEvt.Enabled = 1;// Event 활성화
            CWmx.It.WLib.eventControl.SetEvent(ref posEvtID, posEvt);

            // IO 입력 신호를 받는 버퍼의 조건 설정 (위쪽의 Event와 같은 IO입력 주소를 선택해야함)
            buffCon.BufferConditionType = BufferConditionType.IOInput;
            buffCon.IOAddress.ByteAddress = (int)nByteAddress;
            buffCon.IOAddress.BitOffset = nBitOffset;
            buffCon.Logic = 0;// A 접점 설정 -> FlowIf 신호가 1일때 정지 위한 조건
            // Buffer 내용 clear
            _Bf_Clear();
            if(fCurrPos < 10.0)
            {
                //1) Probe Cylinder Up 위치 이동
                CWmx.It.WLib.basicBuffer.SetOutBit(m_nCh, (short)((int)eY.GRDL_ProbeDn / 8 + 2), (short)eY.GRDL_ProbeDn % 8, Convert.ToByte(false));
                CWmx.It.WLib.basicBuffer.Sleep(m_nCh, 2 * 1000);
                //2) Z-axis "0" 이동
                dPosZ = 0.0 * dPP1Z;
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);
                //3-0) Y-axis 측정 위치 이동
                dPosY = 448.632 * dPP1Y;//CData.MPos[m_iWy].dZ_WHL_BASE - GV.WHEEL_DEF_TIP_T;
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iY, dPosY, dVelY, dAccY, dDecY);

               // dPosZ = 65.0 * dPP1Z;//CData.MPos[m_iWy].dZ_WHL_BASE - GV.WHEEL_DEF_TIP_T;
               // dVelZ = 15.0 * dPP1Z;//600000;
               // CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);
                dPosZ = 72.0 * dPP1Z;//CData.MPos[m_iWy].dZ_WHL_BASE - GV.WHEEL_DEF_TIP_T;
                dVelZ = dVelZ/2.0;
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);
            }else {
                //4-1) Z-axis 측정 위치 대기 위치 Down
                 //dPosZ = 65.0 * dPP1Z;//CData.MPos[m_iWy].dZ_WHL_BASE - GV.WHEEL_DEF_TIP_T;
                 dVelZ = dVelZ/2.0;
                 //CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);
                 //4-2) Z-axis 측정 위치 Down
                 dPosZ = 73.0 * dPP1Z;//CData.MPos[m_iWy].dZ_WHL_BASE - GV.WHEEL_DEF_TIP_T;
                 //dPosZ2 = ((72 - 40.0) * 10000);//CData.MPos[m_iWy].dZ_WHL_BASE - GV.WHEEL_DEF_TIP_T;
                 dVelZ = 0.6 * dPP1Z;//600000;
                 CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);
            }
            // 조건 1 : 구동 중 IO신호가 켜지면 이벤트에 의해 즉시 정지되며, FlowIf구문을 통해 버퍼 또한 일시정지 상태가 됩니다.
            CWmx.It.WLib.basicBuffer.FlowIf(m_nCh, buffCon);            
                CWmx.It.WLib.basicBuffer.AbortAndStop(m_nCh);
            CWmx.It.WLib.basicBuffer.FlowEndIf(m_nCh);
            // 버퍼 실행
            //CWmx.It.WLib.basicBuffer.Execute(buffCh);
        }
        /// <summary>
        /// 버퍼 시퀀스 - NCS Up 하여 Encoder 2'nd 읽기
        /// </summary>
        /// <param name="iStep"></param>
        private void _Bf_NCS_Wheel_Up1(double fCurrPos)
        {           
            //Z축 파라메터
            double dPP1Z = CData.Axes[m_iZ].dPP1;
            double dPosZ = 0;
            double dVelZ = CData.Axes[m_iZ].tRS.iVel * dPP1Z;
            double dAccZ = CData.Axes[m_iZ].tRS.iAcc * dPP1Z;
            double dDecZ = CData.Axes[m_iZ].tRS.iDec * dPP1Z;

            BufferCondition buffCon = new BufferCondition();
            // 이벤트 초기화
            CWmx.It.WLib.eventControl.ClearAllEvent();


            if(fCurrPos == 0.0)dVelZ = 60.0 * dPP1Z;
            else {
                //4) Z-axis 측정 위치 Down
                dPosZ = (fCurrPos) * dPP1Z;
                
            }
            // Buffer 내용 clear
            _Bf_Clear();
            CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);
            // 버퍼 실행
            //CWmx.It.WLib.basicBuffer.Execute(buffCh);
        }       
        /// <summary>
        /// 버퍼 시퀀스 - NCS Down 후 Encoder 1'st 읽기
        /// </summary>
        /// <param name="iStep"></param>
        private void _Bf_NCS_Wheel_Down2()
        {
            uint evtID = 0;
            uint posEvtID = 0;
            uint nByteAddress = 10;
            byte nBitOffset = 7;

            //Z축 파라메터
            double dPP1Z = CData.Axes[m_iZ].dPP1;
            double dPosZ = 0;
            double dVelZ = CData.Axes[m_iZ].tRN.iVel * dPP1Z;
            double dVelZ2 = CData.Axes[m_iZ].tRS.iVel * dPP1Z;
            double dAccZ = CData.Axes[m_iZ].tRS.iAcc * dPP1Z;
            double dDecZ = CData.Axes[m_iZ].tRS.iDec * dPP1Z;

            BufferCondition buffCon = new BufferCondition();
            // 이벤트 초기화
            CWmx.It.WLib.eventControl.ClearAllEvent();
            // Event등록(IO 입력 신호 받는 이벤트)
            wmxCLRLibrary.common.Event evt = new wmxCLRLibrary.common.Event();
            evt.InputFunction = wmxCLRLibrary.common.EventInputFunction.IOBit;
            evt.InputUseOutput = 0;// 0 : Input , 1: Output
            evt.InputByteAddress = nByteAddress;
            evt.InputBitAddress = nBitOffset;
            evt.InputInvert = 1;// 0: A 접점 , 1: B 접점
            evt.Enabled = 1;// Event 활성화
            CWmx.It.WLib.eventControl.SetEvent(ref evtID, evt);

            // 모션Event등록(IO 입력 신호 받는 이벤트가 활성화되면, 축 정지 이벤트)
            wmxCLRLibrary.common.jerkRatioMotionEvent.PosBlockEvent posEvt = new wmxCLRLibrary.common.jerkRatioMotionEvent.PosBlockEvent();
            posEvt.InputEventID = evtID;
            posEvt.OutputFunction = wmxCLRLibrary.common.jerkRatioMotionEvent.OutputFunc.StopSingleAxis;
            posEvt.OutputBlock.Axis = (short)m_iZ;
            posEvt.OutputBlock.Dec = dDecZ;
            posEvt.Enabled = 1;// Event 활성화
            CWmx.It.WLib.eventControl.SetEvent(ref posEvtID, posEvt);

            // IO 입력 신호를 받는 버퍼의 조건 설정 (위쪽의 Event와 같은 IO입력 주소를 선택해야함)
            buffCon.BufferConditionType = BufferConditionType.IOInput;
            buffCon.IOAddress.ByteAddress = (int)nByteAddress;
            buffCon.IOAddress.BitOffset = nBitOffset;
            buffCon.Logic = 0;// A 접점 설정 -> FlowIf 신호가 1일때 정지 위한 조건
            // Buffer 내용 clear
            _Bf_Clear();
           //4-0) Z-axis 측정 위치 대기 위치 Down
            dPosZ = 68.0 * dPP1Z;//CData.MPos[m_iWy].dZ_WHL_BASE - GV.WHEEL_DEF_TIP_T;
            dVelZ = 60.0 * dPP1Z;
            CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);
           //4-1) Z-axis 측정 위치 대기 위치 Down
            dPosZ = 71.0 * dPP1Z;//CData.MPos[m_iWy].dZ_WHL_BASE - GV.WHEEL_DEF_TIP_T;
            dVelZ = 60.0 * dPP1Z;
            CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);
            //4) Z-axis 측정 위치 Down
            dPosZ = 72.0 * dPP1Z;//CData.MPos[m_iWy].dZ_WHL_BASE - GV.WHEEL_DEF_TIP_T;
            dVelZ = 60.0 * dPP1Z;//600000;
            CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ);

            // 조건 1 : 구동 중 IO신호가 켜지면 이벤트에 의해 즉시 정지되며, FlowIf구문을 통해 버퍼 또한 일시정지 상태가 됩니다.
            CWmx.It.WLib.basicBuffer.FlowIf(m_nCh, buffCon);            
                CWmx.It.WLib.basicBuffer.AbortAndStop(m_nCh);
            CWmx.It.WLib.basicBuffer.FlowEndIf(m_nCh);
            // 버퍼 실행
            //CWmx.It.WLib.basicBuffer.Execute(buffCh);
        }

        /// <summary>
        /// 호출 이전 m_iStep = 0
        /// 
        /// </summary>
        /// <param name="m_iGStep"></param>
        /// 
        static double[] dZaxis_Pos = new double[3];// Z-axis Encoder 획득 위치       
        static double[] dZaxis_Measure_Pos = new double[3];// Z-axis Encoder 획득 위치       
        private double fZ_Check_Pos = 0.0;
        private DateTime m_tStTime_0;
        private DateTime m_tStTime_1;
        private TimeSpan m_tTackTime_0;
        private TimeSpan m_tTackTime_1;
        private TimeSpan m_tTackTime_2;

        // 2020.10.29 SungTae Start : Add(Dresser Measure 시 Point 당 측정 시간 확인용)
        private DateTime m_tStTime;
        private DateTime m_tStMeaTime;
        private TimeSpan m_tTackTime;
        private TimeSpan m_tMeaTackTime;
        // 2020.10.29 SungTae End

        public bool _Bf_Ncs_Main()
        {            
            double fCurr_Pos = CMot.It.Get_FP((short)m_iZ);
            double fCurr_CmdPos = 0.0;
            string sData;

            string sDay   = DateTime.Now.ToString("[yyyyMMdd-HHmmss fff]");
            if (m_eWy == EWay.L)
            {
                m_eOt1 = eY.GRDL_ProbeDn;
            }else {
                m_eOt1 = eY.GRDR_ProbeDn;
            }

            if (Convert.ToBoolean(CMot.It.Chk_AlrI((int)EAx.LeftGrindZone_X)) ||
                Convert.ToBoolean(CMot.It.Chk_AlrI((int)EAx.LeftGrindZone_Y)) ||
                Convert.ToBoolean(CMot.It.Chk_AlrI((int)EAx.LeftGrindZone_Z))) {
                CWmx.It.WLib.basicBuffer.AbortAndStop(m_nCh);
                CIO.It.Set_Y(m_eOt1, false);
                if (Convert.ToBoolean(CMot.It.Chk_AlrI((int)EAx.LeftGrindZone_X))) CErr.Show(eErr.LEFT_GRIND_X_AXIS_MOTOR_ALRAM);
                else if (Convert.ToBoolean(CMot.It.Chk_AlrI((int)EAx.LeftGrindZone_Y))) CErr.Show(eErr.LEFT_GRIND_Y_AXIS_MOTOR_ALRAM);
                else CErr.Show(eErr.LEFT_GRIND_Z_AXIS_MOTOR_ALRAM);
                return true;
            } else if (m_iStep == 100)
            {
                sData = (sDay + ",m_iStep = " + m_iStep);
                //var result = System.Windows.MessageBox.Show(sData, "Information", System.Windows.MessageBoxButton.OKCancel);
                var result = System.Windows.MessageBoxResult.OK;
                if (result == System.Windows.MessageBoxResult.OK)
                {
                    m_tStTime_0 = DateTime.Now;
                    CLog.mLogEncoder("Probe 1 Down" );
                    _Bf_NCS_Probe_Down1(fCurr_Pos); 
                    _Bf_Start();                    
                    fZ_Check_Pos = 55.0;
                    Console.WriteLine(sData);
                    m_iStep = 101;
                }
            }else if (m_iStep == 101)
            {
                _Bf_GetStatus();                
                //return true;
                if (m_mBfStat.State == BufferState.Idle) 
                {   
                    Bf_Stop();
                    dZaxis_Pos[0] = CMot.It.Get_FP((short)m_iZ);
                    fCurr_CmdPos  = CMot.It.Get_CP((short)m_iZ);
                    sData = sDay + ",m_iStep = "+ m_iStep + ",dZaxis_Pos[0] Check: " + dZaxis_Pos[0] + "," + fCurr_CmdPos;
                    Console.WriteLine(sData);
                    return true;
                    if (dZaxis_Pos[0] > fZ_Check_Pos )
                    {
                        sData = sDay + ",m_iStep = " + m_iStep + ",dZaxis_Pos[0] Check: -> " + dZaxis_Pos[0] + "," + fCurr_CmdPos;
                        //var result = System.Windows.MessageBox.Show(sData, "Information", System.Windows.MessageBoxButton.OKCancel);
                        var result = System.Windows.MessageBoxResult.OK;
                        if (result == System.Windows.MessageBoxResult.OK)
                        {
                            Console.WriteLine(sData);
                            m_iStep = 102;
                        }                
                    }else
                    {                        
                        CIO.It.Set_Y(m_eOt1, false);
                        Console.WriteLine(sDay + ",m_iStep = " + m_iStep + ",Error !! dZaxis_Pos[0] Miss: -> " + dZaxis_Pos[0] + "," + fCurr_CmdPos);
                        CErr.Show(eErr.LEFT_GRIND_Z_AXIS_MOTOR_ALRAM);
                        return true;
                    }                 
                }
            }else if (m_iStep == 102)
            {
                sData = (sDay + ",m_iStep = " + m_iStep);
                //var result = System.Windows.MessageBox.Show(sData, "Information", System.Windows.MessageBoxButton.OKCancel);
                var result = System.Windows.MessageBoxResult.OK;
                if (result == System.Windows.MessageBoxResult.OK)
                {
                    _Bf_NCS_Probe_Up1(58.0 - 1.0);
                    _Bf_Start();
                    fZ_Check_Pos = 55.0;
                    Console.WriteLine(sData);
                    m_iStep = 103;
                }           
            }else if (m_iStep == 103)
            {
                _Bf_GetStatus();
                if (m_mBfStat.State == BufferState.Idle) 
                {   
                    Bf_Stop();
                    dZaxis_Pos[0] = CMot.It.Get_FP((short)m_iZ);
                    fCurr_CmdPos  = CMot.It.Get_CP((short)m_iZ);
                    sData = sDay + ",m_iStep = "+ m_iStep + ",dZaxis_Pos[0] Clear: " + dZaxis_Pos[0] + "," + fCurr_CmdPos;
                    Console.WriteLine(sData);
                    if (dZaxis_Pos[0] > fZ_Check_Pos )
                    {
                        sData = sDay + ",m_iStep = "+ m_iStep + ",dZaxis_Pos[0] Clear: -> " + dZaxis_Pos[0] + "," + fCurr_CmdPos;
                        //var result = System.Windows.MessageBox.Show(sData, "Information", System.Windows.MessageBoxButton.OKCancel);
                        var result = System.Windows.MessageBoxResult.OK;
                        if (result == System.Windows.MessageBoxResult.OK)
                        {
                            Console.WriteLine(sData);
                            m_iStep = 104;
                        }         
                    }else{                        
                        CIO.It.Set_Y(m_eOt1, false);
                        Console.WriteLine(sDay + ",m_iStep = " + m_iStep + ",Error !! dZaxis_Pos[0] Miss: -> " + dZaxis_Pos[0] + "," + fCurr_CmdPos);
                        CErr.Show(eErr.LEFT_GRIND_Z_AXIS_MOTOR_ALRAM);                    
                        return true;
                    }                 
                }
            }else if (m_iStep == 104){
                sData = (sDay + ",m_iStep = " + m_iStep);
                Console.WriteLine(sData);
                //var result = System.Windows.MessageBox.Show(sData, "Information", System.Windows.MessageBoxButton.OKCancel);
                var result = System.Windows.MessageBoxResult.OK;
                if (result == System.Windows.MessageBoxResult.OK)
                {
                    _Bf_NCS_Probe_Down2(fCurr_Pos);
                    _Bf_Start();
                    fZ_Check_Pos = 55.0;
                    m_iStep = 105;
                }
            }else if (m_iStep == 105){
                _Bf_GetStatus();
                if (m_mBfStat.State == BufferState.Idle){   
                    Bf_Stop();
                    dZaxis_Pos[0] = CMot.It.Get_FP((short)m_iZ);
                    fCurr_CmdPos  = CMot.It.Get_CP((short)m_iZ);                    
                    sData = sDay + ",m_iStep = "+ m_iStep + ",dZaxis_Pos[0] Check: " + dZaxis_Pos[0] + "," + fCurr_CmdPos;
                    Console.WriteLine(sData);
                    if (dZaxis_Pos[0] > fZ_Check_Pos ) {
                        dZaxis_Measure_Pos[0] = dZaxis_Pos[0];
                        sData = sDay + ",m_iStep = "+ m_iStep + ",dZaxis_Pos[0] Check: -> " + dZaxis_Pos[0] + "," + fCurr_CmdPos + "," + dZaxis_Measure_Pos[0];
                        //var result = System.Windows.MessageBox.Show(sData, "Information", System.Windows.MessageBoxButton.OKCancel);
                        var result = System.Windows.MessageBoxResult.OK;
                        if (result == System.Windows.MessageBoxResult.OK)
                        {
                            Console.WriteLine(sData);
                            m_iStep = 106;
                        }         
                    }else {                        
                        CIO.It.Set_Y(m_eOt1, false);
                        Console.WriteLine(sDay + ",m_iStep = " + m_iStep + ",Error !! dZaxis_Pos[0] Miss: -> " + dZaxis_Pos[0] + "," + fCurr_CmdPos);
                        CErr.Show(eErr.LEFT_GRIND_Z_AXIS_MOTOR_ALRAM);                    
                        return true;
                    }                 
                }
            }else if (m_iStep == 106){
                sData = (sDay + ",m_iStep = " + m_iStep);
                Console.WriteLine(sData);
                //var result = System.Windows.MessageBox.Show(sData, "Information", System.Windows.MessageBoxButton.OKCancel);
                var result = System.Windows.MessageBoxResult.OK;
                if (result == System.Windows.MessageBoxResult.OK)
                {
                    _Bf_Zaxis_Up(fCurr_Pos,0);
                    _Bf_Start();
                    fZ_Check_Pos = 10.0;                    
                    m_iStep = 107;
                }
            }else if (m_iStep == 107) {
                _Bf_GetStatus();
                if (m_mBfStat.State == BufferState.Idle) { 
                    dZaxis_Pos[0] = CMot.It.Get_FP((short)m_iZ);
                    fCurr_CmdPos  = CMot.It.Get_CP((short)m_iZ);
                    sData = sDay + ",m_iStep = " + m_iStep + ",dZaxis_Pos[0] Up End: " + dZaxis_Pos[0] + "," + fCurr_CmdPos;
                    Console.WriteLine(sData);
                    if(dZaxis_Pos[0] < fZ_Check_Pos ){// 작업 정상 종료 버퍼 시퀀스 종료 Encoder 값 획득
                        m_tTackTime_0 = DateTime.Now - m_tStTime_0;
                        sData = sDay + ",m_iStep = " + m_iStep + ",dZaxis_Pos[1] Up End->: " + dZaxis_Pos[0] + "," + fCurr_CmdPos + ",span time " +  m_tTackTime_0 ;
                        //var result = System.Windows.MessageBox.Show(sData, "Information", System.Windows.MessageBoxButton.OKCancel);
                        var result = System.Windows.MessageBoxResult.OK;
                        if (result == System.Windows.MessageBoxResult.OK)
                        {
                            Console.WriteLine(sData);
                            m_iStep = 111;
                        }
                    }else {                        
                        CIO.It.Set_Y(m_eOt1, false);
                        Console.WriteLine(sDay + "," + m_iStep + ",Error !! dZaxis_Pos[0] Miss: -> " + dZaxis_Pos[0] + "," + fCurr_CmdPos);
                        CErr.Show(eErr.LEFT_GRIND_Z_AXIS_MOTOR_ALRAM);                    
                        return true;
                    }                    
                }
            }else if (m_iStep == 111)// wheel 높이 측정 Down 1
            {
                sData = (sDay + ",m_iStep = " + m_iStep);
                Console.WriteLine(sData);
                //var result = System.Windows.MessageBox.Show(sData, "Information", System.Windows.MessageBoxButton.OKCancel);
                var result = System.Windows.MessageBoxResult.OK;
                if (result == System.Windows.MessageBoxResult.OK)
                {
                    m_tStTime_1 = DateTime.Now;
                    _Bf_NCS_Wheel_Down1(fCurr_Pos);
                    _Bf_Start();
                    fZ_Check_Pos = 55.0;
                    m_iStep = 112;
                }
            }else if (m_iStep == 112)
            {
                _Bf_GetStatus();
                if (m_mBfStat.State == BufferState.Idle)
                {
                    Bf_Stop();
                    dZaxis_Pos[1] = CMot.It.Get_FP((short)m_iZ);
                    fCurr_CmdPos = CMot.It.Get_CP((short)m_iZ);
                    sData = sDay + ",m_iStep = " + m_iStep + ",dZaxis_Pos[1] Check: " + dZaxis_Pos[1] + "," + fCurr_CmdPos;
                    Console.WriteLine(sData);
                    if (dZaxis_Pos[1] > fZ_Check_Pos)
                    {
                        sData = sDay + ",m_iStep = " + m_iStep + ",dZaxis_Pos[1] Check: -> " + dZaxis_Pos[1] + "," + fCurr_CmdPos;
                        //var result = System.Windows.MessageBox.Show(sData, "Information", System.Windows.MessageBoxButton.OKCancel);
                        var result = System.Windows.MessageBoxResult.OK;
                        if (result == System.Windows.MessageBoxResult.OK)
                        {
                            Console.WriteLine(sData);
                            m_iStep = 113;
                        }
                    }
                    else
                    {
                        CIO.It.Set_Y(m_eOt1, false);
                        CMot.It.Mv_H(m_iZ);
                        Console.WriteLine(sDay + ",m_iStep = " + m_iStep + ",Error !! dZaxis_Pos[1] Miss: -> " + dZaxis_Pos[1] + "," + fCurr_CmdPos);                        
                        CErr.Show(eErr.LEFT_GRIND_Z_AXIS_MOTOR_ALRAM);
                        return true;
                    }
                }
            }
            else if (m_iStep == 113)// wheel 높이 측정 Up 1
            {
                sData = (sDay + ",m_iStep = " + m_iStep);
                Console.WriteLine(sData);
                //var result = System.Windows.MessageBox.Show(sData, "Information", System.Windows.MessageBoxButton.OKCancel);
                var result = System.Windows.MessageBoxResult.OK;
                if (result == System.Windows.MessageBoxResult.OK)
                {
                    _Bf_NCS_Wheel_Up1(65.0 - 0.5);
                    _Bf_Start();
                    fZ_Check_Pos = 55.0;
                    m_iStep = 114;
                }
            }
            else if (m_iStep == 114)
            {
                _Bf_GetStatus();
                if (m_mBfStat.State == BufferState.Idle)
                {
                    Bf_Stop();
                    dZaxis_Pos[1] = CMot.It.Get_FP((short)m_iZ);
                    fCurr_CmdPos = CMot.It.Get_CP((short)m_iZ);
                    Console.WriteLine(sDay + ",m_iStep = " + m_iStep + ",dZaxis_Pos[1] Check: " + dZaxis_Pos[1] + "," + fCurr_CmdPos);
                    if (dZaxis_Pos[1] > fZ_Check_Pos)
                    {
                        Console.WriteLine(sDay + ",m_iStep = " + m_iStep + ",dZaxis_Pos[1] Check: -> " + dZaxis_Pos[1] + "," + fCurr_CmdPos);
                        m_iStep = 115;
                    }
                    else
                    {
                        CIO.It.Set_Y(m_eOt1, false);
                        CMot.It.Mv_H(m_iZ);
                        Console.WriteLine(sDay + ",m_iStep = " + m_iStep + ",Error !! dZaxis_Pos[1] Miss: -> " + dZaxis_Pos[1] + "," + fCurr_CmdPos);
                        CErr.Show(eErr.LEFT_GRIND_Z_AXIS_MOTOR_ALRAM);
                        return true;
                    }
                }
            }
            else if (m_iStep == 115)// wheel 높이 측정 Down 2
            {
                sData = (sDay + ",m_iStep = " + m_iStep);
                Console.WriteLine(sData);
                //var result = System.Windows.MessageBox.Show(sData, "Information", System.Windows.MessageBoxButton.OKCancel);
                var result = System.Windows.MessageBoxResult.OK;
                if (result == System.Windows.MessageBoxResult.OK)
                {
                    _Bf_NCS_Wheel_Down1(fCurr_Pos);
                    _Bf_Start();
                    fZ_Check_Pos = 55.0;
                    m_iStep = 116;
                }
            }
            else if (m_iStep == 116)
            {
                _Bf_GetStatus();
                if (m_mBfStat.State == BufferState.Idle)
                {
                    Bf_Stop();
                    dZaxis_Pos[1] = CMot.It.Get_FP((short)m_iZ);
                    fCurr_CmdPos = CMot.It.Get_CP((short)m_iZ);
                    sData = sDay + ",m_iStep = " + m_iStep + ",dZaxis_Pos[1] Check: " + dZaxis_Pos[1] + "," + fCurr_CmdPos;
                    Console.WriteLine(sData);
                    if (dZaxis_Pos[1] > fZ_Check_Pos)
                    {
                        dZaxis_Measure_Pos[1] = dZaxis_Pos[1];
                        sData = sDay + ",m_iStep = " + m_iStep + ",dZaxis_Pos[1] Check: -> " + dZaxis_Pos[1] + "," + fCurr_CmdPos + "," + dZaxis_Measure_Pos[1];
                        //var result = System.Windows.MessageBox.Show(sData, "Information", System.Windows.MessageBoxButton.OKCancel);
                        var result = System.Windows.MessageBoxResult.OK;
                        if (result == System.Windows.MessageBoxResult.OK)
                        {
                            Console.WriteLine(sData);
                            m_iStep = 117;
                        }
                    }
                    else
                    {
                        CIO.It.Set_Y(m_eOt1, false);
                        CMot.It.Mv_H(m_iZ);
                        Console.WriteLine(sDay + ",m_iStep = " + m_iStep + ",Error !! dZaxis_Pos[1] Miss: -> " + dZaxis_Pos[1] + "," + fCurr_CmdPos);
                        CErr.Show(eErr.LEFT_GRIND_Z_AXIS_MOTOR_ALRAM);
                        return true;
                    }
                }
            }
            else if (m_iStep == 117)// wheel 높이 측정 Up "0"
            {
                sData = (sDay + ",m_iStep = " + m_iStep);
                Console.WriteLine(sData);
                //var result = System.Windows.MessageBox.Show(sData, "Information", System.Windows.MessageBoxButton.OKCancel);
                var result = System.Windows.MessageBoxResult.OK;
                if (result == System.Windows.MessageBoxResult.OK)
                {
                    _Bf_Zaxis_Up(fCurr_Pos,1);
                    _Bf_Start();
                    fZ_Check_Pos = 55.0;
                    m_iStep = 118;
                }
            }
            else if (m_iStep == 118)
            {
                _Bf_GetStatus();
                if (m_mBfStat.State == BufferState.Idle)
                {
                    Bf_Stop();
                    dZaxis_Pos[1] = CMot.It.Get_FP((short)m_iZ);
                    fCurr_CmdPos = CMot.It.Get_CP((short)m_iZ);
                    sData = sDay + ",m_iStep = " + m_iStep + ",dZaxis_Pos[0] Check: " + dZaxis_Pos[0] + "," + fCurr_CmdPos;
                    sData += "\r\n" + sDay + ",m_iStep = " + m_iStep + ",dZaxis_Pos[1] Check: " + dZaxis_Pos[1] + "," + fCurr_CmdPos;
                    Console.WriteLine(sData);
                    if (dZaxis_Pos[1] < fZ_Check_Pos)
                    {
                        m_tTackTime_1 = DateTime.Now - m_tStTime_1;
                        m_tTackTime_2 = DateTime.Now - m_tStTime_0;
                        sData = sDay + ",m_iStep = " + m_iStep + ",dZaxis_Measure_Pos[0] Finish: -> " + dZaxis_Measure_Pos[0] + ",dZaxis_Measure_Pos[1] Finish: -> " + dZaxis_Measure_Pos[1] ;
                        sData += "\r\n" + "Probe - Wheel: -> " + (dZaxis_Measure_Pos[1] - dZaxis_Measure_Pos[0]) ;
                        sData += "\r\n" +  ",m_tTackTime_0:[" + m_tTackTime_0 + "] + m_tTackTime_1:[" + m_tTackTime_1 + "] = m_tTackTime_2:[" + m_tTackTime_2 + "]";

                        var result = System.Windows.MessageBox.Show(sData, "Information", System.Windows.MessageBoxButton.OKCancel);
                        if (result == System.Windows.MessageBoxResult.OK)
                        {
                            Console.WriteLine(sData);
                            m_iStep = 0;
                            return true;
                        }
                    }
                    else
                    {
                        CIO.It.Set_Y(m_eOt1, false);
                        CMot.It.Mv_H(m_iZ);
                        Console.WriteLine(sDay + ",m_iStep = " + m_iStep + ",Error !! dZaxis_Pos[1] Miss: -> " + dZaxis_Pos[1] + "," + fCurr_CmdPos);
                        CErr.Show(eErr.LEFT_GRIND_Z_AXIS_MOTOR_ALRAM);
                        return true;
                    }
                }
            }
            else {
                Console.WriteLine(sDay + ",m_iStep = " + m_iStep + ",_Bf_Ncs_Main() Start");
                m_iStep = 100;
            }
            return false;
        }
        /// <summary>
        /// 버퍼 시퀀스 - 드레싱
        /// </summary>
        /// <param name="iStep"></param>
        private void _Bf_Drs(int iStep)
        {
            int iCnt = CData.DrData[m_iWy].aCnt[iStep];
            //Y축 파라메터
            double dPP1Y = CData.Axes[m_iY].dPP1;
            double dPosY = 0;
            double dVelY = CData.DrData[m_iWy].aParm[iStep].dTblSpd * dPP1Y;
            double dAccY = dVelY * CData.Axes[m_iY].iAccR;
            double dDecY = dVelY * CData.Axes[m_iY].iDecR;
            //Z축 파라메터
            double dPP1Z = CData.Axes[m_iZ].dPP1;            
            double dPosZ = 0;            
            double dVelZ = CData.Axes[m_iZ].tRS.iVel * dPP1Z;
            double dAccZ = CData.Axes[m_iZ].tRS.iAcc * dPP1Z;
            double dDecZ = CData.Axes[m_iZ].tRS.iDec * dPP1Z;

            BufferCondition mBfCon = new BufferCondition();
            mBfCon.Axis = (short)m_iY;
            mBfCon.BufferConditionType = BufferConditionType.RemainingTime;
            mBfCon.Time = 0;

            _Bf_Clear();
            dPosZ = CMot.It.Get_FP(m_iZ) * dPP1Z;
        
            for (int i = 0; i < iCnt; i++)
            {
                CWmx.It.WLib.basicBuffer.Wait(m_nCh, mBfCon);

                dPosY = (i % 2 == 0) ? CData.SPos.dGRD_Y_DrsEnd[m_iWy] : CData.SPos.dGRD_Y_DrsStart[m_iWy];

                dPosY *= dPP1Y;
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.Immediate, (short)m_iY, dPosY, dVelY, dAccY, dDecY);
                //마지막 스텝은 Z축 다운 안함
                if (i != (iCnt - 1))
                {
                    dPosZ += CData.DrData[m_iWy].aParm[iStep].dCycleDep * dPP1Z;
                    CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ, 0, 0, wmxCLRLibrary.TriggerType.RemainingTime, (short)m_iY, BF_TIME);
                }
            }

            CWmx.It.WLib.basicBuffer.Wait(m_nCh, mBfCon);
        }
        /// <summary>
        /// 버퍼 시퀀스 - 드레싱
        /// bDirect : false (ZDn- F-B ZDn ~~ Forward),true (ZDn- F-B ZDn ~~ Backward),
        /// </summary>
        /// <param name="iStep"></param>
        private void _Bf_Drs(int iStep, int nDirect)
        {
            int iCnt = CData.DrData[m_iWy].aCnt[iStep];
            //Y축 파라메터
            double dPP1Y = CData.Axes[m_iY].dPP1;
            double dPosY = 0;
            double dVelY = CData.DrData[m_iWy].aParm[iStep].dTblSpd * dPP1Y;
            double dAccY = dVelY * CData.Axes[m_iY].iAccR;
            double dDecY = dVelY * CData.Axes[m_iY].iDecR;
            //Z축 파라메터
            double dPP1Z = CData.Axes[m_iZ].dPP1;
            double dPosZ = 0;
            double dVelZ = CData.Axes[m_iZ].tRS.iVel * dPP1Z;
            double dAccZ = CData.Axes[m_iZ].tRS.iAcc * dPP1Z;
            double dDecZ = CData.Axes[m_iZ].tRS.iDec * dPP1Z;

            BufferCondition mBfCon = new BufferCondition();
            mBfCon.Axis = (short)m_iY;
            mBfCon.BufferConditionType = BufferConditionType.RemainingTime;
            mBfCon.Time = 0;

            _Bf_Clear();
            dPosZ = CMot.It.Get_FP(m_iZ) * dPP1Z;

            for (int i = 0; i < iCnt; i++)
            {
                CWmx.It.WLib.basicBuffer.Wait(m_nCh, mBfCon);
                dPosY = CData.SPos.dGRD_Y_DrsEnd[m_iWy] * dPP1Y;
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iY, dPosY, dVelY, dAccY, dDecY);
                dPosY = CData.SPos.dGRD_Y_DrsStart[m_iWy] * dPP1Y;
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.Immediate, (short)m_iY, dPosY, dVelY, dAccY, dDecY);

                //마지막 스텝은 Z축 다운 안함
                if (i != (iCnt - 1))
                {
                    dPosZ += CData.DrData[m_iWy].aParm[iStep].dCycleDep * dPP1Z;
                    CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ, 0, 0, wmxCLRLibrary.TriggerType.RemainingTime, (short)m_iY, BF_TIME);
                }
            }
            dPosY = (nDirect == 2) ? CData.SPos.dGRD_Y_DrsEnd[m_iWy] : CData.SPos.dGRD_Y_DrsStart[m_iWy];
            CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iY, dPosY, dVelY, dAccY, dDecY);
            CWmx.It.WLib.basicBuffer.Wait(m_nCh, mBfCon);
        }

        /// <summary>
        /// 버퍼 시퀀스 - 그라인딩
        /// </summary>
        private void _Bf_Grd()
        {
            int iCnt = CData.GrData[m_iWy].aCnt[m_iIndex];
            //Y축 파라메터
            double dPP1Y = CData.Axes[m_iY].dPP1;
            double dPosY = 0;
            double dVelY = 0;
            double dAccY = 0;
            double dDecY = 0;
            //Z축 파라메터
            double dPP1Z = CData.Axes[m_iZ].dPP1;            
            double dPosZ = 0;            
            double dVelZ = CData.Axes[m_iZ].tRS.iVel * dPP1Z;
            double dAccZ = CData.Axes[m_iZ].tRS.iAcc * dPP1Z;
            double dDecZ = CData.Axes[m_iZ].tRS.iDec * dPP1Z;

            double dCyl = 0;
            eStartDir eDir;

            BufferCondition mBfCon = new BufferCondition();
            mBfCon.Axis = (short)m_iY;
            mBfCon.BufferConditionType = BufferConditionType.RemainingTime;
            mBfCon.Time = 0;

            _Bf_Clear();

            if (CData.Dev.bDual == eDual.Normal)
            {
                dVelY = CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].dTblSpd * dPP1Y;
                dCyl = CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].dCycleDep * dPP1Z;
                eDir = CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].eDir;
            }
            else
            {
                dVelY = CData.Dev.aData[m_iWy].aSteps[m_iIndex].dTblSpd * dPP1Y;
                dCyl = CData.Dev.aData[m_iWy].aSteps[m_iIndex].dCycleDep * dPP1Z;
                eDir = CData.Dev.aData[m_iWy].aSteps[m_iIndex].eDir;
            }

            m_dCylZ = dCyl / dPP1Z;

            dAccY = dVelY * CData.Axes[m_iY].iAccR;
            dDecY = dVelY * CData.Axes[m_iY].iDecR;
            dPosZ = CMot.It.Get_FP(m_iZ) * dPP1Z;

            for (int i = 0; i < iCnt; i++)
            {
                CWmx.It.WLib.basicBuffer.Wait(m_nCh, mBfCon);

                if (eDir == eStartDir.Forward)
                { dPosY = (i % 2 == 0) ? CData.Dev.aGrd_Y_End[m_iWy] : CData.Dev.aGrd_Y_Start[m_iWy]; }
                else
                { dPosY = (i % 2 == 0) ? CData.Dev.aGrd_Y_Start[m_iWy] : CData.Dev.aGrd_Y_End[m_iWy]; }

                dPosY *= dPP1Y;
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.Immediate, (short)m_iY, dPosY, dVelY, dAccY, dDecY);
                //마지막 스텝은 Z축 다운 안함
                if (i != (iCnt - 1))
                {
                    dPosZ += dCyl;
                    CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ, 
                                                      0, 0, wmxCLRLibrary.TriggerType.RemainingTime, (short)m_iY, BF_TIME);
                }
            }

            CWmx.It.WLib.basicBuffer.Wait(m_nCh, mBfCon);
        }

        /// <summary>
        /// 버퍼 시퀀스 - 리그라인딩
        /// </summary>
        private void _Bf_GrdRe()
        {
            int iCnt = CData.GrData[m_iWy].aReCnt[m_iIndex];
            //Y축 파라메터
            double dPP1Y = CData.Axes[m_iY].dPP1;
            double dPosY = 0;
            double dVelY = 0;
            double dAccY = 0;
            double dDecY = 0;
            //Z축 파라메터
            double dPP1Z = CData.Axes[m_iZ].dPP1;
            double dPosZ = 0;
            double dVelZ = CData.Axes[m_iZ].tRS.iVel * dPP1Z;
            double dAccZ = CData.Axes[m_iZ].tRS.iAcc * dPP1Z;
            double dDecZ = CData.Axes[m_iZ].tRS.iDec * dPP1Z;

            double dCyl = m_dCylZ * dPP1Z;
            eStartDir eDir;

            BufferCondition mBfCon = new BufferCondition();
            mBfCon.Axis = (short)m_iY;
            mBfCon.BufferConditionType = BufferConditionType.RemainingTime;
            mBfCon.Time = 0;

            _Bf_Clear();

            if (CData.Dev.bDual == eDual.Normal)
            {
                dVelY = CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].dTblSpd * dPP1Y;
                eDir = CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].eDir;
            }
            else
            {
                dVelY = CData.Dev.aData[m_iWy].aSteps[m_iIndex].dTblSpd * dPP1Y;
                eDir = CData.Dev.aData[m_iWy].aSteps[m_iIndex].eDir;
            }

            dAccY = dVelY * CData.Axes[m_iY].iAccR;
            dDecY = dVelY * CData.Axes[m_iY].iDecR;
            dPosZ = CMot.It.Get_FP(m_iZ) * dPP1Z;

            for (int i = 0; i < iCnt; i++)
            {
                CWmx.It.WLib.basicBuffer.Wait(m_nCh, mBfCon);

                if (eDir == eStartDir.Forward)
                { dPosY = (i % 2 == 0) ? CData.Dev.aGrd_Y_End[m_iWy] : CData.Dev.aGrd_Y_Start[m_iWy]; }
                else
                { dPosY = (i % 2 == 0) ? CData.Dev.aGrd_Y_Start[m_iWy] : CData.Dev.aGrd_Y_End[m_iWy]; }

                dPosY *= dPP1Y;
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.Immediate, (short)m_iY, dPosY, dVelY, dAccY, dDecY);
                //마지막 스텝은 Z축 다운 안함
                if (i != (iCnt - 1))
                {
                    dPosZ += dCyl;
                    CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ, 
                                                      0, 0, wmxCLRLibrary.TriggerType.RemainingTime, (short)m_iY, BF_TIME);
                }
            }

            CWmx.It.WLib.basicBuffer.Wait(m_nCh, mBfCon);
        }


        public double t_dPosY1, t_dPosY2, t_dTrig;
        public double t_dVelY, t_dRtoY, t_dCyl;
        public int t_iCnt;

        private void _Bf_Test()
        {
            //Y축 파라메터
            double dPP1Y = CData.Axes[m_iY].dPP1;
            double dPosY = 0;
            t_dVelY *= dPP1Y;
            double dAccY = t_dVelY * t_dRtoY;
            double dDecY = t_dVelY * t_dRtoY;
            //Z축 파라메터
            double dPP1Z = CData.Axes[m_iZ].dPP1;
            double dPosZ = 0;
            double dVelZ = CData.Axes[m_iZ].tRS.iVel * dPP1Z;
            double dAccZ = CData.Axes[m_iZ].tRS.iAcc * dPP1Z;
            double dDecZ = CData.Axes[m_iZ].tRS.iDec * dPP1Z;

            BufferCondition mBfCon = new BufferCondition();
            mBfCon.Axis = (short)m_iY;
            mBfCon.BufferConditionType = BufferConditionType.RemainingTime;
            mBfCon.Time = 0;

            t_dCyl *= dPP1Z;

            _Bf_Clear();

            dPosZ = CMot.It.Get_FP(m_iZ) * dPP1Z;

            for (int i = 0; i < t_iCnt; i++)
            {
                CWmx.It.WLib.basicBuffer.Wait(m_nCh, mBfCon);

                dPosY = (i % 2 == 0) ? t_dPosY2 : t_dPosY1;

                dPosY *= dPP1Y;
                CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.Immediate, (short)m_iY, dPosY, t_dVelY, dAccY, dDecY);
                //마지막 스텝은 Z축 다운 안함
                if (i != (t_iCnt - 1))
                {
                    dPosZ += t_dCyl;
                    CWmx.It.WLib.basicBuffer.StartPos(m_nCh, BufferFinishType.AxisIdle, (short)m_iZ, dPosZ, dVelZ, dAccZ, dDecZ, 
                                                      0, 0, wmxCLRLibrary.TriggerType.RemainingTime, (short)m_iY, t_dTrig);
                }
            }

            CWmx.It.WLib.basicBuffer.Wait(m_nCh, mBfCon);
        }
        #endregion

        public void Chk_PCW()
        {//200624 pjh : Check PCW    
            if (CSQ_Main.It.m_iStat != EStatus.Error && 
                (CSQ_Main.It.m_iStat == EStatus.Idle || CSQ_Main.It.m_iStat == EStatus.Stop))
            {
                if(m_eWy == EWay.L)
                {
                    //double dSplLRpm = CSpl.It.GetFrpm(true);
                    // 2023.03.15 Max
                    double dSplLRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.L));

                    if (dSplLRpm > 0 && !CIO.It.Get_X(eX.GRDL_SplPCW))
                    {
                        //CSpl.It.Write_Stop(EWay.L);
                        // 2023.03.15 Max
                        CSpl_485.It.Write_Stop(m_eWy);

                        CErr.Show(eErr.LEFT_GRIND_SPINDLE_COOLANT_OFF);
                    }
                }
                else
                {
                    //double dSplRRpm = CSpl.It.GetFrpm(false);
                    // 2023.03.15 Max
                    double dSplRRpm = Convert.ToInt32(CSpl_485.It.GetFrpm(EWay.R));

                    if (dSplRRpm > 0 && !CIO.It.Get_X(eX.GRDR_SplPCW))
                    {
                        //CSpl.It.Write_Stop(EWay.R);
                        // 2023.03.15 Max
                        CSpl_485.It.Write_Stop(m_eWy);

                        CErr.Show(eErr.LEFT_GRIND_SPINDLE_COOLANT_OFF);
                    }
                }
            }
        }

        //200814 jhc : 버퍼모드에서 그라인딩/드레싱 카운트 계산
        /// <summary>
        /// 버퍼 모드 동작(그라인딩/드레싱) 중 현재의 반복 회수 확인하기
        /// </summary>
        /// <param name="nMotionStepNum">단위 버퍼 시퀀스 내에서 모션 제어 수</param>
        /// <param name="nTotalCnt">단위 버퍼 시퀀스 반복 회수</param>
        /// <returns></returns>
        public int CalcBfCount(int nMotionStepNum, int nTotalCnt)
        {
            if (nMotionStepNum <= 0)
            { return 0; }

            int iIdx = (int)m_mBfStat.MotionCounter / nMotionStepNum;

            //BufferStatus.blockCount : The remaining number of APIs to be executed
            //BufferStatus.blockIndex : The index of the currently executed API in the buffer
            //BufferStatus.endBlockIndex : The index of the last API in the buffer
            if ((iIdx >= nTotalCnt) || (m_mBfStat.BlockCount <= 0) || (m_mBfStat.BlockIndex == m_mBfStat.EndBlockIndex))
            { iIdx = nTotalCnt; } //200824 jhc :
                                  //{ return nTotalCnt; }

            //200824 jhc : Log
            //200917 jym : 스핀들 부하량 추가
            _SetLog(string.Format("Buf : Count [{0}], BlockIndes[{1}], Y[{2}], Z[{3}],  Load[{4}]  Amp[{5}] Temp[{6}] RPM[{7}] Vac[{8}]",
                                   iIdx.ToString(),
                                   m_mBfStat.BlockIndex.ToString(), 
                                   CMot.It.Get_FP(m_iY).ToString("0.00000"), 
                                   CMot.It.Get_FP(m_iZ).ToString("0.00000"),
                                   CData.Spls[m_iWy].dLoad.ToString(),
                                   CData.Spls[m_iWy].nCurrent_Amp.ToString(),   // CalcBfCount
                                   CData.Spls[m_iWy].dTemp_Val.ToString(),
                                   CData.Spls[m_iWy].iRpm.ToString(),
                                   CData.Parts[m_iPart].dChuck_Vacuum.ToString("0.0")));

            return iIdx;
        }

        //201023 JSKim : Over Grinding Correction - Grinding Count Correction 기능
        private bool OverGrindingCountCorrection()
        {
            bool bResult = false;   // fasle : 보정 불가(해당 Step 에서 Grinding 해야 할 양 보다 오버 양이 크거나 같다)
                                    // true  : 보정 가능 또는 보정 불필요
            int nOldCnt = 0;        // 현재 Grinding Step의 Grinding 횟수 임시 보관
            int nCorrCnt = 0;       // 현재 Grinding Step의 Grinding 횟수에서 차감해야 할 횟수
            int nNewCnt = 0;        // Over Grinding 되었을 경우 재계산된 현재 스텝의 그라인딩 회수

            // 오버 발생 시 Grinding Step Count 보정
            if (m_dRoughOver == 0)
            {
                bResult = true; // 언더 또는 정상 그라인딩 => 보정 불필요
                _SetLog("Normal mode. OverGrinding Correct [PASS] - Not Over", true);
            }
            else
            {
                if (CData.Dev.bDual == eDual.Normal)
                {
                    //210118 jhc : DEBUG
                    //nOldCnt = CData.GrData[(int)EWay.L].aCnt[m_iIndex];
                    nOldCnt = CData.GrData[m_iWy].aCnt[m_iIndex];
                    //..
                    nCorrCnt = Convert.ToInt32((m_dRoughOver + m_ZPosUpOffset) / CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].dCycleDep);
                    nNewCnt = nOldCnt - nCorrCnt;

                    if (nNewCnt > 0)
                    {
                        // 보정 실행 : 해당 Grinding Step에서 Grinding 해야 할 양보다 오버 양이 적다

                        bResult = true; //보정하여 그라인딩

                        //210118 jhc : DEBUG
                        //CData.GrData[(int)EWay.L].aCnt[m_iIndex] = nNewCnt; //보정된 새 카운트로 설정 (현재 스텝 그라인딩 진행)
                        CData.GrData[m_iWy].aCnt[m_iIndex] = nNewCnt; //보정된 새 카운트로 설정 (현재 스텝 그라인딩 진행)
                        //..
                        
                        _SetLog(string.Format("NORMAL mode. OverGrinding Correct [Do Step] - Index : {0}, RoughOver : {1}mm,  Grd Cnt : {2}, Correction Grd Cnt : {3}",
                            m_iIndex, m_dRoughOver, nOldCnt, nNewCnt), true);
                    }
                    else
                    {
                        // 보정 불가 : 해당 Grinding Step에서 Grinding 해야 할 양보다 오버 양이 크거나 같다

                        bResult = false; //현재 스텝 건너뜀

                        // 오버 된 양을 해당 Grinding Step에서 Grinding 해야 할 양을 빼줘서 다음 Grinding Step에서 보정 할 수 있게 남겨 둔다.
                        m_dRoughOver -= (nOldCnt * CData.Dev.aData[(int)EWay.L].aSteps[m_iIndex].dCycleDep);

                        /////////////////////// 이 부분은 삭제 가능성 있음 ///////////////////////
                        if (m_dRoughOver < 0)
                        {
                            m_dRoughOver = 0; //계산 과정에서 발생할 수 있는 다음 스텝 그라인딩 카운트 증가 방지용
                        }
                        ////////////////////////////////////////////////////////////////////////

                        //그라인딩은 진행하지 않지만 각 스텝에서 수행하는 Z축 Up Offset 값 적용만 함
                        if (m_iCnt == 0 && m_iIndex != 0 && m_iIndex != (m_iStepMaxCnt - 1))
                        {
                            //210118 jhc : DEBUG
                            //CData.GrData[(int)EWay.L].aCnt[m_iIndex] = nNewCnt; //재 계산된 카운트로 설정 (화면 표시용, 0 이하 값)
                            CData.GrData[m_iWy].aCnt[m_iIndex] = nNewCnt; //재 계산된 카운트로 설정 (화면 표시용, 0 이하 값)
                            //..
                        }

                        _SetLog(string.Format("NORMAL mode. OverGrinding Correct [Skip Step] - Index : {0}, RoughOver : {1}, Grd Cnt : {2}, Correction Grd Cnt : {3}, m_ZPosUpOffset : {4}",
                            m_iIndex, m_dRoughOver, nOldCnt, nNewCnt, m_ZPosUpOffset), true);
                    }
                }
                else
                {
                    nOldCnt = CData.GrData[m_iWy].aCnt[m_iIndex];
                    nCorrCnt = Convert.ToInt32((m_dRoughOver + m_ZPosUpOffset) / CData.Dev.aData[m_iWy].aSteps[m_iIndex].dCycleDep);
                    nNewCnt = nOldCnt - nCorrCnt;

                    if (nNewCnt > 0)
                    {
                        // 보정 실행 : 해당 Grinding Step에서 Grinding 해야 할 양보다 오버 양이 적다

                        bResult = true; //보정하여 그라인딩

                        CData.GrData[m_iWy].aCnt[m_iIndex] = nNewCnt; //보정된 새 카운트로 설정 (현재 스텝 그라인딩 진행)
                        
                        _SetLog(string.Format("STEP mode. OverGrinding Correct [Do Step] - Index : {0}, RoughOver : {1}mm,  Grd Cnt : {2}, Correction Grd Cnt : {3}",
                            m_iIndex, m_dRoughOver, nOldCnt, nNewCnt), true);
                    }
                    else
                    {
                        // 보정 불가 : 해당 Grinding Step에서 Grinding 해야 할 양보다 오버 양이 크거나 같다

                        bResult = false; //현재 스텝 건너뜀

                        // 오버 된 양을 해당 Grinding Step에서 Grinding 해야 할 양을 빼줘서 다음 Grinding Step에서 보정 할 수 있게 남겨 둔다.
                        m_dRoughOver -= (nOldCnt * CData.Dev.aData[m_iWy].aSteps[m_iIndex].dCycleDep);

                        /////////////////////// 이 부분은 삭제 가능성 있음 ///////////////////////
                        if (m_dRoughOver < 0)
                        {
                            m_dRoughOver = 0; //계산 과정에서 발생할 수 있는 다음 스텝 그라인딩 카운트 증가 방지용
                        }
                        ////////////////////////////////////////////////////////////////////////

                        //그라인딩은 진행하지 않지만 각 스텝에서 수행하는 Z축 Up Offset 값 적용만 함
                        if (m_iCnt == 0 && m_iIndex != 0 && m_iIndex != (m_iStepMaxCnt - 1))
                        {
                            CData.GrData[m_iWy].aCnt[m_iIndex] = nNewCnt; //재 계산된 카운트로 설정 (화면 표시용, 0 이하 값)
                        }

                        _SetLog(string.Format("STEP mode. OverGrinding Correct [Skip Step] - Index : {0}, RoughOver : {1}, Grd Cnt : {2}, Correction Grd Cnt : {3}, m_ZPosUpOffset : {4}",
                            m_iIndex, m_dRoughOver, nOldCnt, nNewCnt, m_ZPosUpOffset), true);
                    }
                }
            }

            return bResult;
        }
        //


        //201225 jhc : 고급 Grind Condition 설정/체크 기능 (Spindle Current, Table Vacuum Low Limit 설정)
        #region 고급 Grind Condition 설정/체크 기능
        /// <summary>
        /// 고급 Grind Condition 체크 플래그 리셋(초기화) => 검사 안 하는 상태로 전환
        /// 만약, 검사 후 Limit Over 조건 발생하여 해당 정보 처리가 별도로 필요할 경우, 반드시 해당 정보 별도 저장 또는 처리 후 ResetAdvancedGrindCondition(int mode, false) 호출해야 함
        /// </summary>
        /// <param name="mode">동작설정 0: 그라인딩, 1: 드레싱</param>
        /// <param name="bCycleStart">Range 체크 시작 플래그, true: 시작(초기화), false: 종료(초기화 않고 마지막 값 유지)</param>
        public void ResetAdvancedGrindCondition(int mode, bool bCycleStart)
        {
            if (bCycleStart)
            {
                //1) Limit Over 상태 초기화 먼저
                ClearAdvancedGrindConditionError();

                //2) 체크 시작 CASE : MIN/MAX 초기값 설정 후
                CData.GrData[m_iWy].dTableVacuumMin = GV.TABLE_VACUUM_MAX;          //Grinding 중 Table Vacuum 최저값 ((-)값, 그라인딩 시 체크, 그라인딩 중 이 값이 변동될 경우 두께 불균일 가능성 있음)
                CData.GrData[m_iWy].nSpindleCurrentMin = GV.SPINDLE_CURRENT_MAX;    //Grinding 중 Spindle 전류 최소값 (그라인딩 또는 드레싱 시 체크, 향 후 사용 가능성 고려한 변수)
                CData.GrData[m_iWy].nSpindleCurrentMax = 0;                         //Grinding 중 Spindle 전류 최대값 (그라인딩 또는 드레싱 시 체크)

                //3) 체크 플래그 설정
                if (mode == 0)
                {
                    CData.GrData[m_iWy].bCheckGrindCondition = true; //고급 설정 범위 체크 시작 (그라인딩 용)
                }
                else
                {
                    CData.GrData[m_iWy].bCheckDressCondition = true; //고급 설정 범위 체크 시작 (드레싱 용)
                }
            }
            else
            {
                //1) 체크 종료 CASE : 체크 플래그 리셋(해제)
                CData.GrData[m_iWy].bCheckGrindCondition = false;   //고급 설정 범위 체크 중지 (그라인딩 용)
                CData.GrData[m_iWy].bCheckDressCondition = false;   //고급 설정 범위 체크 중지 (드레싱 용)

                //2) MIN/MAX 현재값 유지

                //3) Limit Over 상태 초기화 (Alarm 발생 후)
                //m_bStateTableVacuumLow = false; //201231
                //m_bErrTableVacuumLow = false;
                //m_bErrSpindleCurrentLow = false;
                //m_bErrSpindleCurrentHigh = false;
            }

            string s1 = (mode == 0) ? "GRIND" : "DRESS";
            string s2 = (bCycleStart) ? "BEGIN" : "END";
            _SetLog(string.Format("Advanced {0} Condition Check {1}", s1, s2));
        }

        /// <summary>
        /// Limit Over 상태 초기화 (Spindle Current Low/High, Table Vacuum Low Limit)
        /// </summary>
        private void ClearAdvancedGrindConditionError()
        {
            //Limit Over 상태 초기화 (Alarm 발생 후)
            m_bStateTableVacuumLow = false; //201231
            m_bErrTableVacuumLow = false;
            m_bErrSpindleCurrentLow = false;
            m_bErrSpindleCurrentHigh = false;
        }

        /// <summary>
        /// 그라인딩/드레싱 중 스핀들 전류 상/하한 범위 체크, 테이블 버큠 하한 체크
        /// 그라인딩/드레싱 사이클 초기에 매번 실행되는 부분에서 호출되도록 배치해야 함
        /// </summary>
        /// <param name="mode">동작설정 0: Grind, 1: Dress</param>
        /// <returns>0: 정상, -1: Table Vacuum Lower Limit Under, -2: Spindle Current Upper Limit Over, -3: Spindle Current Lower Limit Under</returns>
        private int CheckAdvancedGrindCondition(int mode)
        {
            int result = 0;
            double dTableVac = CData.Parts[m_iPart].dChuck_Vacuum;

            //if (CDataOption.UseDeviceAdvancedOption && CDataOption.UseAdvancedGrindCondition && (CDataOption.SplType == eSpindleType.EtherCat)) //Advanced Grind Condition 체크 사용 조건 (라이선스)
            // 2023.03.15 Max
            if (CDataOption.UseDeviceAdvancedOption && CDataOption.UseAdvancedGrindCondition)
            {
                if (((mode == 0) && (!CData.GrData[m_iWy].bCheckGrindCondition)) || ((mode == 1) && (!CData.GrData[m_iWy].bCheckDressCondition)))
                {
                    //CASE 1 : 아직 조건 체크 시작(Step 10)하지 않았으나, Cycle() function 시작 부분에서 반복되는 시점 => Error를 발생시키면 안 됨
                    //CASE 2 : 조건 체크 진행 그라인딩/드레싱 작업 완료, 체크 플래그 초기화(ResetAdvancedGrindCondition()) 후 나머지 스텝 처리 위해 시퀀스 재 진입 시 Cycle() function 시작 부분에서 반복되는 시점 => Error를 발생시키면 안 됨
                    //         => 만약, 검사 후 Limit Over 조건 발생하여 해당 정보 처리가 별도로 필요할 경우, 반드시 해당 정보 별도 저장 또는 처리 후 검사 플래그 리셋(ResetAdvancedGrindCondition(int mode, false)) 해야 함
                    return (0);
                }

                //1) 테이블 버큠 체크
                if (CData.GrData[m_iWy].bCheckGrindCondition && (CData.Dev.aData[m_iWy].dTableVacuumGrindLimit < 0)) //정상 버큠은 (-) 값 => 버큠 리밋도 (-) 값
                {
                    ///////////////////////////
                    // Table Vacuum 체크 조건 //

                    //201231 : 실시간 체크 값과 비교 (순간적으로 낮아지는 값이 발생할 수 있으므로, 이력용 최저값과 비교하면 안 됨)
                    if (CData.Dev.aData[m_iWy].dTableVacuumGrindLimit < dTableVac) //if ((CData.Dev.aData[m_iWy].dTableVacuumGrindLimit < CData.GrData[m_iWy].dTableVacuumMin)) //정상 버큠은 (-) 값 => 버큠 리밋도 (-) 값
                    //..
                    {
                        ///////////////////////////////////
                        // Table Vacuum Lower Limit 미만 //

                        //201231
                        if (0 < CData.Dev.aData[m_iWy].dTableVacuumLowHoldTime)
                        {
                            //////////////////////////////////////////////////////////////////////////////
                            // Table Vacuum Lower Hold Time 적용될 경우 : Lower Limit 미만 유지 시간 체크 //

                            if (m_bStateTableVacuumLow)
                            {
                                if (true == m_TableVacLowDelay.Chk_Delay())
                                {
                                    ///////////////////////////////////////////////////////////////////////
                                    // Table Vacuum Lower Limit 미만 유지, Hold Time 초과 => 드디어 Error //
                                    m_bErrTableVacuumLow = true; //자재 흡착 불량 => 그라인딩 두께 불균일 가능성
                                    m_bStateTableVacuumLow = false;
                                    //m_dTableVacuumMin = GV.TABLE_VACUUM_MAX; //201231

                                    _SetLog(string.Format("[E] Error : Table Vacuum Lower Limit[{0}] : Hold Time[{1}] Exceeded.",
                                            CData.Dev.aData[m_iWy].dTableVacuumGrindLimit.ToString("0.0"),
                                            CData.Dev.aData[m_iWy].dTableVacuumLowHoldTime.ToString("0.000")));
                                }
                                else
                                {
                                    ///////////////////////////////////////////////////////////////////////////////////////////
                                    // Table Vacuum Lower Limit 미만 유지하고 있으나, 아직 Hold Time 초과 안 함 : 아직 No Error //

                                    //_SetLog(string.Format("Table Vacuum Lower Limit[{0} kPa] Under[{1} kPa] => Not Over Hold Time[{2} s]",
                                    //        CData.Dev.aData[m_iWy].dTableVacuumGrindLimit.ToString("0.0"),
                                    //        dTableVac.ToString("0.0"),
                                    //        CData.Dev.aData[m_iWy].dTableVacuumLowHoldTime.ToString("0.000")));
                                }
                            }
                            else
                            {
                                ////////////////////////////////////////////////////////////////////
                                // Table Vacuum Lower Limit 미만 최초인 경우 :  Hold Time 체크 시작 //
                                m_bStateTableVacuumLow = true; //다음 체크될 때 Hold Time 비교
                                m_TableVacLowDelay.Set_Delay((int)(1000*CData.Dev.aData[m_iWy].dTableVacuumLowHoldTime)); //Set Hold Time

                                _SetLog(string.Format("[S] Table Vacuum Lower Limit[{0} kPa] Under[{1} kPa] => Start Checking Hold Time[{2} s]",
                                        CData.Dev.aData[m_iWy].dTableVacuumGrindLimit.ToString("0.0"),
                                        dTableVac.ToString("0.0"),
                                        CData.Dev.aData[m_iWy].dTableVacuumLowHoldTime.ToString("0.000")));
                            }
                        }
                        else
                        {
                            ////////////////////////////////////////////////////////////
                            // Table Vacuum Lower Hold Time 비 적용 경우 => 즉시 Error //
                            _SetLog(string.Format("[I] Table Vacuum Lower Limit[{0} kPa] Under[{1} kPa] => No Hold Time(Error Immediately)",
                                        CData.Dev.aData[m_iWy].dTableVacuumGrindLimit.ToString("0.0"),
                                        dTableVac.ToString("0.0")));

                            m_bErrTableVacuumLow = true; //자재 흡착 불량 => 그라인딩 두께 불균일 가능성
                            m_bStateTableVacuumLow = false;
                        }
                    }
                    else
                    {
                        ///////////////////////
                        // Table Vacuum 정상 //

                        if (m_bStateTableVacuumLow)
                        {
                            _SetLog(string.Format("[G] Table Vacuum Lower Limit[{0} kPa] Over[{1} kPa] => Stop Checking Hold Time",
                                        CData.Dev.aData[m_iWy].dTableVacuumGrindLimit.ToString("0.0"),
                                        dTableVac.ToString("0.0")));
                        }
                        m_bStateTableVacuumLow = false; //201231 : Table Vacuum Lower 돌파 상태 초기화
                    }
                }

                if (CData.GrData[m_iWy].bCheckGrindCondition || CData.GrData[m_iWy].bCheckDressCondition) //체크 플래그 설정 확인(더블체크 : 조건 검사 타이밍이 아닌 경우 검사하지 않도록)
                {
                    //2) 스핀들 전류 체크
                    if (mode == 0)
                    {
                        //그라인딩 시
                        if ((CData.Dev.aData[m_iWy].nSpindleCurrentGrindHigh > 0) && (CData.Dev.aData[m_iWy].nSpindleCurrentGrindHigh < CData.GrData[m_iWy].nSpindleCurrentMax))
                        {
                            m_bErrSpindleCurrentHigh = true; //스핀들 과부하
                        }
                        if ((CData.Dev.aData[m_iWy].nSpindleCurrentGrindLow > 0) && (CData.GrData[m_iWy].nSpindleCurrentMin < CData.Dev.aData[m_iWy].nSpindleCurrentGrindLow))
                        {
                            m_bErrSpindleCurrentLow = true; //Air-cut 중 발생 가능성 농후함 => 전류 Low Limit 적용은 실시간 확인보다는 그라인딩 후 점검 용으로 사용하는 것이 옳을 듯!!!
                        }
                    }
                    else
                    {
                        //드레싱 시
                        if ((CData.Dev.aData[m_iWy].nSpindleCurrentDressHigh > 0) && (CData.Dev.aData[m_iWy].nSpindleCurrentDressHigh < CData.GrData[m_iWy].nSpindleCurrentMax))
                        {
                            m_bErrSpindleCurrentHigh = true; //스핀들 과부하
                        }
                        if ((CData.Dev.aData[m_iWy].nSpindleCurrentDressLow > 0) && (CData.GrData[m_iWy].nSpindleCurrentMin < CData.Dev.aData[m_iWy].nSpindleCurrentDressLow))
                        {
                            m_bErrSpindleCurrentLow = true; //Air-cut 중 발생 가능성 농후함 => 전류 Low Limit 적용은 실시간 확인보다는 그라인딩 후 점검 용으로 사용하는 것이 옳을 듯!!!
                        }
                    }

                    ////////////////////////////////
                    // 체크 결과에 따른 리턴값 결정 //
                    ////////////////////////////////

                    if (m_bErrTableVacuumLow)          { result = -1; } //테이블 버큠 부족
                    else if (m_bErrSpindleCurrentHigh) { result = -2; } //스핀들 전류 과부하
                    else if (m_bErrSpindleCurrentLow)  { result = -3; } //스핀들 전류 낮음
                }

                return result;
            }
            else
            {
                return (0);
            }
        }
        #endregion
        //..


        // 2021.08.01 lhs Start : UseNewSckGrindProc용 (SCK 전용)
        /// <summary>
        /// Top/Btm/TopD/BtmS 별로 TopMold, BtmMold 계산 함수
        /// </summary>
        /// <param name="dMax"></param>
        /// <param name="dAvg"></param>
        private void CalcTopMoldBtmMold(int iBfAf, double dMax, double dAvg)
        {
			double dPcbMean    = CData.Parts[m_iPart].dPcbMean;
			double dTopMoldAvg = CData.Parts[m_iPart].dTopMoldAvg; // 계산시 Avg만 이용
			double dBtmMoldAvg = CData.Parts[m_iPart].dBtmMoldAvg; // 계산시 Avg만 이용
            double dTopMoldMax = CData.Parts[m_iPart].dTopMoldMax;
            double dBtmMoldMax = CData.Parts[m_iPart].dBtmMoldMax;

            string sMsg;
            sMsg    =   (m_eWy == EWay.L) ? "Left Table, "       : "Right Table, ";
            sMsg    +=  (iBfAf == 0)      ? "Before Measure, "   : "After Measure, ";
            sMsg    +=  string.Format("m_iPart = {0}, ", m_iPart);
            _SetLog(sMsg);
            
            sMsg    =  string.Format("Input Data : PcbMean = {0}, TopMoldAvg = {1}, TopMoldMax = {2}, BtmMoldAvg = {3}, BtmMoldMax = {4}", 
                                                   dPcbMean,      dTopMoldAvg,      dTopMoldMax,      dBtmMoldAvg,      dBtmMoldMax);
            _SetLog(sMsg);  

            // TopMold, BtmMold를 계산하자
            bool bPcbErr  = false;
			bool bMoldErr = false;

            if (CData.Dev.aData[m_iWy].eBaseOnThick == EBaseOnThick.Total)
			{
                // 계산할 수 있을까?
                _SetLog("Base on thickness : Total");
            }
			else  // Mold 기준
			{
                _SetLog("Base on thickness : Mold");

                // 만약 Pcb = 0 이고 Limit 적용시 에러처리 하자 
                if (dPcbMean <= 0 && CData.Dynamic.dPcbRange != 0)
                {
                    bPcbErr = true;
                    _SetLog(string.Format("Pcb Error : PcbRange Apply, Pcb = {0}", dPcbMean));
                }

                bool bApplyLimit = false;
                if (iBfAf == 0) { bApplyLimit = CData.Dev.aData[m_iWy].dBfLimit != 0; }
                else            { bApplyLimit = CData.Dev.aData[m_iWy].dAfLimit != 0; }

                sMsg = ""; //클리어

                if (CData.Dev.eMoldSide == ESide.Top)
				{
					CData.Parts[m_iPart].dTopMoldAvg = dAvg;
					CData.Parts[m_iPart].dTopMoldMax = dMax;
					CData.Parts[m_iPart].dBtmMoldAvg = 0;
					CData.Parts[m_iPart].dBtmMoldMax = 0;

                    sMsg = "TopS ";
				}
				else if (CData.Dev.eMoldSide == ESide.BtmS)  // Single
				{
					CData.Parts[m_iPart].dBtmMoldAvg = dAvg;
					CData.Parts[m_iPart].dBtmMoldMax = dMax;
					CData.Parts[m_iPart].dTopMoldAvg = 0;
					CData.Parts[m_iPart].dTopMoldMax = 0;

                    sMsg = "BtmS ";
                }
				else if (CData.Dev.eMoldSide == ESide.TopD) // Double
				{
					if (dTopMoldAvg <= 0 && dBtmMoldAvg <= 0 && bApplyLimit) 
                    { 
                        bMoldErr = true;
                        _SetLog("Mold Error : dTopMoldAvg <= 0 && dBtmMoldAvg <= 0 && bApplyLimit");
                    }

					// 이전에 Top Single(MTM/Grinding)이었다면 Pcb, TopMold의 값만 알 수 있고 BtmMold는 알 수 없으므로 계산을 해야 함.
					if (dPcbMean > 0 && dTopMoldAvg > 0 && dBtmMoldAvg == 0) 
					{
                        dBtmMoldAvg = m_listBtmMoldTh.Average();    // 이전에 Add한 List에서 Avg를 얻자
                        dBtmMoldMax = m_listBtmMoldTh.Max();        // 이전에 Add한 List에서 Max를 얻자
						_SetLog(string.Format("Top Double Side : calculated BtmMold Avg = {0}, BtmMold Max = {1}", dBtmMoldAvg, dBtmMoldMax));
					}
					CData.Parts[m_iPart].dTopMoldAvg = dAvg;
					CData.Parts[m_iPart].dTopMoldMax = dMax;
					CData.Parts[m_iPart].dBtmMoldAvg = dBtmMoldAvg;
					CData.Parts[m_iPart].dBtmMoldMax = dBtmMoldMax;

                    sMsg = "TopD ";
                }
				else if (CData.Dev.eMoldSide == ESide.Btm)  // Double
				{
					if (dTopMoldAvg <= 0 && dBtmMoldAvg <= 0 && bApplyLimit) 
                    {
                        bMoldErr = true;
                        _SetLog("Mold Error : dTopMoldAvg <= 0 && dBtmMoldAvg <= 0 && bApplyLimit");
                    }
                    // 이전에 Btm Single(MTM/Grinding)이었다면 Pcb, BtmMold의 값만 알 수 있고 TopMold는 알 수 없으므로 계산을 해야 함.
                    if (dPcbMean > 0 && dBtmMoldAvg > 0 && dTopMoldAvg == 0)
					{
                        dTopMoldAvg = m_listTopMoldTh.Average();    // 이전에 Add한 List에서 Avg를 얻자
                        dTopMoldMax = m_listTopMoldTh.Max();        // 이전에 Add한 List에서 Max를 얻자
						_SetLog(string.Format("Btm Double Side : calculated TopMold Avg = {0}, TopMold Max = {1}", dTopMoldAvg, dTopMoldMax));
					}
					CData.Parts[m_iPart].dBtmMoldAvg = dAvg;
					CData.Parts[m_iPart].dBtmMoldMax = dMax;
					CData.Parts[m_iPart].dTopMoldAvg = dTopMoldAvg;
					CData.Parts[m_iPart].dTopMoldMax = dTopMoldMax;

                    sMsg = "BtmD ";
                }
			}//end : else // Mold

            sMsg += string.Format("Output Data : PcbMean = {0}, TopMoldAvg = {1}, TopMoldMax = {2}, BtmMoldAvg = {3}, BtmMoldMax = {4}",
                                                CData.Parts[m_iPart].dPcbMean,
                                                CData.Parts[m_iPart].dTopMoldAvg,
                                                CData.Parts[m_iPart].dTopMoldMax,
                                                CData.Parts[m_iPart].dBtmMoldAvg,
                                                CData.Parts[m_iPart].dBtmMoldMax);
            _SetLog(sMsg);

            // 모든 값이 0보다 작으면 에러 처리
            if (CData.Parts[m_iPart].dPcbMean    < 0)   { bPcbErr = true; }
            if (CData.Parts[m_iPart].dTopMoldAvg < 0 ||
                CData.Parts[m_iPart].dTopMoldMax < 0 ||
                CData.Parts[m_iPart].dBtmMoldAvg < 0 ||
                CData.Parts[m_iPart].dBtmMoldMax < 0)   { bMoldErr = true; }

            // 에러처리 : Pcb, Topmold, btmMold
            if (bPcbErr || bMoldErr)
			{
                if (iBfAf == (int)EMeaStep.Before/*0*/)
                {
                    if (m_eWy == EWay.L) m_bMeaErrBf_L = true;
                    if (m_eWy == EWay.R) m_bMeaErrBf_R = true;
                }
                else
                {
                    if (m_eWy == EWay.L) m_bMeaErrAf_L = true;
                    if (m_eWy == EWay.R) m_bMeaErrAf_R = true;
                }

                if (bPcbErr)    _SetLog(string.Format("SideMode = {0}, BfAf = {1}, Pcb error. Pcb thick = {2}", CData.Dev.eMoldSide, iBfAf, dPcbMean));
				if (bMoldErr)   _SetLog(string.Format("SideMode = {0}, BfAf = {1}, TopMold or BtmMold error. TopMold thick = {2}, BtmMold thick= {3}", CData.Dev.eMoldSide, iBfAf, dTopMoldAvg, dBtmMoldAvg));
			}
			//-------------------------------
		}
        // 2021.08.01 lhs End : UseNewSckGrindProc용 (SCK 전용)

        //220801 pjh : Pump Error Check용 함수
        public int ChkPumpErr()
        {
            int iRet = 0;

            if(m_eWy == EWay.L)
            {
                if      (!CIO.It.Get_X(eX.PUMPL_FlowLow))  iRet = 1;
                else if (!CIO.It.Get_X(eX.PUMPL_TempHigh)) iRet = 2;
                else if (!CIO.It.Get_X(eX.PUMPL_OverLoad)) iRet = 3;
            }
            else
            {
                if      (!CIO.It.Get_X(eX.PUMPR_FlowLow))  iRet = 4;
                else if (!CIO.It.Get_X(eX.PUMPR_TempHigh)) iRet = 5;
                else if (!CIO.It.Get_X(eX.PUMPR_OverLoad)) iRet = 6;
            }

            return iRet;
        }
        //


        // 2020-12-14, jhLee ===============================================================================
        #region 미사용 함수 삭제
        ///// <summary>
        ///// 스트립 1 포인트 측정 함수 (자재 그라인딩 중 사용)
        ///// </summary>
        ///// <returns></returns>
        //public bool Cyl_MeaOne()
        //{//m_dInspGrd 결과 값 들어감 
        //    // Timeout check
        //    if (m_iPreStep != m_iStep)
        //    { m_mTimeout.Set_Delay(TIMEOUT); }
        //    else
        //    {
        //        if (m_mTimeout.Chk_Delay())
        //        {
        //            if (m_eWy == EWay.L)
        //            { CErr.Show(eErr.LEFT_GRIND_STRIP_INSPECTION_ONE_TIMEOUT); }
        //            else
        //            { CErr.Show(eErr.RIGHT_GRIND_STRIP_INSPECTION_ONE_TIMEOUT); }
        //            _SetLog("Error : Timeout.");

        //            m_iStep = 0;
        //            return true;
        //        }
        //    }

        //    // 191121 ghk_display_strip
        //    if (CDataOption.Package == ePkg.Strip)
        //    {
        //        if (!Chk_Strip())
        //        {
        //            if (m_eWy == EWay.L)
        //            { CErr.Show(eErr.LEFT_GRIND_VACUUM_ERROR); }
        //            else
        //            { CErr.Show(eErr.RIGHT_GRIND_VACUUM_ERROR); }
        //            _SetLog("Error : Vacuum fail.");

        //            m_iStep = 0;
        //            return true;
        //        }
        //    }
        //    else
        //    {   // 200317 mjy : 조건 추가
        //        if (!Chk_Unit())
        //        {
        //            if (m_eWy == EWay.L)
        //            { CErr.Show(eErr.LEFT_GRIND_VACUUM_ERROR); }
        //            else
        //            { CErr.Show(eErr.RIGHT_GRIND_VACUUM_ERROR); }
        //            _SetLog("Error : Vacuum fail.");

        //            m_iStep = 0;
        //            return true;
        //        }
        //    }

        //    m_iPreStep = m_iStep;

        //    switch (m_iStep)
        //    {
        //        default:
        //            {
        //                m_iStep = 0;
        //                return true;
        //            }

        //        case 10:
        //            {// 축 상태 체크
        //                // 200722 jym : 스핀들 정지 체크
        //                // 2020.11.23_1 JSKim St
        //                //if (!Chk_Spl())
        //                //{
        //                //    CSpl.It.Write_Stop(m_eWy);
        //                //    return false;
        //                //}
        //                if (CData.Opt.bWheelStopWaitSkip == false)
        //                {
        //                    if (!Chk_Spl())
        //                    {
        //                        CSpl.It.Write_Stop(m_eWy);
        //                        return false;
        //                    }
        //                }
        //                // 2020.11.23_1 JSKim Ed

        //                if (Chk_Axes())
        //                {
        //                    m_iStep = 0;
        //                    return true;
        //                }
        //                _SetLog("Check axes.");

        //                m_iStep++;
        //                return false;
        //            }

        //        case 11:
        //            {// IO 초기화
        //                _InitCycle();
        //                _SetLog("Init cycle.");

        //                m_iStep++;
        //                return false;
        //            }

        //        case 12:
        //            {//데이터 저장 변수 초기화
        //                m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - GV.EQP_TABLE_MIN_THICKNESS;

        //                if (m_eWy == EWay.L)
        //                {
        //                    m_eOt1 = eY.GRDL_ProbeDn;
        //                    m_eOt2 = eY.GRDL_ProbeAir;
        //                }
        //                else
        //                {
        //                    m_eOt1 = eY.GRDR_ProbeDn;
        //                    m_eOt2 = eY.GRDR_ProbeAir;
        //                }

        //                _SetLog("Measure Z axis position.", m_dPosZ);

        //                m_iStep++;
        //                return false;
        //            }

        //        case 13:
        //            {//Z축 테이블 측정 위치로 이동
        //                CMot.It.Mv_N(m_iZ, m_dPosZ);
        //                _SetLog("Z axsi move position.", m_dPosZ);

        //                m_iStep++;
        //                return false;
        //            }

        //        case 14:
        //            {//Z축 테이블 측정 위치 이동 확인, Y축 테이블 상단 측정 위치 이동
        //                if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
        //                { return false; }

        //                CMot.It.Mv_N(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]);
        //                _SetLog("Y axis move table inspection.", CData.SPos.dGRD_Y_TblInsp[m_iWy]);

        //                m_iStep++;
        //                return false;
        //            }

        //        case 15:
        //            {//Y축 테이블 상단 측정 위치 이동 확인, X축 0으로 이동
        //                if (!CMot.It.Get_Mv(m_iY, CData.SPos.dGRD_Y_TblInsp[m_iWy]))
        //                { return false; }

        //                CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
        //                _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

        //                m_iStep++;
        //                return false;
        //            }

        //        case 16:
        //            {//X축 0으로 이동, 프로브 에어 온
        //                if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
        //                { return false; }

        //                Func_PrbAir(true);
        //                _SetLog("Porbe air on.");

        //                m_iStep++;
        //                return false;
        //            }

        //        case 17:
        //            {//프로브 에어 온 확인, 프로브 다운
        //                if (CIO.It.Get_Y(m_eOt2))
        //                {
        //                    Func_PrbDown(true);
        //                    _SetLog("Probe down.");

        //                    m_iStep++;
        //                }

        //                return false;
        //            }

        //        case 18:
        //            {//프로브 다운 확인, 프로브 에어 오프
        //                if (Func_PrbDown(true))
        //                {
        //                    Func_PrbAir(false);
        //                    m_tmPrb.Set_Delay(GV.PRB_DELAY);
        //                    _SetLog("Porbe air off.  Set delay : " + GV.PRB_DELAY + "ms");

        //                    m_iStep++;
        //                }

        //                return false;
        //            }

        //        case 19:
        //            {//프로브 에어 오프 확인, 프로브 값 획득 후 테이블 높이 계산
        //                if (Func_PrbAir(false) && m_tmPrb.Chk_Delay())
        //                {
        //                    double dVal = CPrb.It.Read_Val(m_eWy);
        //                    _SetLog("Probe value : " + dVal + "mm");

        //                    CData.Tbl_Af[m_iWy, 0] = dVal + GV.EQP_TABLE_MIN_THICKNESS;
        //                    m_dPosZ = CData.MPos[m_iWy].dZ_TBL_BASE - CData.Tbl_Af[m_iWy, 0];
        //                    _SetLog("Table thickness : " + CData.Tbl_Af[m_iWy, 0] + "mm", m_dPosZ);

        //                    m_iStep++;
        //                }

        //                return false;
        //            }

        //        case 20:
        //            {//프로브 업  == 테이블 측정 ==
        //                Func_PrbDown(false);
        //                m_tmPrb.Set_Delay(GV.PRB_DELAY);
        //                _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

        //                m_iStep++;
        //                return false;
        //            }

        //        case 21:
        //            {//프로브 업 확인, Z축 자재 측정 위치로 이동

        //                //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
        //                bool   bProbeUp  = Func_PrbDown(false);
        //                double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값
        //                if (bProbeUp && (dProbeVal >= GV.dProbeUpHeight) && m_tmPrb.Chk_Delay())
        //                {
        //                    CMot.It.Mv_N(m_iZ, m_dPosZ);
        //                    _SetLog("Z axis move position.", m_dPosZ);

        //                    m_iStep++;
        //                }

        //                return false;
        //            }

        //        case 22:
        //            {//Z축 자재 측정 위치로 이동 확인, Y축 자재 측정 포지션으로 이동
        //                if (!CMot.It.Get_Mv(m_iZ, m_dPosZ))
        //                { return false; }

        //                if (CDataOption.Package == ePkg.Strip)
        //                {
        //                    m_dPosY = CData.Dev.aData[m_iWy].aPosBf[(CData.Dev.iRow / 2), 0].dY;
        //                }
        //                else
        //                {   // 200317 mjy : Unit 일때 마지막 Unit 번호 찾아 측정
        //                    int iUnit = Cal_LastU();
        //                    m_dPosY = CData.MPos[m_iWy].dY_PRB_TBL_CENTER + CData.Dev.aUnitCen[iUnit];
        //                }

        //                CMot.It.Mv_N(m_iY, m_dPosY);
        //                _SetLog("Y axis move position.", m_dPosY);

        //                m_iStep++;
        //                return false;
        //            }

        //        case 23:
        //            {//Y축 자재 측정 포지션 이동 확인, 프로브 에어 온
        //                if (!CMot.It.Get_Mv(m_iY, m_dPosY))
        //                { return false; }

        //                Func_PrbAir(true);
        //                _SetLog("Probe air on.");

        //                m_iStep++;
        //                return false;
        //            }

        //        case 24:
        //            {//프로브 에어 온 확인, 프로브 다운
        //                if (Func_PrbAir(true))
        //                {
        //                    Func_PrbDown(true);
        //                    m_tmPrb.Set_Delay(GV.PRB_DELAY);
        //                    _SetLog("Probe down.  Set delay : " + GV.PRB_DELAY + "ms");

        //                    m_iStep++;
        //                }

        //                return false;
        //            }

        //        case 25:
        //            {//프로브 다운 확인, 프로브 에어 오프
        //                if (Func_PrbDown(true) && m_tmPrb.Chk_Delay())
        //                {
        //                    Func_PrbAir(false);
        //                    m_tmPrb.Set_Delay(GV.PRB_DELAY);
        //                    _SetLog("Probe air off.  Set delay : " + GV.PRB_DELAY + "ms");

        //                    m_iStep++;
        //                }

        //                return false;
        //            }

        //        case 26:
        //            {//프로브 에어 오프 확인, 프로브 값 읽어서 자재 측정값 저장, 프로브 업
        //                if (Func_PrbAir(false) && m_tmPrb.Chk_Delay())
        //                {
        //                    // 2020.09.11 JSKim St
        //                    //if (CData.Dev.bDynamicSkip)
        //                    if (CData.Dev.bDynamicSkip || CData.Dev.eMoldSide == ESide.TopD) //20200825 lks
        //                    // 2020.09.11 JSKim Ed
        //                    {//다이나믹 펑션 스킵
        //                        m_PbOfset = CPrb.It.Read_Val(m_eWy);
        //                        _SetLog("DF skip.  Probe value : " + m_PbOfset + "mm");

        //                        //191018 ksg :
        //                        if ((CData.Dev.bDual == eDual.Normal))
        //                        {
        //                            if (CData.Dev.aData[(int)EWay.L].dOneLimit > 0)
        //                            {
        //                                if (CData.GrData[m_iWy].aOldOnPont[0] < (m_PbOfset - CData.Dev.aData[(int)EWay.L].dOneLimit))
        //                                { m_WrongCalFlag = true; }
        //                                else
        //                                { CData.GrData[m_iWy].aOldOnPont[0] = m_PbOfset; }
        //                                //191022 ksg :
        //                                double Gap = CData.GrData[m_iWy].aOldOnPont[0] - m_PbOfset;
        //                                _SetLog(string.Format("Normal.  Old : {0}mm  New : {1}mm  Gap : {2}mm", CData.GrData[m_iWy].aOldOnPont[0], m_PbOfset, Gap));
        //                            }
        //                        }
        //                        else
        //                        {
        //                            if (CData.Dev.aData[m_iWy].dOneLimit > 0)
        //                            {
        //                                if (CData.GrData[m_iWy].aOldOnPont[0] < (m_PbOfset - CData.Dev.aData[m_iWy].dOneLimit))
        //                                { m_WrongCalFlag = true; }
        //                                else
        //                                { CData.GrData[m_iWy].aOldOnPont[0] = m_PbOfset; }
        //                                //191022 ksg :
        //                                double Gap = CData.GrData[m_iWy].aOldOnPont[0] - m_PbOfset;
        //                                _SetLog(string.Format("Dual.  Old : {0}mm  New : {1}mm  Gap : {2}mm", CData.GrData[m_iWy].aOldOnPont[0], m_PbOfset, Gap));
        //                            }
        //                        }
        //                        dTemp = 0.0;
        //                        if (CData.Opt.bSecsUse)
        //                        {// One Point SECSGEM 으로 Data 사용 시 DF 및 Host Down Data 값 적용 20200401 LCY
        //                            if (CData.Dynamic.iHeightType == 0)
        //                            {//PCB 측정 값 중 Max 값 사용
        //                                dTemp = CData.Parts[m_iPart].dPcbMax;
        //                                _SetLog("PCB Max : " + dTemp + "mm");
        //                            }
        //                            else
        //                            {//PCB 측정 값 중 펑균 값 사용
        //                                dTemp = CData.Parts[m_iPart].dPcbMean;
        //                                _SetLog("PCB Mean : " + dTemp + "mm");
        //                            }
        //                        }

        //                        m_PbOfset = (m_PbOfset + CData.Dev.aData[m_iWy].dPrbOffset) - dTemp;
        //                        m_dInspGrd = m_PbOfset;
        //                        _SetLog("One point value : " + m_dInspGrd + "mm  RNR : " + CData.Dev.aData[m_iWy].dPrbOffset + "mm");
        //                    }
        //                    else
        //                    {//다이나믹 펑션 사용
        //                     //DF 사용시 DF측정 안할경우 Max만 사용
        //                        if (CDataOption.MeasureDf == eDfServerType.NotMeasureDf)
        //                        { CData.Dynamic.iHeightType = 0; }

        //                        m_PbOfset = CPrb.It.Read_Val(m_eWy);
        //                        _SetLog("DF use.  Probe value : " + m_PbOfset + "mm");

        //                        //191018 ksg :
        //                        if ((CData.Dev.bDual == eDual.Normal))
        //                        {
        //                            if (CData.Dev.aData[(int)EWay.L].dOneLimit > 0)
        //                            {
        //                                if (CData.GrData[m_iWy].aOldOnPont[0] < (m_PbOfset - CData.Dev.aData[(int)EWay.L].dOneLimit))
        //                                { m_WrongCalFlag = true; }
        //                                else
        //                                { CData.GrData[m_iWy].aOldOnPont[0] = m_PbOfset; }
        //                                //191022 ksg :
        //                                double Gap = CData.GrData[m_iWy].aOldOnPont[0] - m_PbOfset;
        //                                _SetLog(string.Format("Normal.  Old : {0}mm  New : {1}mm  Gap : {2}mm", CData.GrData[m_iWy].aOldOnPont[0], m_PbOfset, Gap));
        //                            }
        //                        }
        //                        else
        //                        {
        //                            if (CData.Dev.aData[m_iWy].dOneLimit > 0)
        //                            {
        //                                if (CData.GrData[m_iWy].aOldOnPont[0] < (m_PbOfset - CData.Dev.aData[m_iWy].dOneLimit))
        //                                { m_WrongCalFlag = true; }
        //                                else
        //                                { CData.GrData[m_iWy].aOldOnPont[0] = m_PbOfset; }
        //                                //191022 ksg :
        //                                double Gap = CData.GrData[m_iWy].aOldOnPont[0] - m_PbOfset;
        //                                _SetLog(string.Format("Dual.  Old : {0}mm  New : {1}mm  Gap : {2}mm", CData.GrData[m_iWy].aOldOnPont[0], m_PbOfset, Gap));
        //                            }
        //                        }

        //                        m_PbOfset = m_PbOfset + CData.Dev.aData[m_iWy].dPrbOffset;
        //                        if (CDataOption.eDfserver == eDfserver.Use && !CData.Dev.bDfServerSkip && CData.dfInfo.sGl != "GL1" && CSQ_Main.It.m_iStat == EStatus.Auto_Running)
        //                        {//[GL2, GL3]
        //                            if (CData.Dynamic.iHeightType == 0)
        //                            {//PCB 측정 값 중 Max 값 사용
        //                                m_dInspGrd = m_PbOfset - CData.Parts[m_iPart].dDfMax;
        //                                _SetLog("DF Max : " + CData.Parts[m_iPart].dDfMax + "mm");
        //                            }
        //                            else
        //                            {
        //                                m_dInspGrd = m_PbOfset - CData.Parts[m_iPart].dDfAvg;
        //                                _SetLog("DF Avg : " + CData.Parts[m_iPart].dDfAvg + "mm");
        //                            }
        //                        }
        //                        else
        //                        {//[GL1]
        //                            if (CData.Dynamic.iHeightType == 0)
        //                            {//PCB 측정 값 중 Max 값 사용
        //                             //DF 사용시 DF 측정 할경우
        //                                if (CDataOption.MeasureDf == eDfServerType.MeasureDf)
        //                                {
        //                                    m_dInspGrd = m_PbOfset - CData.Parts[m_iPart].dPcbMax;
        //                                    _SetLog("PCB Max : " + CData.Parts[m_iPart].dPcbMax + "mm");
        //                                }
        //                                else
        //                                {//DF 사용시 DF 측정 안할경우
        //                                    m_dInspGrd = m_PbOfset;
        //                                }
        //                            }
        //                            else
        //                            {
        //                                m_dInspGrd = m_PbOfset - CData.Parts[m_iPart].dPcbMean;
        //                                _SetLog("PCB Mean : " + CData.Parts[m_iPart].dPcbMean + "mm");
        //                            }
        //                        }

        //                        _SetLog("One point value : " + m_dInspGrd + "mm  RNR : " + CData.Dev.aData[m_iWy].dPrbOffset + "mm");
        //                    }

        //                    CData.GrData[m_iWy].a1Pt[m_iIndex] = m_dInspGrd;
        //                    Func_PrbDown(false);
        //                    m_tmPrb.Set_Delay(GV.PRB_DELAY);
        //                    _SetLog("Probe up.  Set delay : " + GV.PRB_DELAY + "ms");

        //                    m_iStep++;
        //                }

        //                return false;
        //            }

        //        case 27:
        //            {//프로브 업 확인, 프로브 X축 포지션 0으로 이동
        //                //200710 jhc : 프로브 업체크 조건 = (프로브 UP 신호) && (프로브 값 > 기준 높이)
        //                //if (!CIO.It.Get_Y(m_eOt1) && m_tmPrb.Chk_Delay())
        //                bool   bProbeUp  = Func_PrbDown(false);
        //                double dProbeVal = CPrb.It.Read_Val(m_eWy); //프로브 값
        //                if (bProbeUp && (dProbeVal >= GV.dProbeUpHeight) && m_tmPrb.Chk_Delay())
        //                {
        //                    CMot.It.Mv_N(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]);
        //                    _SetLog("X axis move zero.", CData.SPos.dGRD_X_Zero[m_iWy]);

        //                    m_iStep++;
        //                }

        //                return false;
        //            }

        //        case 28:
        //            {//프로브 X축 대기위치로 이동 확인
        //                if (!CMot.It.Get_Mv(m_iX, CData.SPos.dGRD_X_Zero[m_iWy]))
        //                { return false; }
        //                _SetLog("Finish.");

        //                m_iStep = 0;
        //                return true;
        //            }
        //    }
        //}

        #endregion // 미사용 함수 삭제





    }
}
